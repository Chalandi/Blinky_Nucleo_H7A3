
#ifndef STM32H7X3_H
#define STM32H7X3_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef __cplusplus
  #define   __I     volatile        
#else
  #define   __I     volatile const  
#endif
#define     __O     volatile        
#define     __IO    volatile        

#define     __IM     volatile const 
#define     __OM     volatile       
#define     __IOM    volatile       

typedef unsigned long uint32;


/* =========================================================================================================================== */
/* ================                                           COMP1                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief COMP1 (COMP1)
  */

typedef struct {                                /*!< (@ 0x58003800) COMP1 Structure                                            */
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000000) Comparator status register                                 */
    
    struct {
      __IM  uint32 C1VAL      : 1;            /*!< [0..0] COMP channel 1 output status bit                                   */
      __IM  uint32 C2VAL      : 1;            /*!< [1..1] COMP channel 2 output status bit                                   */
            uint32            : 14;
      __IM  uint32 C1IF       : 1;            /*!< [16..16] COMP channel 1 Interrupt Flag                                    */
      __IM  uint32 C2IF       : 1;            /*!< [17..17] COMP channel 2 Interrupt Flag                                    */
            uint32            : 14;
    } bit;
  } COMP1_SR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000004) Comparator interrupt clear flag register                   */
    
    struct {
            uint32            : 16;
      __OM  uint32 CC1IF      : 1;            /*!< [16..16] Clear COMP channel 1 Interrupt Flag                              */
      __OM  uint32 CC2IF      : 1;            /*!< [17..17] Clear COMP channel 2 Interrupt Flag                              */
            uint32            : 14;
    } bit;
  } COMP1_ICFR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) Comparator option register                                 */
    
    struct {
      __IOM uint32 AFOP       : 11;           /*!< [10..0] Selection of source for alternate function of output
                                                     ports                                                                     */
      __IOM uint32 OR         : 21;           /*!< [31..11] Option Register                                                  */
    } bit;
  } COMP1_OR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) Comparator configuration register 1                        */
    
    struct {
      __IOM uint32 EN         : 1;            /*!< [0..0] COMP channel 1 enable bit                                          */
      __IOM uint32 BRGEN      : 1;            /*!< [1..1] Scaler bridge enable                                               */
      __IOM uint32 SCALEN     : 1;            /*!< [2..2] Voltage scaler enable bit                                          */
      __IOM uint32 POLARITY   : 1;            /*!< [3..3] COMP channel 1 polarity selection bit                              */
            uint32            : 2;
      __IOM uint32 ITEN       : 1;            /*!< [6..6] COMP channel 1 interrupt enable                                    */
            uint32            : 1;
      __IOM uint32 HYST       : 2;            /*!< [9..8] COMP channel 1 hysteresis selection bits                           */
            uint32            : 2;
      __IOM uint32 PWRMODE    : 2;            /*!< [13..12] Power Mode of the COMP channel 1                                 */
            uint32            : 2;
      __IOM uint32 INMSEL     : 3;            /*!< [18..16] COMP channel 1 inverting input selection field                   */
            uint32            : 1;
      __IOM uint32 INPSEL     : 1;            /*!< [20..20] COMP channel 1 non-inverting input selection bit                 */
            uint32            : 3;
      __IOM uint32 BLANKING   : 4;            /*!< [27..24] COMP channel 1 blanking source selection bits                    */
            uint32            : 3;
      __IOM uint32 LOCK       : 1;            /*!< [31..31] Lock bit                                                         */
    } bit;
  } COMP1_CFGR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) Comparator configuration register 2                        */
    
    struct {
      __IOM uint32 EN         : 1;            /*!< [0..0] COMP channel 1 enable bit                                          */
      __IOM uint32 BRGEN      : 1;            /*!< [1..1] Scaler bridge enable                                               */
      __IOM uint32 SCALEN     : 1;            /*!< [2..2] Voltage scaler enable bit                                          */
      __IOM uint32 POLARITY   : 1;            /*!< [3..3] COMP channel 1 polarity selection bit                              */
      __IOM uint32 WINMODE    : 1;            /*!< [4..4] Window comparator mode selection bit                               */
            uint32            : 1;
      __IOM uint32 ITEN       : 1;            /*!< [6..6] COMP channel 1 interrupt enable                                    */
            uint32            : 1;
      __IOM uint32 HYST       : 2;            /*!< [9..8] COMP channel 1 hysteresis selection bits                           */
            uint32            : 2;
      __IOM uint32 PWRMODE    : 2;            /*!< [13..12] Power Mode of the COMP channel 1                                 */
            uint32            : 2;
      __IOM uint32 INMSEL     : 3;            /*!< [18..16] COMP channel 1 inverting input selection field                   */
            uint32            : 1;
      __IOM uint32 INPSEL     : 1;            /*!< [20..20] COMP channel 1 non-inverting input selection bit                 */
            uint32            : 3;
      __IOM uint32 BLANKING   : 4;            /*!< [27..24] COMP channel 1 blanking source selection bits                    */
            uint32            : 3;
      __IOM uint32 LOCK       : 1;            /*!< [31..31] Lock bit                                                         */
    } bit;
  } COMP1_CFGR2;
} COMP1_Type;                                   /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                            CRS                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief CRS (CRS)
  */

typedef struct {                                /*!< (@ 0x40008400) CRS Structure                                              */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) CRS control register                                       */
    
    struct {
      __IOM uint32 SYNCOKIE   : 1;            /*!< [0..0] SYNC event OK interrupt enable                                     */
      __IOM uint32 SYNCWARNIE : 1;            /*!< [1..1] SYNC warning interrupt enable                                      */
      __IOM uint32 ERRIE      : 1;            /*!< [2..2] Synchronization or trimming error interrupt enable                 */
      __IOM uint32 ESYNCIE    : 1;            /*!< [3..3] Expected SYNC interrupt enable                                     */
            uint32            : 1;
      __IOM uint32 CEN        : 1;            /*!< [5..5] Frequency error counter enable This bit enables the oscillator
                                                     clock for the frequency error counter. When this bit is
                                                     set, the CRS_CFGR register is write-protected and cannot
                                                     be modified.                                                              */
      __IOM uint32 AUTOTRIMEN : 1;            /*!< [6..6] Automatic trimming enable This bit enables the automatic
                                                     hardware adjustment of TRIM bits according to the measured
                                                     frequency error between two SYNC events. If this bit is
                                                     set, the TRIM bits are read-only. The TRIM value can be
                                                     adjusted by hardware by one or two steps at a time, depending
                                                     on the measured frequency error value. Refer to Section7.3.4:
                                                     Frequency error evaluation and automa                                     */
      __IM  uint32 SWSYNC     : 1;            /*!< [7..7] Generate software SYNC event This bit is set by software
                                                     in order to generate a software SYNC event. It is automatically
                                                     cleared by hardware.                                                      */
      __IOM uint32 TRIM       : 6;            /*!< [13..8] HSI48 oscillator smooth trimming These bits provide
                                                     a user-programmable trimming value to the HSI48 oscillator.
                                                     They can be programmed to adjust to variations in voltage
                                                     and temperature that influence the frequency of the HSI48.
                                                     The default value is 32, which corresponds to the middle
                                                     of the trimming interval. The trimming step is around 67
                                                     kHz between two consecutive TRIM steps. A higher TRIM                     */
            uint32            : 18;
    } bit;
  } CRS_CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) This register can be written only when the frequency
                                                                    error counter is disabled (CEN bit is cleared
                                                                    in CRS_CR). When the counter is enabled,
                                                                    this register is write-protected.                          */
    
    struct {
      __IOM uint32 RELOAD     : 16;           /*!< [15..0] Counter reload value RELOAD is the value to be loaded
                                                     in the frequency error counter with each SYNC event. Refer
                                                     to Section7.3.3: Frequency error measurement for more details
                                                     about counter behavior.                                                   */
      __IOM uint32 FELIM      : 8;            /*!< [23..16] Frequency error limit FELIM contains the value to be
                                                     used to evaluate the captured frequency error value latched
                                                     in the FECAP[15:0] bits of the CRS_ISR register. Refer
                                                     to Section7.3.4: Frequency error evaluation and automatic
                                                     trimming for more details about FECAP evaluation.                         */
      __IOM uint32 SYNCDIV    : 3;            /*!< [26..24] SYNC divider These bits are set and cleared by software
                                                     to control the division factor of the SYNC signal.                        */
            uint32            : 1;
      __IOM uint32 SYNCSRC    : 2;            /*!< [29..28] SYNC signal source selection These bits are set and
                                                     cleared by software to select the SYNC signal source. Note:
                                                     When using USB LPM (Link Power Management) and the device
                                                     is in Sleep mode, the periodic USB SOF will not be generated
                                                     by the host. No SYNC signal will therefore be provided
                                                     to the CRS to calibrate the HSI48 on the run. To guarantee
                                                     the required clock precision after waking up from Sleep
                                                                                                                               */
            uint32            : 1;
      __IOM uint32 SYNCPOL    : 1;            /*!< [31..31] SYNC polarity selection This bit is set and cleared
                                                     by software to select the input polarity for the SYNC signal
                                                     source.                                                                   */
    } bit;
  } CRS_CFGR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000008) CRS interrupt and status register                          */
    
    struct {
      __IM  uint32 SYNCOKF    : 1;            /*!< [0..0] SYNC event OK flag This flag is set by hardware when
                                                     the measured frequency error is smaller than FELIM * 3.
                                                     This means that either no adjustment of the TRIM value
                                                     is needed or that an adjustment by one trimming step is
                                                     enough to compensate the frequency error. An interrupt
                                                     is generated if the SYNCOKIE bit is set in the CRS_CR register.
                                                     It is cleared by software by setting the SYNCOKC bit in
                                                     the                                                                       */
      __IM  uint32 SYNCWARNF  : 1;            /*!< [1..1] SYNC warning flag This flag is set by hardware when the
                                                     measured frequency error is greater than or equal to FELIM
                                                     * 3, but smaller than FELIM * 128. This means that to compensate
                                                     the frequency error, the TRIM value must be adjusted by
                                                     two steps or more. An interrupt is generated if the SYNCWARNIE
                                                     bit is set in the CRS_CR register. It is cleared by software
                                                     by setting the SYNCWARNC bit in the CRS_ICR                               */
      __IM  uint32 ERRF       : 1;            /*!< [2..2] Error flag This flag is set by hardware in case of any
                                                     synchronization or trimming error. It is the logical OR
                                                     of the TRIMOVF, SYNCMISS and SYNCERR bits. An interrupt
                                                     is generated if the ERRIE bit is set in the CRS_CR register.
                                                     It is cleared by software in reaction to setting the ERRC
                                                     bit in the CRS_ICR register, which clears the TRIMOVF,
                                                     SYNCMISS and SYNCERR bits.                                                */
      __IM  uint32 ESYNCF     : 1;            /*!< [3..3] Expected SYNC flag This flag is set by hardware when
                                                     the frequency error counter reached a zero value. An interrupt
                                                     is generated if the ESYNCIE bit is set in the CRS_CR register.
                                                     It is cleared by software by setting the ESYNCC bit in
                                                     the CRS_ICR register.                                                     */
            uint32            : 4;
      __IM  uint32 SYNCERR    : 1;            /*!< [8..8] SYNC error This flag is set by hardware when the SYNC
                                                     pulse arrives before the ESYNC event and the measured frequency
                                                     error is greater than or equal to FELIM * 128. This means
                                                     that the frequency error is too big (internal frequency
                                                     too low) to be compensated by adjusting the TRIM value,
                                                     and that some other action should be taken. An interrupt
                                                     is generated if the ERRIE bit is set in the CRS_CR                        */
      __IM  uint32 SYNCMISS   : 1;            /*!< [9..9] SYNC missed This flag is set by hardware when the frequency
                                                     error counter reached value FELIM * 128 and no SYNC was
                                                     detected, meaning either that a SYNC pulse was missed or
                                                     that the frequency error is too big (internal frequency
                                                     too high) to be compensated by adjusting the TRIM value,
                                                     and that some other action should be taken. At this point,
                                                     the frequency error counter is stopped (waiting for a                     */
      __IM  uint32 TRIMOVF    : 1;            /*!< [10..10] Trimming overflow or underflow This flag is set by
                                                     hardware when the automatic trimming tries to over- or
                                                     under-flow the TRIM value. An interrupt is generated if
                                                     the ERRIE bit is set in the CRS_CR register. It is cleared
                                                     by software by setting the ERRC bit in the CRS_ICR register.              */
            uint32            : 4;
      __IM  uint32 FEDIR      : 1;            /*!< [15..15] Frequency error direction FEDIR is the counting direction
                                                     of the frequency error counter latched in the time of the
                                                     last SYNC event. It shows whether the actual frequency
                                                     is below or above the target.                                             */
      __IM  uint32 FECAP      : 16;           /*!< [31..16] Frequency error capture FECAP is the frequency error
                                                     counter value latched in the time of the last SYNC event.
                                                     Refer to Section7.3.4: Frequency error evaluation and automatic
                                                     trimming for more details about FECAP usage.                              */
    } bit;
  } CRS_ISR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) CRS interrupt flag clear register                          */
    
    struct {
      __IOM uint32 SYNCOKC    : 1;            /*!< [0..0] SYNC event OK clear flag Writing 1 to this bit clears
                                                     the SYNCOKF flag in the CRS_ISR register.                                 */
      __IOM uint32 SYNCWARNC  : 1;            /*!< [1..1] SYNC warning clear flag Writing 1 to this bit clears
                                                     the SYNCWARNF flag in the CRS_ISR register.                               */
      __IOM uint32 ERRC       : 1;            /*!< [2..2] Error clear flag Writing 1 to this bit clears TRIMOVF,
                                                     SYNCMISS and SYNCERR bits and consequently also the ERRF
                                                     flag in the CRS_ISR register.                                             */
      __IOM uint32 ESYNCC     : 1;            /*!< [3..3] Expected SYNC clear flag Writing 1 to this bit clears
                                                     the ESYNCF flag in the CRS_ISR register.                                  */
            uint32            : 28;
    } bit;
  } CRS_ICR;
} CRS_Type;                                     /*!< Size = 16 (0x10)                                                          */



/* =========================================================================================================================== */
/* ================                                            DAC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief DAC (DAC)
  */

typedef struct {                                /*!< (@ 0x40007400) DAC Structure                                              */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) DAC control register                                       */
    
    struct {
      __IOM uint32 EN1        : 1;            /*!< [0..0] DAC channel1 enable This bit is set and cleared by software
                                                     to enable/disable DAC channel1.                                           */
      __IOM uint32 TEN1       : 1;            /*!< [1..1] DAC channel1 trigger enable                                        */
      __IOM uint32 TSEL1      : 3;            /*!< [4..2] DAC channel1 trigger selection These bits select the
                                                     external event used to trigger DAC channel1. Note: Only
                                                     used if bit TEN1 = 1 (DAC channel1 trigger enabled).                      */
            uint32            : 1;
      __IOM uint32 WAVE1      : 2;            /*!< [7..6] DAC channel1 noise/triangle wave generation enable These
                                                     bits are set and cleared by software. Note: Only used if
                                                     bit TEN1 = 1 (DAC channel1 trigger enabled).                              */
      __IOM uint32 MAMP1      : 4;            /*!< [11..8] DAC channel1 mask/amplitude selector These bits are
                                                     written by software to select mask in wave generation mode
                                                     or amplitude in triangle generation mode. = 1011: Unmask
                                                     bits[11:0] of LFSR/ triangle amplitude equal to 4095                      */
      __IOM uint32 DMAEN1     : 1;            /*!< [12..12] DAC channel1 DMA enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 DMAUDRIE1  : 1;            /*!< [13..13] DAC channel1 DMA Underrun Interrupt enable This bit
                                                     is set and cleared by software.                                           */
      __IOM uint32 CEN1       : 1;            /*!< [14..14] DAC Channel 1 calibration enable This bit is set and
                                                     cleared by software to enable/disable DAC channel 1 calibration,
                                                     it can be written only if bit EN1=0 into DAC_CR (the calibration
                                                     mode can be entered/exit only when the DAC channel is disabled)
                                                     Otherwise, the write operation is ignored.                                */
            uint32            : 1;
      __IOM uint32 EN2        : 1;            /*!< [16..16] DAC channel2 enable This bit is set and cleared by
                                                     software to enable/disable DAC channel2.                                  */
      __IOM uint32 TEN2       : 1;            /*!< [17..17] DAC channel2 trigger enable                                      */
      __IOM uint32 TSEL2      : 3;            /*!< [20..18] DAC channel2 trigger selection These bits select the
                                                     external event used to trigger DAC channel2 Note: Only
                                                     used if bit TEN2 = 1 (DAC channel2 trigger enabled).                      */
            uint32            : 1;
      __IOM uint32 WAVE2      : 2;            /*!< [23..22] DAC channel2 noise/triangle wave generation enable
                                                     These bits are set/reset by software. 1x: Triangle wave
                                                     generation enabled Note: Only used if bit TEN2 = 1 (DAC
                                                     channel2 trigger enabled)                                                 */
      __IOM uint32 MAMP2      : 4;            /*!< [27..24] DAC channel2 mask/amplitude selector These bits are
                                                     written by software to select mask in wave generation mode
                                                     or amplitude in triangle generation mode. = 1011: Unmask
                                                     bits[11:0] of LFSR/ triangle amplitude equal to 4095                      */
      __IOM uint32 DMAEN2     : 1;            /*!< [28..28] DAC channel2 DMA enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 DMAUDRIE2  : 1;            /*!< [29..29] DAC channel2 DMA underrun interrupt enable This bit
                                                     is set and cleared by software.                                           */
      __IOM uint32 CEN2       : 1;            /*!< [30..30] DAC Channel 2 calibration enable This bit is set and
                                                     cleared by software to enable/disable DAC channel 2 calibration,
                                                     it can be written only if bit EN2=0 into DAC_CR (the calibration
                                                     mode can be entered/exit only when the DAC channel is disabled)
                                                     Otherwise, the write operation is ignored.                                */
            uint32            : 1;
    } bit;
  } DAC_CR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000004) DAC software trigger register                              */
    
    struct {
      __OM  uint32 SWTRIG1    : 1;            /*!< [0..0] DAC channel1 software trigger This bit is set by software
                                                     to trigger the DAC in software trigger mode. Note: This
                                                     bit is cleared by hardware (one APB1 clock cycle later)
                                                     once the DAC_DHR1 register value has been loaded into the
                                                     DAC_DOR1 register.                                                        */
      __OM  uint32 SWTRIG2    : 1;            /*!< [1..1] DAC channel2 software trigger This bit is set by software
                                                     to trigger the DAC in software trigger mode. Note: This
                                                     bit is cleared by hardware (one APB1 clock cycle later)
                                                     once the DAC_DHR2 register value has been loaded into the
                                                     DAC_DOR2 register.                                                        */
            uint32            : 30;
    } bit;
  } DAC_SWTRGR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) DAC channel1 12-bit right-aligned data holding
                                                                    register                                                   */
    
    struct {
      __IOM uint32 DACC1DHR   : 12;           /*!< [11..0] DAC channel1 12-bit right-aligned data These bits are
                                                     written by software which specifies 12-bit data for DAC
                                                     channel1.                                                                 */
            uint32            : 20;
    } bit;
  } DAC_DHR12R1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) DAC channel1 12-bit left aligned data holding
                                                                    register                                                   */
    
    struct {
            uint32            : 4;
      __IOM uint32 DACC1DHR   : 12;           /*!< [15..4] DAC channel1 12-bit left-aligned data These bits are
                                                     written by software which specifies 12-bit data for DAC
                                                     channel1.                                                                 */
            uint32            : 16;
    } bit;
  } DAC_DHR12L1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) DAC channel1 8-bit right aligned data holding
                                                                    register                                                   */
    
    struct {
      __IOM uint32 DACC1DHR   : 8;            /*!< [7..0] DAC channel1 8-bit right-aligned data These bits are
                                                     written by software which specifies 8-bit data for DAC
                                                     channel1.                                                                 */
            uint32            : 24;
    } bit;
  } DAC_DHR8R1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000014) DAC channel2 12-bit right aligned data holding
                                                                    register                                                   */
    
    struct {
      __IOM uint32 DACC2DHR   : 12;           /*!< [11..0] DAC channel2 12-bit right-aligned data These bits are
                                                     written by software which specifies 12-bit data for DAC
                                                     channel2.                                                                 */
            uint32            : 20;
    } bit;
  } DAC_DHR12R2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000018) DAC channel2 12-bit left aligned data holding
                                                                    register                                                   */
    
    struct {
            uint32            : 4;
      __IOM uint32 DACC2DHR   : 12;           /*!< [15..4] DAC channel2 12-bit left-aligned data These bits are
                                                     written by software which specify 12-bit data for DAC channel2.           */
            uint32            : 16;
    } bit;
  } DAC_DHR12L2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000001C) DAC channel2 8-bit right-aligned data holding
                                                                    register                                                   */
    
    struct {
      __IOM uint32 DACC2DHR   : 8;            /*!< [7..0] DAC channel2 8-bit right-aligned data These bits are
                                                     written by software which specifies 8-bit data for DAC
                                                     channel2.                                                                 */
            uint32            : 24;
    } bit;
  } DAC_DHR8R2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000020) Dual DAC 12-bit right-aligned data holding register        */
    
    struct {
      __IOM uint32 DACC1DHR   : 12;           /*!< [11..0] DAC channel1 12-bit right-aligned data These bits are
                                                     written by software which specifies 12-bit data for DAC
                                                     channel1.                                                                 */
            uint32            : 4;
      __IOM uint32 DACC2DHR   : 12;           /*!< [27..16] DAC channel2 12-bit right-aligned data These bits are
                                                     written by software which specifies 12-bit data for DAC
                                                     channel2.                                                                 */
            uint32            : 4;
    } bit;
  } DAC_DHR12RD;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000024) DUAL DAC 12-bit left aligned data holding register         */
    
    struct {
            uint32            : 4;
      __IOM uint32 DACC1DHR   : 12;           /*!< [15..4] DAC channel1 12-bit left-aligned data These bits are
                                                     written by software which specifies 12-bit data for DAC
                                                     channel1.                                                                 */
            uint32            : 4;
      __IOM uint32 DACC2DHR   : 12;           /*!< [31..20] DAC channel2 12-bit left-aligned data These bits are
                                                     written by software which specifies 12-bit data for DAC
                                                     channel2.                                                                 */
    } bit;
  } DAC_DHR12LD;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000028) DUAL DAC 8-bit right aligned data holding register         */
    
    struct {
      __IOM uint32 DACC1DHR   : 8;            /*!< [7..0] DAC channel1 8-bit right-aligned data These bits are
                                                     written by software which specifies 8-bit data for DAC
                                                     channel1.                                                                 */
      __IOM uint32 DACC2DHR   : 8;            /*!< [15..8] DAC channel2 8-bit right-aligned data These bits are
                                                     written by software which specifies 8-bit data for DAC
                                                     channel2.                                                                 */
            uint32            : 16;
    } bit;
  } DAC_DHR8RD;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000002C) DAC channel1 data output register                          */
    
    struct {
      __IM  uint32 DACC1DOR   : 12;           /*!< [11..0] DAC channel1 data output These bits are read-only, they
                                                     contain data output for DAC channel1.                                     */
            uint32            : 20;
    } bit;
  } DAC_DOR1;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000030) DAC channel2 data output register                          */
    
    struct {
      __IM  uint32 DACC2DOR   : 12;           /*!< [11..0] DAC channel2 data output These bits are read-only, they
                                                     contain data output for DAC channel2.                                     */
            uint32            : 20;
    } bit;
  } DAC_DOR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000034) DAC status register                                        */
    
    struct {
            uint32            : 13;
      __IOM uint32 DMAUDR1    : 1;            /*!< [13..13] DAC channel1 DMA underrun flag This bit is set by hardware
                                                     and cleared by software (by writing it to 1).                             */
      __IM  uint32 CAL_FLAG1  : 1;            /*!< [14..14] DAC Channel 1 calibration offset status This bit is
                                                     set and cleared by hardware                                               */
      __IM  uint32 BWST1      : 1;            /*!< [15..15] DAC Channel 1 busy writing sample time flag This bit
                                                     is systematically set just after Sample & Hold mode enable
                                                     and is set each time the software writes the register DAC_SHSR1,
                                                     It is cleared by hardware when the write operation of DAC_SHSR1
                                                     is complete. (It takes about 3LSI periods of synchronization).            */
            uint32            : 13;
      __IOM uint32 DMAUDR2    : 1;            /*!< [29..29] DAC channel2 DMA underrun flag This bit is set by hardware
                                                     and cleared by software (by writing it to 1).                             */
      __IM  uint32 CAL_FLAG2  : 1;            /*!< [30..30] DAC Channel 2 calibration offset status This bit is
                                                     set and cleared by hardware                                               */
      __IM  uint32 BWST2      : 1;            /*!< [31..31] DAC Channel 2 busy writing sample time flag This bit
                                                     is systematically set just after Sample & Hold mode enable
                                                     and is set each time the software writes the register DAC_SHSR2,
                                                     It is cleared by hardware when the write operation of DAC_SHSR2
                                                     is complete. (It takes about 3 LSI periods of synchronization).           */
    } bit;
  } DAC_SR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000038) DAC calibration control register                           */
    
    struct {
      __IOM uint32 OTRIM1     : 5;            /*!< [4..0] DAC Channel 1 offset trimming value                                */
            uint32            : 11;
      __IOM uint32 OTRIM2     : 5;            /*!< [20..16] DAC Channel 2 offset trimming value                              */
            uint32            : 11;
    } bit;
  } DAC_CCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000003C) DAC mode control register                                  */
    
    struct {
      __IOM uint32 MODE1      : 3;            /*!< [2..0] DAC Channel 1 mode These bits can be written only when
                                                     the DAC is disabled and not in the calibration mode (when
                                                     bit EN1=0 and bit CEN1 =0 in the DAC_CR register). If EN1=1
                                                     or CEN1 =1 the write operation is ignored. They can be
                                                     set and cleared by software to select the DAC Channel 1
                                                     mode: DAC Channel 1 in normal Mode DAC Channel 1 in sample
                                                     &amp; hold mode                                                           */
            uint32            : 13;
      __IOM uint32 MODE2      : 3;            /*!< [18..16] DAC Channel 2 mode These bits can be written only when
                                                     the DAC is disabled and not in the calibration mode (when
                                                     bit EN2=0 and bit CEN2 =0 in the DAC_CR register). If EN2=1
                                                     or CEN2 =1 the write operation is ignored. They can be
                                                     set and cleared by software to select the DAC Channel 2
                                                     mode: DAC Channel 2 in normal Mode DAC Channel 2 in sample
                                                     &amp; hold mode                                                           */
            uint32            : 13;
    } bit;
  } DAC_MCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000040) DAC Sample and Hold sample time register 1                 */
    
    struct {
      __IOM uint32 TSAMPLE1   : 10;           /*!< [9..0] DAC Channel 1 sample Time (only valid in sample &amp;
                                                     hold mode) These bits can be written when the DAC channel1
                                                     is disabled or also during normal operation. in the latter
                                                     case, the write can be done only when BWSTx of DAC_SR register
                                                     is low, If BWSTx=1, the write operation is ignored.                       */
            uint32            : 22;
    } bit;
  } DAC_SHSR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000044) DAC Sample and Hold sample time register 2                 */
    
    struct {
      __IOM uint32 TSAMPLE2   : 10;           /*!< [9..0] DAC Channel 2 sample Time (only valid in sample &amp;
                                                     hold mode) These bits can be written when the DAC channel2
                                                     is disabled or also during normal operation. in the latter
                                                     case, the write can be done only when BWSTx of DAC_SR register
                                                     is low, if BWSTx=1, the write operation is ignored.                       */
            uint32            : 22;
    } bit;
  } DAC_SHSR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000048) DAC Sample and Hold hold time register                     */
    
    struct {
      __IOM uint32 THOLD1     : 10;           /*!< [9..0] DAC Channel 1 hold Time (only valid in sample &amp; hold
                                                     mode) Hold time= (THOLD[9:0]) x T LSI                                     */
            uint32            : 6;
      __IOM uint32 THOLD2     : 10;           /*!< [25..16] DAC Channel 2 hold time (only valid in sample &amp;
                                                     hold mode). Hold time= (THOLD[9:0]) x T LSI                               */
            uint32            : 6;
    } bit;
  } DAC_SHHR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000004C) DAC Sample and Hold refresh time register                  */
    
    struct {
      __IOM uint32 TREFRESH1  : 8;            /*!< [7..0] DAC Channel 1 refresh Time (only valid in sample &amp;
                                                     hold mode) Refresh time= (TREFRESH[7:0]) x T LSI                          */
            uint32            : 8;
      __IOM uint32 TREFRESH2  : 8;            /*!< [23..16] DAC Channel 2 refresh Time (only valid in sample &amp;
                                                     hold mode) Refresh time= (TREFRESH[7:0]) x T LSI                          */
            uint32            : 8;
    } bit;
  } DAC_SHRR;
} DAC_Type;                                     /*!< Size = 80 (0x50)                                                          */



/* =========================================================================================================================== */
/* ================                                           BDMA                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief BDMA (BDMA)
  */

typedef struct {                                /*!< (@ 0x58025400) BDMA Structure                                             */
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000000) DMA interrupt status register                              */
    
    struct {
      __IM  uint32 GIF1       : 1;            /*!< [0..0] Channel x global interrupt flag (x = 1..8) This bit is
                                                     set by hardware. It is cleared by software writing 1 to
                                                     the corresponding bit in the DMA_IFCR register.                           */
      __IM  uint32 TCIF1      : 1;            /*!< [1..1] Channel x transfer complete flag (x = 1..8) This bit
                                                     is set by hardware. It is cleared by software writing 1
                                                     to the corresponding bit in the DMA_IFCR register.                        */
      __IM  uint32 HTIF1      : 1;            /*!< [2..2] Channel x half transfer flag (x = 1..8) This bit is set
                                                     by hardware. It is cleared by software writing 1 to the
                                                     corresponding bit in the DMA_IFCR register.                               */
      __IM  uint32 TEIF1      : 1;            /*!< [3..3] Channel x transfer error flag (x = 1..8) This bit is
                                                     set by hardware. It is cleared by software writing 1 to
                                                     the corresponding bit in the DMA_IFCR register.                           */
      __IM  uint32 GIF2       : 1;            /*!< [4..4] Channel x global interrupt flag (x = 1..8) This bit is
                                                     set by hardware. It is cleared by software writing 1 to
                                                     the corresponding bit in the DMA_IFCR register.                           */
      __IM  uint32 TCIF2      : 1;            /*!< [5..5] Channel x transfer complete flag (x = 1..8) This bit
                                                     is set by hardware. It is cleared by software writing 1
                                                     to the corresponding bit in the DMA_IFCR register.                        */
      __IM  uint32 HTIF2      : 1;            /*!< [6..6] Channel x half transfer flag (x = 1..8) This bit is set
                                                     by hardware. It is cleared by software writing 1 to the
                                                     corresponding bit in the DMA_IFCR register.                               */
      __IM  uint32 TEIF2      : 1;            /*!< [7..7] Channel x transfer error flag (x = 1..8) This bit is
                                                     set by hardware. It is cleared by software writing 1 to
                                                     the corresponding bit in the DMA_IFCR register.                           */
      __IM  uint32 GIF3       : 1;            /*!< [8..8] Channel x global interrupt flag (x = 1..8) This bit is
                                                     set by hardware. It is cleared by software writing 1 to
                                                     the corresponding bit in the DMA_IFCR register.                           */
      __IM  uint32 TCIF3      : 1;            /*!< [9..9] Channel x transfer complete flag (x = 1..8) This bit
                                                     is set by hardware. It is cleared by software writing 1
                                                     to the corresponding bit in the DMA_IFCR register.                        */
      __IM  uint32 HTIF3      : 1;            /*!< [10..10] Channel x half transfer flag (x = 1..8) This bit is
                                                     set by hardware. It is cleared by software writing 1 to
                                                     the corresponding bit in the DMA_IFCR register.                           */
      __IM  uint32 TEIF3      : 1;            /*!< [11..11] Channel x transfer error flag (x = 1..8) This bit is
                                                     set by hardware. It is cleared by software writing 1 to
                                                     the corresponding bit in the DMA_IFCR register.                           */
      __IM  uint32 GIF4       : 1;            /*!< [12..12] Channel x global interrupt flag (x = 1..8) This bit
                                                     is set by hardware. It is cleared by software writing 1
                                                     to the corresponding bit in the DMA_IFCR register.                        */
      __IM  uint32 TCIF4      : 1;            /*!< [13..13] Channel x transfer complete flag (x = 1..8) This bit
                                                     is set by hardware. It is cleared by software writing 1
                                                     to the corresponding bit in the DMA_IFCR register.                        */
      __IM  uint32 HTIF4      : 1;            /*!< [14..14] Channel x half transfer flag (x = 1..8) This bit is
                                                     set by hardware. It is cleared by software writing 1 to
                                                     the corresponding bit in the DMA_IFCR register.                           */
      __IM  uint32 TEIF4      : 1;            /*!< [15..15] Channel x transfer error flag (x = 1..8) This bit is
                                                     set by hardware. It is cleared by software writing 1 to
                                                     the corresponding bit in the DMA_IFCR register.                           */
      __IM  uint32 GIF5       : 1;            /*!< [16..16] Channel x global interrupt flag (x = 1..8) This bit
                                                     is set by hardware. It is cleared by software writing 1
                                                     to the corresponding bit in the DMA_IFCR register.                        */
      __IM  uint32 TCIF5      : 1;            /*!< [17..17] Channel x transfer complete flag (x = 1..8) This bit
                                                     is set by hardware. It is cleared by software writing 1
                                                     to the corresponding bit in the DMA_IFCR register.                        */
      __IM  uint32 HTIF5      : 1;            /*!< [18..18] Channel x half transfer flag (x = 1..8) This bit is
                                                     set by hardware. It is cleared by software writing 1 to
                                                     the corresponding bit in the DMA_IFCR register.                           */
      __IM  uint32 TEIF5      : 1;            /*!< [19..19] Channel x transfer error flag (x = 1..8) This bit is
                                                     set by hardware. It is cleared by software writing 1 to
                                                     the corresponding bit in the DMA_IFCR register.                           */
      __IM  uint32 GIF6       : 1;            /*!< [20..20] Channel x global interrupt flag (x = 1..8) This bit
                                                     is set by hardware. It is cleared by software writing 1
                                                     to the corresponding bit in the DMA_IFCR register.                        */
      __IM  uint32 TCIF6      : 1;            /*!< [21..21] Channel x transfer complete flag (x = 1..8) This bit
                                                     is set by hardware. It is cleared by software writing 1
                                                     to the corresponding bit in the DMA_IFCR register.                        */
      __IM  uint32 HTIF6      : 1;            /*!< [22..22] Channel x half transfer flag (x = 1..8) This bit is
                                                     set by hardware. It is cleared by software writing 1 to
                                                     the corresponding bit in the DMA_IFCR register.                           */
      __IM  uint32 TEIF6      : 1;            /*!< [23..23] Channel x transfer error flag (x = 1..8) This bit is
                                                     set by hardware. It is cleared by software writing 1 to
                                                     the corresponding bit in the DMA_IFCR register.                           */
      __IM  uint32 GIF7       : 1;            /*!< [24..24] Channel x global interrupt flag (x = 1..8) This bit
                                                     is set by hardware. It is cleared by software writing 1
                                                     to the corresponding bit in the DMA_IFCR register.                        */
      __IM  uint32 TCIF7      : 1;            /*!< [25..25] Channel x transfer complete flag (x = 1..8) This bit
                                                     is set by hardware. It is cleared by software writing 1
                                                     to the corresponding bit in the DMA_IFCR register.                        */
      __IM  uint32 HTIF7      : 1;            /*!< [26..26] Channel x half transfer flag (x = 1..8) This bit is
                                                     set by hardware. It is cleared by software writing 1 to
                                                     the corresponding bit in the DMA_IFCR register.                           */
      __IM  uint32 TEIF7      : 1;            /*!< [27..27] Channel x transfer error flag (x = 1..8) This bit is
                                                     set by hardware. It is cleared by software writing 1 to
                                                     the corresponding bit in the DMA_IFCR register.                           */
      __IM  uint32 GIF8       : 1;            /*!< [28..28] Channel x global interrupt flag (x = 1..8) This bit
                                                     is set by hardware. It is cleared by software writing 1
                                                     to the corresponding bit in the DMA_IFCR register.                        */
      __IM  uint32 TCIF8      : 1;            /*!< [29..29] Channel x transfer complete flag (x = 1..8) This bit
                                                     is set by hardware. It is cleared by software writing 1
                                                     to the corresponding bit in the DMA_IFCR register.                        */
      __IM  uint32 HTIF8      : 1;            /*!< [30..30] Channel x half transfer flag (x = 1..8) This bit is
                                                     set by hardware. It is cleared by software writing 1 to
                                                     the corresponding bit in the DMA_IFCR register.                           */
      __IM  uint32 TEIF8      : 1;            /*!< [31..31] Channel x transfer error flag (x = 1..8) This bit is
                                                     set by hardware. It is cleared by software writing 1 to
                                                     the corresponding bit in the DMA_IFCR register.                           */
    } bit;
  } BDMA_ISR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000004) DMA interrupt flag clear register                          */
    
    struct {
      __OM  uint32 CGIF1      : 1;            /*!< [0..0] Channel x global interrupt clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32 CTCIF1     : 1;            /*!< [1..1] Channel x transfer complete clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32 CHTIF1     : 1;            /*!< [2..2] Channel x half transfer clear This bit is set and cleared
                                                     by software.                                                              */
      __OM  uint32 CTEIF1     : 1;            /*!< [3..3] Channel x transfer error clear This bit is set and cleared
                                                     by software.                                                              */
      __OM  uint32 CGIF2      : 1;            /*!< [4..4] Channel x global interrupt clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32 CTCIF2     : 1;            /*!< [5..5] Channel x transfer complete clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32 CHTIF2     : 1;            /*!< [6..6] Channel x half transfer clear This bit is set and cleared
                                                     by software.                                                              */
      __OM  uint32 CTEIF2     : 1;            /*!< [7..7] Channel x transfer error clear This bit is set and cleared
                                                     by software.                                                              */
      __OM  uint32 CGIF3      : 1;            /*!< [8..8] Channel x global interrupt clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32 CTCIF3     : 1;            /*!< [9..9] Channel x transfer complete clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32 CHTIF3     : 1;            /*!< [10..10] Channel x half transfer clear This bit is set and cleared
                                                     by software.                                                              */
      __OM  uint32 CTEIF3     : 1;            /*!< [11..11] Channel x transfer error clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32 CGIF4      : 1;            /*!< [12..12] Channel x global interrupt clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32 CTCIF4     : 1;            /*!< [13..13] Channel x transfer complete clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32 CHTIF4     : 1;            /*!< [14..14] Channel x half transfer clear This bit is set and cleared
                                                     by software.                                                              */
      __OM  uint32 CTEIF4     : 1;            /*!< [15..15] Channel x transfer error clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32 CGIF5      : 1;            /*!< [16..16] Channel x global interrupt clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32 CTCIF5     : 1;            /*!< [17..17] Channel x transfer complete clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32 CHTIF5     : 1;            /*!< [18..18] Channel x half transfer clear This bit is set and cleared
                                                     by software.                                                              */
      __OM  uint32 CTEIF5     : 1;            /*!< [19..19] Channel x transfer error clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32 CGIF6      : 1;            /*!< [20..20] Channel x global interrupt clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32 CTCIF6     : 1;            /*!< [21..21] Channel x transfer complete clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32 CHTIF6     : 1;            /*!< [22..22] Channel x half transfer clear This bit is set and cleared
                                                     by software.                                                              */
      __OM  uint32 CTEIF6     : 1;            /*!< [23..23] Channel x transfer error clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32 CGIF7      : 1;            /*!< [24..24] Channel x global interrupt clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32 CTCIF7     : 1;            /*!< [25..25] Channel x transfer complete clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32 CHTIF7     : 1;            /*!< [26..26] Channel x half transfer clear This bit is set and cleared
                                                     by software.                                                              */
      __OM  uint32 CTEIF7     : 1;            /*!< [27..27] Channel x transfer error clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32 CGIF8      : 1;            /*!< [28..28] Channel x global interrupt clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32 CTCIF8     : 1;            /*!< [29..29] Channel x transfer complete clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32 CHTIF8     : 1;            /*!< [30..30] Channel x half transfer clear This bit is set and cleared
                                                     by software.                                                              */
      __OM  uint32 CTEIF8     : 1;            /*!< [31..31] Channel x transfer error clear This bit is set and
                                                     cleared by software.                                                      */
    } bit;
  } BDMA_IFCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) DMA channel x configuration register                       */
    
    struct {
      __IOM uint32 EN         : 1;            /*!< [0..0] Channel enable This bit is set and cleared by software.            */
      __IOM uint32 TCIE       : 1;            /*!< [1..1] Transfer complete interrupt enable This bit is set and
                                                     cleared by software.                                                      */
      __IOM uint32 HTIE       : 1;            /*!< [2..2] Half transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 TEIE       : 1;            /*!< [3..3] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 DIR        : 1;            /*!< [4..4] Data transfer direction This bit is set and cleared by
                                                     software.                                                                 */
      __IOM uint32 CIRC       : 1;            /*!< [5..5] Circular mode This bit is set and cleared by software.             */
      __IOM uint32 PINC       : 1;            /*!< [6..6] Peripheral increment mode This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 MINC       : 1;            /*!< [7..7] Memory increment mode This bit is set and cleared by
                                                     software.                                                                 */
      __IOM uint32 PSIZE      : 2;            /*!< [9..8] Peripheral size These bits are set and cleared by software.        */
      __IOM uint32 MSIZE      : 2;            /*!< [11..10] Memory size These bits are set and cleared by software.          */
      __IOM uint32 PL         : 2;            /*!< [13..12] Channel priority level These bits are set and cleared
                                                     by software.                                                              */
      __IOM uint32 MEM2MEM    : 1;            /*!< [14..14] Memory to memory mode This bit is set and cleared by
                                                     software.                                                                 */
            uint32            : 17;
    } bit;
  } BDMA_CCR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) DMA channel x number of data register                      */
    
    struct {
      __IOM uint32 NDT        : 16;           /*!< [15..0] Number of data to transfer Number of data to be transferred
                                                     (0 up to 65535). This register can only be written when
                                                     the channel is disabled. Once the channel is enabled, this
                                                     register is read-only, indicating the remaining bytes to
                                                     be transmitted. This register decrements after each DMA
                                                     transfer. Once the transfer is completed, this register
                                                     can either stay at zero or be reloaded automa                             */
            uint32            : 16;
    } bit;
  } BDMA_CNDTR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) This register must not be written when the channel
                                                                    is enabled.                                                */
    
    struct {
      __IOM uint32 PA         : 32;           /*!< [31..0] Peripheral address Base address of the peripheral data
                                                     register from/to which the data will be read/written. When
                                                     PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access
                                                     is automatically aligned to a half-word address. When PSIZE
                                                     is 10 (32-bit), PA[1:0] are ignored. Access is automatically
                                                     aligned to a word address.                                                */
    } bit;
  } BDMA_CPAR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000014) This register must not be written when the channel
                                                                    is enabled.                                                */
    
    struct {
      __IOM uint32 MA         : 32;           /*!< [31..0] Memory address Base address of the memory area from/to
                                                     which the data will be read/written. When MSIZE is 01 (16-bit),
                                                     the MA[0] bit is ignored. Access is automatically aligned
                                                     to a half-word address. When MSIZE is 10 (32-bit), MA[1:0]
                                                     are ignored. Access is automatically aligned to a word
                                                     address.                                                                  */
    } bit;
  } BDMA_CMAR1;
  __IM  uint32  RESERVED;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000001C) DMA channel x configuration register                       */
    
    struct {
      __IOM uint32 EN         : 1;            /*!< [0..0] Channel enable This bit is set and cleared by software.            */
      __IOM uint32 TCIE       : 1;            /*!< [1..1] Transfer complete interrupt enable This bit is set and
                                                     cleared by software.                                                      */
      __IOM uint32 HTIE       : 1;            /*!< [2..2] Half transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 TEIE       : 1;            /*!< [3..3] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 DIR        : 1;            /*!< [4..4] Data transfer direction This bit is set and cleared by
                                                     software.                                                                 */
      __IOM uint32 CIRC       : 1;            /*!< [5..5] Circular mode This bit is set and cleared by software.             */
      __IOM uint32 PINC       : 1;            /*!< [6..6] Peripheral increment mode This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 MINC       : 1;            /*!< [7..7] Memory increment mode This bit is set and cleared by
                                                     software.                                                                 */
      __IOM uint32 PSIZE      : 2;            /*!< [9..8] Peripheral size These bits are set and cleared by software.        */
      __IOM uint32 MSIZE      : 2;            /*!< [11..10] Memory size These bits are set and cleared by software.          */
      __IOM uint32 PL         : 2;            /*!< [13..12] Channel priority level These bits are set and cleared
                                                     by software.                                                              */
      __IOM uint32 MEM2MEM    : 1;            /*!< [14..14] Memory to memory mode This bit is set and cleared by
                                                     software.                                                                 */
            uint32            : 17;
    } bit;
  } BDMA_CCR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000020) DMA channel x number of data register                      */
    
    struct {
      __IOM uint32 NDT        : 16;           /*!< [15..0] Number of data to transfer Number of data to be transferred
                                                     (0 up to 65535). This register can only be written when
                                                     the channel is disabled. Once the channel is enabled, this
                                                     register is read-only, indicating the remaining bytes to
                                                     be transmitted. This register decrements after each DMA
                                                     transfer. Once the transfer is completed, this register
                                                     can either stay at zero or be reloaded automa                             */
            uint32            : 16;
    } bit;
  } BDMA_CNDTR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000024) This register must not be written when the channel
                                                                    is enabled.                                                */
    
    struct {
      __IOM uint32 PA         : 32;           /*!< [31..0] Peripheral address Base address of the peripheral data
                                                     register from/to which the data will be read/written. When
                                                     PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access
                                                     is automatically aligned to a half-word address. When PSIZE
                                                     is 10 (32-bit), PA[1:0] are ignored. Access is automatically
                                                     aligned to a word address.                                                */
    } bit;
  } BDMA_CPAR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000028) This register must not be written when the channel
                                                                    is enabled.                                                */
    
    struct {
      __IOM uint32 MA         : 32;           /*!< [31..0] Memory address Base address of the memory area from/to
                                                     which the data will be read/written. When MSIZE is 01 (16-bit),
                                                     the MA[0] bit is ignored. Access is automatically aligned
                                                     to a half-word address. When MSIZE is 10 (32-bit), MA[1:0]
                                                     are ignored. Access is automatically aligned to a word
                                                     address.                                                                  */
    } bit;
  } BDMA_CMAR2;
  __IM  uint32  RESERVED1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000030) DMA channel x configuration register                       */
    
    struct {
      __IOM uint32 EN         : 1;            /*!< [0..0] Channel enable This bit is set and cleared by software.            */
      __IOM uint32 TCIE       : 1;            /*!< [1..1] Transfer complete interrupt enable This bit is set and
                                                     cleared by software.                                                      */
      __IOM uint32 HTIE       : 1;            /*!< [2..2] Half transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 TEIE       : 1;            /*!< [3..3] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 DIR        : 1;            /*!< [4..4] Data transfer direction This bit is set and cleared by
                                                     software.                                                                 */
      __IOM uint32 CIRC       : 1;            /*!< [5..5] Circular mode This bit is set and cleared by software.             */
      __IOM uint32 PINC       : 1;            /*!< [6..6] Peripheral increment mode This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 MINC       : 1;            /*!< [7..7] Memory increment mode This bit is set and cleared by
                                                     software.                                                                 */
      __IOM uint32 PSIZE      : 2;            /*!< [9..8] Peripheral size These bits are set and cleared by software.        */
      __IOM uint32 MSIZE      : 2;            /*!< [11..10] Memory size These bits are set and cleared by software.          */
      __IOM uint32 PL         : 2;            /*!< [13..12] Channel priority level These bits are set and cleared
                                                     by software.                                                              */
      __IOM uint32 MEM2MEM    : 1;            /*!< [14..14] Memory to memory mode This bit is set and cleared by
                                                     software.                                                                 */
            uint32            : 17;
    } bit;
  } BDMA_CCR3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000034) DMA channel x number of data register                      */
    
    struct {
      __IOM uint32 NDT        : 16;           /*!< [15..0] Number of data to transfer Number of data to be transferred
                                                     (0 up to 65535). This register can only be written when
                                                     the channel is disabled. Once the channel is enabled, this
                                                     register is read-only, indicating the remaining bytes to
                                                     be transmitted. This register decrements after each DMA
                                                     transfer. Once the transfer is completed, this register
                                                     can either stay at zero or be reloaded automa                             */
            uint32            : 16;
    } bit;
  } BDMA_CNDTR3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000038) This register must not be written when the channel
                                                                    is enabled.                                                */
    
    struct {
      __IOM uint32 PA         : 32;           /*!< [31..0] Peripheral address Base address of the peripheral data
                                                     register from/to which the data will be read/written. When
                                                     PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access
                                                     is automatically aligned to a half-word address. When PSIZE
                                                     is 10 (32-bit), PA[1:0] are ignored. Access is automatically
                                                     aligned to a word address.                                                */
    } bit;
  } BDMA_CPAR3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000003C) This register must not be written when the channel
                                                                    is enabled.                                                */
    
    struct {
      __IOM uint32 MA         : 32;           /*!< [31..0] Memory address Base address of the memory area from/to
                                                     which the data will be read/written. When MSIZE is 01 (16-bit),
                                                     the MA[0] bit is ignored. Access is automatically aligned
                                                     to a half-word address. When MSIZE is 10 (32-bit), MA[1:0]
                                                     are ignored. Access is automatically aligned to a word
                                                     address.                                                                  */
    } bit;
  } BDMA_CMAR3;
  __IM  uint32  RESERVED2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000044) DMA channel x configuration register                       */
    
    struct {
      __IOM uint32 EN         : 1;            /*!< [0..0] Channel enable This bit is set and cleared by software.            */
      __IOM uint32 TCIE       : 1;            /*!< [1..1] Transfer complete interrupt enable This bit is set and
                                                     cleared by software.                                                      */
      __IOM uint32 HTIE       : 1;            /*!< [2..2] Half transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 TEIE       : 1;            /*!< [3..3] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 DIR        : 1;            /*!< [4..4] Data transfer direction This bit is set and cleared by
                                                     software.                                                                 */
      __IOM uint32 CIRC       : 1;            /*!< [5..5] Circular mode This bit is set and cleared by software.             */
      __IOM uint32 PINC       : 1;            /*!< [6..6] Peripheral increment mode This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 MINC       : 1;            /*!< [7..7] Memory increment mode This bit is set and cleared by
                                                     software.                                                                 */
      __IOM uint32 PSIZE      : 2;            /*!< [9..8] Peripheral size These bits are set and cleared by software.        */
      __IOM uint32 MSIZE      : 2;            /*!< [11..10] Memory size These bits are set and cleared by software.          */
      __IOM uint32 PL         : 2;            /*!< [13..12] Channel priority level These bits are set and cleared
                                                     by software.                                                              */
      __IOM uint32 MEM2MEM    : 1;            /*!< [14..14] Memory to memory mode This bit is set and cleared by
                                                     software.                                                                 */
            uint32            : 17;
    } bit;
  } BDMA_CCR4;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000048) DMA channel x number of data register                      */
    
    struct {
      __IOM uint32 NDT        : 16;           /*!< [15..0] Number of data to transfer Number of data to be transferred
                                                     (0 up to 65535). This register can only be written when
                                                     the channel is disabled. Once the channel is enabled, this
                                                     register is read-only, indicating the remaining bytes to
                                                     be transmitted. This register decrements after each DMA
                                                     transfer. Once the transfer is completed, this register
                                                     can either stay at zero or be reloaded automa                             */
            uint32            : 16;
    } bit;
  } BDMA_CNDTR4;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000004C) This register must not be written when the channel
                                                                    is enabled.                                                */
    
    struct {
      __IOM uint32 PA         : 32;           /*!< [31..0] Peripheral address Base address of the peripheral data
                                                     register from/to which the data will be read/written. When
                                                     PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access
                                                     is automatically aligned to a half-word address. When PSIZE
                                                     is 10 (32-bit), PA[1:0] are ignored. Access is automatically
                                                     aligned to a word address.                                                */
    } bit;
  } BDMA_CPAR4;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000050) This register must not be written when the channel
                                                                    is enabled.                                                */
    
    struct {
      __IOM uint32 MA         : 32;           /*!< [31..0] Memory address Base address of the memory area from/to
                                                     which the data will be read/written. When MSIZE is 01 (16-bit),
                                                     the MA[0] bit is ignored. Access is automatically aligned
                                                     to a half-word address. When MSIZE is 10 (32-bit), MA[1:0]
                                                     are ignored. Access is automatically aligned to a word
                                                     address.                                                                  */
    } bit;
  } BDMA_CMAR4;
  __IM  uint32  RESERVED3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000058) DMA channel x configuration register                       */
    
    struct {
      __IOM uint32 EN         : 1;            /*!< [0..0] Channel enable This bit is set and cleared by software.            */
      __IOM uint32 TCIE       : 1;            /*!< [1..1] Transfer complete interrupt enable This bit is set and
                                                     cleared by software.                                                      */
      __IOM uint32 HTIE       : 1;            /*!< [2..2] Half transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 TEIE       : 1;            /*!< [3..3] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 DIR        : 1;            /*!< [4..4] Data transfer direction This bit is set and cleared by
                                                     software.                                                                 */
      __IOM uint32 CIRC       : 1;            /*!< [5..5] Circular mode This bit is set and cleared by software.             */
      __IOM uint32 PINC       : 1;            /*!< [6..6] Peripheral increment mode This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 MINC       : 1;            /*!< [7..7] Memory increment mode This bit is set and cleared by
                                                     software.                                                                 */
      __IOM uint32 PSIZE      : 2;            /*!< [9..8] Peripheral size These bits are set and cleared by software.        */
      __IOM uint32 MSIZE      : 2;            /*!< [11..10] Memory size These bits are set and cleared by software.          */
      __IOM uint32 PL         : 2;            /*!< [13..12] Channel priority level These bits are set and cleared
                                                     by software.                                                              */
      __IOM uint32 MEM2MEM    : 1;            /*!< [14..14] Memory to memory mode This bit is set and cleared by
                                                     software.                                                                 */
            uint32            : 17;
    } bit;
  } BDMA_CCR5;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000005C) DMA channel x number of data register                      */
    
    struct {
      __IOM uint32 NDT        : 16;           /*!< [15..0] Number of data to transfer Number of data to be transferred
                                                     (0 up to 65535). This register can only be written when
                                                     the channel is disabled. Once the channel is enabled, this
                                                     register is read-only, indicating the remaining bytes to
                                                     be transmitted. This register decrements after each DMA
                                                     transfer. Once the transfer is completed, this register
                                                     can either stay at zero or be reloaded automa                             */
            uint32            : 16;
    } bit;
  } BDMA_CNDTR5;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000060) This register must not be written when the channel
                                                                    is enabled.                                                */
    
    struct {
      __IOM uint32 PA         : 32;           /*!< [31..0] Peripheral address Base address of the peripheral data
                                                     register from/to which the data will be read/written. When
                                                     PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access
                                                     is automatically aligned to a half-word address. When PSIZE
                                                     is 10 (32-bit), PA[1:0] are ignored. Access is automatically
                                                     aligned to a word address.                                                */
    } bit;
  } BDMA_CPAR5;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000064) This register must not be written when the channel
                                                                    is enabled.                                                */
    
    struct {
      __IOM uint32 MA         : 32;           /*!< [31..0] Memory address Base address of the memory area from/to
                                                     which the data will be read/written. When MSIZE is 01 (16-bit),
                                                     the MA[0] bit is ignored. Access is automatically aligned
                                                     to a half-word address. When MSIZE is 10 (32-bit), MA[1:0]
                                                     are ignored. Access is automatically aligned to a word
                                                     address.                                                                  */
    } bit;
  } BDMA_CMAR5;
  __IM  uint32  RESERVED4;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000006C) DMA channel x configuration register                       */
    
    struct {
      __IOM uint32 EN         : 1;            /*!< [0..0] Channel enable This bit is set and cleared by software.            */
      __IOM uint32 TCIE       : 1;            /*!< [1..1] Transfer complete interrupt enable This bit is set and
                                                     cleared by software.                                                      */
      __IOM uint32 HTIE       : 1;            /*!< [2..2] Half transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 TEIE       : 1;            /*!< [3..3] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 DIR        : 1;            /*!< [4..4] Data transfer direction This bit is set and cleared by
                                                     software.                                                                 */
      __IOM uint32 CIRC       : 1;            /*!< [5..5] Circular mode This bit is set and cleared by software.             */
      __IOM uint32 PINC       : 1;            /*!< [6..6] Peripheral increment mode This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 MINC       : 1;            /*!< [7..7] Memory increment mode This bit is set and cleared by
                                                     software.                                                                 */
      __IOM uint32 PSIZE      : 2;            /*!< [9..8] Peripheral size These bits are set and cleared by software.        */
      __IOM uint32 MSIZE      : 2;            /*!< [11..10] Memory size These bits are set and cleared by software.          */
      __IOM uint32 PL         : 2;            /*!< [13..12] Channel priority level These bits are set and cleared
                                                     by software.                                                              */
      __IOM uint32 MEM2MEM    : 1;            /*!< [14..14] Memory to memory mode This bit is set and cleared by
                                                     software.                                                                 */
            uint32            : 17;
    } bit;
  } BDMA_CCR6;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000070) DMA channel x number of data register                      */
    
    struct {
      __IOM uint32 NDT        : 16;           /*!< [15..0] Number of data to transfer Number of data to be transferred
                                                     (0 up to 65535). This register can only be written when
                                                     the channel is disabled. Once the channel is enabled, this
                                                     register is read-only, indicating the remaining bytes to
                                                     be transmitted. This register decrements after each DMA
                                                     transfer. Once the transfer is completed, this register
                                                     can either stay at zero or be reloaded automa                             */
            uint32            : 16;
    } bit;
  } BDMA_CNDTR6;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000074) This register must not be written when the channel
                                                                    is enabled.                                                */
    
    struct {
      __IOM uint32 PA         : 32;           /*!< [31..0] Peripheral address Base address of the peripheral data
                                                     register from/to which the data will be read/written. When
                                                     PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access
                                                     is automatically aligned to a half-word address. When PSIZE
                                                     is 10 (32-bit), PA[1:0] are ignored. Access is automatically
                                                     aligned to a word address.                                                */
    } bit;
  } BDMA_CPAR6;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000078) This register must not be written when the channel
                                                                    is enabled.                                                */
    
    struct {
      __IOM uint32 MA         : 32;           /*!< [31..0] Memory address Base address of the memory area from/to
                                                     which the data will be read/written. When MSIZE is 01 (16-bit),
                                                     the MA[0] bit is ignored. Access is automatically aligned
                                                     to a half-word address. When MSIZE is 10 (32-bit), MA[1:0]
                                                     are ignored. Access is automatically aligned to a word
                                                     address.                                                                  */
    } bit;
  } BDMA_CMAR6;
  __IM  uint32  RESERVED5;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000080) DMA channel x configuration register                       */
    
    struct {
      __IOM uint32 EN         : 1;            /*!< [0..0] Channel enable This bit is set and cleared by software.            */
      __IOM uint32 TCIE       : 1;            /*!< [1..1] Transfer complete interrupt enable This bit is set and
                                                     cleared by software.                                                      */
      __IOM uint32 HTIE       : 1;            /*!< [2..2] Half transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 TEIE       : 1;            /*!< [3..3] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 DIR        : 1;            /*!< [4..4] Data transfer direction This bit is set and cleared by
                                                     software.                                                                 */
      __IOM uint32 CIRC       : 1;            /*!< [5..5] Circular mode This bit is set and cleared by software.             */
      __IOM uint32 PINC       : 1;            /*!< [6..6] Peripheral increment mode This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 MINC       : 1;            /*!< [7..7] Memory increment mode This bit is set and cleared by
                                                     software.                                                                 */
      __IOM uint32 PSIZE      : 2;            /*!< [9..8] Peripheral size These bits are set and cleared by software.        */
      __IOM uint32 MSIZE      : 2;            /*!< [11..10] Memory size These bits are set and cleared by software.          */
      __IOM uint32 PL         : 2;            /*!< [13..12] Channel priority level These bits are set and cleared
                                                     by software.                                                              */
      __IOM uint32 MEM2MEM    : 1;            /*!< [14..14] Memory to memory mode This bit is set and cleared by
                                                     software.                                                                 */
            uint32            : 17;
    } bit;
  } BDMA_CCR7;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000084) DMA channel x number of data register                      */
    
    struct {
      __IOM uint32 NDT        : 16;           /*!< [15..0] Number of data to transfer Number of data to be transferred
                                                     (0 up to 65535). This register can only be written when
                                                     the channel is disabled. Once the channel is enabled, this
                                                     register is read-only, indicating the remaining bytes to
                                                     be transmitted. This register decrements after each DMA
                                                     transfer. Once the transfer is completed, this register
                                                     can either stay at zero or be reloaded automa                             */
            uint32            : 16;
    } bit;
  } BDMA_CNDTR7;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000088) This register must not be written when the channel
                                                                    is enabled.                                                */
    
    struct {
      __IOM uint32 PA         : 32;           /*!< [31..0] Peripheral address Base address of the peripheral data
                                                     register from/to which the data will be read/written. When
                                                     PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access
                                                     is automatically aligned to a half-word address. When PSIZE
                                                     is 10 (32-bit), PA[1:0] are ignored. Access is automatically
                                                     aligned to a word address.                                                */
    } bit;
  } BDMA_CPAR7;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000008C) This register must not be written when the channel
                                                                    is enabled.                                                */
    
    struct {
      __IOM uint32 MA         : 32;           /*!< [31..0] Memory address Base address of the memory area from/to
                                                     which the data will be read/written. When MSIZE is 01 (16-bit),
                                                     the MA[0] bit is ignored. Access is automatically aligned
                                                     to a half-word address. When MSIZE is 10 (32-bit), MA[1:0]
                                                     are ignored. Access is automatically aligned to a word
                                                     address.                                                                  */
    } bit;
  } BDMA_CMAR7;
  __IM  uint32  RESERVED6;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000094) DMA channel x configuration register                       */
    
    struct {
      __IOM uint32 EN         : 1;            /*!< [0..0] Channel enable This bit is set and cleared by software.            */
      __IOM uint32 TCIE       : 1;            /*!< [1..1] Transfer complete interrupt enable This bit is set and
                                                     cleared by software.                                                      */
      __IOM uint32 HTIE       : 1;            /*!< [2..2] Half transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 TEIE       : 1;            /*!< [3..3] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 DIR        : 1;            /*!< [4..4] Data transfer direction This bit is set and cleared by
                                                     software.                                                                 */
      __IOM uint32 CIRC       : 1;            /*!< [5..5] Circular mode This bit is set and cleared by software.             */
      __IOM uint32 PINC       : 1;            /*!< [6..6] Peripheral increment mode This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 MINC       : 1;            /*!< [7..7] Memory increment mode This bit is set and cleared by
                                                     software.                                                                 */
      __IOM uint32 PSIZE      : 2;            /*!< [9..8] Peripheral size These bits are set and cleared by software.        */
      __IOM uint32 MSIZE      : 2;            /*!< [11..10] Memory size These bits are set and cleared by software.          */
      __IOM uint32 PL         : 2;            /*!< [13..12] Channel priority level These bits are set and cleared
                                                     by software.                                                              */
      __IOM uint32 MEM2MEM    : 1;            /*!< [14..14] Memory to memory mode This bit is set and cleared by
                                                     software.                                                                 */
            uint32            : 17;
    } bit;
  } BDMA_CCR8;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000098) DMA channel x number of data register                      */
    
    struct {
      __IOM uint32 NDT        : 16;           /*!< [15..0] Number of data to transfer Number of data to be transferred
                                                     (0 up to 65535). This register can only be written when
                                                     the channel is disabled. Once the channel is enabled, this
                                                     register is read-only, indicating the remaining bytes to
                                                     be transmitted. This register decrements after each DMA
                                                     transfer. Once the transfer is completed, this register
                                                     can either stay at zero or be reloaded automa                             */
            uint32            : 16;
    } bit;
  } BDMA_CNDTR8;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000009C) This register must not be written when the channel
                                                                    is enabled.                                                */
    
    struct {
      __IOM uint32 PA         : 32;           /*!< [31..0] Peripheral address Base address of the peripheral data
                                                     register from/to which the data will be read/written. When
                                                     PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access
                                                     is automatically aligned to a half-word address. When PSIZE
                                                     is 10 (32-bit), PA[1:0] are ignored. Access is automatically
                                                     aligned to a word address.                                                */
    } bit;
  } BDMA_CPAR8;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000A0) This register must not be written when the channel
                                                                    is enabled.                                                */
    
    struct {
      __IOM uint32 MA         : 32;           /*!< [31..0] Memory address Base address of the memory area from/to
                                                     which the data will be read/written. When MSIZE is 01 (16-bit),
                                                     the MA[0] bit is ignored. Access is automatically aligned
                                                     to a half-word address. When MSIZE is 10 (32-bit), MA[1:0]
                                                     are ignored. Access is automatically aligned to a word
                                                     address.                                                                  */
    } bit;
  } BDMA_CMAR8;
} BDMA_Type;                                    /*!< Size = 164 (0xa4)                                                         */



/* =========================================================================================================================== */
/* ================                                           DMA2D                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief DMA2D (DMA2D)
  */

typedef struct {                                /*!< (@ 0x52001000) DMA2D Structure                                            */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) DMA2D control register                                     */
    
    struct {
      __IOM uint32 START      : 1;            /*!< [0..0] Start This bit can be used to launch the DMA2D according
                                                     to the parameters loaded in the various configuration registers           */
      __IOM uint32 SUSP       : 1;            /*!< [1..1] Suspend This bit can be used to suspend the current transfer.
                                                     This bit is set and reset by software. It is automatically
                                                     reset by hardware when the START bit is reset.                            */
      __IOM uint32 ABORT      : 1;            /*!< [2..2] Abort This bit can be used to abort the current transfer.
                                                     This bit is set by software and is automatically reset
                                                     by hardware when the START bit is reset.                                  */
            uint32            : 5;
      __IOM uint32 TEIE       : 1;            /*!< [8..8] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 TCIE       : 1;            /*!< [9..9] Transfer complete interrupt enable This bit is set and
                                                     cleared by software.                                                      */
      __IOM uint32 TWIE       : 1;            /*!< [10..10] Transfer watermark interrupt enable This bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32 CAEIE      : 1;            /*!< [11..11] CLUT access error interrupt enable This bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32 CTCIE      : 1;            /*!< [12..12] CLUT transfer complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32 CEIE       : 1;            /*!< [13..13] Configuration Error Interrupt Enable This bit is set
                                                     and cleared by software.                                                  */
            uint32            : 2;
      __IOM uint32 MODE       : 2;            /*!< [17..16] DMA2D mode This bit is set and cleared by software.
                                                     It cannot be modified while a transfer is ongoing.                        */
            uint32            : 14;
    } bit;
  } DMA2D_CR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000004) DMA2D Interrupt Status Register                            */
    
    struct {
      __IM  uint32 TEIF       : 1;            /*!< [0..0] Transfer error interrupt flag This bit is set when an
                                                     error occurs during a DMA transfer (data transfer or automatic
                                                     CLUT loading).                                                            */
      __IM  uint32 TCIF       : 1;            /*!< [1..1] Transfer complete interrupt flag This bit is set when
                                                     a DMA2D transfer operation is complete (data transfer only).              */
      __IM  uint32 TWIF       : 1;            /*!< [2..2] Transfer watermark interrupt flag This bit is set when
                                                     the last pixel of the watermarked line has been transferred.              */
      __IM  uint32 CAEIF      : 1;            /*!< [3..3] CLUT access error interrupt flag This bit is set when
                                                     the CPU accesses the CLUT while the CLUT is being automatically
                                                     copied from a system memory to the internal DMA2D.                        */
      __IM  uint32 CTCIF      : 1;            /*!< [4..4] CLUT transfer complete interrupt flag This bit is set
                                                     when the CLUT copy from a system memory area to the internal
                                                     DMA2D memory is complete.                                                 */
      __IM  uint32 CEIF       : 1;            /*!< [5..5] Configuration error interrupt flag This bit is set when
                                                     the START bit of DMA2D_CR, DMA2DFGPFCCR or DMA2D_BGPFCCR
                                                     is set and a wrong configuration has been programmed.                     */
            uint32            : 26;
    } bit;
  } DMA2D_ISR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) DMA2D interrupt flag clear register                        */
    
    struct {
      __IOM uint32 CTEIF      : 1;            /*!< [0..0] Clear Transfer error interrupt flag Programming this
                                                     bit to 1 clears the TEIF flag in the DMA2D_ISR register                   */
      __IOM uint32 CTCIF      : 1;            /*!< [1..1] Clear transfer complete interrupt flag Programming this
                                                     bit to 1 clears the TCIF flag in the DMA2D_ISR register                   */
      __IOM uint32 CTWIF      : 1;            /*!< [2..2] Clear transfer watermark interrupt flag Programming this
                                                     bit to 1 clears the TWIF flag in the DMA2D_ISR register                   */
      __IOM uint32 CAECIF     : 1;            /*!< [3..3] Clear CLUT access error interrupt flag Programming this
                                                     bit to 1 clears the CAEIF flag in the DMA2D_ISR register                  */
      __IOM uint32 CCTCIF     : 1;            /*!< [4..4] Clear CLUT transfer complete interrupt flag Programming
                                                     this bit to 1 clears the CTCIF flag in the DMA2D_ISR register             */
      __IOM uint32 CCEIF      : 1;            /*!< [5..5] Clear configuration error interrupt flag Programming
                                                     this bit to 1 clears the CEIF flag in the DMA2D_ISR register              */
            uint32            : 26;
    } bit;
  } DMA2D_IFCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) DMA2D foreground memory address register                   */
    
    struct {
      __IOM uint32 MA         : 32;           /*!< [31..0] Memory address Address of the data used for the foreground
                                                     image. This register can only be written when data transfers
                                                     are disabled. Once the data transfer has started, this
                                                     register is read-only. The address alignment must match
                                                     the image format selected e.g. a 32-bit per pixel format
                                                     must be 32-bit aligned, a 16-bit per pixel format must
                                                     be 16-bit aligned and a 4-bit per pixel format must be
                                                                                                                               */
    } bit;
  } DMA2D_FGMAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) DMA2D foreground offset register                           */
    
    struct {
      __IOM uint32 LO         : 14;           /*!< [13..0] Line offset Line offset used for the foreground expressed
                                                     in pixel. This value is used to generate the address. It
                                                     is added at the end of each line to determine the starting
                                                     address of the next line. These bits can only be written
                                                     when data transfers are disabled. Once a data transfer
                                                     has started, they become read-only. If the image format
                                                     is 4-bit per pixel, the line offset must be eve                           */
            uint32            : 18;
    } bit;
  } DMA2D_FGOR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000014) DMA2D background memory address register                   */
    
    struct {
      __IOM uint32 MA         : 32;           /*!< [31..0] Memory address Address of the data used for the background
                                                     image. This register can only be written when data transfers
                                                     are disabled. Once a data transfer has started, this register
                                                     is read-only. The address alignment must match the image
                                                     format selected e.g. a 32-bit per pixel format must be
                                                     32-bit aligned, a 16-bit per pixel format must be 16-bit
                                                     aligned and a 4-bit per pixel format must be                              */
    } bit;
  } DMA2D_BGMAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000018) DMA2D background offset register                           */
    
    struct {
      __IOM uint32 LO         : 14;           /*!< [13..0] Line offset Line offset used for the background image
                                                     (expressed in pixel). This value is used for the address
                                                     generation. It is added at the end of each line to determine
                                                     the starting address of the next line. These bits can only
                                                     be written when data transfers are disabled. Once data
                                                     transfer has started, they become read-only. If the image
                                                     format is 4-bit per pixel, the line offset must be                        */
            uint32            : 18;
    } bit;
  } DMA2D_BGOR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000001C) DMA2D foreground PFC control register                      */
    
    struct {
      __IOM uint32 CM         : 4;            /*!< [3..0] Color mode These bits defines the color format of the
                                                     foreground image. They can only be written when data transfers
                                                     are disabled. Once the transfer has started, they are read-only.
                                                     others: meaningless                                                       */
      __IOM uint32 CCM        : 1;            /*!< [4..4] CLUT color mode This bit defines the color format of
                                                     the CLUT. It can only be written when the transfer is disabled.
                                                     Once the CLUT transfer has started, this bit is read-only.                */
      __IOM uint32 START      : 1;            /*!< [5..5] Start This bit can be set to start the automatic loading
                                                     of the CLUT. It is automatically reset: ** at the end of
                                                     the transfer ** when the transfer is aborted by the user
                                                     application by setting the ABORT bit in DMA2D_CR ** when
                                                     a transfer error occurs ** when the transfer has not started
                                                     due to a configuration error or another transfer operation
                                                     already ongoing (data transfer or automatic                               */
            uint32            : 2;
      __IOM uint32 CS         : 8;            /*!< [15..8] CLUT size These bits define the size of the CLUT used
                                                     for the foreground image. Once the CLUT transfer has started,
                                                     this field is read-only. The number of CLUT entries is
                                                     equal to CS[7:0] + 1.                                                     */
      __IOM uint32 AM         : 2;            /*!< [17..16] Alpha mode These bits select the alpha channel value
                                                     to be used for the foreground image. They can only be written
                                                     data the transfer are disabled. Once the transfer has started,
                                                     they become read-only. other configurations are meaningless               */
      __IOM uint32 CSS        : 2;            /*!< [19..18] Chroma Sub-Sampling These bits define the chroma sub-sampling
                                                     mode for YCbCr color mode. Once the transfer has started,
                                                     these bits are read-only. others: meaningless                             */
      __IOM uint32 AI         : 1;            /*!< [20..20] Alpha Inverted This bit inverts the alpha value. Once
                                                     the transfer has started, this bit is read-only.                          */
      __IOM uint32 RBS        : 1;            /*!< [21..21] Red Blue Swap This bit allows to swap the R &amp; B
                                                     to support BGR or ABGR color formats. Once the transfer
                                                     has started, this bit is read-only.                                       */
            uint32            : 2;
      __IOM uint32 ALPHA      : 8;            /*!< [31..24] Alpha value These bits define a fixed alpha channel
                                                     value which can replace the original alpha value or be
                                                     multiplied by the original alpha value according to the
                                                     alpha mode selected through the AM[1:0] bits. These bits
                                                     can only be written when data transfers are disabled. Once
                                                     a transfer has started, they become read-only.                            */
    } bit;
  } DMA2D_FGPFCCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000020) DMA2D foreground color register                            */
    
    struct {
      __IOM uint32 BLUE       : 8;            /*!< [7..0] Blue Value These bits defines the blue value for the
                                                     A4 or A8 mode of the foreground image. They can only be
                                                     written when data transfers are disabled. Once the transfer
                                                     has started, They are read-only.                                          */
      __IOM uint32 GREEN      : 8;            /*!< [15..8] Green Value These bits defines the green value for the
                                                     A4 or A8 mode of the foreground image. They can only be
                                                     written when data transfers are disabled. Once the transfer
                                                     has started, They are read-only.                                          */
      __IOM uint32 RED        : 8;            /*!< [23..16] Red Value These bits defines the red value for the
                                                     A4 or A8 mode of the foreground image. They can only be
                                                     written when data transfers are disabled. Once the transfer
                                                     has started, they are read-only.                                          */
            uint32            : 8;
    } bit;
  } DMA2D_FGCOLR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000024) DMA2D background PFC control register                      */
    
    struct {
      __IOM uint32 CM         : 4;            /*!< [3..0] Color mode These bits define the color format of the
                                                     foreground image. These bits can only be written when data
                                                     transfers are disabled. Once the transfer has started,
                                                     they are read-only. others: meaningless                                   */
      __IOM uint32 CCM        : 1;            /*!< [4..4] CLUT Color mode These bits define the color format of
                                                     the CLUT. This register can only be written when the transfer
                                                     is disabled. Once the CLUT transfer has started, this bit
                                                     is read-only.                                                             */
      __IOM uint32 START      : 1;            /*!< [5..5] Start This bit is set to start the automatic loading
                                                     of the CLUT. This bit is automatically reset: ** at the
                                                     end of the transfer ** when the transfer is aborted by
                                                     the user application by setting the ABORT bit in the DMA2D_CR
                                                     ** when a transfer error occurs ** when the transfer has
                                                     not started due to a configuration error or another transfer
                                                     operation already on going (data transfer or                              */
            uint32            : 2;
      __IOM uint32 CS         : 8;            /*!< [15..8] CLUT size These bits define the size of the CLUT used
                                                     for the BG. Once the CLUT transfer has started, this field
                                                     is read-only. The number of CLUT entries is equal to CS[7:0]
                                                     + 1.                                                                      */
      __IOM uint32 AM         : 2;            /*!< [17..16] Alpha mode These bits define which alpha channel value
                                                     to be used for the background image. These bits can only
                                                     be written when data transfers are disabled. Once the transfer
                                                     has started, they are read-only. others: meaningless                      */
            uint32            : 2;
      __IOM uint32 AI         : 1;            /*!< [20..20] Alpha Inverted This bit inverts the alpha value. Once
                                                     the transfer has started, this bit is read-only.                          */
      __IOM uint32 RBS        : 1;            /*!< [21..21] Red Blue Swap This bit allows to swap the R &amp; B
                                                     to support BGR or ABGR color formats. Once the transfer
                                                     has started, this bit is read-only.                                       */
            uint32            : 2;
      __IOM uint32 ALPHA      : 8;            /*!< [31..24] Alpha value These bits define a fixed alpha channel
                                                     value which can replace the original alpha value or be
                                                     multiplied with the original alpha value according to the
                                                     alpha mode selected with bits AM[1: 0]. These bits can
                                                     only be written when data transfers are disabled. Once
                                                     the transfer has started, they are read-only.                             */
    } bit;
  } DMA2D_BGPFCCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000028) DMA2D background color register                            */
    
    struct {
      __IOM uint32 BLUE       : 8;            /*!< [7..0] Blue Value These bits define the blue value for the A4
                                                     or A8 mode of the background. These bits can only be written
                                                     when data transfers are disabled. Once the transfer has
                                                     started, they are read-only.                                              */
      __IOM uint32 GREEN      : 8;            /*!< [15..8] Green Value These bits define the green value for the
                                                     A4 or A8 mode of the background. These bits can only be
                                                     written when data transfers are disabled. Once the transfer
                                                     has started, they are read-only.                                          */
      __IOM uint32 RED        : 8;            /*!< [23..16] Red Value These bits define the red value for the A4
                                                     or A8 mode of the background. These bits can only be written
                                                     when data transfers are disabled. Once the transfer has
                                                     started, they are read-only.                                              */
            uint32            : 8;
    } bit;
  } DMA2D_BGCOLR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000002C) DMA2D foreground CLUT memory address register              */
    
    struct {
      __IOM uint32 MA         : 32;           /*!< [31..0] Memory Address Address of the data used for the CLUT
                                                     address dedicated to the foreground image. This register
                                                     can only be written when no transfer is ongoing. Once the
                                                     CLUT transfer has started, this register is read-only.
                                                     If the foreground CLUT format is 32-bit, the address must
                                                     be 32-bit aligned.                                                        */
    } bit;
  } DMA2D_FGCMAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000030) DMA2D background CLUT memory address register              */
    
    struct {
      __IOM uint32 MA         : 32;           /*!< [31..0] Memory address Address of the data used for the CLUT
                                                     address dedicated to the background image. This register
                                                     can only be written when no transfer is on going. Once
                                                     the CLUT transfer has started, this register is read-only.
                                                     If the background CLUT format is 32-bit, the address must
                                                     be 32-bit aligned.                                                        */
    } bit;
  } DMA2D_BGCMAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000034) DMA2D output PFC control register                          */
    
    struct {
      __IOM uint32 CM         : 3;            /*!< [2..0] Color mode These bits define the color format of the
                                                     output image. These bits can only be written when data
                                                     transfers are disabled. Once the transfer has started,
                                                     they are read-only. others: meaningless                                   */
            uint32            : 17;
      __IOM uint32 AI         : 1;            /*!< [20..20] Alpha Inverted This bit inverts the alpha value. Once
                                                     the transfer has started, this bit is read-only.                          */
      __IOM uint32 RBS        : 1;            /*!< [21..21] Red Blue Swap This bit allows to swap the R &amp; B
                                                     to support BGR or ABGR color formats. Once the transfer
                                                     has started, this bit is read-only.                                       */
            uint32            : 10;
    } bit;
  } DMA2D_OPFCCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000038) DMA2D output color register                                */
    
    struct {
      __IOM uint32 BLUE       : 8;            /*!< [7..0] Blue Value These bits define the blue value of the output
                                                     image. These bits can only be written when data transfers
                                                     are disabled. Once the transfer has started, they are read-only.          */
      __IOM uint32 GREEN      : 8;            /*!< [15..8] Green Value These bits define the green value of the
                                                     output image. These bits can only be written when data
                                                     transfers are disabled. Once the transfer has started,
                                                     they are read-only.                                                       */
      __IOM uint32 RED        : 8;            /*!< [23..16] Red Value These bits define the red value of the output
                                                     image. These bits can only be written when data transfers
                                                     are disabled. Once the transfer has started, they are read-only.          */
      __IOM uint32 ALPHA      : 8;            /*!< [31..24] Alpha Channel Value These bits define the alpha channel
                                                     of the output color. These bits can only be written when
                                                     data transfers are disabled. Once the transfer has started,
                                                     they are read-only.                                                       */
    } bit;
  } DMA2D_OCOLR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000003C) DMA2D output memory address register                       */
    
    struct {
      __IOM uint32 MA         : 32;           /*!< [31..0] Memory Address Address of the data used for the output
                                                     FIFO. These bits can only be written when data transfers
                                                     are disabled. Once the transfer has started, they are read-only.
                                                     The address alignment must match the image format selected
                                                     e.g. a 32-bit per pixel format must be 32-bit aligned and
                                                     a 16-bit per pixel format must be 16-bit aligned.                         */
    } bit;
  } DMA2D_OMAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000040) DMA2D output offset register                               */
    
    struct {
      __IOM uint32 LO         : 14;           /*!< [13..0] Line Offset Line offset used for the output (expressed
                                                     in pixels). This value is used for the address generation.
                                                     It is added at the end of each line to determine the starting
                                                     address of the next line. These bits can only be written
                                                     when data transfers are disabled. Once the transfer has
                                                     started, they are read-only.                                              */
            uint32            : 18;
    } bit;
  } DMA2D_OOR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000044) DMA2D number of line register                              */
    
    struct {
      __IOM uint32 NL         : 16;           /*!< [15..0] Number of lines Number of lines of the area to be transferred.
                                                     These bits can only be written when data transfers are
                                                     disabled. Once the transfer has started, they are read-only.              */
      __IOM uint32 PL         : 14;           /*!< [29..16] Pixel per lines Number of pixels per lines of the area
                                                     to be transferred. These bits can only be written when
                                                     data transfers are disabled. Once the transfer has started,
                                                     they are read-only. If any of the input image format is
                                                     4-bit per pixel, pixel per lines must be even.                            */
            uint32            : 2;
    } bit;
  } DMA2D_NLR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000048) DMA2D line watermark register                              */
    
    struct {
      __IOM uint32 LW         : 16;           /*!< [15..0] Line watermark These bits allow to configure the line
                                                     watermark for interrupt generation. An interrupt is raised
                                                     when the last pixel of the watermarked line has been transferred.
                                                     These bits can only be written when data transfers are
                                                     disabled. Once the transfer has started, they are read-only.              */
            uint32            : 16;
    } bit;
  } DMA2D_LWR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000004C) DMA2D AXI master timer configuration register              */
    
    struct {
      __IOM uint32 EN         : 1;            /*!< [0..0] Enable Enables the dead time functionality.                        */
            uint32            : 7;
      __IOM uint32 DT         : 8;            /*!< [15..8] Dead Time Dead time value in the AXI clock cycle inserted
                                                     between two consecutive accesses on the AXI master port.
                                                     These bits represent the minimum guaranteed number of cycles
                                                     between two consecutive AXI accesses.                                     */
            uint32            : 16;
    } bit;
  } DMA2D_AMTCR;
} DMA2D_Type;                                   /*!< Size = 80 (0x50)                                                          */



/* =========================================================================================================================== */
/* ================                                          DMAMUX2                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief DMAMUX (DMAMUX2)
  */

typedef struct {                                /*!< (@ 0x58025800) DMAMUX2 Structure                                          */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32 DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32 SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32 EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32            : 6;
      __IOM uint32 SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32 SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32 NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32 SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32            : 3;
    } bit;
  } DMAMUX2_C0CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32 DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32 SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32 EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32            : 6;
      __IOM uint32 SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32 SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32 NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32 SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32            : 3;
    } bit;
  } DMAMUX2_C1CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32 DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32 SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32 EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32            : 6;
      __IOM uint32 SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32 SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32 NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32 SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32            : 3;
    } bit;
  } DMAMUX2_C2CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32 DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32 SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32 EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32            : 6;
      __IOM uint32 SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32 SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32 NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32 SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32            : 3;
    } bit;
  } DMAMUX2_C3CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32 DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32 SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32 EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32            : 6;
      __IOM uint32 SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32 SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32 NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32 SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32            : 3;
    } bit;
  } DMAMUX2_C4CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000014) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32 DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32 SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32 EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32            : 6;
      __IOM uint32 SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32 SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32 NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32 SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32            : 3;
    } bit;
  } DMAMUX2_C5CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000018) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32 DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32 SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32 EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32            : 6;
      __IOM uint32 SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32 SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32 NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32 SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32            : 3;
    } bit;
  } DMAMUX2_C6CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000001C) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32 DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32 SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32 EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32            : 6;
      __IOM uint32 SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32 SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32 NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32 SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32            : 3;
    } bit;
  } DMAMUX2_C7CR;
  __IM  uint32  RESERVED[24];
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000080) DMAMUX request line multiplexer interrupt channel
                                                                    status register                                            */
    
    struct {
      __IM  uint32 SOF        : 16;           /*!< [15..0] Synchronization overrun event flag                                */
            uint32            : 16;
    } bit;
  } DMAMUX2_CSR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000084) DMAMUX request line multiplexer interrupt clear
                                                                    flag register                                              */
    
    struct {
      __OM  uint32 CSOF       : 16;           /*!< [15..0] Clear synchronization overrun event flag                          */
            uint32            : 16;
    } bit;
  } DMAMUX2_CFR;
  __IM  uint32  RESERVED1[30];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000100) DMAMux - DMA request generator channel x control
                                                                    register                                                   */
    
    struct {
      __IOM uint32 SIG_ID     : 5;            /*!< [4..0] DMA request trigger input selected                                 */
            uint32            : 3;
      __IOM uint32 OIE        : 1;            /*!< [8..8] Interrupt enable at trigger event overrun                          */
            uint32            : 7;
      __IOM uint32 GE         : 1;            /*!< [16..16] DMA request generator channel enable/disable                     */
      __IOM uint32 GPOL       : 2;            /*!< [18..17] DMA request generator trigger event type selection
                                                     Defines the trigger event on the selected DMA request trigger
                                                     input                                                                     */
      __IOM uint32 GNBREQ     : 5;            /*!< [23..19] Number of DMA requests to generate Defines the number
                                                     of DMA requests generated after a trigger event, then stop
                                                     generating. The actual number of generated DMA requests
                                                     is GNBREQ+1. Note: This field can only be written when
                                                     GE bit is reset.                                                          */
            uint32            : 8;
    } bit;
  } DMAMUX2_RG0CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000104) DMAMux - DMA request generator channel x control
                                                                    register                                                   */
    
    struct {
      __IOM uint32 SIG_ID     : 5;            /*!< [4..0] DMA request trigger input selected                                 */
            uint32            : 3;
      __IOM uint32 OIE        : 1;            /*!< [8..8] Interrupt enable at trigger event overrun                          */
            uint32            : 7;
      __IOM uint32 GE         : 1;            /*!< [16..16] DMA request generator channel enable/disable                     */
      __IOM uint32 GPOL       : 2;            /*!< [18..17] DMA request generator trigger event type selection
                                                     Defines the trigger event on the selected DMA request trigger
                                                     input                                                                     */
      __IOM uint32 GNBREQ     : 5;            /*!< [23..19] Number of DMA requests to generate Defines the number
                                                     of DMA requests generated after a trigger event, then stop
                                                     generating. The actual number of generated DMA requests
                                                     is GNBREQ+1. Note: This field can only be written when
                                                     GE bit is reset.                                                          */
            uint32            : 8;
    } bit;
  } DMAMUX2_RG1CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000108) DMAMux - DMA request generator channel x control
                                                                    register                                                   */
    
    struct {
      __IOM uint32 SIG_ID     : 5;            /*!< [4..0] DMA request trigger input selected                                 */
            uint32            : 3;
      __IOM uint32 OIE        : 1;            /*!< [8..8] Interrupt enable at trigger event overrun                          */
            uint32            : 7;
      __IOM uint32 GE         : 1;            /*!< [16..16] DMA request generator channel enable/disable                     */
      __IOM uint32 GPOL       : 2;            /*!< [18..17] DMA request generator trigger event type selection
                                                     Defines the trigger event on the selected DMA request trigger
                                                     input                                                                     */
      __IOM uint32 GNBREQ     : 5;            /*!< [23..19] Number of DMA requests to generate Defines the number
                                                     of DMA requests generated after a trigger event, then stop
                                                     generating. The actual number of generated DMA requests
                                                     is GNBREQ+1. Note: This field can only be written when
                                                     GE bit is reset.                                                          */
            uint32            : 8;
    } bit;
  } DMAMUX2_RG2CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000010C) DMAMux - DMA request generator channel x control
                                                                    register                                                   */
    
    struct {
      __IOM uint32 SIG_ID     : 5;            /*!< [4..0] DMA request trigger input selected                                 */
            uint32            : 3;
      __IOM uint32 OIE        : 1;            /*!< [8..8] Interrupt enable at trigger event overrun                          */
            uint32            : 7;
      __IOM uint32 GE         : 1;            /*!< [16..16] DMA request generator channel enable/disable                     */
      __IOM uint32 GPOL       : 2;            /*!< [18..17] DMA request generator trigger event type selection
                                                     Defines the trigger event on the selected DMA request trigger
                                                     input                                                                     */
      __IOM uint32 GNBREQ     : 5;            /*!< [23..19] Number of DMA requests to generate Defines the number
                                                     of DMA requests generated after a trigger event, then stop
                                                     generating. The actual number of generated DMA requests
                                                     is GNBREQ+1. Note: This field can only be written when
                                                     GE bit is reset.                                                          */
            uint32            : 8;
    } bit;
  } DMAMUX2_RG3CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000110) DMAMux - DMA request generator channel x control
                                                                    register                                                   */
    
    struct {
      __IOM uint32 SIG_ID     : 5;            /*!< [4..0] DMA request trigger input selected                                 */
            uint32            : 3;
      __IOM uint32 OIE        : 1;            /*!< [8..8] Interrupt enable at trigger event overrun                          */
            uint32            : 7;
      __IOM uint32 GE         : 1;            /*!< [16..16] DMA request generator channel enable/disable                     */
      __IOM uint32 GPOL       : 2;            /*!< [18..17] DMA request generator trigger event type selection
                                                     Defines the trigger event on the selected DMA request trigger
                                                     input                                                                     */
      __IOM uint32 GNBREQ     : 5;            /*!< [23..19] Number of DMA requests to generate Defines the number
                                                     of DMA requests generated after a trigger event, then stop
                                                     generating. The actual number of generated DMA requests
                                                     is GNBREQ+1. Note: This field can only be written when
                                                     GE bit is reset.                                                          */
            uint32            : 8;
    } bit;
  } DMAMUX2_RG4CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000114) DMAMux - DMA request generator channel x control
                                                                    register                                                   */
    
    struct {
      __IOM uint32 SIG_ID     : 5;            /*!< [4..0] DMA request trigger input selected                                 */
            uint32            : 3;
      __IOM uint32 OIE        : 1;            /*!< [8..8] Interrupt enable at trigger event overrun                          */
            uint32            : 7;
      __IOM uint32 GE         : 1;            /*!< [16..16] DMA request generator channel enable/disable                     */
      __IOM uint32 GPOL       : 2;            /*!< [18..17] DMA request generator trigger event type selection
                                                     Defines the trigger event on the selected DMA request trigger
                                                     input                                                                     */
      __IOM uint32 GNBREQ     : 5;            /*!< [23..19] Number of DMA requests to generate Defines the number
                                                     of DMA requests generated after a trigger event, then stop
                                                     generating. The actual number of generated DMA requests
                                                     is GNBREQ+1. Note: This field can only be written when
                                                     GE bit is reset.                                                          */
            uint32            : 8;
    } bit;
  } DMAMUX2_RG5CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000118) DMAMux - DMA request generator channel x control
                                                                    register                                                   */
    
    struct {
      __IOM uint32 SIG_ID     : 5;            /*!< [4..0] DMA request trigger input selected                                 */
            uint32            : 3;
      __IOM uint32 OIE        : 1;            /*!< [8..8] Interrupt enable at trigger event overrun                          */
            uint32            : 7;
      __IOM uint32 GE         : 1;            /*!< [16..16] DMA request generator channel enable/disable                     */
      __IOM uint32 GPOL       : 2;            /*!< [18..17] DMA request generator trigger event type selection
                                                     Defines the trigger event on the selected DMA request trigger
                                                     input                                                                     */
      __IOM uint32 GNBREQ     : 5;            /*!< [23..19] Number of DMA requests to generate Defines the number
                                                     of DMA requests generated after a trigger event, then stop
                                                     generating. The actual number of generated DMA requests
                                                     is GNBREQ+1. Note: This field can only be written when
                                                     GE bit is reset.                                                          */
            uint32            : 8;
    } bit;
  } DMAMUX2_RG6CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000011C) DMAMux - DMA request generator channel x control
                                                                    register                                                   */
    
    struct {
      __IOM uint32 SIG_ID     : 5;            /*!< [4..0] DMA request trigger input selected                                 */
            uint32            : 3;
      __IOM uint32 OIE        : 1;            /*!< [8..8] Interrupt enable at trigger event overrun                          */
            uint32            : 7;
      __IOM uint32 GE         : 1;            /*!< [16..16] DMA request generator channel enable/disable                     */
      __IOM uint32 GPOL       : 2;            /*!< [18..17] DMA request generator trigger event type selection
                                                     Defines the trigger event on the selected DMA request trigger
                                                     input                                                                     */
      __IOM uint32 GNBREQ     : 5;            /*!< [23..19] Number of DMA requests to generate Defines the number
                                                     of DMA requests generated after a trigger event, then stop
                                                     generating. The actual number of generated DMA requests
                                                     is GNBREQ+1. Note: This field can only be written when
                                                     GE bit is reset.                                                          */
            uint32            : 8;
    } bit;
  } DMAMUX2_RG7CR;
  __IM  uint32  RESERVED2[8];
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000140) DMAMux - DMA request generator status register             */
    
    struct {
      __IM  uint32 OF         : 8;            /*!< [7..0] Trigger event overrun flag The flag is set when a trigger
                                                     event occurs on DMA request generator channel x, while
                                                     the DMA request generator counter value is lower than GNBREQ.
                                                     The flag is cleared by writing 1 to the corresponding COFx
                                                     bit in DMAMUX_RGCFR register.                                             */
            uint32            : 24;
    } bit;
  } DMAMUX2_RGSR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000144) DMAMux - DMA request generator clear flag register         */
    
    struct {
      __OM  uint32 COF        : 8;            /*!< [7..0] Clear trigger event overrun flag Upon setting, this bit
                                                     clears the corresponding overrun flag OFx in the DMAMUX_RGCSR
                                                     register.                                                                 */
            uint32            : 24;
    } bit;
  } DMAMUX2_RGCFR;
} DMAMUX2_Type;                                 /*!< Size = 328 (0x148)                                                        */



/* =========================================================================================================================== */
/* ================                                            FMC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief FMC (FMC)
  */

typedef struct {                                /*!< (@ 0x52004000) FMC Structure                                              */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) This register contains the control information
                                                                    of each memory bank, used for SRAMs, PSRAM
                                                                    and NOR Flash memories.                                    */
    
    struct {
      __IOM uint32 MBKEN      : 1;            /*!< [0..0] Memory bank enable bit This bit enables the memory bank.
                                                     After reset Bank1 is enabled, all others are disabled.
                                                     Accessing a disabled bank causes an ERROR on AXI bus.                     */
      __IOM uint32 MUXEN      : 1;            /*!< [1..1] Address/data multiplexing enable bit When this bit is
                                                     set, the address and data values are multiplexed on the
                                                     data bus, valid only with NOR and PSRAM memories:                         */
      __IOM uint32 MTYP       : 2;            /*!< [3..2] Memory type These bits define the type of external memory
                                                     attached to the corresponding memory bank:                                */
      __IOM uint32 MWID       : 2;            /*!< [5..4] Memory data bus width Defines the external memory device
                                                     width, valid for all type of memories.                                    */
      __IOM uint32 FACCEN     : 1;            /*!< [6..6] Flash access enable This bit enables NOR Flash memory
                                                     access operations.                                                        */
            uint32            : 1;
      __IOM uint32 BURSTEN    : 1;            /*!< [8..8] Burst enable bit This bit enables/disables synchronous
                                                     accesses during read operations. It is valid only for synchronous
                                                     memories operating in Burst mode:                                         */
      __IOM uint32 WAITPOL    : 1;            /*!< [9..9] Wait signal polarity bit This bit defines the polarity
                                                     of the wait signal from memory used for either in synchronous
                                                     or asynchronous mode:                                                     */
            uint32            : 1;
      __IOM uint32 WAITCFG    : 1;            /*!< [11..11] Wait timing configuration The NWAIT signal indicates
                                                     whether the data from the memory are valid or if a wait
                                                     state must be inserted when accessing the memory in synchronous
                                                     mode. This configuration bit determines if NWAIT is asserted
                                                     by the memory one clock cycle before the wait state or
                                                     during the wait state:                                                    */
      __IOM uint32 WREN       : 1;            /*!< [12..12] Write enable bit This bit indicates whether write operations
                                                     are enabled/disabled in the bank by the FMC:                              */
      __IOM uint32 WAITEN     : 1;            /*!< [13..13] Wait enable bit This bit enables/disables wait-state
                                                     insertion via the NWAIT signal when accessing the memory
                                                     in synchronous mode.                                                      */
      __IOM uint32 EXTMOD     : 1;            /*!< [14..14] Extended mode enable. This bit enables the FMC to program
                                                     the write timings for asynchronous accesses inside the
                                                     FMC_BWTR register, thus resulting in different timings
                                                     for read and write operations. Note: When the extended
                                                     mode is disabled, the FMC can operate in Mode1 or Mode2
                                                     as follows: ** Mode 1 is the default mode when the SRAM/PSRAM
                                                     memory type is selected (MTYP =0x0 or 0x01) ** Mode 2 is
                                                     the de                                                                    */
      __IOM uint32 ASYNCWAIT  : 1;            /*!< [15..15] Wait signal during asynchronous transfers This bit
                                                     enables/disables the FMC to use the wait signal even during
                                                     an asynchronous protocol.                                                 */
      __IOM uint32 CPSIZE     : 3;            /*!< [18..16] CRAM Page Size These are used for Cellular RAM 1.5
                                                     which does not allow burst access to cross the address
                                                     boundaries between pages. When these bits are configured,
                                                     the FMC controller splits automatically the burst access
                                                     when the memory page size is reached (refer to memory datasheet
                                                     for page size). Other configuration: reserved.                            */
      __IOM uint32 CBURSTRW   : 1;            /*!< [19..19] Write burst enable For PSRAM (CRAM) operating in Burst
                                                     mode, the bit enables synchronous accesses during write
                                                     operations. The enable bit for synchronous read accesses
                                                     is the BURSTEN bit in the FMC_BCRx register.                              */
      __IOM uint32 CCLKEN     : 1;            /*!< [20..20] Continuous Clock Enable This bit enables the FMC_CLK
                                                     clock output to external memory devices. Note: The CCLKEN
                                                     bit of the FMC_BCR2..4 registers is dont care. It is only
                                                     enabled through the FMC_BCR1 register. Bank 1 must be configured
                                                     in synchronous mode to generate the FMC_CLK continuous
                                                     clock. If CCLKEN bit is set, the FMC_CLK clock ratio is
                                                     specified by CLKDIV value in the FMC_BTR1 register.                       */
      __IOM uint32 WFDIS      : 1;            /*!< [21..21] Write FIFO Disable This bit disables the Write FIFO
                                                     used by the FMC controller. Note: The WFDIS bit of the
                                                     FMC_BCR2..4 registers is dont care. It is only enabled
                                                     through the FMC_BCR1 register.                                            */
            uint32            : 2;
      __IOM uint32 BMAP       : 2;            /*!< [25..24] FMC bank mapping These bits allows different to remap
                                                     SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.Refer
                                                     to Table 10 for Note: The BMAP bits of the FMC_BCR2..4
                                                     registers are dont care. It is only enabled through the
                                                     FMC_BCR1 register.                                                        */
            uint32            : 5;
      __IOM uint32 FMCEN      : 1;            /*!< [31..31] FMC controller Enable This bit enables/disables the
                                                     FMC controller. Note: The FMCEN bit of the FMC_BCR2..4
                                                     registers is dont care. It is only enabled through the
                                                     FMC_BCR1 register.                                                        */
    } bit;
  } FMC_BCR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) This register contains the control information
                                                                    of each memory bank, used for SRAMs, PSRAM
                                                                    and NOR Flash memories.If the EXTMOD bit
                                                                    is set in the FMC_BCRx register, then this
                                                                    register is partitioned for write and read
                                                                    access, that is, 2 registers are available:
                                                                    one to configure read accesses (this register)
                                                                    and one to configure write accesses (FMC_BWTRx
                                                                    registers).                                                */
    
    struct {
      __IOM uint32 ADDSET     : 4;            /*!< [3..0] Address setup phase duration These bits are written by
                                                     software to define the duration of the address setup phase
                                                     (refer to Figure81 to Figure93), used in SRAMs, ROMs and
                                                     asynchronous NOR Flash: For each access mode address setup
                                                     phase duration, please refer to the respective figure (refer
                                                     to Figure81 to Figure93). Note: In synchronous accesses,
                                                     this value is dont care. In Muxed mode or Mode D, the mi                  */
      __IOM uint32 ADDHLD     : 4;            /*!< [7..4] Address-hold phase duration These bits are written by
                                                     software to define the duration of the address hold phase
                                                     (refer to Figure81 to Figure93), used in mode D or multiplexed
                                                     accesses: For each access mode address-hold phase duration,
                                                     please refer to the respective figure (Figure81 to Figure93).
                                                     Note: In synchronous accesses, this value is not used,
                                                     the address hold phase is always 1 memory clock                           */
      __IOM uint32 DATAST     : 8;            /*!< [15..8] Data-phase duration These bits are written by software
                                                     to define the duration of the data phase (refer to Figure81
                                                     to Figure93), used in asynchronous accesses: For each memory
                                                     type and access mode data-phase duration, please refer
                                                     to the respective figure (Figure81 to Figure93). Example:
                                                     Mode1, write access, DATAST=1: Data-phase duration= DATAST+1
                                                     = 2 KCK_FMC clock cycles. Note: In sync                                   */
      __IOM uint32 BUSTURN    : 4;            /*!< [19..16] Bus turnaround phase duration These bits are written
                                                     by software to add a delay at the end of a write-to-read
                                                     or read-to write transaction. The programmed bus turnaround
                                                     delay is inserted between an asynchronous read (in muxed
                                                     or mode D) or write transaction and any other asynchronous
                                                     /synchronous read/write from/to a static bank. If a read
                                                     operation is performed, the bank can be the same or a differe             */
      __IOM uint32 CLKDIV     : 4;            /*!< [23..20] Clock divide ratio (for FMC_CLK signal) These bits
                                                     define the period of FMC_CLK clock output signal, expressed
                                                     in number of KCK_FMC cycles: In asynchronous NOR Flash,
                                                     SRAM or PSRAM accesses, this value is dont care. Note:
                                                     Refer to Section20.6.5: Synchronous transactions for FMC_CLK
                                                     divider ratio formula)                                                    */
      __IOM uint32 DATLAT     : 4;            /*!< [27..24] Data latency for synchronous memory For synchronous
                                                     access with read write burst mode enabled these bits define
                                                     the number of memory clock cycles                                         */
      __IOM uint32 ACCMOD     : 2;            /*!< [29..28] Access mode These bits specify the asynchronous access
                                                     modes as shown in the timing diagrams. They are taken into
                                                     account only when the EXTMOD bit in the FMC_BCRx register
                                                     is 1.                                                                     */
            uint32            : 2;
    } bit;
  } FMC_BTR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) This register contains the control information
                                                                    of each memory bank, used for SRAMs, PSRAM
                                                                    and NOR Flash memories.                                    */
    
    struct {
      __IOM uint32 MBKEN      : 1;            /*!< [0..0] Memory bank enable bit This bit enables the memory bank.
                                                     After reset Bank1 is enabled, all others are disabled.
                                                     Accessing a disabled bank causes an ERROR on AXI bus.                     */
      __IOM uint32 MUXEN      : 1;            /*!< [1..1] Address/data multiplexing enable bit When this bit is
                                                     set, the address and data values are multiplexed on the
                                                     data bus, valid only with NOR and PSRAM memories:                         */
      __IOM uint32 MTYP       : 2;            /*!< [3..2] Memory type These bits define the type of external memory
                                                     attached to the corresponding memory bank:                                */
      __IOM uint32 MWID       : 2;            /*!< [5..4] Memory data bus width Defines the external memory device
                                                     width, valid for all type of memories.                                    */
      __IOM uint32 FACCEN     : 1;            /*!< [6..6] Flash access enable This bit enables NOR Flash memory
                                                     access operations.                                                        */
            uint32            : 1;
      __IOM uint32 BURSTEN    : 1;            /*!< [8..8] Burst enable bit This bit enables/disables synchronous
                                                     accesses during read operations. It is valid only for synchronous
                                                     memories operating in Burst mode:                                         */
      __IOM uint32 WAITPOL    : 1;            /*!< [9..9] Wait signal polarity bit This bit defines the polarity
                                                     of the wait signal from memory used for either in synchronous
                                                     or asynchronous mode:                                                     */
            uint32            : 1;
      __IOM uint32 WAITCFG    : 1;            /*!< [11..11] Wait timing configuration The NWAIT signal indicates
                                                     whether the data from the memory are valid or if a wait
                                                     state must be inserted when accessing the memory in synchronous
                                                     mode. This configuration bit determines if NWAIT is asserted
                                                     by the memory one clock cycle before the wait state or
                                                     during the wait state:                                                    */
      __IOM uint32 WREN       : 1;            /*!< [12..12] Write enable bit This bit indicates whether write operations
                                                     are enabled/disabled in the bank by the FMC:                              */
      __IOM uint32 WAITEN     : 1;            /*!< [13..13] Wait enable bit This bit enables/disables wait-state
                                                     insertion via the NWAIT signal when accessing the memory
                                                     in synchronous mode.                                                      */
      __IOM uint32 EXTMOD     : 1;            /*!< [14..14] Extended mode enable. This bit enables the FMC to program
                                                     the write timings for asynchronous accesses inside the
                                                     FMC_BWTR register, thus resulting in different timings
                                                     for read and write operations. Note: When the extended
                                                     mode is disabled, the FMC can operate in Mode1 or Mode2
                                                     as follows: ** Mode 1 is the default mode when the SRAM/PSRAM
                                                     memory type is selected (MTYP =0x0 or 0x01) ** Mode 2 is
                                                     the de                                                                    */
      __IOM uint32 ASYNCWAIT  : 1;            /*!< [15..15] Wait signal during asynchronous transfers This bit
                                                     enables/disables the FMC to use the wait signal even during
                                                     an asynchronous protocol.                                                 */
      __IOM uint32 CPSIZE     : 3;            /*!< [18..16] CRAM Page Size These are used for Cellular RAM 1.5
                                                     which does not allow burst access to cross the address
                                                     boundaries between pages. When these bits are configured,
                                                     the FMC controller splits automatically the burst access
                                                     when the memory page size is reached (refer to memory datasheet
                                                     for page size). Other configuration: reserved.                            */
      __IOM uint32 CBURSTRW   : 1;            /*!< [19..19] Write burst enable For PSRAM (CRAM) operating in Burst
                                                     mode, the bit enables synchronous accesses during write
                                                     operations. The enable bit for synchronous read accesses
                                                     is the BURSTEN bit in the FMC_BCRx register.                              */
      __IOM uint32 CCLKEN     : 1;            /*!< [20..20] Continuous Clock Enable This bit enables the FMC_CLK
                                                     clock output to external memory devices. Note: The CCLKEN
                                                     bit of the FMC_BCR2..4 registers is dont care. It is only
                                                     enabled through the FMC_BCR1 register. Bank 1 must be configured
                                                     in synchronous mode to generate the FMC_CLK continuous
                                                     clock. If CCLKEN bit is set, the FMC_CLK clock ratio is
                                                     specified by CLKDIV value in the FMC_BTR1 register.                       */
      __IOM uint32 WFDIS      : 1;            /*!< [21..21] Write FIFO Disable This bit disables the Write FIFO
                                                     used by the FMC controller. Note: The WFDIS bit of the
                                                     FMC_BCR2..4 registers is dont care. It is only enabled
                                                     through the FMC_BCR1 register.                                            */
            uint32            : 2;
      __IOM uint32 BMAP       : 2;            /*!< [25..24] FMC bank mapping These bits allows different to remap
                                                     SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.Refer
                                                     to Table 10 for Note: The BMAP bits of the FMC_BCR2..4
                                                     registers are dont care. It is only enabled through the
                                                     FMC_BCR1 register.                                                        */
            uint32            : 5;
      __IOM uint32 FMCEN      : 1;            /*!< [31..31] FMC controller Enable This bit enables/disables the
                                                     FMC controller. Note: The FMCEN bit of the FMC_BCR2..4
                                                     registers is dont care. It is only enabled through the
                                                     FMC_BCR1 register.                                                        */
    } bit;
  } FMC_BCR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) This register contains the control information
                                                                    of each memory bank, used for SRAMs, PSRAM
                                                                    and NOR Flash memories.If the EXTMOD bit
                                                                    is set in the FMC_BCRx register, then this
                                                                    register is partitioned for write and read
                                                                    access, that is, 2 registers are available:
                                                                    one to configure read accesses (this register)
                                                                    and one to configure write accesses (FMC_BWTRx
                                                                    registers).                                                */
    
    struct {
      __IOM uint32 ADDSET     : 4;            /*!< [3..0] Address setup phase duration These bits are written by
                                                     software to define the duration of the address setup phase
                                                     (refer to Figure81 to Figure93), used in SRAMs, ROMs and
                                                     asynchronous NOR Flash: For each access mode address setup
                                                     phase duration, please refer to the respective figure (refer
                                                     to Figure81 to Figure93). Note: In synchronous accesses,
                                                     this value is dont care. In Muxed mode or Mode D, the mi                  */
      __IOM uint32 ADDHLD     : 4;            /*!< [7..4] Address-hold phase duration These bits are written by
                                                     software to define the duration of the address hold phase
                                                     (refer to Figure81 to Figure93), used in mode D or multiplexed
                                                     accesses: For each access mode address-hold phase duration,
                                                     please refer to the respective figure (Figure81 to Figure93).
                                                     Note: In synchronous accesses, this value is not used,
                                                     the address hold phase is always 1 memory clock                           */
      __IOM uint32 DATAST     : 8;            /*!< [15..8] Data-phase duration These bits are written by software
                                                     to define the duration of the data phase (refer to Figure81
                                                     to Figure93), used in asynchronous accesses: For each memory
                                                     type and access mode data-phase duration, please refer
                                                     to the respective figure (Figure81 to Figure93). Example:
                                                     Mode1, write access, DATAST=1: Data-phase duration= DATAST+1
                                                     = 2 KCK_FMC clock cycles. Note: In sync                                   */
      __IOM uint32 BUSTURN    : 4;            /*!< [19..16] Bus turnaround phase duration These bits are written
                                                     by software to add a delay at the end of a write-to-read
                                                     or read-to write transaction. The programmed bus turnaround
                                                     delay is inserted between an asynchronous read (in muxed
                                                     or mode D) or write transaction and any other asynchronous
                                                     /synchronous read/write from/to a static bank. If a read
                                                     operation is performed, the bank can be the same or a differe             */
      __IOM uint32 CLKDIV     : 4;            /*!< [23..20] Clock divide ratio (for FMC_CLK signal) These bits
                                                     define the period of FMC_CLK clock output signal, expressed
                                                     in number of KCK_FMC cycles: In asynchronous NOR Flash,
                                                     SRAM or PSRAM accesses, this value is dont care. Note:
                                                     Refer to Section20.6.5: Synchronous transactions for FMC_CLK
                                                     divider ratio formula)                                                    */
      __IOM uint32 DATLAT     : 4;            /*!< [27..24] Data latency for synchronous memory For synchronous
                                                     access with read write burst mode enabled these bits define
                                                     the number of memory clock cycles                                         */
      __IOM uint32 ACCMOD     : 2;            /*!< [29..28] Access mode These bits specify the asynchronous access
                                                     modes as shown in the timing diagrams. They are taken into
                                                     account only when the EXTMOD bit in the FMC_BCRx register
                                                     is 1.                                                                     */
            uint32            : 2;
    } bit;
  } FMC_BTR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) This register contains the control information
                                                                    of each memory bank, used for SRAMs, PSRAM
                                                                    and NOR Flash memories.                                    */
    
    struct {
      __IOM uint32 MBKEN      : 1;            /*!< [0..0] Memory bank enable bit This bit enables the memory bank.
                                                     After reset Bank1 is enabled, all others are disabled.
                                                     Accessing a disabled bank causes an ERROR on AXI bus.                     */
      __IOM uint32 MUXEN      : 1;            /*!< [1..1] Address/data multiplexing enable bit When this bit is
                                                     set, the address and data values are multiplexed on the
                                                     data bus, valid only with NOR and PSRAM memories:                         */
      __IOM uint32 MTYP       : 2;            /*!< [3..2] Memory type These bits define the type of external memory
                                                     attached to the corresponding memory bank:                                */
      __IOM uint32 MWID       : 2;            /*!< [5..4] Memory data bus width Defines the external memory device
                                                     width, valid for all type of memories.                                    */
      __IOM uint32 FACCEN     : 1;            /*!< [6..6] Flash access enable This bit enables NOR Flash memory
                                                     access operations.                                                        */
            uint32            : 1;
      __IOM uint32 BURSTEN    : 1;            /*!< [8..8] Burst enable bit This bit enables/disables synchronous
                                                     accesses during read operations. It is valid only for synchronous
                                                     memories operating in Burst mode:                                         */
      __IOM uint32 WAITPOL    : 1;            /*!< [9..9] Wait signal polarity bit This bit defines the polarity
                                                     of the wait signal from memory used for either in synchronous
                                                     or asynchronous mode:                                                     */
            uint32            : 1;
      __IOM uint32 WAITCFG    : 1;            /*!< [11..11] Wait timing configuration The NWAIT signal indicates
                                                     whether the data from the memory are valid or if a wait
                                                     state must be inserted when accessing the memory in synchronous
                                                     mode. This configuration bit determines if NWAIT is asserted
                                                     by the memory one clock cycle before the wait state or
                                                     during the wait state:                                                    */
      __IOM uint32 WREN       : 1;            /*!< [12..12] Write enable bit This bit indicates whether write operations
                                                     are enabled/disabled in the bank by the FMC:                              */
      __IOM uint32 WAITEN     : 1;            /*!< [13..13] Wait enable bit This bit enables/disables wait-state
                                                     insertion via the NWAIT signal when accessing the memory
                                                     in synchronous mode.                                                      */
      __IOM uint32 EXTMOD     : 1;            /*!< [14..14] Extended mode enable. This bit enables the FMC to program
                                                     the write timings for asynchronous accesses inside the
                                                     FMC_BWTR register, thus resulting in different timings
                                                     for read and write operations. Note: When the extended
                                                     mode is disabled, the FMC can operate in Mode1 or Mode2
                                                     as follows: ** Mode 1 is the default mode when the SRAM/PSRAM
                                                     memory type is selected (MTYP =0x0 or 0x01) ** Mode 2 is
                                                     the de                                                                    */
      __IOM uint32 ASYNCWAIT  : 1;            /*!< [15..15] Wait signal during asynchronous transfers This bit
                                                     enables/disables the FMC to use the wait signal even during
                                                     an asynchronous protocol.                                                 */
      __IOM uint32 CPSIZE     : 3;            /*!< [18..16] CRAM Page Size These are used for Cellular RAM 1.5
                                                     which does not allow burst access to cross the address
                                                     boundaries between pages. When these bits are configured,
                                                     the FMC controller splits automatically the burst access
                                                     when the memory page size is reached (refer to memory datasheet
                                                     for page size). Other configuration: reserved.                            */
      __IOM uint32 CBURSTRW   : 1;            /*!< [19..19] Write burst enable For PSRAM (CRAM) operating in Burst
                                                     mode, the bit enables synchronous accesses during write
                                                     operations. The enable bit for synchronous read accesses
                                                     is the BURSTEN bit in the FMC_BCRx register.                              */
      __IOM uint32 CCLKEN     : 1;            /*!< [20..20] Continuous Clock Enable This bit enables the FMC_CLK
                                                     clock output to external memory devices. Note: The CCLKEN
                                                     bit of the FMC_BCR2..4 registers is dont care. It is only
                                                     enabled through the FMC_BCR1 register. Bank 1 must be configured
                                                     in synchronous mode to generate the FMC_CLK continuous
                                                     clock. If CCLKEN bit is set, the FMC_CLK clock ratio is
                                                     specified by CLKDIV value in the FMC_BTR1 register.                       */
      __IOM uint32 WFDIS      : 1;            /*!< [21..21] Write FIFO Disable This bit disables the Write FIFO
                                                     used by the FMC controller. Note: The WFDIS bit of the
                                                     FMC_BCR2..4 registers is dont care. It is only enabled
                                                     through the FMC_BCR1 register.                                            */
            uint32            : 2;
      __IOM uint32 BMAP       : 2;            /*!< [25..24] FMC bank mapping These bits allows different to remap
                                                     SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.Refer
                                                     to Table 10 for Note: The BMAP bits of the FMC_BCR2..4
                                                     registers are dont care. It is only enabled through the
                                                     FMC_BCR1 register.                                                        */
            uint32            : 5;
      __IOM uint32 FMCEN      : 1;            /*!< [31..31] FMC controller Enable This bit enables/disables the
                                                     FMC controller. Note: The FMCEN bit of the FMC_BCR2..4
                                                     registers is dont care. It is only enabled through the
                                                     FMC_BCR1 register.                                                        */
    } bit;
  } FMC_BCR3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000014) This register contains the control information
                                                                    of each memory bank, used for SRAMs, PSRAM
                                                                    and NOR Flash memories.If the EXTMOD bit
                                                                    is set in the FMC_BCRx register, then this
                                                                    register is partitioned for write and read
                                                                    access, that is, 2 registers are available:
                                                                    one to configure read accesses (this register)
                                                                    and one to configure write accesses (FMC_BWTRx
                                                                    registers).                                                */
    
    struct {
      __IOM uint32 ADDSET     : 4;            /*!< [3..0] Address setup phase duration These bits are written by
                                                     software to define the duration of the address setup phase
                                                     (refer to Figure81 to Figure93), used in SRAMs, ROMs and
                                                     asynchronous NOR Flash: For each access mode address setup
                                                     phase duration, please refer to the respective figure (refer
                                                     to Figure81 to Figure93). Note: In synchronous accesses,
                                                     this value is dont care. In Muxed mode or Mode D, the mi                  */
      __IOM uint32 ADDHLD     : 4;            /*!< [7..4] Address-hold phase duration These bits are written by
                                                     software to define the duration of the address hold phase
                                                     (refer to Figure81 to Figure93), used in mode D or multiplexed
                                                     accesses: For each access mode address-hold phase duration,
                                                     please refer to the respective figure (Figure81 to Figure93).
                                                     Note: In synchronous accesses, this value is not used,
                                                     the address hold phase is always 1 memory clock                           */
      __IOM uint32 DATAST     : 8;            /*!< [15..8] Data-phase duration These bits are written by software
                                                     to define the duration of the data phase (refer to Figure81
                                                     to Figure93), used in asynchronous accesses: For each memory
                                                     type and access mode data-phase duration, please refer
                                                     to the respective figure (Figure81 to Figure93). Example:
                                                     Mode1, write access, DATAST=1: Data-phase duration= DATAST+1
                                                     = 2 KCK_FMC clock cycles. Note: In sync                                   */
      __IOM uint32 BUSTURN    : 4;            /*!< [19..16] Bus turnaround phase duration These bits are written
                                                     by software to add a delay at the end of a write-to-read
                                                     or read-to write transaction. The programmed bus turnaround
                                                     delay is inserted between an asynchronous read (in muxed
                                                     or mode D) or write transaction and any other asynchronous
                                                     /synchronous read/write from/to a static bank. If a read
                                                     operation is performed, the bank can be the same or a differe             */
      __IOM uint32 CLKDIV     : 4;            /*!< [23..20] Clock divide ratio (for FMC_CLK signal) These bits
                                                     define the period of FMC_CLK clock output signal, expressed
                                                     in number of KCK_FMC cycles: In asynchronous NOR Flash,
                                                     SRAM or PSRAM accesses, this value is dont care. Note:
                                                     Refer to Section20.6.5: Synchronous transactions for FMC_CLK
                                                     divider ratio formula)                                                    */
      __IOM uint32 DATLAT     : 4;            /*!< [27..24] Data latency for synchronous memory For synchronous
                                                     access with read write burst mode enabled these bits define
                                                     the number of memory clock cycles                                         */
      __IOM uint32 ACCMOD     : 2;            /*!< [29..28] Access mode These bits specify the asynchronous access
                                                     modes as shown in the timing diagrams. They are taken into
                                                     account only when the EXTMOD bit in the FMC_BCRx register
                                                     is 1.                                                                     */
            uint32            : 2;
    } bit;
  } FMC_BTR3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000018) This register contains the control information
                                                                    of each memory bank, used for SRAMs, PSRAM
                                                                    and NOR Flash memories.                                    */
    
    struct {
      __IOM uint32 MBKEN      : 1;            /*!< [0..0] Memory bank enable bit This bit enables the memory bank.
                                                     After reset Bank1 is enabled, all others are disabled.
                                                     Accessing a disabled bank causes an ERROR on AXI bus.                     */
      __IOM uint32 MUXEN      : 1;            /*!< [1..1] Address/data multiplexing enable bit When this bit is
                                                     set, the address and data values are multiplexed on the
                                                     data bus, valid only with NOR and PSRAM memories:                         */
      __IOM uint32 MTYP       : 2;            /*!< [3..2] Memory type These bits define the type of external memory
                                                     attached to the corresponding memory bank:                                */
      __IOM uint32 MWID       : 2;            /*!< [5..4] Memory data bus width Defines the external memory device
                                                     width, valid for all type of memories.                                    */
      __IOM uint32 FACCEN     : 1;            /*!< [6..6] Flash access enable This bit enables NOR Flash memory
                                                     access operations.                                                        */
            uint32            : 1;
      __IOM uint32 BURSTEN    : 1;            /*!< [8..8] Burst enable bit This bit enables/disables synchronous
                                                     accesses during read operations. It is valid only for synchronous
                                                     memories operating in Burst mode:                                         */
      __IOM uint32 WAITPOL    : 1;            /*!< [9..9] Wait signal polarity bit This bit defines the polarity
                                                     of the wait signal from memory used for either in synchronous
                                                     or asynchronous mode:                                                     */
            uint32            : 1;
      __IOM uint32 WAITCFG    : 1;            /*!< [11..11] Wait timing configuration The NWAIT signal indicates
                                                     whether the data from the memory are valid or if a wait
                                                     state must be inserted when accessing the memory in synchronous
                                                     mode. This configuration bit determines if NWAIT is asserted
                                                     by the memory one clock cycle before the wait state or
                                                     during the wait state:                                                    */
      __IOM uint32 WREN       : 1;            /*!< [12..12] Write enable bit This bit indicates whether write operations
                                                     are enabled/disabled in the bank by the FMC:                              */
      __IOM uint32 WAITEN     : 1;            /*!< [13..13] Wait enable bit This bit enables/disables wait-state
                                                     insertion via the NWAIT signal when accessing the memory
                                                     in synchronous mode.                                                      */
      __IOM uint32 EXTMOD     : 1;            /*!< [14..14] Extended mode enable. This bit enables the FMC to program
                                                     the write timings for asynchronous accesses inside the
                                                     FMC_BWTR register, thus resulting in different timings
                                                     for read and write operations. Note: When the extended
                                                     mode is disabled, the FMC can operate in Mode1 or Mode2
                                                     as follows: ** Mode 1 is the default mode when the SRAM/PSRAM
                                                     memory type is selected (MTYP =0x0 or 0x01) ** Mode 2 is
                                                     the de                                                                    */
      __IOM uint32 ASYNCWAIT  : 1;            /*!< [15..15] Wait signal during asynchronous transfers This bit
                                                     enables/disables the FMC to use the wait signal even during
                                                     an asynchronous protocol.                                                 */
      __IOM uint32 CPSIZE     : 3;            /*!< [18..16] CRAM Page Size These are used for Cellular RAM 1.5
                                                     which does not allow burst access to cross the address
                                                     boundaries between pages. When these bits are configured,
                                                     the FMC controller splits automatically the burst access
                                                     when the memory page size is reached (refer to memory datasheet
                                                     for page size). Other configuration: reserved.                            */
      __IOM uint32 CBURSTRW   : 1;            /*!< [19..19] Write burst enable For PSRAM (CRAM) operating in Burst
                                                     mode, the bit enables synchronous accesses during write
                                                     operations. The enable bit for synchronous read accesses
                                                     is the BURSTEN bit in the FMC_BCRx register.                              */
      __IOM uint32 CCLKEN     : 1;            /*!< [20..20] Continuous Clock Enable This bit enables the FMC_CLK
                                                     clock output to external memory devices. Note: The CCLKEN
                                                     bit of the FMC_BCR2..4 registers is dont care. It is only
                                                     enabled through the FMC_BCR1 register. Bank 1 must be configured
                                                     in synchronous mode to generate the FMC_CLK continuous
                                                     clock. If CCLKEN bit is set, the FMC_CLK clock ratio is
                                                     specified by CLKDIV value in the FMC_BTR1 register.                       */
      __IOM uint32 WFDIS      : 1;            /*!< [21..21] Write FIFO Disable This bit disables the Write FIFO
                                                     used by the FMC controller. Note: The WFDIS bit of the
                                                     FMC_BCR2..4 registers is dont care. It is only enabled
                                                     through the FMC_BCR1 register.                                            */
            uint32            : 2;
      __IOM uint32 BMAP       : 2;            /*!< [25..24] FMC bank mapping These bits allows different to remap
                                                     SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.Refer
                                                     to Table 10 for Note: The BMAP bits of the FMC_BCR2..4
                                                     registers are dont care. It is only enabled through the
                                                     FMC_BCR1 register.                                                        */
            uint32            : 5;
      __IOM uint32 FMCEN      : 1;            /*!< [31..31] FMC controller Enable This bit enables/disables the
                                                     FMC controller. Note: The FMCEN bit of the FMC_BCR2..4
                                                     registers is dont care. It is only enabled through the
                                                     FMC_BCR1 register.                                                        */
    } bit;
  } FMC_BCR4;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000001C) This register contains the control information
                                                                    of each memory bank, used for SRAMs, PSRAM
                                                                    and NOR Flash memories.If the EXTMOD bit
                                                                    is set in the FMC_BCRx register, then this
                                                                    register is partitioned for write and read
                                                                    access, that is, 2 registers are available:
                                                                    one to configure read accesses (this register)
                                                                    and one to configure write accesses (FMC_BWTRx
                                                                    registers).                                                */
    
    struct {
      __IOM uint32 ADDSET     : 4;            /*!< [3..0] Address setup phase duration These bits are written by
                                                     software to define the duration of the address setup phase
                                                     (refer to Figure81 to Figure93), used in SRAMs, ROMs and
                                                     asynchronous NOR Flash: For each access mode address setup
                                                     phase duration, please refer to the respective figure (refer
                                                     to Figure81 to Figure93). Note: In synchronous accesses,
                                                     this value is dont care. In Muxed mode or Mode D, the mi                  */
      __IOM uint32 ADDHLD     : 4;            /*!< [7..4] Address-hold phase duration These bits are written by
                                                     software to define the duration of the address hold phase
                                                     (refer to Figure81 to Figure93), used in mode D or multiplexed
                                                     accesses: For each access mode address-hold phase duration,
                                                     please refer to the respective figure (Figure81 to Figure93).
                                                     Note: In synchronous accesses, this value is not used,
                                                     the address hold phase is always 1 memory clock                           */
      __IOM uint32 DATAST     : 8;            /*!< [15..8] Data-phase duration These bits are written by software
                                                     to define the duration of the data phase (refer to Figure81
                                                     to Figure93), used in asynchronous accesses: For each memory
                                                     type and access mode data-phase duration, please refer
                                                     to the respective figure (Figure81 to Figure93). Example:
                                                     Mode1, write access, DATAST=1: Data-phase duration= DATAST+1
                                                     = 2 KCK_FMC clock cycles. Note: In sync                                   */
      __IOM uint32 BUSTURN    : 4;            /*!< [19..16] Bus turnaround phase duration These bits are written
                                                     by software to add a delay at the end of a write-to-read
                                                     or read-to write transaction. The programmed bus turnaround
                                                     delay is inserted between an asynchronous read (in muxed
                                                     or mode D) or write transaction and any other asynchronous
                                                     /synchronous read/write from/to a static bank. If a read
                                                     operation is performed, the bank can be the same or a differe             */
      __IOM uint32 CLKDIV     : 4;            /*!< [23..20] Clock divide ratio (for FMC_CLK signal) These bits
                                                     define the period of FMC_CLK clock output signal, expressed
                                                     in number of KCK_FMC cycles: In asynchronous NOR Flash,
                                                     SRAM or PSRAM accesses, this value is dont care. Note:
                                                     Refer to Section20.6.5: Synchronous transactions for FMC_CLK
                                                     divider ratio formula)                                                    */
      __IOM uint32 DATLAT     : 4;            /*!< [27..24] Data latency for synchronous memory For synchronous
                                                     access with read write burst mode enabled these bits define
                                                     the number of memory clock cycles                                         */
      __IOM uint32 ACCMOD     : 2;            /*!< [29..28] Access mode These bits specify the asynchronous access
                                                     modes as shown in the timing diagrams. They are taken into
                                                     account only when the EXTMOD bit in the FMC_BCRx register
                                                     is 1.                                                                     */
            uint32            : 2;
    } bit;
  } FMC_BTR4;
  __IM  uint32  RESERVED[24];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000080) NAND Flash control registers                               */
    
    struct {
            uint32            : 1;
      __IOM uint32 PWAITEN    : 1;            /*!< [1..1] Wait feature enable bit. This bit enables the Wait feature
                                                     for the NAND Flash memory bank:                                           */
      __IOM uint32 PBKEN      : 1;            /*!< [2..2] NAND Flash memory bank enable bit. This bit enables the
                                                     memory bank. Accessing a disabled memory bank causes an
                                                     ERROR on AXI bus                                                          */
            uint32            : 1;
      __IOM uint32 PWID       : 2;            /*!< [5..4] Data bus width. These bits define the external memory
                                                     device width.                                                             */
      __IOM uint32 ECCEN      : 1;            /*!< [6..6] ECC computation logic enable bit                                   */
            uint32            : 2;
      __IOM uint32 TCLR       : 4;            /*!< [12..9] CLE to RE delay. These bits set time from CLE low to
                                                     RE low in number of KCK_FMC clock cycles. The time is give
                                                     by the following formula: t_clr = (TCLR + SET + 2) TKCK_FMC
                                                     where TKCK_FMC is the KCK_FMC clock period Note: Set is
                                                     MEMSET or ATTSET according to the addressed space.                        */
      __IOM uint32 TAR        : 4;            /*!< [16..13] ALE to RE delay. These bits set time from ALE low to
                                                     RE low in number of KCK_FMC clock cycles. Time is: t_ar
                                                     = (TAR + SET + 2) TKCK_FMC where TKCK_FMC is the FMC clock
                                                     period Note: Set is MEMSET or ATTSET according to the addressed
                                                     space.                                                                    */
      __IOM uint32 ECCPS      : 3;            /*!< [19..17] ECC page size. These bits define the page size for
                                                     the extended ECC:                                                         */
            uint32            : 12;
    } bit;
  } FMC_PCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000084) This register contains information about the
                                                                    FIFO status and interrupt. The FMC features
                                                                    a FIFO that is used when writing to memories
                                                                    to transfer up to 16 words of data.This
                                                                    is used to quickly write to the FIFO and
                                                                    free the AXI bus for transactions to peripherals
                                                                    other than the FMC, while the FMC is draining
                                                                    its FIFO into the memory. One of these register
                                                                    bits indicates the status of the FIFO, for
                                                                    ECC purposes.The                                           */
    
    struct {
      __IOM uint32 IRS        : 1;            /*!< [0..0] Interrupt rising edge status The flag is set by hardware
                                                     and reset by software. Note: If this bit is written by
                                                     software to 1 it will be set.                                             */
      __IOM uint32 ILS        : 1;            /*!< [1..1] Interrupt high-level status The flag is set by hardware
                                                     and reset by software.                                                    */
      __IOM uint32 IFS        : 1;            /*!< [2..2] Interrupt falling edge status The flag is set by hardware
                                                     and reset by software. Note: If this bit is written by
                                                     software to 1 it will be set.                                             */
      __IOM uint32 IREN       : 1;            /*!< [3..3] Interrupt rising edge detection enable bit                         */
      __IOM uint32 ILEN       : 1;            /*!< [4..4] Interrupt high-level detection enable bit                          */
      __IOM uint32 IFEN       : 1;            /*!< [5..5] Interrupt falling edge detection enable bit                        */
      __IM  uint32 FEMPT      : 1;            /*!< [6..6] FIFO empty. Read-only bit that provides the status of
                                                     the FIFO                                                                  */
            uint32            : 25;
    } bit;
  } FMC_SR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000088) The FMC_PMEM read/write register contains the
                                                                    timing information for NAND Flash memory
                                                                    bank. This information is used to access
                                                                    either the common memory space of the NAND
                                                                    Flash for command, address write access
                                                                    and data read/write access.                                */
    
    struct {
      __IOM uint32 MEMSET     : 8;            /*!< [7..0] Common memory x setup time These bits define the number
                                                     of KCK_FMC (+1) clock cycles to set up the address before
                                                     the command assertion (NWE, NOE), for NAND Flash read or
                                                     write access to common memory space:                                      */
      __IOM uint32 MEMWAIT    : 8;            /*!< [15..8] Common memory wait time These bits define the minimum
                                                     number of KCK_FMC (+1) clock cycles to assert the command
                                                     (NWE, NOE), for NAND Flash read or write access to common
                                                     memory space. The duration of command assertion is extended
                                                     if the wait signal (NWAIT) is active (low) at the end of
                                                     the programmed value of KCK_FMC:                                          */
      __IOM uint32 MEMHOLD    : 8;            /*!< [23..16] Common memory hold time These bits define the number
                                                     of KCK_FMC clock cycles for write accesses and KCK_FMC+1
                                                     clock cycles for read accesses during which the address
                                                     is held (and data for write accesses) after the command
                                                     is de-asserted (NWE, NOE), for NAND Flash read or write
                                                     access to common memory space:                                            */
      __IOM uint32 MEMHIZ     : 8;            /*!< [31..24] Common memory x data bus Hi-Z time These bits define
                                                     the number of KCK_FMC clock cycles during which the data
                                                     bus is kept Hi-Z after the start of a NAND Flash write
                                                     access to common memory space. This is only valid for write
                                                     transactions:                                                             */
    } bit;
  } FMC_PMEM;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000008C) The FMC_PATT read/write register contains the
                                                                    timing information for NAND Flash memory
                                                                    bank. It is used for 8-bit accesses to the
                                                                    attribute memory space of the NAND Flash
                                                                    for the last address write access if the
                                                                    timing must differ from that of previous
                                                                    accesses (for Ready/Busy management, refer
                                                                    to Section20.8.5: NAND Flash prewait feature).             */
    
    struct {
      __IOM uint32 ATTSET     : 8;            /*!< [7..0] Attribute memory setup time These bits define the number
                                                     of KCK_FMC (+1) clock cycles to set up address before the
                                                     command assertion (NWE, NOE), for NAND Flash read or write
                                                     access to attribute memory space:                                         */
      __IOM uint32 ATTWAIT    : 8;            /*!< [15..8] Attribute memory wait time These bits define the minimum
                                                     number of x KCK_FMC (+1) clock cycles to assert the command
                                                     (NWE, NOE), for NAND Flash read or write access to attribute
                                                     memory space. The duration for command assertion is extended
                                                     if the wait signal (NWAIT) is active (low) at the end of
                                                     the programmed value of KCK_FMC:                                          */
      __IOM uint32 ATTHOLD    : 8;            /*!< [23..16] Attribute memory hold time These bits define the number
                                                     of KCK_FMC clock cycles during which the address is held
                                                     (and data for write access) after the command de-assertion
                                                     (NWE, NOE), for NAND Flash read or write access to attribute
                                                     memory space:                                                             */
      __IOM uint32 ATTHIZ     : 8;            /*!< [31..24] Attribute memory data bus Hi-Z time These bits define
                                                     the number of KCK_FMC clock cycles during which the data
                                                     bus is kept in Hi-Z after the start of a NAND Flash write
                                                     access to attribute memory space on socket. Only valid
                                                     for writ transaction:                                                     */
    } bit;
  } FMC_PATT;
  __IM  uint32  RESERVED1;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000094) This register contain the current error correction
                                                                    code value computed by the ECC computation
                                                                    modules of the FMC NAND controller. When
                                                                    the CPU reads/writes the data from a NAND
                                                                    Flash memory page at the correct address
                                                                    (refer to Section20.8.6: Computation of
                                                                    the error correction code (ECC) in NAND
                                                                    Flash memory), the data read/written from/to
                                                                    the NAND Flash memory are processed automatically
                                                                    by the ECC computation m                                   */
    
    struct {
      __IM  uint32 ECC        : 32;           /*!< [31..0] ECC result This field contains the value computed by
                                                     the ECC computation logic. Table167 describes the contents
                                                     of these bit fields.                                                      */
    } bit;
  } FMC_ECCR;
  __IM  uint32  RESERVED2[27];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000104) This register contains the control information
                                                                    of each memory bank. It is used for SRAMs,
                                                                    PSRAMs and NOR Flash memories. When the
                                                                    EXTMOD bit is set in the FMC_BCRx register,
                                                                    then this register is active for write access.             */
    
    struct {
      __IOM uint32 ADDSET     : 4;            /*!< [3..0] Address setup phase duration. These bits are written
                                                     by software to define the duration of the address setup
                                                     phase in KCK_FMC cycles (refer to Figure81 to Figure93),
                                                     used in asynchronous accesses: ... Note: In synchronous
                                                     accesses, this value is not used, the address setup phase
                                                     is always 1 Flash clock period duration. In muxed mode,
                                                     the minimum ADDSET value is 1.                                            */
      __IOM uint32 ADDHLD     : 4;            /*!< [7..4] Address-hold phase duration. These bits are written by
                                                     software to define the duration of the address hold phase
                                                     (refer to Figure81 to Figure93), used in asynchronous multiplexed
                                                     accesses: ... Note: In synchronous NOR Flash accesses,
                                                     this value is not used, the address hold phase is always
                                                     1 Flash clock period duration.                                            */
      __IOM uint32 DATAST     : 8;            /*!< [15..8] Data-phase duration. These bits are written by software
                                                     to define the duration of the data phase (refer to Figure81
                                                     to Figure93), used in asynchronous SRAM, PSRAM and NOR
                                                     Flash memory accesses:                                                    */
      __IOM uint32 BUSTURN    : 4;            /*!< [19..16] Bus turnaround phase duration These bits are written
                                                     by software to add a delay at the end of a write transaction
                                                     to match the minimum time between consecutive transactions
                                                     (tEHEL from ENx high to ENx low): (BUSTRUN + 1) KCK_FMC
                                                     period &#8805; tEHELmin. The programmed bus turnaround
                                                     delay is inserted between a an asynchronous write transfer
                                                     and any other asynchronous /synchronous read or write                     */
            uint32            : 8;
      __IOM uint32 ACCMOD     : 2;            /*!< [29..28] Access mode. These bits specify the asynchronous access
                                                     modes as shown in the next timing diagrams.These bits are
                                                     taken into account only when the EXTMOD bit in the FMC_BCRx
                                                     register is 1.                                                            */
            uint32            : 2;
    } bit;
  } FMC_BWTR1;
  __IM  uint32  RESERVED3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000010C) This register contains the control information
                                                                    of each memory bank. It is used for SRAMs,
                                                                    PSRAMs and NOR Flash memories. When the
                                                                    EXTMOD bit is set in the FMC_BCRx register,
                                                                    then this register is active for write access.             */
    
    struct {
      __IOM uint32 ADDSET     : 4;            /*!< [3..0] Address setup phase duration. These bits are written
                                                     by software to define the duration of the address setup
                                                     phase in KCK_FMC cycles (refer to Figure81 to Figure93),
                                                     used in asynchronous accesses: ... Note: In synchronous
                                                     accesses, this value is not used, the address setup phase
                                                     is always 1 Flash clock period duration. In muxed mode,
                                                     the minimum ADDSET value is 1.                                            */
      __IOM uint32 ADDHLD     : 4;            /*!< [7..4] Address-hold phase duration. These bits are written by
                                                     software to define the duration of the address hold phase
                                                     (refer to Figure81 to Figure93), used in asynchronous multiplexed
                                                     accesses: ... Note: In synchronous NOR Flash accesses,
                                                     this value is not used, the address hold phase is always
                                                     1 Flash clock period duration.                                            */
      __IOM uint32 DATAST     : 8;            /*!< [15..8] Data-phase duration. These bits are written by software
                                                     to define the duration of the data phase (refer to Figure81
                                                     to Figure93), used in asynchronous SRAM, PSRAM and NOR
                                                     Flash memory accesses:                                                    */
      __IOM uint32 BUSTURN    : 4;            /*!< [19..16] Bus turnaround phase duration These bits are written
                                                     by software to add a delay at the end of a write transaction
                                                     to match the minimum time between consecutive transactions
                                                     (tEHEL from ENx high to ENx low): (BUSTRUN + 1) KCK_FMC
                                                     period &#8805; tEHELmin. The programmed bus turnaround
                                                     delay is inserted between a an asynchronous write transfer
                                                     and any other asynchronous /synchronous read or write                     */
            uint32            : 8;
      __IOM uint32 ACCMOD     : 2;            /*!< [29..28] Access mode. These bits specify the asynchronous access
                                                     modes as shown in the next timing diagrams.These bits are
                                                     taken into account only when the EXTMOD bit in the FMC_BCRx
                                                     register is 1.                                                            */
            uint32            : 2;
    } bit;
  } FMC_BWTR2;
  __IM  uint32  RESERVED4;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000114) This register contains the control information
                                                                    of each memory bank. It is used for SRAMs,
                                                                    PSRAMs and NOR Flash memories. When the
                                                                    EXTMOD bit is set in the FMC_BCRx register,
                                                                    then this register is active for write access.             */
    
    struct {
      __IOM uint32 ADDSET     : 4;            /*!< [3..0] Address setup phase duration. These bits are written
                                                     by software to define the duration of the address setup
                                                     phase in KCK_FMC cycles (refer to Figure81 to Figure93),
                                                     used in asynchronous accesses: ... Note: In synchronous
                                                     accesses, this value is not used, the address setup phase
                                                     is always 1 Flash clock period duration. In muxed mode,
                                                     the minimum ADDSET value is 1.                                            */
      __IOM uint32 ADDHLD     : 4;            /*!< [7..4] Address-hold phase duration. These bits are written by
                                                     software to define the duration of the address hold phase
                                                     (refer to Figure81 to Figure93), used in asynchronous multiplexed
                                                     accesses: ... Note: In synchronous NOR Flash accesses,
                                                     this value is not used, the address hold phase is always
                                                     1 Flash clock period duration.                                            */
      __IOM uint32 DATAST     : 8;            /*!< [15..8] Data-phase duration. These bits are written by software
                                                     to define the duration of the data phase (refer to Figure81
                                                     to Figure93), used in asynchronous SRAM, PSRAM and NOR
                                                     Flash memory accesses:                                                    */
      __IOM uint32 BUSTURN    : 4;            /*!< [19..16] Bus turnaround phase duration These bits are written
                                                     by software to add a delay at the end of a write transaction
                                                     to match the minimum time between consecutive transactions
                                                     (tEHEL from ENx high to ENx low): (BUSTRUN + 1) KCK_FMC
                                                     period &#8805; tEHELmin. The programmed bus turnaround
                                                     delay is inserted between a an asynchronous write transfer
                                                     and any other asynchronous /synchronous read or write                     */
            uint32            : 8;
      __IOM uint32 ACCMOD     : 2;            /*!< [29..28] Access mode. These bits specify the asynchronous access
                                                     modes as shown in the next timing diagrams.These bits are
                                                     taken into account only when the EXTMOD bit in the FMC_BCRx
                                                     register is 1.                                                            */
            uint32            : 2;
    } bit;
  } FMC_BWTR3;
  __IM  uint32  RESERVED5;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000011C) This register contains the control information
                                                                    of each memory bank. It is used for SRAMs,
                                                                    PSRAMs and NOR Flash memories. When the
                                                                    EXTMOD bit is set in the FMC_BCRx register,
                                                                    then this register is active for write access.             */
    
    struct {
      __IOM uint32 ADDSET     : 4;            /*!< [3..0] Address setup phase duration. These bits are written
                                                     by software to define the duration of the address setup
                                                     phase in KCK_FMC cycles (refer to Figure81 to Figure93),
                                                     used in asynchronous accesses: ... Note: In synchronous
                                                     accesses, this value is not used, the address setup phase
                                                     is always 1 Flash clock period duration. In muxed mode,
                                                     the minimum ADDSET value is 1.                                            */
      __IOM uint32 ADDHLD     : 4;            /*!< [7..4] Address-hold phase duration. These bits are written by
                                                     software to define the duration of the address hold phase
                                                     (refer to Figure81 to Figure93), used in asynchronous multiplexed
                                                     accesses: ... Note: In synchronous NOR Flash accesses,
                                                     this value is not used, the address hold phase is always
                                                     1 Flash clock period duration.                                            */
      __IOM uint32 DATAST     : 8;            /*!< [15..8] Data-phase duration. These bits are written by software
                                                     to define the duration of the data phase (refer to Figure81
                                                     to Figure93), used in asynchronous SRAM, PSRAM and NOR
                                                     Flash memory accesses:                                                    */
      __IOM uint32 BUSTURN    : 4;            /*!< [19..16] Bus turnaround phase duration These bits are written
                                                     by software to add a delay at the end of a write transaction
                                                     to match the minimum time between consecutive transactions
                                                     (tEHEL from ENx high to ENx low): (BUSTRUN + 1) KCK_FMC
                                                     period &#8805; tEHELmin. The programmed bus turnaround
                                                     delay is inserted between a an asynchronous write transfer
                                                     and any other asynchronous /synchronous read or write                     */
            uint32            : 8;
      __IOM uint32 ACCMOD     : 2;            /*!< [29..28] Access mode. These bits specify the asynchronous access
                                                     modes as shown in the next timing diagrams.These bits are
                                                     taken into account only when the EXTMOD bit in the FMC_BCRx
                                                     register is 1.                                                            */
            uint32            : 2;
    } bit;
  } FMC_BWTR4;
  __IM  uint32  RESERVED6[8];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000140) This register contains the control parameters
                                                                    for each SDRAM memory bank                                 */
    
    struct {
      __IOM uint32 NC         : 2;            /*!< [1..0] Number of column address bits These bits define the number
                                                     of bits of a column address.                                              */
      __IOM uint32 NR         : 2;            /*!< [3..2] Number of row address bits These bits define the number
                                                     of bits of a row address.                                                 */
      __IOM uint32 MWID       : 2;            /*!< [5..4] Memory data bus width. These bits define the memory device
                                                     width.                                                                    */
      __IOM uint32 NB         : 1;            /*!< [6..6] Number of internal banks This bit sets the number of
                                                     internal banks.                                                           */
      __IOM uint32 CAS        : 2;            /*!< [8..7] CAS Latency This bits sets the SDRAM CAS latency in number
                                                     of memory clock cycles                                                    */
      __IOM uint32 WP         : 1;            /*!< [9..9] Write protection This bit enables write mode access to
                                                     the SDRAM bank.                                                           */
      __IOM uint32 SDCLK      : 2;            /*!< [11..10] SDRAM clock configuration These bits define the SDRAM
                                                     clock period for both SDRAM banks and allow disabling the
                                                     clock before changing the frequency. In this case the SDRAM
                                                     must be re-initialized. Note: The corresponding bits in
                                                     the FMC_SDCR2 register is read only.                                      */
      __IOM uint32 RBURST     : 1;            /*!< [12..12] Burst read This bit enables burst read mode. The SDRAM
                                                     controller anticipates the next read commands during the
                                                     CAS latency and stores data in the Read FIFO. Note: The
                                                     corresponding bit in the FMC_SDCR2 register is read only.                 */
      __IOM uint32 RPIPE      : 2;            /*!< [14..13] Read pipe These bits define the delay, in KCK_FMC clock
                                                     cycles, for reading data after CAS latency. Note: The corresponding
                                                     bits in the FMC_SDCR2 register is read only.                              */
            uint32            : 17;
    } bit;
  } FMC_SDCR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000144) This register contains the control parameters
                                                                    for each SDRAM memory bank                                 */
    
    struct {
      __IOM uint32 NC         : 2;            /*!< [1..0] Number of column address bits These bits define the number
                                                     of bits of a column address.                                              */
      __IOM uint32 NR         : 2;            /*!< [3..2] Number of row address bits These bits define the number
                                                     of bits of a row address.                                                 */
      __IOM uint32 MWID       : 2;            /*!< [5..4] Memory data bus width. These bits define the memory device
                                                     width.                                                                    */
      __IOM uint32 NB         : 1;            /*!< [6..6] Number of internal banks This bit sets the number of
                                                     internal banks.                                                           */
      __IOM uint32 CAS        : 2;            /*!< [8..7] CAS Latency This bits sets the SDRAM CAS latency in number
                                                     of memory clock cycles                                                    */
      __IOM uint32 WP         : 1;            /*!< [9..9] Write protection This bit enables write mode access to
                                                     the SDRAM bank.                                                           */
      __IOM uint32 SDCLK      : 2;            /*!< [11..10] SDRAM clock configuration These bits define the SDRAM
                                                     clock period for both SDRAM banks and allow disabling the
                                                     clock before changing the frequency. In this case the SDRAM
                                                     must be re-initialized. Note: The corresponding bits in
                                                     the FMC_SDCR2 register is read only.                                      */
      __IOM uint32 RBURST     : 1;            /*!< [12..12] Burst read This bit enables burst read mode. The SDRAM
                                                     controller anticipates the next read commands during the
                                                     CAS latency and stores data in the Read FIFO. Note: The
                                                     corresponding bit in the FMC_SDCR2 register is read only.                 */
      __IOM uint32 RPIPE      : 2;            /*!< [14..13] Read pipe These bits define the delay, in KCK_FMC clock
                                                     cycles, for reading data after CAS latency. Note: The corresponding
                                                     bits in the FMC_SDCR2 register is read only.                              */
            uint32            : 17;
    } bit;
  } FMC_SDCR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000148) This register contains the timing parameters
                                                                    of each SDRAM bank                                         */
    
    struct {
      __IOM uint32 TMRD       : 4;            /*!< [3..0] Load Mode Register to Active These bits define the delay
                                                     between a Load Mode Register command and an Active or Refresh
                                                     command in number of memory clock cycles. ....                            */
      __IOM uint32 TXSR       : 4;            /*!< [7..4] Exit Self-refresh delay These bits define the delay from
                                                     releasing the Self-refresh command to issuing the Activate
                                                     command in number of memory clock cycles. .... Note: If
                                                     two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2
                                                     must be programmed with the same TXSR timing corresponding
                                                     to the slowest SDRAM device.                                              */
      __IOM uint32 TRAS       : 4;            /*!< [11..8] Self refresh time These bits define the minimum Self-refresh
                                                     period in number of memory clock cycles. ....                             */
      __IOM uint32 TRC        : 4;            /*!< [15..12] Row cycle delay These bits define the delay between
                                                     the Refresh command and the Activate command, as well as
                                                     the delay between two consecutive Refresh commands. It
                                                     is expressed in number of memory clock cycles. The TRC
                                                     timing is only configured in the FMC_SDTR1 register. If
                                                     two SDRAM devices are used, the TRC must be programmed
                                                     with the timings of the slowest device. .... Note: TRC
                                                     must match the TRC                                                        */
      __IOM uint32 TWR        : 4;            /*!< [19..16] Recovery delay These bits define the delay between
                                                     a Write and a Precharge command in number of memory clock
                                                     cycles. .... Note: TWR must be programmed to match the
                                                     write recovery time (tWR) defined in the SDRAM datasheet,
                                                     and to guarantee that: TWR &#8805; TRAS - TRCD and TWR
                                                     &#8805;TRC - TRCD - TRP Example: TRAS= 4 cycles, TRCD=
                                                     2 cycles. So, TWR &gt;= 2 cycles. TWR must be programmed
                                                                                                                               */
      __IOM uint32 TRP        : 4;            /*!< [23..20] Row precharge delay These bits define the delay between
                                                     a Precharge command and another command in number of memory
                                                     clock cycles. The TRP timing is only configured in the
                                                     FMC_SDTR1 register. If two SDRAM devices are used, the
                                                     TRP must be programmed with the timing of the slowest device.
                                                     .... Note: The corresponding bits in the FMC_SDTR2 register
                                                     are dont care.                                                            */
      __IOM uint32 TRCD       : 4;            /*!< [27..24] Row to column delay These bits define the delay between
                                                     the Activate command and a Read/Write command in number
                                                     of memory clock cycles. ....                                              */
            uint32            : 4;
    } bit;
  } FMC_SDTR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000014C) This register contains the timing parameters
                                                                    of each SDRAM bank                                         */
    
    struct {
      __IOM uint32 TMRD       : 4;            /*!< [3..0] Load Mode Register to Active These bits define the delay
                                                     between a Load Mode Register command and an Active or Refresh
                                                     command in number of memory clock cycles. ....                            */
      __IOM uint32 TXSR       : 4;            /*!< [7..4] Exit Self-refresh delay These bits define the delay from
                                                     releasing the Self-refresh command to issuing the Activate
                                                     command in number of memory clock cycles. .... Note: If
                                                     two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2
                                                     must be programmed with the same TXSR timing corresponding
                                                     to the slowest SDRAM device.                                              */
      __IOM uint32 TRAS       : 4;            /*!< [11..8] Self refresh time These bits define the minimum Self-refresh
                                                     period in number of memory clock cycles. ....                             */
      __IOM uint32 TRC        : 4;            /*!< [15..12] Row cycle delay These bits define the delay between
                                                     the Refresh command and the Activate command, as well as
                                                     the delay between two consecutive Refresh commands. It
                                                     is expressed in number of memory clock cycles. The TRC
                                                     timing is only configured in the FMC_SDTR1 register. If
                                                     two SDRAM devices are used, the TRC must be programmed
                                                     with the timings of the slowest device. .... Note: TRC
                                                     must match the TRC                                                        */
      __IOM uint32 TWR        : 4;            /*!< [19..16] Recovery delay These bits define the delay between
                                                     a Write and a Precharge command in number of memory clock
                                                     cycles. .... Note: TWR must be programmed to match the
                                                     write recovery time (tWR) defined in the SDRAM datasheet,
                                                     and to guarantee that: TWR &#8805; TRAS - TRCD and TWR
                                                     &#8805;TRC - TRCD - TRP Example: TRAS= 4 cycles, TRCD=
                                                     2 cycles. So, TWR &gt;= 2 cycles. TWR must be programmed
                                                                                                                               */
      __IOM uint32 TRP        : 4;            /*!< [23..20] Row precharge delay These bits define the delay between
                                                     a Precharge command and another command in number of memory
                                                     clock cycles. The TRP timing is only configured in the
                                                     FMC_SDTR1 register. If two SDRAM devices are used, the
                                                     TRP must be programmed with the timing of the slowest device.
                                                     .... Note: The corresponding bits in the FMC_SDTR2 register
                                                     are dont care.                                                            */
      __IOM uint32 TRCD       : 4;            /*!< [27..24] Row to column delay These bits define the delay between
                                                     the Activate command and a Read/Write command in number
                                                     of memory clock cycles. ....                                              */
            uint32            : 4;
    } bit;
  } FMC_SDTR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000150) This register contains the command issued when
                                                                    the SDRAM device is accessed. This register
                                                                    is used to initialize the SDRAM device,
                                                                    and to activate the Self-refresh and the
                                                                    Power-down modes. As soon as the MODE field
                                                                    is written, the command will be issued only
                                                                    to one or to both SDRAM banks according
                                                                    to CTB1 and CTB2 command bits. This register
                                                                    is the same for both SDRAM banks.                          */
    
    struct {
      __IOM uint32 MODE       : 3;            /*!< [2..0] Command mode These bits define the command issued to
                                                     the SDRAM device. Note: When a command is issued, at least
                                                     one Command Target Bank bit ( CTB1 or CTB2) must be set
                                                     otherwise the command will be ignored. Note: If two SDRAM
                                                     banks are used, the Auto-refresh and PALL command must
                                                     be issued simultaneously to the two devices with CTB1 and
                                                     CTB2 bits set otherwise the command will be ignored. Note:
                                                                                                                               */
      __IOM uint32 CTB2       : 1;            /*!< [3..3] Command Target Bank 2 This bit indicates whether the
                                                     command will be issued to SDRAM Bank 2 or not.                            */
      __IOM uint32 CTB1       : 1;            /*!< [4..4] Command Target Bank 1 This bit indicates whether the
                                                     command will be issued to SDRAM Bank 1 or not.                            */
      __IOM uint32 NRFS       : 4;            /*!< [8..5] Number of Auto-refresh These bits define the number of
                                                     consecutive Auto-refresh commands issued when MODE = 011.
                                                     ....                                                                      */
      __IOM uint32 MRD        : 14;           /*!< [22..9] Mode Register definition This 14-bit field defines the
                                                     SDRAM Mode Register content. The Mode Register is programmed
                                                     using the Load Mode Register command. The MRD[13:0] bits
                                                     are also used to program the extended mode register for
                                                     mobile SDRAM.                                                             */
            uint32            : 9;
    } bit;
  } FMC_SDCMR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000154) This register sets the refresh rate in number
                                                                    of SDCLK clock cycles between the refresh
                                                                    cycles by configuring the Refresh Timer
                                                                    Count value.Examplewhere 64 ms is the SDRAM
                                                                    refresh period.The refresh rate must be
                                                                    increased by 20 SDRAM clock cycles (as in
                                                                    the above example) to obtain a safe margin
                                                                    if an internal refresh request occurs when
                                                                    a read request has been accepted. It corresponds
                                                                    to a COUNT value of 00001110                               */
    
    struct {
      __OM  uint32 CRE        : 1;            /*!< [0..0] Clear Refresh error flag This bit is used to clear the
                                                     Refresh Error Flag (RE) in the Status Register.                           */
      __IOM uint32 COUNT      : 13;           /*!< [13..1] Refresh Timer Count This 13-bit field defines the refresh
                                                     rate of the SDRAM device. It is expressed in number of
                                                     memory clock cycles. It must be set at least to 41 SDRAM
                                                     clock cycles (0x29). Refresh rate = (COUNT + 1) x SDRAM
                                                     frequency clock COUNT = (SDRAM refresh period / Number
                                                     of rows) - 20                                                             */
      __IOM uint32 REIE       : 1;            /*!< [14..14] RES Interrupt Enable                                             */
            uint32            : 17;
    } bit;
  } FMC_SDRTR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000158) SDRAM Status register                                      */
    
    struct {
      __IM  uint32 RE         : 1;            /*!< [0..0] Refresh error flag An interrupt is generated if REIE
                                                     = 1 and RE = 1                                                            */
      __IM  uint32 MODES1     : 2;            /*!< [2..1] Status Mode for Bank 1 These bits define the Status Mode
                                                     of SDRAM Bank 1.                                                          */
      __IM  uint32 MODES2     : 2;            /*!< [4..3] Status Mode for Bank 2 These bits define the Status Mode
                                                     of SDRAM Bank 2.                                                          */
            uint32            : 27;
    } bit;
  } FMC_SDSR;
} FMC_Type;                                     /*!< Size = 348 (0x15c)                                                        */



/* =========================================================================================================================== */
/* ================                                            CEC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief CEC (CEC)
  */

typedef struct {                                /*!< (@ 0x40006C00) CEC Structure                                              */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) CEC control register                                       */
    
    struct {
      __IOM uint32 CECEN      : 1;            /*!< [0..0] CEC Enable The CECEN bit is set and cleared by software.
                                                     CECEN=1 starts message reception and enables the TXSOM
                                                     control. CECEN=0 disables the CEC peripheral, clears all
                                                     bits of CEC_CR register and aborts any on-going reception
                                                     or transmission.                                                          */
      __IOM uint32 TXSOM      : 1;            /*!< [1..1] Tx Start Of Message TXSOM is set by software to command
                                                     transmission of the first byte of a CEC message. If the
                                                     CEC message consists of only one byte, TXEOM must be set
                                                     before of TXSOM. Start-Bit is effectively started on the
                                                     CEC line after SFT is counted. If TXSOM is set while a
                                                     message reception is ongoing, transmission will start after
                                                     the end of reception. TXSOM is cleared by hardware                        */
      __IOM uint32 TXEOM      : 1;            /*!< [2..2] Tx End Of Message The TXEOM bit is set by software to
                                                     command transmission of the last byte of a CEC message.
                                                     TXEOM is cleared by hardware at the same time and under
                                                     the same conditions as for TXSOM. Note: TXEOM must be set
                                                     when CECEN=1 TXEOM must be set before writing transmission
                                                     data to TXDR If TXEOM is set when TXSOM=0, transmitted
                                                     message will consist of 1 byte (HEADER) only (PING message)               */
            uint32            : 29;
    } bit;
  } CEC_CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) This register is used to configure the HDMI-CEC
                                                                    controller. It is mandatory to write CEC_CFGR
                                                                    only when CECEN=0.                                         */
    
    struct {
      __IOM uint32 SFT        : 3;            /*!< [2..0] Signal Free Time SFT bits are set by software. In the
                                                     SFT=0x0 configuration the number of nominal data bit periods
                                                     waited before transmission is ruled by hardware according
                                                     to the transmission history. In all the other configurations
                                                     the SFT number is determined by software. * 0x0 ** 2.5
                                                     Data-Bit periods if CEC is the last bus initiator with
                                                     unsuccessful transmission (ARBLST=1, TXERR=1,                             */
      __IOM uint32 RXTOL      : 1;            /*!< [3..3] Rx-Tolerance The RXTOL bit is set and cleared by software.
                                                     ** Start-Bit, +/- 200 s rise, +/- 200 s fall. ** Data-Bit:
                                                     +/- 200 s rise. +/- 350 s fall. ** Start-Bit: +/- 400 s
                                                     rise, +/- 400 s fall ** Data-Bit: +/-300 s rise, +/- 500
                                                     s fall                                                                    */
      __IOM uint32 BRESTP     : 1;            /*!< [4..4] Rx-Stop on Bit Rising Error The BRESTP bit is set and
                                                     cleared by software.                                                      */
      __IOM uint32 BREGEN     : 1;            /*!< [5..5] Generate Error-Bit on Bit Rising Error The BREGEN bit
                                                     is set and cleared by software. Note: If BRDNOGEN=0, an
                                                     Error-bit is generated upon BRE detection with BRESTP=1
                                                     in broadcast even if BREGEN=0                                             */
      __IOM uint32 LBPEGEN    : 1;            /*!< [6..6] Generate Error-Bit on Long Bit Period Error The LBPEGEN
                                                     bit is set and cleared by software. Note: If BRDNOGEN=0,
                                                     an Error-bit is generated upon LBPE detection in broadcast
                                                     even if LBPEGEN=0                                                         */
      __IOM uint32 BRDNOGEN   : 1;            /*!< [7..7] Avoid Error-Bit Generation in Broadcast The BRDNOGEN
                                                     bit is set and cleared by software.                                       */
      __IOM uint32 SFTOPT     : 1;            /*!< [8..8] SFT Option Bit The SFTOPT bit is set and cleared by software.      */
            uint32            : 7;
      __IOM uint32 OAR        : 15;           /*!< [30..16] Own addresses configuration The OAR bits are set by
                                                     software to select which destination logical addresses
                                                     has to be considered in receive mode. Each bit, when set,
                                                     enables the CEC logical address identified by the given
                                                     bit position. At the end of HEADER reception, the received
                                                     destination address is compared with the enabled addresses.
                                                     In case of matching address, the incoming message is                      */
      __IOM uint32 LSTN       : 1;            /*!< [31..31] Listen mode LSTN bit is set and cleared by software.             */
    } bit;
  } CEC_CFGR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000008) CEC Tx data register                                       */
    
    struct {
      __OM  uint32 TXD        : 8;            /*!< [7..0] Tx Data register. TXD is a write-only register containing
                                                     the data byte to be transmitted. Note: TXD must be written
                                                     when TXSTART=1                                                            */
            uint32            : 24;
    } bit;
  } CEC_TXDR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000000C) CEC Rx Data Register                                       */
    
    struct {
      __IM  uint32 RXD        : 8;            /*!< [7..0] Rx Data register. RXD is read-only and contains the last
                                                     data byte which has been received from the CEC line.                      */
            uint32            : 24;
    } bit;
  } CEC_RXDR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) CEC Interrupt and Status Register                          */
    
    struct {
      __IOM uint32 RXBR       : 1;            /*!< [0..0] Rx-Byte Received The RXBR bit is set by hardware to inform
                                                     application that a new byte has been received from the
                                                     CEC line and stored into the RXD buffer. RXBR is cleared
                                                     by software write at 1.                                                   */
      __IOM uint32 RXEND      : 1;            /*!< [1..1] End Of Reception RXEND is set by hardware to inform application
                                                     that the last byte of a CEC message is received from the
                                                     CEC line and stored into the RXD buffer. RXEND is set at
                                                     the same time of RXBR. RXEND is cleared by software write
                                                     at 1.                                                                     */
      __IOM uint32 RXOVR      : 1;            /*!< [2..2] Rx-Overrun RXOVR is set by hardware if RXBR is not yet
                                                     cleared at the time a new byte is received on the CEC line
                                                     and stored into RXD. RXOVR assertion stops message reception
                                                     so that no acknowledge is sent. In case of broadcast, a
                                                     negative acknowledge is sent. RXOVR is cleared by software
                                                     write at 1.                                                               */
      __IOM uint32 BRE        : 1;            /*!< [3..3] Rx-Bit Rising Error BRE is set by hardware in case a
                                                     Data-Bit waveform is detected with Bit Rising Error. BRE
                                                     is set either at the time the misplaced rising edge occurs,
                                                     or at the end of the maximum BRE tolerance allowed by RXTOL,
                                                     in case rising edge is still longing. BRE stops message
                                                     reception if BRESTP=1. BRE generates an Error-Bit on the
                                                     CEC line if BREGEN=1. BRE is cleared by software                          */
      __IOM uint32 SBPE       : 1;            /*!< [4..4] Rx-Short Bit Period Error SBPE is set by hardware in
                                                     case a Data-Bit waveform is detected with Short Bit Period
                                                     Error. SBPE is set at the time the anticipated falling
                                                     edge occurs. SBPE generates an Error-Bit on the CEC line.
                                                     SBPE is cleared by software write at 1.                                   */
      __IOM uint32 LBPE       : 1;            /*!< [5..5] Rx-Long Bit Period Error LBPE is set by hardware in case
                                                     a Data-Bit waveform is detected with Long Bit Period Error.
                                                     LBPE is set at the end of the maximum bit-extension tolerance
                                                     allowed by RXTOL, in case falling edge is still longing.
                                                     LBPE always stops reception of the CEC message. LBPE generates
                                                     an Error-Bit on the CEC line if LBPEGEN=1. In case of broadcast,
                                                     Error-Bit is generated even in case of                                    */
      __IOM uint32 RXACKE     : 1;            /*!< [6..6] Rx-Missing Acknowledge In receive mode, RXACKE is set
                                                     by hardware to inform application that no acknowledge was
                                                     seen on the CEC line. RXACKE applies only for broadcast
                                                     messages and in listen mode also for not directly addressed
                                                     messages (destination address not enabled in OAR). RXACKE
                                                     aborts message reception. RXACKE is cleared by software
                                                     write at 1.                                                               */
      __IOM uint32 ARBLST     : 1;            /*!< [7..7] Arbitration Lost ARBLST is set by hardware to inform
                                                     application that CEC device is switching to reception due
                                                     to arbitration lost event following the TXSOM command.
                                                     ARBLST can be due either to a contending CEC device starting
                                                     earlier or starting at the same time but with higher HEADER
                                                     priority. After ARBLST assertion TXSOM bit keeps pending
                                                     for next transmission attempt. ARBLST is clea                             */
      __IOM uint32 TXBR       : 1;            /*!< [8..8] Tx-Byte Request TXBR is set by hardware to inform application
                                                     that the next transmission data has to be written to TXDR.
                                                     TXBR is set when the 4th bit of currently transmitted byte
                                                     is sent. Application must write the next byte to TXDR within
                                                     6 nominal data-bit periods before transmission underrun
                                                     error occurs (TXUDR). TXBR is cleared by software write
                                                     at 1.                                                                     */
      __IOM uint32 TXEND      : 1;            /*!< [9..9] End of Transmission TXEND is set by hardware to inform
                                                     application that the last byte of the CEC message has been
                                                     successfully transmitted. TXEND clears the TXSOM and TXEOM
                                                     control bits. TXEND is cleared by software write at 1.                    */
      __IOM uint32 TXUDR      : 1;            /*!< [10..10] Tx-Buffer Underrun In transmission mode, TXUDR is set
                                                     by hardware if application was not in time to load TXDR
                                                     before of next byte transmission. TXUDR aborts message
                                                     transmission and clears TXSOM and TXEOM control bits. TXUDR
                                                     is cleared by software write at 1                                         */
      __IOM uint32 TXERR      : 1;            /*!< [11..11] Tx-Error In transmission mode, TXERR is set by hardware
                                                     if the CEC initiator detects low impedance on the CEC line
                                                     while it is released. TXERR aborts message transmission
                                                     and clears TXSOM and TXEOM controls. TXERR is cleared by
                                                     software write at 1.                                                      */
      __IOM uint32 TXACKE     : 1;            /*!< [12..12] Tx-Missing Acknowledge Error In transmission mode,
                                                     TXACKE is set by hardware to inform application that no
                                                     acknowledge was received. In case of broadcast transmission,
                                                     TXACKE informs application that a negative acknowledge
                                                     was received. TXACKE aborts message transmission and clears
                                                     TXSOM and TXEOM controls. TXACKE is cleared by software
                                                     write at 1.                                                               */
            uint32            : 19;
    } bit;
  } CEC_ISR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000014) CEC interrupt enable register                              */
    
    struct {
      __IOM uint32 RXBRIE     : 1;            /*!< [0..0] Rx-Byte Received Interrupt Enable The RXBRIE bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32 RXENDIE    : 1;            /*!< [1..1] End Of Reception Interrupt Enable The RXENDIE bit is
                                                     set and cleared by software.                                              */
      __IOM uint32 RXOVRIE    : 1;            /*!< [2..2] Rx-Buffer Overrun Interrupt Enable The RXOVRIE bit is
                                                     set and cleared by software.                                              */
      __IOM uint32 BREIE      : 1;            /*!< [3..3] Bit Rising Error Interrupt Enable The BREIE bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32 SBPEIE     : 1;            /*!< [4..4] Short Bit Period Error Interrupt Enable The SBPEIE bit
                                                     is set and cleared by software.                                           */
      __IOM uint32 LBPEIE     : 1;            /*!< [5..5] Long Bit Period Error Interrupt Enable The LBPEIE bit
                                                     is set and cleared by software.                                           */
      __IOM uint32 RXACKIE    : 1;            /*!< [6..6] Rx-Missing Acknowledge Error Interrupt Enable The RXACKIE
                                                     bit is set and cleared by software.                                       */
      __IOM uint32 ARBLSTIE   : 1;            /*!< [7..7] Arbitration Lost Interrupt Enable The ARBLSTIE bit is
                                                     set and cleared by software.                                              */
      __IOM uint32 TXBRIE     : 1;            /*!< [8..8] Tx-Byte Request Interrupt Enable The TXBRIE bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32 TXENDIE    : 1;            /*!< [9..9] Tx-End Of Message Interrupt Enable The TXENDIE bit is
                                                     set and cleared by software.                                              */
      __IOM uint32 TXUDRIE    : 1;            /*!< [10..10] Tx-Underrun Interrupt Enable The TXUDRIE bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32 TXERRIE    : 1;            /*!< [11..11] Tx-Error Interrupt Enable The TXERRIE bit is set and
                                                     cleared by software.                                                      */
      __IOM uint32 TXACKIE    : 1;            /*!< [12..12] Tx-Missing Acknowledge Error Interrupt Enable The TXACKEIE
                                                     bit is set and cleared by software.                                       */
            uint32            : 19;
    } bit;
  } CEC_IER;
} CEC_Type;                                     /*!< Size = 24 (0x18)                                                          */



/* =========================================================================================================================== */
/* ================                                           HSEM                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief HSEM (HSEM)
  */

typedef struct {                                /*!< (@ 0x58026400) HSEM Structure                                             */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IOM uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_R0;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IOM uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_R1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IOM uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_R2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IOM uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_R3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IOM uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_R4;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000014) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IOM uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_R5;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000018) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IOM uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_R6;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000001C) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IOM uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_R7;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000020) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IOM uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_R8;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000024) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IOM uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_R9;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000028) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IOM uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_R10;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000002C) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IOM uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_R11;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000030) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IOM uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_R12;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000034) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IOM uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_R13;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000038) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IOM uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_R14;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000003C) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IOM uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_R15;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000040) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IOM uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_R16;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000044) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IOM uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_R17;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000048) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IOM uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_R18;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000004C) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IOM uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_R19;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000050) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IOM uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_R20;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000054) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IOM uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_R21;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000058) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IOM uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_R22;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000005C) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IOM uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_R23;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000060) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IOM uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_R24;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000064) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IOM uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_R25;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000068) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IOM uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_R26;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000006C) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IOM uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_R27;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000070) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IOM uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_R28;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000074) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IOM uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_R29;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000078) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IOM uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_R30;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000007C) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IOM uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_R31;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000080) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IM  uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_RLR0;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000084) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IM  uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_RLR1;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000088) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IM  uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_RLR2;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000008C) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IM  uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_RLR3;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000090) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IM  uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_RLR4;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000094) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IM  uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_RLR5;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000098) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IM  uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_RLR6;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000009C) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IM  uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_RLR7;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000000A0) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IM  uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_RLR8;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000000A4) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IM  uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_RLR9;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000000A8) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IM  uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_RLR10;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000000AC) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IM  uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_RLR11;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000000B0) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IM  uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_RLR12;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000000B4) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IM  uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_RLR13;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000000B8) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IM  uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_RLR14;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000000BC) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IM  uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_RLR15;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000000C0) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IM  uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_RLR16;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000000C4) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IM  uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_RLR17;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000000C8) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IM  uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_RLR18;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000000CC) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IM  uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_RLR19;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000000D0) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IM  uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_RLR20;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000000D4) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IM  uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_RLR21;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000000D8) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IM  uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_RLR22;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000000DC) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IM  uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_RLR23;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000000E0) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IM  uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_RLR24;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000000E4) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IM  uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_RLR25;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000000E8) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IM  uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_RLR26;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000000EC) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IM  uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_RLR27;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000000F0) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IM  uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_RLR28;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000000F4) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IM  uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_RLR29;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000000F8) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IM  uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_RLR30;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000000FC) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32 PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32 MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32            : 15;
      __IM  uint32 LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } bit;
  } HSEM_RLR31;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000100) HSEM Interrupt enable register                             */
    
    struct {
      __IOM uint32 ISEM0      : 1;            /*!< [0..0] Interrupt semaphore n enable bit                                   */
      __IOM uint32 ISEM1      : 1;            /*!< [1..1] Interrupt semaphore n enable bit                                   */
      __IOM uint32 ISEM2      : 1;            /*!< [2..2] Interrupt semaphore n enable bit                                   */
      __IOM uint32 ISEM3      : 1;            /*!< [3..3] Interrupt semaphore n enable bit                                   */
      __IOM uint32 ISEM4      : 1;            /*!< [4..4] Interrupt semaphore n enable bit                                   */
      __IOM uint32 ISEM5      : 1;            /*!< [5..5] Interrupt semaphore n enable bit                                   */
      __IOM uint32 ISEM6      : 1;            /*!< [6..6] Interrupt semaphore n enable bit                                   */
      __IOM uint32 ISEM7      : 1;            /*!< [7..7] Interrupt semaphore n enable bit                                   */
      __IOM uint32 ISEM8      : 1;            /*!< [8..8] Interrupt semaphore n enable bit                                   */
      __IOM uint32 ISEM9      : 1;            /*!< [9..9] Interrupt semaphore n enable bit                                   */
      __IOM uint32 ISEM10     : 1;            /*!< [10..10] Interrupt semaphore n enable bit                                 */
      __IOM uint32 ISEM11     : 1;            /*!< [11..11] Interrupt semaphore n enable bit                                 */
      __IOM uint32 ISEM12     : 1;            /*!< [12..12] Interrupt semaphore n enable bit                                 */
      __IOM uint32 ISEM13     : 1;            /*!< [13..13] Interrupt semaphore n enable bit                                 */
      __IOM uint32 ISEM14     : 1;            /*!< [14..14] Interrupt semaphore n enable bit                                 */
      __IOM uint32 ISEM15     : 1;            /*!< [15..15] Interrupt semaphore n enable bit                                 */
      __IOM uint32 ISEM16     : 1;            /*!< [16..16] Interrupt semaphore n enable bit                                 */
      __IOM uint32 ISEM17     : 1;            /*!< [17..17] Interrupt semaphore n enable bit                                 */
      __IOM uint32 ISEM18     : 1;            /*!< [18..18] Interrupt semaphore n enable bit                                 */
      __IOM uint32 ISEM19     : 1;            /*!< [19..19] Interrupt semaphore n enable bit                                 */
      __IOM uint32 ISEM20     : 1;            /*!< [20..20] Interrupt semaphore n enable bit                                 */
      __IOM uint32 ISEM21     : 1;            /*!< [21..21] Interrupt semaphore n enable bit                                 */
      __IOM uint32 ISEM22     : 1;            /*!< [22..22] Interrupt semaphore n enable bit                                 */
      __IOM uint32 ISEM23     : 1;            /*!< [23..23] Interrupt semaphore n enable bit                                 */
      __IOM uint32 ISEM24     : 1;            /*!< [24..24] Interrupt semaphore n enable bit                                 */
      __IOM uint32 ISEM25     : 1;            /*!< [25..25] Interrupt semaphore n enable bit                                 */
      __IOM uint32 ISEM26     : 1;            /*!< [26..26] Interrupt semaphore n enable bit                                 */
      __IOM uint32 ISEM27     : 1;            /*!< [27..27] Interrupt semaphore n enable bit                                 */
      __IOM uint32 ISEM28     : 1;            /*!< [28..28] Interrupt semaphore n enable bit                                 */
      __IOM uint32 ISEM29     : 1;            /*!< [29..29] Interrupt semaphore n enable bit                                 */
      __IOM uint32 ISEM30     : 1;            /*!< [30..30] Interrupt semaphore n enable bit                                 */
      __IOM uint32 ISEM31     : 1;            /*!< [31..31] Interrupt(N) semaphore n enable bit.                             */
    } bit;
  } HSEM_IER;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000104) HSEM Interrupt clear register                              */
    
    struct {
      __IM  uint32 ISEM0      : 1;            /*!< [0..0] Interrupt(N) semaphore n clear bit                                 */
      __IM  uint32 ISEM1      : 1;            /*!< [1..1] Interrupt(N) semaphore n clear bit                                 */
      __IM  uint32 ISEM2      : 1;            /*!< [2..2] Interrupt(N) semaphore n clear bit                                 */
      __IM  uint32 ISEM3      : 1;            /*!< [3..3] Interrupt(N) semaphore n clear bit                                 */
      __IM  uint32 ISEM4      : 1;            /*!< [4..4] Interrupt(N) semaphore n clear bit                                 */
      __IM  uint32 ISEM5      : 1;            /*!< [5..5] Interrupt(N) semaphore n clear bit                                 */
      __IM  uint32 ISEM6      : 1;            /*!< [6..6] Interrupt(N) semaphore n clear bit                                 */
      __IM  uint32 ISEM7      : 1;            /*!< [7..7] Interrupt(N) semaphore n clear bit                                 */
      __IM  uint32 ISEM8      : 1;            /*!< [8..8] Interrupt(N) semaphore n clear bit                                 */
      __IM  uint32 ISEM9      : 1;            /*!< [9..9] Interrupt(N) semaphore n clear bit                                 */
      __IM  uint32 ISEM10     : 1;            /*!< [10..10] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32 ISEM11     : 1;            /*!< [11..11] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32 ISEM12     : 1;            /*!< [12..12] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32 ISEM13     : 1;            /*!< [13..13] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32 ISEM14     : 1;            /*!< [14..14] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32 ISEM15     : 1;            /*!< [15..15] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32 ISEM16     : 1;            /*!< [16..16] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32 ISEM17     : 1;            /*!< [17..17] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32 ISEM18     : 1;            /*!< [18..18] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32 ISEM19     : 1;            /*!< [19..19] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32 ISEM20     : 1;            /*!< [20..20] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32 ISEM21     : 1;            /*!< [21..21] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32 ISEM22     : 1;            /*!< [22..22] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32 ISEM23     : 1;            /*!< [23..23] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32 ISEM24     : 1;            /*!< [24..24] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32 ISEM25     : 1;            /*!< [25..25] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32 ISEM26     : 1;            /*!< [26..26] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32 ISEM27     : 1;            /*!< [27..27] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32 ISEM28     : 1;            /*!< [28..28] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32 ISEM29     : 1;            /*!< [29..29] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32 ISEM30     : 1;            /*!< [30..30] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32 ISEM31     : 1;            /*!< [31..31] Interrupt(N) semaphore n clear bit                               */
    } bit;
  } HSEM_ICR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000108) HSEM Interrupt status register                             */
    
    struct {
      __IM  uint32 ISEM0      : 1;            /*!< [0..0] Interrupt(N) semaphore n status bit before enable (mask)           */
      __IM  uint32 ISEM1      : 1;            /*!< [1..1] Interrupt(N) semaphore n status bit before enable (mask)           */
      __IM  uint32 ISEM2      : 1;            /*!< [2..2] Interrupt(N) semaphore n status bit before enable (mask)           */
      __IM  uint32 ISEM3      : 1;            /*!< [3..3] Interrupt(N) semaphore n status bit before enable (mask)           */
      __IM  uint32 ISEM4      : 1;            /*!< [4..4] Interrupt(N) semaphore n status bit before enable (mask)           */
      __IM  uint32 ISEM5      : 1;            /*!< [5..5] Interrupt(N) semaphore n status bit before enable (mask)           */
      __IM  uint32 ISEM6      : 1;            /*!< [6..6] Interrupt(N) semaphore n status bit before enable (mask)           */
      __IM  uint32 ISEM7      : 1;            /*!< [7..7] Interrupt(N) semaphore n status bit before enable (mask)           */
      __IM  uint32 ISEM8      : 1;            /*!< [8..8] Interrupt(N) semaphore n status bit before enable (mask)           */
      __IM  uint32 ISEM9      : 1;            /*!< [9..9] Interrupt(N) semaphore n status bit before enable (mask)           */
      __IM  uint32 ISEM10     : 1;            /*!< [10..10] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32 ISEM11     : 1;            /*!< [11..11] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32 ISEM12     : 1;            /*!< [12..12] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32 ISEM13     : 1;            /*!< [13..13] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32 ISEM14     : 1;            /*!< [14..14] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32 ISEM15     : 1;            /*!< [15..15] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32 ISEM16     : 1;            /*!< [16..16] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32 ISEM17     : 1;            /*!< [17..17] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32 ISEM18     : 1;            /*!< [18..18] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32 ISEM19     : 1;            /*!< [19..19] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32 ISEM20     : 1;            /*!< [20..20] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32 ISEM21     : 1;            /*!< [21..21] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32 ISEM22     : 1;            /*!< [22..22] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32 ISEM23     : 1;            /*!< [23..23] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32 ISEM24     : 1;            /*!< [24..24] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32 ISEM25     : 1;            /*!< [25..25] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32 ISEM26     : 1;            /*!< [26..26] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32 ISEM27     : 1;            /*!< [27..27] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32 ISEM28     : 1;            /*!< [28..28] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32 ISEM29     : 1;            /*!< [29..29] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32 ISEM30     : 1;            /*!< [30..30] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32 ISEM31     : 1;            /*!< [31..31] Interrupt(N) semaphore n status bit before enable (mask)         */
    } bit;
  } HSEM_ISR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000010C) HSEM Masked interrupt status register                      */
    
    struct {
      __IM  uint32 ISEM0      : 1;            /*!< [0..0] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32 ISEM1      : 1;            /*!< [1..1] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32 ISEM2      : 1;            /*!< [2..2] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32 ISEM3      : 1;            /*!< [3..3] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32 ISEM4      : 1;            /*!< [4..4] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32 ISEM5      : 1;            /*!< [5..5] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32 ISEM6      : 1;            /*!< [6..6] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32 ISEM7      : 1;            /*!< [7..7] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32 ISEM8      : 1;            /*!< [8..8] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32 ISEM9      : 1;            /*!< [9..9] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32 ISEM10     : 1;            /*!< [10..10] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32 ISEM11     : 1;            /*!< [11..11] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32 ISEM12     : 1;            /*!< [12..12] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32 ISEM13     : 1;            /*!< [13..13] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32 ISEM14     : 1;            /*!< [14..14] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32 ISEM15     : 1;            /*!< [15..15] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32 ISEM16     : 1;            /*!< [16..16] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32 ISEM17     : 1;            /*!< [17..17] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32 ISEM18     : 1;            /*!< [18..18] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32 ISEM19     : 1;            /*!< [19..19] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32 ISEM20     : 1;            /*!< [20..20] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32 ISEM21     : 1;            /*!< [21..21] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32 ISEM22     : 1;            /*!< [22..22] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32 ISEM23     : 1;            /*!< [23..23] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32 ISEM24     : 1;            /*!< [24..24] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32 ISEM25     : 1;            /*!< [25..25] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32 ISEM26     : 1;            /*!< [26..26] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32 ISEM27     : 1;            /*!< [27..27] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32 ISEM28     : 1;            /*!< [28..28] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32 ISEM29     : 1;            /*!< [29..29] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32 ISEM30     : 1;            /*!< [30..30] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32 ISEM31     : 1;            /*!< [31..31] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
    } bit;
  } HSEM_MISR;
  __IM  uint32  RESERVED[12];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000140) HSEM Clear register                                        */
    
    struct {
            uint32            : 8;
      __IOM uint32 MASTERID   : 8;            /*!< [15..8] MasterID of semaphores to be cleared                              */
      __IOM uint32 KEY        : 16;           /*!< [31..16] Semaphore clear Key                                              */
    } bit;
  } HSEM_CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000144) HSEM Interrupt clear register                              */
    
    struct {
            uint32            : 16;
      __IOM uint32 KEY        : 16;           /*!< [31..16] Semaphore Clear Key                                              */
    } bit;
  } HSEM_KEYR;
} HSEM_Type;                                    /*!< Size = 328 (0x148)                                                        */



/* =========================================================================================================================== */
/* ================                                           I2C1                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief I2C (I2C1)
  */

typedef struct {                                /*!< (@ 0x40005400) I2C1 Structure                                             */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) Access: No wait states, except if a write access
                                                                    occurs while a write access to this register
                                                                    is ongoing. In this case, wait states are
                                                                    inserted in the second write access until
                                                                    the previous one is completed. The latency
                                                                    of the second write access can be up to
                                                                    2 x PCLK1 + 6 x I2CCLK.                                    */
    
    struct {
      __IOM uint32 PE         : 1;            /*!< [0..0] Peripheral enable Note: When PE=0, the I2C SCL and SDA
                                                     lines are released. Internal state machines and status
                                                     bits are put back to their reset value. When cleared, PE
                                                     must be kept low for at least 3 APB clock cycles.                         */
      __IOM uint32 TXIE       : 1;            /*!< [1..1] TX Interrupt enable                                                */
      __IOM uint32 RXIE       : 1;            /*!< [2..2] RX Interrupt enable                                                */
      __IOM uint32 ADDRIE     : 1;            /*!< [3..3] Address match Interrupt enable (slave only)                        */
      __IOM uint32 NACKIE     : 1;            /*!< [4..4] Not acknowledge received Interrupt enable                          */
      __IOM uint32 STOPIE     : 1;            /*!< [5..5] STOP detection Interrupt enable                                    */
      __IOM uint32 TCIE       : 1;            /*!< [6..6] Transfer Complete interrupt enable Note: Any of these
                                                     events will generate an interrupt: Transfer Complete (TC)
                                                     Transfer Complete Reload (TCR)                                            */
      __IOM uint32 ERRIE      : 1;            /*!< [7..7] Error interrupts enable Note: Any of these errors generate
                                                     an interrupt: Arbitration Loss (ARLO) Bus Error detection
                                                     (BERR) Overrun/Underrun (OVR) Timeout detection (TIMEOUT)
                                                     PEC error detection (PECERR) Alert pin event detection
                                                     (ALERT)                                                                   */
      __IOM uint32 DNF        : 4;            /*!< [11..8] Digital noise filter These bits are used to configure
                                                     the digital noise filter on SDA and SCL input. The digital
                                                     filter will filter spikes with a length of up to DNF[3:0]
                                                     * tI2CCLK ... Note: If the analog filter is also enabled,
                                                     the digital filter is added to the analog filter. This
                                                     filter can only be programmed when the I2C is disabled
                                                     (PE = 0).                                                                 */
      __IOM uint32 ANFOFF     : 1;            /*!< [12..12] Analog noise filter OFF Note: This bit can only be
                                                     programmed when the I2C is disabled (PE = 0).                             */
            uint32            : 1;
      __IOM uint32 TXDMAEN    : 1;            /*!< [14..14] DMA transmission requests enable                                 */
      __IOM uint32 RXDMAEN    : 1;            /*!< [15..15] DMA reception requests enable                                    */
      __IOM uint32 SBC        : 1;            /*!< [16..16] Slave byte control This bit is used to enable hardware
                                                     byte control in slave mode.                                               */
      __IOM uint32 NOSTRETCH  : 1;            /*!< [17..17] Clock stretching disable This bit is used to disable
                                                     clock stretching in slave mode. It must be kept cleared
                                                     in master mode. Note: This bit can only be programmed when
                                                     the I2C is disabled (PE = 0).                                             */
      __IOM uint32 WUPEN      : 1;            /*!< [18..18] Wakeup from Stop mode enable Note: If the Wakeup from
                                                     Stop mode feature is not supported, this bit is reserved
                                                     and forced by hardware to 0. Please refer to Section25.3:
                                                     I2C implementation. Note: WUPEN can be set only when DNF
                                                     = 0000                                                                    */
      __IOM uint32 GCEN       : 1;            /*!< [19..19] General call enable                                              */
      __IOM uint32 SMBHEN     : 1;            /*!< [20..20] SMBus Host address enable Note: If the SMBus feature
                                                     is not supported, this bit is reserved and forced by hardware
                                                     to 0. Please refer to Section25.3: I2C implementation.                    */
      __IOM uint32 SMBDEN     : 1;            /*!< [21..21] SMBus Device Default address enable Note: If the SMBus
                                                     feature is not supported, this bit is reserved and forced
                                                     by hardware to 0. Please refer to Section25.3: I2C implementation.        */
      __IOM uint32 ALERTEN    : 1;            /*!< [22..22] SMBus alert enable Device mode (SMBHEN=0): Host mode
                                                     (SMBHEN=1): Note: When ALERTEN=0, the SMBA pin can be used
                                                     as a standard GPIO. If the SMBus feature is not supported,
                                                     this bit is reserved and forced by hardware to 0. Please
                                                     refer to Section25.3: I2C implementation.                                 */
      __IOM uint32 PECEN      : 1;            /*!< [23..23] PEC enable Note: If the SMBus feature is not supported,
                                                     this bit is reserved and forced by hardware to 0. Please
                                                     refer to Section25.3: I2C implementation.                                 */
            uint32            : 8;
    } bit;
  } I2C_CR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) Access: No wait states, except if a write access
                                                                    occurs while a write access to this register
                                                                    is ongoing. In this case, wait states are
                                                                    inserted in the second write access until
                                                                    the previous one is completed. The latency
                                                                    of the second write access can be up to
                                                                    2 x PCLK1 + 6 x I2CCLK.                                    */
    
    struct {
      __IOM uint32 SADD0      : 1;            /*!< [0..0] Slave address bit 0 (master mode) In 7-bit addressing
                                                     mode (ADD10 = 0): This bit is dont care In 10-bit addressing
                                                     mode (ADD10 = 1): This bit should be written with bit 0
                                                     of the slave address to be sent Note: Changing these bits
                                                     when the START bit is set is not allowed.                                 */
      __IOM uint32 SADD1      : 1;            /*!< [1..1] Slave address bit 7:1 (master mode) In 7-bit addressing
                                                     mode (ADD10 = 0): These bits should be written with the
                                                     7-bit slave address to be sent In 10-bit addressing mode
                                                     (ADD10 = 1): These bits should be written with bits 7:1
                                                     of the slave address to be sent. Note: Changing these bits
                                                     when the START bit is set is not allowed.                                 */
      __IOM uint32 SADD2      : 1;            /*!< [2..2] Slave address bit 7:1 (master mode) In 7-bit addressing
                                                     mode (ADD10 = 0): These bits should be written with the
                                                     7-bit slave address to be sent In 10-bit addressing mode
                                                     (ADD10 = 1): These bits should be written with bits 7:1
                                                     of the slave address to be sent. Note: Changing these bits
                                                     when the START bit is set is not allowed.                                 */
      __IOM uint32 SADD3      : 1;            /*!< [3..3] Slave address bit 7:1 (master mode) In 7-bit addressing
                                                     mode (ADD10 = 0): These bits should be written with the
                                                     7-bit slave address to be sent In 10-bit addressing mode
                                                     (ADD10 = 1): These bits should be written with bits 7:1
                                                     of the slave address to be sent. Note: Changing these bits
                                                     when the START bit is set is not allowed.                                 */
      __IOM uint32 SADD4      : 1;            /*!< [4..4] Slave address bit 7:1 (master mode) In 7-bit addressing
                                                     mode (ADD10 = 0): These bits should be written with the
                                                     7-bit slave address to be sent In 10-bit addressing mode
                                                     (ADD10 = 1): These bits should be written with bits 7:1
                                                     of the slave address to be sent. Note: Changing these bits
                                                     when the START bit is set is not allowed.                                 */
      __IOM uint32 SADD5      : 1;            /*!< [5..5] Slave address bit 7:1 (master mode) In 7-bit addressing
                                                     mode (ADD10 = 0): These bits should be written with the
                                                     7-bit slave address to be sent In 10-bit addressing mode
                                                     (ADD10 = 1): These bits should be written with bits 7:1
                                                     of the slave address to be sent. Note: Changing these bits
                                                     when the START bit is set is not allowed.                                 */
      __IOM uint32 SADD6      : 1;            /*!< [6..6] Slave address bit 7:1 (master mode) In 7-bit addressing
                                                     mode (ADD10 = 0): These bits should be written with the
                                                     7-bit slave address to be sent In 10-bit addressing mode
                                                     (ADD10 = 1): These bits should be written with bits 7:1
                                                     of the slave address to be sent. Note: Changing these bits
                                                     when the START bit is set is not allowed.                                 */
      __IOM uint32 SADD7      : 1;            /*!< [7..7] Slave address bit 7:1 (master mode) In 7-bit addressing
                                                     mode (ADD10 = 0): These bits should be written with the
                                                     7-bit slave address to be sent In 10-bit addressing mode
                                                     (ADD10 = 1): These bits should be written with bits 7:1
                                                     of the slave address to be sent. Note: Changing these bits
                                                     when the START bit is set is not allowed.                                 */
      __IOM uint32 SADD8      : 1;            /*!< [8..8] Slave address bit 9:8 (master mode) In 7-bit addressing
                                                     mode (ADD10 = 0): These bits are dont care In 10-bit addressing
                                                     mode (ADD10 = 1): These bits should be written with bits
                                                     9:8 of the slave address to be sent Note: Changing these
                                                     bits when the START bit is set is not allowed.                            */
      __IOM uint32 SADD9      : 1;            /*!< [9..9] Slave address bit 9:8 (master mode) In 7-bit addressing
                                                     mode (ADD10 = 0): These bits are dont care In 10-bit addressing
                                                     mode (ADD10 = 1): These bits should be written with bits
                                                     9:8 of the slave address to be sent Note: Changing these
                                                     bits when the START bit is set is not allowed.                            */
      __IOM uint32 RD_WRN     : 1;            /*!< [10..10] Transfer direction (master mode) Note: Changing this
                                                     bit when the START bit is set is not allowed.                             */
      __IOM uint32 ADD10      : 1;            /*!< [11..11] 10-bit addressing mode (master mode) Note: Changing
                                                     this bit when the START bit is set is not allowed.                        */
      __IOM uint32 HEAD10R    : 1;            /*!< [12..12] 10-bit address header only read direction (master receiver
                                                     mode) Note: Changing this bit when the START bit is set
                                                     is not allowed.                                                           */
      __IOM uint32 START      : 1;            /*!< [13..13] Start generation This bit is set by software, and cleared
                                                     by hardware after the Start followed by the address sequence
                                                     is sent, by an arbitration loss, by a timeout error detection,
                                                     or when PE = 0. It can also be cleared by software by writing
                                                     1 to the ADDRCF bit in the I2C_ICR register. If the I2C
                                                     is already in master mode with AUTOEND = 0, setting this
                                                     bit generates a Repeated Start c                                          */
      __IOM uint32 STOP       : 1;            /*!< [14..14] Stop generation (master mode) The bit is set by software,
                                                     cleared by hardware when a Stop condition is detected,
                                                     or when PE = 0. In Master Mode: Note: Writing 0 to this
                                                     bit has no effect.                                                        */
      __IOM uint32 NACK       : 1;            /*!< [15..15] NACK generation (slave mode) The bit is set by software,
                                                     cleared by hardware when the NACK is sent, or when a STOP
                                                     condition or an Address matched is received, or when PE=0.
                                                     Note: Writing 0 to this bit has no effect. This bit is
                                                     used in slave mode only: in master receiver mode, NACK
                                                     is automatically generated after last byte preceding STOP
                                                     or RESTART condition, whatever the NACK bit value. When
                                                     an                                                                        */
      __IOM uint32 NBYTES     : 8;            /*!< [23..16] Number of bytes The number of bytes to be transmitted/received
                                                     is programmed there. This field is dont care in slave mode
                                                     with SBC=0. Note: Changing these bits when the START bit
                                                     is set is not allowed.                                                    */
      __IOM uint32 RELOAD     : 1;            /*!< [24..24] NBYTES reload mode This bit is set and cleared by software.      */
      __IOM uint32 AUTOEND    : 1;            /*!< [25..25] Automatic end mode (master mode) This bit is set and
                                                     cleared by software. Note: This bit has no effect in slave
                                                     mode or when the RELOAD bit is set.                                       */
      __IOM uint32 PECBYTE    : 1;            /*!< [26..26] Packet error checking byte This bit is set by software,
                                                     and cleared by hardware when the PEC is transferred, or
                                                     when a STOP condition or an Address matched is received,
                                                     also when PE=0. Note: Writing 0 to this bit has no effect.
                                                     This bit has no effect when RELOAD is set. This bit has
                                                     no effect is slave mode when SBC=0. If the SMBus feature
                                                     is not supported, this bit is reserved and forced by                      */
            uint32            : 5;
    } bit;
  } I2C_CR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) Access: No wait states, except if a write access
                                                                    occurs while a write access to this register
                                                                    is ongoing. In this case, wait states are
                                                                    inserted in the second write access until
                                                                    the previous one is completed. The latency
                                                                    of the second write access can be up to
                                                                    2 x PCLK1 + 6 x I2CCLK.                                    */
    
    struct {
      __IOM uint32 OA1        : 10;           /*!< [9..0] Interface address 7-bit addressing mode: dont care 10-bit
                                                     addressing mode: bits 9:8 of address Note: These bits can
                                                     be written only when OA1EN=0. OA1[7:1]: Interface address
                                                     Bits 7:1 of address Note: These bits can be written only
                                                     when OA1EN=0. OA1[0]: Interface address 7-bit addressing
                                                     mode: dont care 10-bit addressing mode: bit 0 of address
                                                     Note: This bit can be written only when OA1EN=0.                          */
      __IOM uint32 OA1MODE    : 1;            /*!< [10..10] Own Address 1 10-bit mode Note: This bit can be written
                                                     only when OA1EN=0.                                                        */
            uint32            : 4;
      __IOM uint32 OA1EN      : 1;            /*!< [15..15] Own Address 1 enable                                             */
            uint32            : 16;
    } bit;
  } I2C_OAR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) Access: No wait states, except if a write access
                                                                    occurs while a write access to this register
                                                                    is ongoing. In this case, wait states are
                                                                    inserted in the second write access until
                                                                    the previous one is completed. The latency
                                                                    of the second write access can be up to
                                                                    2 x PCLK1 + 6 x I2CCLK.                                    */
    
    struct {
            uint32            : 1;
      __IOM uint32 OA2        : 7;            /*!< [7..1] Interface address bits 7:1 of address Note: These bits
                                                     can be written only when OA2EN=0.                                         */
      __IOM uint32 OA2MSK     : 3;            /*!< [10..8] Own Address 2 masks Note: These bits can be written
                                                     only when OA2EN=0. As soon as OA2MSK is not equal to 0,
                                                     the reserved I2C addresses (0b0000xxx and 0b1111xxx) are
                                                     not acknowledged even if the comparison matches.                          */
            uint32            : 4;
      __IOM uint32 OA2EN      : 1;            /*!< [15..15] Own Address 2 enable                                             */
            uint32            : 16;
    } bit;
  } I2C_OAR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) Access: No wait states                                     */
    
    struct {
      __IOM uint32 SCLL       : 8;            /*!< [7..0] SCL low period (master mode) This field is used to generate
                                                     the SCL low period in master mode. tSCLL = (SCLL+1) x tPRESC
                                                     Note: SCLL is also used to generate tBUF and tSU:STA timings.             */
      __IOM uint32 SCLH       : 8;            /*!< [15..8] SCL high period (master mode) This field is used to
                                                     generate the SCL high period in master mode. tSCLH = (SCLH+1)
                                                     x tPRESC Note: SCLH is also used to generate tSU:STO and
                                                     tHD:STA timing.                                                           */
      __IOM uint32 SDADEL     : 4;            /*!< [19..16] Data hold time This field is used to generate the delay
                                                     tSDADEL between SCL falling edge and SDA edge. In master
                                                     mode and in slave mode with NOSTRETCH = 0, the SCL line
                                                     is stretched low during tSDADEL. tSDADEL= SDADEL x tPRESC
                                                     Note: SDADEL is used to generate tHD:DAT timing.                          */
      __IOM uint32 SCLDEL     : 4;            /*!< [23..20] Data setup time This field is used to generate a delay
                                                     tSCLDEL between SDA edge and SCL rising edge. In master
                                                     mode and in slave mode with NOSTRETCH = 0, the SCL line
                                                     is stretched low during tSCLDEL. tSCLDEL = (SCLDEL+1) x
                                                     tPRESC Note: tSCLDEL is used to generate tSU:DAT timing.                  */
            uint32            : 4;
      __IOM uint32 PRESC      : 4;            /*!< [31..28] Timing prescaler This field is used to prescale I2CCLK
                                                     in order to generate the clock period tPRESC used for data
                                                     setup and hold counters (refer to I2C timings on page9)
                                                     and for SCL high and low level counters (refer to I2C master
                                                     initialization on page24). tPRESC = (PRESC+1) x tI2CCLK                   */
    } bit;
  } I2C_TIMINGR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000014) Access: No wait states, except if a write access
                                                                    occurs while a write access to this register
                                                                    is ongoing. In this case, wait states are
                                                                    inserted in the second write access until
                                                                    the previous one is completed. The latency
                                                                    of the second write access can be up to
                                                                    2 x PCLK1 + 6 x I2CCLK.                                    */
    
    struct {
      __IOM uint32 TIMEOUTA   : 12;           /*!< [11..0] Bus Timeout A This field is used to configure: The SCL
                                                     low timeout condition tTIMEOUT when TIDLE=0 tTIMEOUT= (TIMEOUTA+1)
                                                     x 2048 x tI2CCLK The bus idle condition (both SCL and SDA
                                                     high) when TIDLE=1 tIDLE= (TIMEOUTA+1) x 4 x tI2CCLK Note:
                                                     These bits can be written only when TIMOUTEN=0.                           */
      __IOM uint32 TIDLE      : 1;            /*!< [12..12] Idle clock timeout detection Note: This bit can be
                                                     written only when TIMOUTEN=0.                                             */
            uint32            : 2;
      __IOM uint32 TIMOUTEN   : 1;            /*!< [15..15] Clock timeout enable                                             */
      __IOM uint32 TIMEOUTB   : 12;           /*!< [27..16] Bus timeout B This field is used to configure the cumulative
                                                     clock extension timeout: In master mode, the master cumulative
                                                     clock low extend time (tLOW:MEXT) is detected In slave
                                                     mode, the slave cumulative clock low extend time (tLOW:SEXT)
                                                     is detected tLOW:EXT= (TIMEOUTB+1) x 2048 x tI2CCLK Note:
                                                     These bits can be written only when TEXTEN=0.                             */
            uint32            : 3;
      __IOM uint32 TEXTEN     : 1;            /*!< [31..31] Extended clock timeout enable                                    */
    } bit;
  } I2C_TIMEOUTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000018) Access: No wait states                                     */
    
    struct {
      __IOM uint32 TXE        : 1;            /*!< [0..0] Transmit data register empty (transmitters) This bit
                                                     is set by hardware when the I2C_TXDR register is empty.
                                                     It is cleared when the next data to be sent is written
                                                     in the I2C_TXDR register. This bit can be written to 1
                                                     by software in order to flush the transmit data register
                                                     I2C_TXDR. Note: This bit is set by hardware when PE=0.                    */
      __IOM uint32 TXIS       : 1;            /*!< [1..1] Transmit interrupt status (transmitters) This bit is
                                                     set by hardware when the I2C_TXDR register is empty and
                                                     the data to be transmitted must be written in the I2C_TXDR
                                                     register. It is cleared when the next data to be sent is
                                                     written in the I2C_TXDR register. This bit can be written
                                                     to 1 by software when NOSTRETCH=1 only, in order to generate
                                                     a TXIS event (interrupt if TXIE=1 or DMA request if                       */
      __IM  uint32 RXNE       : 1;            /*!< [2..2] Receive data register not empty (receivers) This bit
                                                     is set by hardware when the received data is copied into
                                                     the I2C_RXDR register, and is ready to be read. It is cleared
                                                     when I2C_RXDR is read. Note: This bit is cleared by hardware
                                                     when PE=0.                                                                */
      __IM  uint32 ADDR       : 1;            /*!< [3..3] Address matched (slave mode) This bit is set by hardware
                                                     as soon as the received slave address matched with one
                                                     of the enabled slave addresses. It is cleared by software
                                                     by setting ADDRCF bit. Note: This bit is cleared by hardware
                                                     when PE=0.                                                                */
      __IM  uint32 NACKF      : 1;            /*!< [4..4] Not Acknowledge received flag This flag is set by hardware
                                                     when a NACK is received after a byte transmission. It is
                                                     cleared by software by setting the NACKCF bit. Note: This
                                                     bit is cleared by hardware when PE=0.                                     */
      __IM  uint32 STOPF      : 1;            /*!< [5..5] Stop detection flag This flag is set by hardware when
                                                     a Stop condition is detected on the bus and the peripheral
                                                     is involved in this transfer: either as a master, provided
                                                     that the STOP condition is generated by the peripheral.
                                                     or as a slave, provided that the peripheral has been addressed
                                                     previously during this transfer. It is cleared by software
                                                     by setting the STOPCF bit. Note: This bit is                              */
      __IM  uint32 TC         : 1;            /*!< [6..6] Transfer Complete (master mode) This flag is set by hardware
                                                     when RELOAD=0, AUTOEND=0 and NBYTES data have been transferred.
                                                     It is cleared by software when START bit or STOP bit is
                                                     set. Note: This bit is cleared by hardware when PE=0.                     */
      __IM  uint32 TCR        : 1;            /*!< [7..7] Transfer Complete Reload This flag is set by hardware
                                                     when RELOAD=1 and NBYTES data have been transferred. It
                                                     is cleared by software when NBYTES is written to a non-zero
                                                     value. Note: This bit is cleared by hardware when PE=0.
                                                     This flag is only for master mode, or for slave mode when
                                                     the SBC bit is set.                                                       */
      __IM  uint32 BERR       : 1;            /*!< [8..8] Bus error This flag is set by hardware when a misplaced
                                                     Start or Stop condition is detected whereas the peripheral
                                                     is involved in the transfer. The flag is not set during
                                                     the address phase in slave mode. It is cleared by software
                                                     by setting BERRCF bit. Note: This bit is cleared by hardware
                                                     when PE=0.                                                                */
      __IM  uint32 ARLO       : 1;            /*!< [9..9] Arbitration lost This flag is set by hardware in case
                                                     of arbitration loss. It is cleared by software by setting
                                                     the ARLOCF bit. Note: This bit is cleared by hardware when
                                                     PE=0.                                                                     */
      __IM  uint32 OVR        : 1;            /*!< [10..10] Overrun/Underrun (slave mode) This flag is set by hardware
                                                     in slave mode with NOSTRETCH=1, when an overrun/underrun
                                                     error occurs. It is cleared by software by setting the
                                                     OVRCF bit. Note: This bit is cleared by hardware when PE=0.               */
      __IM  uint32 PECERR     : 1;            /*!< [11..11] PEC Error in reception This flag is set by hardware
                                                     when the received PEC does not match with the PEC register
                                                     content. A NACK is automatically sent after the wrong PEC
                                                     reception. It is cleared by software by setting the PECCF
                                                     bit. Note: This bit is cleared by hardware when PE=0. If
                                                     the SMBus feature is not supported, this bit is reserved
                                                     and forced by hardware to 0. Please refer to Section25.3:
                                                     I2C                                                                       */
      __IM  uint32 TIMEOUT    : 1;            /*!< [12..12] Timeout or tLOW detection flag This flag is set by
                                                     hardware when a timeout or extended clock timeout occurred.
                                                     It is cleared by software by setting the TIMEOUTCF bit.
                                                     Note: This bit is cleared by hardware when PE=0. If the
                                                     SMBus feature is not supported, this bit is reserved and
                                                     forced by hardware to 0. Please refer to Section25.3: I2C
                                                     implementation.                                                           */
      __IM  uint32 ALERT      : 1;            /*!< [13..13] SMBus alert This flag is set by hardware when SMBHEN=1
                                                     (SMBus host configuration), ALERTEN=1 and a SMBALERT event
                                                     (falling edge) is detected on SMBA pin. It is cleared by
                                                     software by setting the ALERTCF bit. Note: This bit is
                                                     cleared by hardware when PE=0. If the SMBus feature is
                                                     not supported, this bit is reserved and forced by hardware
                                                     to 0. Please refer to Section25.3: I2C implementa                         */
            uint32            : 1;
      __IM  uint32 BUSY       : 1;            /*!< [15..15] Bus busy This flag indicates that a communication is
                                                     in progress on the bus. It is set by hardware when a START
                                                     condition is detected. It is cleared by hardware when a
                                                     Stop condition is detected, or when PE=0.                                 */
      __IM  uint32 DIR        : 1;            /*!< [16..16] Transfer direction (Slave mode) This flag is updated
                                                     when an address match event occurs (ADDR=1).                              */
      __IM  uint32 ADDCODE    : 7;            /*!< [23..17] Address match code (Slave mode) These bits are updated
                                                     with the received address when an address match event occurs
                                                     (ADDR = 1). In the case of a 10-bit address, ADDCODE provides
                                                     the 10-bit header followed by the 2 MSBs of the address.                  */
            uint32            : 8;
    } bit;
  } I2C_ISR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x0000001C) Access: No wait states                                     */
    
    struct {
            uint32            : 3;
      __OM  uint32 ADDRCF     : 1;            /*!< [3..3] Address matched flag clear Writing 1 to this bit clears
                                                     the ADDR flag in the I2C_ISR register. Writing 1 to this
                                                     bit also clears the START bit in the I2C_CR2 register.                    */
      __OM  uint32 NACKCF     : 1;            /*!< [4..4] Not Acknowledge flag clear Writing 1 to this bit clears
                                                     the ACKF flag in I2C_ISR register.                                        */
      __OM  uint32 STOPCF     : 1;            /*!< [5..5] Stop detection flag clear Writing 1 to this bit clears
                                                     the STOPF flag in the I2C_ISR register.                                   */
            uint32            : 2;
      __OM  uint32 BERRCF     : 1;            /*!< [8..8] Bus error flag clear Writing 1 to this bit clears the
                                                     BERRF flag in the I2C_ISR register.                                       */
      __OM  uint32 ARLOCF     : 1;            /*!< [9..9] Arbitration Lost flag clear Writing 1 to this bit clears
                                                     the ARLO flag in the I2C_ISR register.                                    */
      __OM  uint32 OVRCF      : 1;            /*!< [10..10] Overrun/Underrun flag clear Writing 1 to this bit clears
                                                     the OVR flag in the I2C_ISR register.                                     */
      __OM  uint32 PECCF      : 1;            /*!< [11..11] PEC Error flag clear Writing 1 to this bit clears the
                                                     PECERR flag in the I2C_ISR register. Note: If the SMBus
                                                     feature is not supported, this bit is reserved and forced
                                                     by hardware to 0. Please refer to Section25.3: I2C implementation.        */
      __OM  uint32 TIMOUTCF   : 1;            /*!< [12..12] Timeout detection flag clear Writing 1 to this bit
                                                     clears the TIMEOUT flag in the I2C_ISR register. Note:
                                                     If the SMBus feature is not supported, this bit is reserved
                                                     and forced by hardware to 0. Please refer to Section25.3:
                                                     I2C implementation.                                                       */
      __OM  uint32 ALERTCF    : 1;            /*!< [13..13] Alert flag clear Writing 1 to this bit clears the ALERT
                                                     flag in the I2C_ISR register. Note: If the SMBus feature
                                                     is not supported, this bit is reserved and forced by hardware
                                                     to 0. Please refer to Section25.3: I2C implementation.                    */
            uint32            : 18;
    } bit;
  } I2C_ICR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000020) Access: No wait states                                     */
    
    struct {
      __IM  uint32 PEC        : 8;            /*!< [7..0] Packet error checking register This field contains the
                                                     internal PEC when PECEN=1. The PEC is cleared by hardware
                                                     when PE=0.                                                                */
            uint32            : 24;
    } bit;
  } I2C_PECR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000024) Access: No wait states                                     */
    
    struct {
      __IM  uint32 RXDATA     : 8;            /*!< [7..0] 8-bit receive data Data byte received from the I2C bus.            */
            uint32            : 24;
    } bit;
  } I2C_RXDR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000028) Access: No wait states                                     */
    
    struct {
      __IOM uint32 TXDATA     : 8;            /*!< [7..0] 8-bit transmit data Data byte to be transmitted to the
                                                     I2C bus. Note: These bits can be written only when TXE=1.                 */
            uint32            : 24;
    } bit;
  } I2C_TXDR;
} I2C1_Type;                                    /*!< Size = 44 (0x2c)                                                          */



/* =========================================================================================================================== */
/* ================                                           GPIOA                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief GPIO (GPIOA)
  */

typedef struct {                                /*!< (@ 0x58020000) GPIOA Structure                                            */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) GPIO port mode register                                    */
    
    struct {
      __IOM uint32 MODER0      : 2;            /*!< [1..0] [1:0]: Port x configuration bits (y = 0..15) These bits
                                                      are written by software to configure the I/O mode.                        */
      __IOM uint32 MODER1      : 2;            /*!< [3..2] [1:0]: Port x configuration bits (y = 0..15) These bits
                                                      are written by software to configure the I/O mode.                        */
      __IOM uint32 MODER2      : 2;            /*!< [5..4] [1:0]: Port x configuration bits (y = 0..15) These bits
                                                      are written by software to configure the I/O mode.                        */
      __IOM uint32 MODER3      : 2;            /*!< [7..6] [1:0]: Port x configuration bits (y = 0..15) These bits
                                                      are written by software to configure the I/O mode.                        */
      __IOM uint32 MODER4      : 2;            /*!< [9..8] [1:0]: Port x configuration bits (y = 0..15) These bits
                                                      are written by software to configure the I/O mode.                        */
      __IOM uint32 MODER5      : 2;            /*!< [11..10] [1:0]: Port x configuration bits (y = 0..15) These
                                                      bits are written by software to configure the I/O mode.                   */
      __IOM uint32 MODER6      : 2;            /*!< [13..12] [1:0]: Port x configuration bits (y = 0..15) These
                                                      bits are written by software to configure the I/O mode.                   */
      __IOM uint32 MODER7      : 2;            /*!< [15..14] [1:0]: Port x configuration bits (y = 0..15) These
                                                      bits are written by software to configure the I/O mode.                   */
      __IOM uint32 MODER8      : 2;            /*!< [17..16] [1:0]: Port x configuration bits (y = 0..15) These
                                                      bits are written by software to configure the I/O mode.                   */
      __IOM uint32 MODER9      : 2;            /*!< [19..18] [1:0]: Port x configuration bits (y = 0..15) These
                                                      bits are written by software to configure the I/O mode.                   */
      __IOM uint32 MODER10     : 2;            /*!< [21..20] [1:0]: Port x configuration bits (y = 0..15) These
                                                      bits are written by software to configure the I/O mode.                   */
      __IOM uint32 MODER11     : 2;            /*!< [23..22] [1:0]: Port x configuration bits (y = 0..15) These
                                                      bits are written by software to configure the I/O mode.                   */
      __IOM uint32 MODER12     : 2;            /*!< [25..24] [1:0]: Port x configuration bits (y = 0..15) These
                                                      bits are written by software to configure the I/O mode.                   */
      __IOM uint32 MODER13     : 2;            /*!< [27..26] [1:0]: Port x configuration bits (y = 0..15) These
                                                      bits are written by software to configure the I/O mode.                   */
      __IOM uint32 MODER14     : 2;            /*!< [29..28] [1:0]: Port x configuration bits (y = 0..15) These
                                                      bits are written by software to configure the I/O mode.                   */
      __IOM uint32 MODER15     : 2;            /*!< [31..30] [1:0]: Port x configuration bits (y = 0..15) These
                                                     bits are written by software to configure the I/O mode.                   */
    } bit;
  } MODER;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) GPIO port output type register                             */
    
    struct {
      __IOM uint32 OTR0        : 1;            /*!< [0..0] Port x configuration bits (y = 0..15) These bits are
                                                      written by software to configure the I/O output type.                     */
      __IOM uint32 OTR1        : 1;            /*!< [1..1] Port x configuration bits (y = 0..15) These bits are
                                                      written by software to configure the I/O output type.                     */
      __IOM uint32 OTR2        : 1;            /*!< [2..2] Port x configuration bits (y = 0..15) These bits are
                                                      written by software to configure the I/O output type.                     */
      __IOM uint32 OTR3        : 1;            /*!< [3..3] Port x configuration bits (y = 0..15) These bits are
                                                      written by software to configure the I/O output type.                     */
      __IOM uint32 OTR4        : 1;            /*!< [4..4] Port x configuration bits (y = 0..15) These bits are
                                                      written by software to configure the I/O output type.                     */
      __IOM uint32 OTR5        : 1;            /*!< [5..5] Port x configuration bits (y = 0..15) These bits are
                                                      written by software to configure the I/O output type.                     */
      __IOM uint32 OTR6        : 1;            /*!< [6..6] Port x configuration bits (y = 0..15) These bits are
                                                      written by software to configure the I/O output type.                     */
      __IOM uint32 OTR7        : 1;            /*!< [7..7] Port x configuration bits (y = 0..15) These bits are
                                                      written by software to configure the I/O output type.                     */
      __IOM uint32 OTR8        : 1;            /*!< [8..8] Port x configuration bits (y = 0..15) These bits are
                                                      written by software to configure the I/O output type.                     */
      __IOM uint32 OTR9        : 1;            /*!< [9..9] Port x configuration bits (y = 0..15) These bits are
                                                      written by software to configure the I/O output type.                     */
      __IOM uint32 OTR10       : 1;            /*!< [10..10] Port x configuration bits (y = 0..15) These bits are
                                                      written by software to configure the I/O output type.                     */
      __IOM uint32 OTR11       : 1;            /*!< [11..11] Port x configuration bits (y = 0..15) These bits are
                                                      written by software to configure the I/O output type.                     */
      __IOM uint32 OTR12       : 1;            /*!< [12..12] Port x configuration bits (y = 0..15) These bits are
                                                      written by software to configure the I/O output type.                     */
      __IOM uint32 OTR13       : 1;            /*!< [13..13] Port x configuration bits (y = 0..15) These bits are
                                                      written by software to configure the I/O output type.                     */
      __IOM uint32 OTR14       : 1;            /*!< [14..14] Port x configuration bits (y = 0..15) These bits are
                                                      written by software to configure the I/O output type.                     */
      __IOM uint32 OTR15       : 1;            /*!< [15..15] Port x configuration bits (y = 0..15) These bits are
                                                     written by software to configure the I/O output type.                     */
            uint32            : 16;
    } bit;
  } OTYPER;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) GPIO port output speed register                            */
    
    struct {
      __IOM uint32 OSPEEDR0    : 2;            /*!< [1..0] [1:0]: Port x configuration bits (y = 0..15) These bits
                                                      are written by software to configure the I/O output speed.
                                                      Note: Refer to the device datasheet for the frequency specifications
                                                      and the power supply and load conditions for each speed.                  */
      __IOM uint32 OSPEEDR1    : 2;            /*!< [3..2] [1:0]: Port x configuration bits (y = 0..15) These bits
                                                      are written by software to configure the I/O output speed.
                                                      Note: Refer to the device datasheet for the frequency specifications
                                                      and the power supply and load conditions for each speed.                  */
      __IOM uint32 OSPEEDR2    : 2;            /*!< [5..4] [1:0]: Port x configuration bits (y = 0..15) These bits
                                                      are written by software to configure the I/O output speed.
                                                      Note: Refer to the device datasheet for the frequency specifications
                                                      and the power supply and load conditions for each speed.                  */
      __IOM uint32 OSPEEDR3    : 2;            /*!< [7..6] [1:0]: Port x configuration bits (y = 0..15) These bits
                                                      are written by software to configure the I/O output speed.
                                                      Note: Refer to the device datasheet for the frequency specifications
                                                      and the power supply and load conditions for each speed.                  */
      __IOM uint32 OSPEEDR4    : 2;            /*!< [9..8] [1:0]: Port x configuration bits (y = 0..15) These bits
                                                      are written by software to configure the I/O output speed.
                                                      Note: Refer to the device datasheet for the frequency specifications
                                                      and the power supply and load conditions for each speed.                  */
      __IOM uint32 OSPEEDR5    : 2;            /*!< [11..10] [1:0]: Port x configuration bits (y = 0..15) These
                                                      bits are written by software to configure the I/O output
                                                      speed. Note: Refer to the device datasheet for the frequency
                                                      specifications and the power supply and load conditions
                                                      for each speed.                                                           */
      __IOM uint32 OSPEEDR6    : 2;            /*!< [13..12] [1:0]: Port x configuration bits (y = 0..15) These
                                                      bits are written by software to configure the I/O output
                                                      speed. Note: Refer to the device datasheet for the frequency
                                                      specifications and the power supply and load conditions
                                                      for each speed.                                                           */
      __IOM uint32 OSPEEDR7    : 2;            /*!< [15..14] [1:0]: Port x configuration bits (y = 0..15) These
                                                      bits are written by software to configure the I/O output
                                                      speed. Note: Refer to the device datasheet for the frequency
                                                      specifications and the power supply and load conditions
                                                      for each speed.                                                           */
      __IOM uint32 OSPEEDR8    : 2;            /*!< [17..16] [1:0]: Port x configuration bits (y = 0..15) These
                                                      bits are written by software to configure the I/O output
                                                      speed. Note: Refer to the device datasheet for the frequency
                                                      specifications and the power supply and load conditions
                                                      for each speed.                                                           */
      __IOM uint32 OSPEEDR9    : 2;            /*!< [19..18] [1:0]: Port x configuration bits (y = 0..15) These
                                                      bits are written by software to configure the I/O output
                                                      speed. Note: Refer to the device datasheet for the frequency
                                                      specifications and the power supply and load conditions
                                                      for each speed.                                                           */
      __IOM uint32 OSPEEDR10   : 2;            /*!< [21..20] [1:0]: Port x configuration bits (y = 0..15) These
                                                      bits are written by software to configure the I/O output
                                                      speed. Note: Refer to the device datasheet for the frequency
                                                      specifications and the power supply and load conditions
                                                      for each speed.                                                           */
      __IOM uint32 OSPEEDR11   : 2;            /*!< [23..22] [1:0]: Port x configuration bits (y = 0..15) These
                                                      bits are written by software to configure the I/O output
                                                      speed. Note: Refer to the device datasheet for the frequency
                                                      specifications and the power supply and load conditions
                                                      for each speed.                                                           */
      __IOM uint32 OSPEEDR12   : 2;            /*!< [25..24] [1:0]: Port x configuration bits (y = 0..15) These
                                                      bits are written by software to configure the I/O output
                                                      speed. Note: Refer to the device datasheet for the frequency
                                                      specifications and the power supply and load conditions
                                                      for each speed.                                                           */
      __IOM uint32 OSPEEDR13   : 2;            /*!< [27..26] [1:0]: Port x configuration bits (y = 0..15) These
                                                      bits are written by software to configure the I/O output
                                                      speed. Note: Refer to the device datasheet for the frequency
                                                      specifications and the power supply and load conditions
                                                      for each speed.                                                           */
      __IOM uint32 OSPEEDR14   : 2;            /*!< [29..28] [1:0]: Port x configuration bits (y = 0..15) These
                                                      bits are written by software to configure the I/O output
                                                      speed. Note: Refer to the device datasheet for the frequency
                                                      specifications and the power supply and load conditions
                                                      for each speed.                                                           */
      __IOM uint32 OSPEEDR15   : 2;            /*!< [31..30] [1:0]: Port x configuration bits (y = 0..15) These
                                                     bits are written by software to configure the I/O output
                                                     speed. Note: Refer to the device datasheet for the frequency
                                                     specifications and the power supply and load conditions
                                                     for each speed.                                                           */
    } bit;
  } OSPEEDR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) GPIO port pull-up/pull-down register                       */
    
    struct {
      __IOM uint32 PUPDR0      : 2;            /*!< [1..0] [1:0]: Port x configuration bits (y = 0..15) These bits
                                                      are written by software to configure the I/O pull-up or
                                                      pull-down                                                                 */
      __IOM uint32 PUPDR1      : 2;            /*!< [3..2] [1:0]: Port x configuration bits (y = 0..15) These bits
                                                      are written by software to configure the I/O pull-up or
                                                      pull-down                                                                 */
      __IOM uint32 PUPDR2      : 2;            /*!< [5..4] [1:0]: Port x configuration bits (y = 0..15) These bits
                                                      are written by software to configure the I/O pull-up or
                                                      pull-down                                                                 */
      __IOM uint32 PUPDR3      : 2;            /*!< [7..6] [1:0]: Port x configuration bits (y = 0..15) These bits
                                                      are written by software to configure the I/O pull-up or
                                                      pull-down                                                                 */
      __IOM uint32 PUPDR4      : 2;            /*!< [9..8] [1:0]: Port x configuration bits (y = 0..15) These bits
                                                      are written by software to configure the I/O pull-up or
                                                      pull-down                                                                 */
      __IOM uint32 PUPDR5      : 2;            /*!< [11..10] [1:0]: Port x configuration bits (y = 0..15) These
                                                      bits are written by software to configure the I/O pull-up
                                                      or pull-down                                                              */
      __IOM uint32 PUPDR6      : 2;            /*!< [13..12] [1:0]: Port x configuration bits (y = 0..15) These
                                                      bits are written by software to configure the I/O pull-up
                                                      or pull-down                                                              */
      __IOM uint32 PUPDR7      : 2;            /*!< [15..14] [1:0]: Port x configuration bits (y = 0..15) These
                                                      bits are written by software to configure the I/O pull-up
                                                      or pull-down                                                              */
      __IOM uint32 PUPDR8      : 2;            /*!< [17..16] [1:0]: Port x configuration bits (y = 0..15) These
                                                      bits are written by software to configure the I/O pull-up
                                                      or pull-down                                                              */
      __IOM uint32 PUPDR9      : 2;            /*!< [19..18] [1:0]: Port x configuration bits (y = 0..15) These
                                                      bits are written by software to configure the I/O pull-up
                                                      or pull-down                                                              */
      __IOM uint32 PUPDR10     : 2;            /*!< [21..20] [1:0]: Port x configuration bits (y = 0..15) These
                                                      bits are written by software to configure the I/O pull-up
                                                      or pull-down                                                              */
      __IOM uint32 PUPDR11     : 2;            /*!< [23..22] [1:0]: Port x configuration bits (y = 0..15) These
                                                      bits are written by software to configure the I/O pull-up
                                                      or pull-down                                                              */
      __IOM uint32 PUPDR12     : 2;            /*!< [25..24] [1:0]: Port x configuration bits (y = 0..15) These
                                                      bits are written by software to configure the I/O pull-up
                                                      or pull-down                                                              */
      __IOM uint32 PUPDR13     : 2;            /*!< [27..26] [1:0]: Port x configuration bits (y = 0..15) These
                                                      bits are written by software to configure the I/O pull-up
                                                      or pull-down                                                              */
      __IOM uint32 PUPDR14     : 2;            /*!< [29..28] [1:0]: Port x configuration bits (y = 0..15) These
                                                      bits are written by software to configure the I/O pull-up
                                                      or pull-down                                                              */
      __IOM uint32 PUPDR15     : 2;            /*!< [31..30] [1:0]: Port x configuration bits (y = 0..15) These
                                                     bits are written by software to configure the I/O pull-up
                                                     or pull-down                                                              */
    } bit;
  } PUPDR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000010) GPIO port input data register                              */
    
    struct {
      __IM  uint32 IDR0        : 1;            /*!< [0..0] Port input data bit (y = 0..15) These bits are read-only.
                                                      They contain the input value of the corresponding I/O port.               */
      __IM  uint32 IDR1        : 1;            /*!< [1..1] Port input data bit (y = 0..15) These bits are read-only.
                                                      They contain the input value of the corresponding I/O port.               */
      __IM  uint32 IDR2        : 1;            /*!< [2..2] Port input data bit (y = 0..15) These bits are read-only.
                                                      They contain the input value of the corresponding I/O port.               */
      __IM  uint32 IDR3        : 1;            /*!< [3..3] Port input data bit (y = 0..15) These bits are read-only.
                                                      They contain the input value of the corresponding I/O port.               */
      __IM  uint32 IDR4        : 1;            /*!< [4..4] Port input data bit (y = 0..15) These bits are read-only.
                                                      They contain the input value of the corresponding I/O port.               */
      __IM  uint32 IDR5        : 1;            /*!< [5..5] Port input data bit (y = 0..15) These bits are read-only.
                                                      They contain the input value of the corresponding I/O port.               */
      __IM  uint32 IDR6        : 1;            /*!< [6..6] Port input data bit (y = 0..15) These bits are read-only.
                                                      They contain the input value of the corresponding I/O port.               */
      __IM  uint32 IDR7        : 1;            /*!< [7..7] Port input data bit (y = 0..15) These bits are read-only.
                                                      They contain the input value of the corresponding I/O port.               */
      __IM  uint32 IDR8        : 1;            /*!< [8..8] Port input data bit (y = 0..15) These bits are read-only.
                                                      They contain the input value of the corresponding I/O port.               */
      __IM  uint32 IDR9        : 1;            /*!< [9..9] Port input data bit (y = 0..15) These bits are read-only.
                                                      They contain the input value of the corresponding I/O port.               */
      __IM  uint32 IDR10       : 1;            /*!< [10..10] Port input data bit (y = 0..15) These bits are read-only.
                                                      They contain the input value of the corresponding I/O port.               */
      __IM  uint32 IDR11       : 1;            /*!< [11..11] Port input data bit (y = 0..15) These bits are read-only.
                                                      They contain the input value of the corresponding I/O port.               */
      __IM  uint32 IDR12       : 1;            /*!< [12..12] Port input data bit (y = 0..15) These bits are read-only.
                                                      They contain the input value of the corresponding I/O port.               */
      __IM  uint32 IDR13       : 1;            /*!< [13..13] Port input data bit (y = 0..15) These bits are read-only.
                                                      They contain the input value of the corresponding I/O port.               */
      __IM  uint32 IDR14       : 1;            /*!< [14..14] Port input data bit (y = 0..15) These bits are read-only.
                                                      They contain the input value of the corresponding I/O port.               */
      __IM  uint32 IDR15       : 1;            /*!< [15..15] Port input data bit (y = 0..15) These bits are read-only.
                                                     They contain the input value of the corresponding I/O port.               */
            uint32            : 16;
    } bit;
  } IDR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000014) GPIO port output data register                             */
    
    struct {
      __IOM uint32 ODR0        : 1;            /*!< [0..0] Port output data bit These bits can be read and written
                                                      by software. Note: For atomic bit set/reset, the OD bits
                                                      can be individually set and/or reset by writing to the
                                                      GPIOx_BSRR or GPIOx_BRR registers (x = A..F).                             */
      __IOM uint32 ODR1        : 1;            /*!< [1..1] Port output data bit These bits can be read and written
                                                      by software. Note: For atomic bit set/reset, the OD bits
                                                      can be individually set and/or reset by writing to the
                                                      GPIOx_BSRR or GPIOx_BRR registers (x = A..F).                             */
      __IOM uint32 ODR2        : 1;            /*!< [2..2] Port output data bit These bits can be read and written
                                                      by software. Note: For atomic bit set/reset, the OD bits
                                                      can be individually set and/or reset by writing to the
                                                      GPIOx_BSRR or GPIOx_BRR registers (x = A..F).                             */
      __IOM uint32 ODR3        : 1;            /*!< [3..3] Port output data bit These bits can be read and written
                                                      by software. Note: For atomic bit set/reset, the OD bits
                                                      can be individually set and/or reset by writing to the
                                                      GPIOx_BSRR or GPIOx_BRR registers (x = A..F).                             */
      __IOM uint32 ODR4        : 1;            /*!< [4..4] Port output data bit These bits can be read and written
                                                      by software. Note: For atomic bit set/reset, the OD bits
                                                      can be individually set and/or reset by writing to the
                                                      GPIOx_BSRR or GPIOx_BRR registers (x = A..F).                             */
      __IOM uint32 ODR5        : 1;            /*!< [5..5] Port output data bit These bits can be read and written
                                                      by software. Note: For atomic bit set/reset, the OD bits
                                                      can be individually set and/or reset by writing to the
                                                      GPIOx_BSRR or GPIOx_BRR registers (x = A..F).                             */
      __IOM uint32 ODR6        : 1;            /*!< [6..6] Port output data bit These bits can be read and written
                                                      by software. Note: For atomic bit set/reset, the OD bits
                                                      can be individually set and/or reset by writing to the
                                                      GPIOx_BSRR or GPIOx_BRR registers (x = A..F).                             */
      __IOM uint32 ODR7        : 1;            /*!< [7..7] Port output data bit These bits can be read and written
                                                      by software. Note: For atomic bit set/reset, the OD bits
                                                      can be individually set and/or reset by writing to the
                                                      GPIOx_BSRR or GPIOx_BRR registers (x = A..F).                             */
      __IOM uint32 ODR8        : 1;            /*!< [8..8] Port output data bit These bits can be read and written
                                                      by software. Note: For atomic bit set/reset, the OD bits
                                                      can be individually set and/or reset by writing to the
                                                      GPIOx_BSRR or GPIOx_BRR registers (x = A..F).                             */
      __IOM uint32 ODR9        : 1;            /*!< [9..9] Port output data bit These bits can be read and written
                                                      by software. Note: For atomic bit set/reset, the OD bits
                                                      can be individually set and/or reset by writing to the
                                                      GPIOx_BSRR or GPIOx_BRR registers (x = A..F).                             */
      __IOM uint32 ODR10       : 1;            /*!< [10..10] Port output data bit These bits can be read and written
                                                      by software. Note: For atomic bit set/reset, the OD bits
                                                      can be individually set and/or reset by writing to the
                                                      GPIOx_BSRR or GPIOx_BRR registers (x = A..F).                             */
      __IOM uint32 ODR11       : 1;            /*!< [11..11] Port output data bit These bits can be read and written
                                                      by software. Note: For atomic bit set/reset, the OD bits
                                                      can be individually set and/or reset by writing to the
                                                      GPIOx_BSRR or GPIOx_BRR registers (x = A..F).                             */
      __IOM uint32 ODR12       : 1;            /*!< [12..12] Port output data bit These bits can be read and written
                                                      by software. Note: For atomic bit set/reset, the OD bits
                                                      can be individually set and/or reset by writing to the
                                                      GPIOx_BSRR or GPIOx_BRR registers (x = A..F).                             */
      __IOM uint32 ODR13       : 1;            /*!< [13..13] Port output data bit These bits can be read and written
                                                      by software. Note: For atomic bit set/reset, the OD bits
                                                      can be individually set and/or reset by writing to the
                                                      GPIOx_BSRR or GPIOx_BRR registers (x = A..F).                             */
      __IOM uint32 ODR14       : 1;            /*!< [14..14] Port output data bit These bits can be read and written
                                                      by software. Note: For atomic bit set/reset, the OD bits
                                                      can be individually set and/or reset by writing to the
                                                      GPIOx_BSRR or GPIOx_BRR registers (x = A..F).                             */
      __IOM uint32 ODR15       : 1;            /*!< [15..15] Port output data bit These bits can be read and written
                                                     by software. Note: For atomic bit set/reset, the OD bits
                                                     can be individually set and/or reset by writing to the
                                                     GPIOx_BSRR or GPIOx_BRR registers (x = A..F).                             */
            uint32            : 16;
    } bit;
  } ODR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000018) GPIO port bit set/reset register                           */
    
    struct {
      __OM  uint32 BS0        : 1;            /*!< [0..0] Port x set bit y (y= 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000.                            */
      __OM  uint32 BS1        : 1;            /*!< [1..1] Port x set bit y (y= 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000.                            */
      __OM  uint32 BS2        : 1;            /*!< [2..2] Port x set bit y (y= 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000.                            */
      __OM  uint32 BS3        : 1;            /*!< [3..3] Port x set bit y (y= 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000.                            */
      __OM  uint32 BS4        : 1;            /*!< [4..4] Port x set bit y (y= 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000.                            */
      __OM  uint32 BS5        : 1;            /*!< [5..5] Port x set bit y (y= 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000.                            */
      __OM  uint32 BS6        : 1;            /*!< [6..6] Port x set bit y (y= 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000.                            */
      __OM  uint32 BS7        : 1;            /*!< [7..7] Port x set bit y (y= 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000.                            */
      __OM  uint32 BS8        : 1;            /*!< [8..8] Port x set bit y (y= 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000.                            */
      __OM  uint32 BS9        : 1;            /*!< [9..9] Port x set bit y (y= 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000.                            */
      __OM  uint32 BS10       : 1;            /*!< [10..10] Port x set bit y (y= 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000.                            */
      __OM  uint32 BS11       : 1;            /*!< [11..11] Port x set bit y (y= 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000.                            */
      __OM  uint32 BS12       : 1;            /*!< [12..12] Port x set bit y (y= 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000.                            */
      __OM  uint32 BS13       : 1;            /*!< [13..13] Port x set bit y (y= 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000.                            */
      __OM  uint32 BS14       : 1;            /*!< [14..14] Port x set bit y (y= 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000.                            */
      __OM  uint32 BS15       : 1;            /*!< [15..15] Port x set bit y (y= 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000.                            */
      __OM  uint32 BR0        : 1;            /*!< [16..16] Port x reset bit y (y = 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000. Note: If
                                                     both BSx and BRx are set, BSx has priority.                               */
      __OM  uint32 BR1        : 1;            /*!< [17..17] Port x reset bit y (y = 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000. Note: If
                                                     both BSx and BRx are set, BSx has priority.                               */
      __OM  uint32 BR2        : 1;            /*!< [18..18] Port x reset bit y (y = 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000. Note: If
                                                     both BSx and BRx are set, BSx has priority.                               */
      __OM  uint32 BR3        : 1;            /*!< [19..19] Port x reset bit y (y = 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000. Note: If
                                                     both BSx and BRx are set, BSx has priority.                               */
      __OM  uint32 BR4        : 1;            /*!< [20..20] Port x reset bit y (y = 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000. Note: If
                                                     both BSx and BRx are set, BSx has priority.                               */
      __OM  uint32 BR5        : 1;            /*!< [21..21] Port x reset bit y (y = 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000. Note: If
                                                     both BSx and BRx are set, BSx has priority.                               */
      __OM  uint32 BR6        : 1;            /*!< [22..22] Port x reset bit y (y = 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000. Note: If
                                                     both BSx and BRx are set, BSx has priority.                               */
      __OM  uint32 BR7        : 1;            /*!< [23..23] Port x reset bit y (y = 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000. Note: If
                                                     both BSx and BRx are set, BSx has priority.                               */
      __OM  uint32 BR8        : 1;            /*!< [24..24] Port x reset bit y (y = 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000. Note: If
                                                     both BSx and BRx are set, BSx has priority.                               */
      __OM  uint32 BR9        : 1;            /*!< [25..25] Port x reset bit y (y = 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000. Note: If
                                                     both BSx and BRx are set, BSx has priority.                               */
      __OM  uint32 BR10       : 1;            /*!< [26..26] Port x reset bit y (y = 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000. Note: If
                                                     both BSx and BRx are set, BSx has priority.                               */
      __OM  uint32 BR11       : 1;            /*!< [27..27] Port x reset bit y (y = 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000. Note: If
                                                     both BSx and BRx are set, BSx has priority.                               */
      __OM  uint32 BR12       : 1;            /*!< [28..28] Port x reset bit y (y = 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000. Note: If
                                                     both BSx and BRx are set, BSx has priority.                               */
      __OM  uint32 BR13       : 1;            /*!< [29..29] Port x reset bit y (y = 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000. Note: If
                                                     both BSx and BRx are set, BSx has priority.                               */
      __OM  uint32 BR14       : 1;            /*!< [30..30] Port x reset bit y (y = 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000. Note: If
                                                     both BSx and BRx are set, BSx has priority.                               */
      __OM  uint32 BR15       : 1;            /*!< [31..31] Port x reset bit y (y = 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000. Note: If
                                                     both BSx and BRx are set, BSx has priority.                               */
    } bit;
  } BSRR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000001C) This register is used to lock the configuration
                                                                    of the port bits when a correct write sequence
                                                                    is applied to bit 16 (LCKK). The value of
                                                                    bits [15:0] is used to lock the configuration
                                                                    of the GPIO. During the write sequence,
                                                                    the value of LCKR[15:0] must not change.
                                                                    When the LOCK sequence has been applied
                                                                    on a port bit, the value of this port bit
                                                                    can no longer be modified until the next
                                                                    MCU reset or peripheral reset.                             */
    
    struct {
      __IOM uint32 LCK0       : 1;            /*!< [0..0] Port x lock bit y (y= 0..15) These bits are read/write
                                                     but can only be written when the LCKK bit is 0.                           */
      __IOM uint32 LCK1       : 1;            /*!< [1..1] Port x lock bit y (y= 0..15) These bits are read/write
                                                     but can only be written when the LCKK bit is 0.                           */
      __IOM uint32 LCK2       : 1;            /*!< [2..2] Port x lock bit y (y= 0..15) These bits are read/write
                                                     but can only be written when the LCKK bit is 0.                           */
      __IOM uint32 LCK3       : 1;            /*!< [3..3] Port x lock bit y (y= 0..15) These bits are read/write
                                                     but can only be written when the LCKK bit is 0.                           */
      __IOM uint32 LCK4       : 1;            /*!< [4..4] Port x lock bit y (y= 0..15) These bits are read/write
                                                     but can only be written when the LCKK bit is 0.                           */
      __IOM uint32 LCK5       : 1;            /*!< [5..5] Port x lock bit y (y= 0..15) These bits are read/write
                                                     but can only be written when the LCKK bit is 0.                           */
      __IOM uint32 LCK6       : 1;            /*!< [6..6] Port x lock bit y (y= 0..15) These bits are read/write
                                                     but can only be written when the LCKK bit is 0.                           */
      __IOM uint32 LCK7       : 1;            /*!< [7..7] Port x lock bit y (y= 0..15) These bits are read/write
                                                     but can only be written when the LCKK bit is 0.                           */
      __IOM uint32 LCK8       : 1;            /*!< [8..8] Port x lock bit y (y= 0..15) These bits are read/write
                                                     but can only be written when the LCKK bit is 0.                           */
      __IOM uint32 LCK9       : 1;            /*!< [9..9] Port x lock bit y (y= 0..15) These bits are read/write
                                                     but can only be written when the LCKK bit is 0.                           */
      __IOM uint32 LCK10      : 1;            /*!< [10..10] Port x lock bit y (y= 0..15) These bits are read/write
                                                     but can only be written when the LCKK bit is 0.                           */
      __IOM uint32 LCK11      : 1;            /*!< [11..11] Port x lock bit y (y= 0..15) These bits are read/write
                                                     but can only be written when the LCKK bit is 0.                           */
      __IOM uint32 LCK12      : 1;            /*!< [12..12] Port x lock bit y (y= 0..15) These bits are read/write
                                                     but can only be written when the LCKK bit is 0.                           */
      __IOM uint32 LCK13      : 1;            /*!< [13..13] Port x lock bit y (y= 0..15) These bits are read/write
                                                     but can only be written when the LCKK bit is 0.                           */
      __IOM uint32 LCK14      : 1;            /*!< [14..14] Port x lock bit y (y= 0..15) These bits are read/write
                                                     but can only be written when the LCKK bit is 0.                           */
      __IOM uint32 LCK15      : 1;            /*!< [15..15] Port x lock bit y (y= 0..15) These bits are read/write
                                                     but can only be written when the LCKK bit is 0.                           */
      __IOM uint32 LCKK       : 1;            /*!< [16..16] Lock key This bit can be read any time. It can only
                                                     be modified using the lock key write sequence. LOCK key
                                                     write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16]
                                                     = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD
                                                     LCKR[16] = 1 (this read operation is optional but it confirms
                                                     that the lock is active) Note: During the LOCK key write
                                                     sequence, the value of LCK[15:0] must not change. Any error
                                                     in                                                                        */
            uint32            : 15;
    } bit;
  } LCKR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000020) GPIO alternate function low register                       */
    
    struct {
      __IOM uint32 AFSEL0     : 4;            /*!< [3..0] [3:0]: Alternate function selection for port x pin y
                                                     (y = 0..7) These bits are written by software to configure
                                                     alternate function I/Os AFSELy selection:                                 */
      __IOM uint32 AFSEL1     : 4;            /*!< [7..4] [3:0]: Alternate function selection for port x pin y
                                                     (y = 0..7) These bits are written by software to configure
                                                     alternate function I/Os AFSELy selection:                                 */
      __IOM uint32 AFSEL2     : 4;            /*!< [11..8] [3:0]: Alternate function selection for port x pin y
                                                     (y = 0..7) These bits are written by software to configure
                                                     alternate function I/Os AFSELy selection:                                 */
      __IOM uint32 AFSEL3     : 4;            /*!< [15..12] [3:0]: Alternate function selection for port x pin
                                                     y (y = 0..7) These bits are written by software to configure
                                                     alternate function I/Os AFSELy selection:                                 */
      __IOM uint32 AFSEL4     : 4;            /*!< [19..16] [3:0]: Alternate function selection for port x pin
                                                     y (y = 0..7) These bits are written by software to configure
                                                     alternate function I/Os AFSELy selection:                                 */
      __IOM uint32 AFSEL5     : 4;            /*!< [23..20] [3:0]: Alternate function selection for port x pin
                                                     y (y = 0..7) These bits are written by software to configure
                                                     alternate function I/Os AFSELy selection:                                 */
      __IOM uint32 AFSEL6     : 4;            /*!< [27..24] [3:0]: Alternate function selection for port x pin
                                                     y (y = 0..7) These bits are written by software to configure
                                                     alternate function I/Os AFSELy selection:                                 */
      __IOM uint32 AFSEL7     : 4;            /*!< [31..28] [3:0]: Alternate function selection for port x pin
                                                     y (y = 0..7) These bits are written by software to configure
                                                     alternate function I/Os AFSELy selection:                                 */
    } bit;
  } AFRL;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000024) GPIO alternate function high register                      */
    
    struct {
      __IOM uint32 AFSEL8     : 4;            /*!< [3..0] [3:0]: Alternate function selection for port x pin y
                                                     (y = 8..15) These bits are written by software to configure
                                                     alternate function I/Os                                                   */
      __IOM uint32 AFSEL9     : 4;            /*!< [7..4] [3:0]: Alternate function selection for port x pin y
                                                     (y = 8..15) These bits are written by software to configure
                                                     alternate function I/Os                                                   */
      __IOM uint32 AFSEL10    : 4;            /*!< [11..8] [3:0]: Alternate function selection for port x pin y
                                                     (y = 8..15) These bits are written by software to configure
                                                     alternate function I/Os                                                   */
      __IOM uint32 AFSEL11    : 4;            /*!< [15..12] [3:0]: Alternate function selection for port x pin
                                                     y (y = 8..15) These bits are written by software to configure
                                                     alternate function I/Os                                                   */
      __IOM uint32 AFSEL12    : 4;            /*!< [19..16] [3:0]: Alternate function selection for port x pin
                                                     y (y = 8..15) These bits are written by software to configure
                                                     alternate function I/Os                                                   */
      __IOM uint32 AFSEL13    : 4;            /*!< [23..20] [3:0]: Alternate function selection for port x pin
                                                     y (y = 8..15) These bits are written by software to configure
                                                     alternate function I/Os                                                   */
      __IOM uint32 AFSEL14    : 4;            /*!< [27..24] [3:0]: Alternate function selection for port x pin
                                                     y (y = 8..15) These bits are written by software to configure
                                                     alternate function I/Os                                                   */
      __IOM uint32 AFSEL15    : 4;            /*!< [31..28] [3:0]: Alternate function selection for port x pin
                                                     y (y = 8..15) These bits are written by software to configure
                                                     alternate function I/Os                                                   */
    } bit;
  } AFRH;
} GPIOA_Type;                                   /*!< Size = 40 (0x28)                                                          */



/* =========================================================================================================================== */
/* ================                                           JPEG                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief JPEG (JPEG)
  */

typedef struct {                                /*!< (@ 0x52003000) JPEG Structure                                             */
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000000) JPEG codec control register                                */
    
    struct {
      __OM  uint32 START      : 1;            /*!< [0..0] Start This bit start or stop the encoding or decoding
                                                     process. Read this register always return 0.                              */
            uint32            : 31;
    } bit;
  } JPEG_CONFR0;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) JPEG codec configuration register 1                        */
    
    struct {
      __IOM uint32 NF         : 2;            /*!< [1..0] Number of color components This field defines the number
                                                     of color components minus 1.                                              */
            uint32            : 1;
      __IOM uint32 DE         : 1;            /*!< [3..3] Decoding Enable This bit selects the coding or decoding
                                                     process                                                                   */
      __IOM uint32 COLORSPACE : 2;            /*!< [5..4] Color Space This filed defines the number of quantization
                                                     tables minus 1 to insert in the output stream.                            */
      __IOM uint32 NS         : 2;            /*!< [7..6] Number of components for Scan This field defines the
                                                     number of components minus 1 for scan header marker segment.              */
      __IOM uint32 HDR        : 1;            /*!< [8..8] Header Processing This bit enable the header processing
                                                     (generation/parsing).                                                     */
            uint32            : 7;
      __IOM uint32 YSIZE      : 16;           /*!< [31..16] Y Size This field defines the number of lines in source
                                                     image.                                                                    */
    } bit;
  } JPEG_CONFR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) JPEG codec configuration register 2                        */
    
    struct {
      __IOM uint32 NMCU       : 26;           /*!< [25..0] Number of MCU For encoding: this field defines the number
                                                     of MCU units minus 1 to encode. For decoding: this field
                                                     indicates the number of complete MCU units minus 1 to be
                                                     decoded (this field is updated after the JPEG header parsing).
                                                     If the decoded image size has not a X or Y size multiple
                                                     of 8 or 16 (depending on the sub-sampling process), the
                                                     resulting incomplete or empty MCU must be added to                        */
            uint32            : 6;
    } bit;
  } JPEG_CONFR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) JPEG codec configuration register 3                        */
    
    struct {
            uint32            : 16;
      __IOM uint32 XSIZE      : 16;           /*!< [31..16] X size This field defines the number of pixels per
                                                     line.                                                                     */
    } bit;
  } JPEG_CONFR3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) JPEG codec configuration register 4-7                      */
    
    struct {
      __IOM uint32 HD         : 1;            /*!< [0..0] Huffman DC Selects the Huffman table for encoding the
                                                     DC coefficients.                                                          */
      __IOM uint32 HA         : 1;            /*!< [1..1] Huffman AC Selects the Huffman table for encoding the
                                                     AC coefficients.                                                          */
      __IOM uint32 QT         : 2;            /*!< [3..2] Quantization Table Selects quantization table associated
                                                     with a color component.                                                   */
      __IOM uint32 NB         : 4;            /*!< [7..4] Number of Block Number of data units minus 1 that belong
                                                     to a particular color in the MCU.                                         */
      __IOM uint32 VSF        : 4;            /*!< [11..8] Vertical Sampling Factor Vertical sampling factor for
                                                     component i.                                                              */
      __IOM uint32 HSF        : 4;            /*!< [15..12] Horizontal Sampling Factor Horizontal sampling factor
                                                     for component i.                                                          */
            uint32            : 16;
    } bit;
  } JPEG_CONFRN1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000014) JPEG codec configuration register 4-7                      */
    
    struct {
      __IOM uint32 HD         : 1;            /*!< [0..0] Huffman DC Selects the Huffman table for encoding the
                                                     DC coefficients.                                                          */
      __IOM uint32 HA         : 1;            /*!< [1..1] Huffman AC Selects the Huffman table for encoding the
                                                     AC coefficients.                                                          */
      __IOM uint32 QT         : 2;            /*!< [3..2] Quantization Table Selects quantization table associated
                                                     with a color component.                                                   */
      __IOM uint32 NB         : 4;            /*!< [7..4] Number of Block Number of data units minus 1 that belong
                                                     to a particular color in the MCU.                                         */
      __IOM uint32 VSF        : 4;            /*!< [11..8] Vertical Sampling Factor Vertical sampling factor for
                                                     component i.                                                              */
      __IOM uint32 HSF        : 4;            /*!< [15..12] Horizontal Sampling Factor Horizontal sampling factor
                                                     for component i.                                                          */
            uint32            : 16;
    } bit;
  } JPEG_CONFRN2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000018) JPEG codec configuration register 4-7                      */
    
    struct {
      __IOM uint32 HD         : 1;            /*!< [0..0] Huffman DC Selects the Huffman table for encoding the
                                                     DC coefficients.                                                          */
      __IOM uint32 HA         : 1;            /*!< [1..1] Huffman AC Selects the Huffman table for encoding the
                                                     AC coefficients.                                                          */
      __IOM uint32 QT         : 2;            /*!< [3..2] Quantization Table Selects quantization table associated
                                                     with a color component.                                                   */
      __IOM uint32 NB         : 4;            /*!< [7..4] Number of Block Number of data units minus 1 that belong
                                                     to a particular color in the MCU.                                         */
      __IOM uint32 VSF        : 4;            /*!< [11..8] Vertical Sampling Factor Vertical sampling factor for
                                                     component i.                                                              */
      __IOM uint32 HSF        : 4;            /*!< [15..12] Horizontal Sampling Factor Horizontal sampling factor
                                                     for component i.                                                          */
            uint32            : 16;
    } bit;
  } JPEG_CONFRN3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000001C) JPEG codec configuration register 4-7                      */
    
    struct {
      __IOM uint32 HD         : 1;            /*!< [0..0] Huffman DC Selects the Huffman table for encoding the
                                                     DC coefficients.                                                          */
      __IOM uint32 HA         : 1;            /*!< [1..1] Huffman AC Selects the Huffman table for encoding the
                                                     AC coefficients.                                                          */
      __IOM uint32 QT         : 2;            /*!< [3..2] Quantization Table Selects quantization table associated
                                                     with a color component.                                                   */
      __IOM uint32 NB         : 4;            /*!< [7..4] Number of Block Number of data units minus 1 that belong
                                                     to a particular color in the MCU.                                         */
      __IOM uint32 VSF        : 4;            /*!< [11..8] Vertical Sampling Factor Vertical sampling factor for
                                                     component i.                                                              */
      __IOM uint32 HSF        : 4;            /*!< [15..12] Horizontal Sampling Factor Horizontal sampling factor
                                                     for component i.                                                          */
            uint32            : 16;
    } bit;
  } JPEG_CONFRN4;
  __IM  uint32  RESERVED[4];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000030) JPEG control register                                      */
    
    struct {
      __IOM uint32 JCEN       : 1;            /*!< [0..0] JPEG Core Enable Enable the JPEG codec Core.                       */
      __IOM uint32 IFTIE      : 1;            /*!< [1..1] Input FIFO Threshold Interrupt Enable This bit enables
                                                     the interrupt generation when input FIFO reach the threshold.             */
      __IOM uint32 IFNFIE     : 1;            /*!< [2..2] Input FIFO Not Full Interrupt Enable This bit enables
                                                     the interrupt generation when input FIFO is not empty.                    */
      __IOM uint32 OFTIE      : 1;            /*!< [3..3] Output FIFO Threshold Interrupt Enable This bit enables
                                                     the interrupt generation when output FIFO reach the threshold.            */
      __IOM uint32 OFNEIE     : 1;            /*!< [4..4] Output FIFO Not Empty Interrupt Enable This bit enables
                                                     the interrupt generation when output FIFO is not empty.                   */
      __IOM uint32 EOCIE      : 1;            /*!< [5..5] End of Conversion Interrupt Enable This bit enables the
                                                     interrupt generation on the end of conversion.                            */
      __IOM uint32 HPDIE      : 1;            /*!< [6..6] Header Parsing Done Interrupt Enable This bit enables
                                                     the interrupt generation on the Header Parsing Operation.                 */
            uint32            : 4;
      __IOM uint32 IDMAEN     : 1;            /*!< [11..11] Input DMA Enable Enable the DMA request generation
                                                     for the input FIFO.                                                       */
      __IOM uint32 ODMAEN     : 1;            /*!< [12..12] Output DMA Enable Enable the DMA request generation
                                                     for the output FIFO.                                                      */
      __IOM uint32 IFF        : 1;            /*!< [13..13] Input FIFO Flush This bit flush the input FIFO. This
                                                     bit is always read as 0.                                                  */
      __IOM uint32 OFF        : 1;            /*!< [14..14] Output FIFO Flush This bit flush the output FIFO. This
                                                     bit is always read as 0.                                                  */
            uint32            : 17;
    } bit;
  } JPEG_CR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000034) JPEG status register                                       */
    
    struct {
            uint32            : 1;
      __IM  uint32 IFTF       : 1;            /*!< [1..1] Input FIFO Threshold Flag This bit is set when the input
                                                     FIFO is not full and is bellow its threshold.                             */
      __IM  uint32 IFNFF      : 1;            /*!< [2..2] Input FIFO Not Full Flag This bit is set when the input
                                                     FIFO is not full (a data can be written).                                 */
      __IM  uint32 OFTF       : 1;            /*!< [3..3] Output FIFO Threshold Flag This bit is set when the output
                                                     FIFO is not empty and has reach its threshold.                            */
      __IM  uint32 OFNEF      : 1;            /*!< [4..4] Output FIFO Not Empty Flag This bit is set when the output
                                                     FIFO is not empty (a data is available).                                  */
      __IM  uint32 EOCF       : 1;            /*!< [5..5] End of Conversion Flag This bit is set when the JPEG
                                                     codec core has finished the encoding or the decoding process
                                                     and than last data has been sent to the output FIFO.                      */
      __IM  uint32 HPDF       : 1;            /*!< [6..6] Header Parsing Done Flag This bit is set in decode mode
                                                     when the JPEG codec has finished the parsing of the headers
                                                     and the internal registers have been updated.                             */
      __IM  uint32 COF        : 1;            /*!< [7..7] Codec Operation Flag This bit is set when when a JPEG
                                                     codec operation is on going (encoding or decoding).                       */
            uint32            : 24;
    } bit;
  } JPEG_SR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000038) JPEG clear flag register                                   */
    
    struct {
            uint32            : 5;
      __IOM uint32 CEOCF      : 1;            /*!< [5..5] Clear End of Conversion Flag Writing 1 clears the End
                                                     of Conversion Flag of the JPEG Status Register.                           */
      __IOM uint32 CHPDF      : 1;            /*!< [6..6] Clear Header Parsing Done Flag Writing 1 clears the Header
                                                     Parsing Done Flag of the JPEG Status Register.                            */
            uint32            : 25;
    } bit;
  } JPEG_CFR;
  __IM  uint32  RESERVED1;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000040) JPEG data input register                                   */
    
    struct {
      __OM  uint32 DATAIN     : 32;           /*!< [31..0] Data Input FIFO Input FIFO data register.                         */
    } bit;
  } JPEG_DIR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000044) JPEG data output register                                  */
    
    struct {
      __IM  uint32 DATAOUT    : 32;           /*!< [31..0] Data Output FIFO Output FIFO data register.                       */
    } bit;
  } JPEG_DOR;
} JPEG_Type;                                    /*!< Size = 72 (0x48)                                                          */



/* =========================================================================================================================== */
/* ================                                           MDMA                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief MDMA (MDMA)
  */

typedef struct {                                /*!< (@ 0x52000000) MDMA Structure                                             */
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000000) MDMA Global Interrupt/Status Register                      */
    
    struct {
      __IM  uint32 GIF0       : 1;            /*!< [0..0] Channel x global interrupt flag (x=...) This bit is set
                                                     and reset by hardware. It is a logical OR of all the Channel
                                                     x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which
                                                     are enabled in the interrupt mask register (CTCIEx, BTIEx,
                                                     BRTIEx, TEIEx)                                                            */
      __IM  uint32 GIF1       : 1;            /*!< [1..1] Channel x global interrupt flag (x=...) This bit is set
                                                     and reset by hardware. It is a logical OR of all the Channel
                                                     x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which
                                                     are enabled in the interrupt mask register (CTCIEx, BTIEx,
                                                     BRTIEx, TEIEx)                                                            */
      __IM  uint32 GIF2       : 1;            /*!< [2..2] Channel x global interrupt flag (x=...) This bit is set
                                                     and reset by hardware. It is a logical OR of all the Channel
                                                     x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which
                                                     are enabled in the interrupt mask register (CTCIEx, BTIEx,
                                                     BRTIEx, TEIEx)                                                            */
      __IM  uint32 GIF3       : 1;            /*!< [3..3] Channel x global interrupt flag (x=...) This bit is set
                                                     and reset by hardware. It is a logical OR of all the Channel
                                                     x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which
                                                     are enabled in the interrupt mask register (CTCIEx, BTIEx,
                                                     BRTIEx, TEIEx)                                                            */
      __IM  uint32 GIF4       : 1;            /*!< [4..4] Channel x global interrupt flag (x=...) This bit is set
                                                     and reset by hardware. It is a logical OR of all the Channel
                                                     x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which
                                                     are enabled in the interrupt mask register (CTCIEx, BTIEx,
                                                     BRTIEx, TEIEx)                                                            */
      __IM  uint32 GIF5       : 1;            /*!< [5..5] Channel x global interrupt flag (x=...) This bit is set
                                                     and reset by hardware. It is a logical OR of all the Channel
                                                     x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which
                                                     are enabled in the interrupt mask register (CTCIEx, BTIEx,
                                                     BRTIEx, TEIEx)                                                            */
      __IM  uint32 GIF6       : 1;            /*!< [6..6] Channel x global interrupt flag (x=...) This bit is set
                                                     and reset by hardware. It is a logical OR of all the Channel
                                                     x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which
                                                     are enabled in the interrupt mask register (CTCIEx, BTIEx,
                                                     BRTIEx, TEIEx)                                                            */
      __IM  uint32 GIF7       : 1;            /*!< [7..7] Channel x global interrupt flag (x=...) This bit is set
                                                     and reset by hardware. It is a logical OR of all the Channel
                                                     x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which
                                                     are enabled in the interrupt mask register (CTCIEx, BTIEx,
                                                     BRTIEx, TEIEx)                                                            */
      __IM  uint32 GIF8       : 1;            /*!< [8..8] Channel x global interrupt flag (x=...) This bit is set
                                                     and reset by hardware. It is a logical OR of all the Channel
                                                     x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which
                                                     are enabled in the interrupt mask register (CTCIEx, BTIEx,
                                                     BRTIEx, TEIEx)                                                            */
      __IM  uint32 GIF9       : 1;            /*!< [9..9] Channel x global interrupt flag (x=...) This bit is set
                                                     and reset by hardware. It is a logical OR of all the Channel
                                                     x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which
                                                     are enabled in the interrupt mask register (CTCIEx, BTIEx,
                                                     BRTIEx, TEIEx)                                                            */
      __IM  uint32 GIF10      : 1;            /*!< [10..10] Channel x global interrupt flag (x=...) This bit is
                                                     set and reset by hardware. It is a logical OR of all the
                                                     Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx)
                                                     which are enabled in the interrupt mask register (CTCIEx,
                                                     BTIEx, BRTIEx, TEIEx)                                                     */
      __IM  uint32 GIF11      : 1;            /*!< [11..11] Channel x global interrupt flag (x=...) This bit is
                                                     set and reset by hardware. It is a logical OR of all the
                                                     Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx)
                                                     which are enabled in the interrupt mask register (CTCIEx,
                                                     BTIEx, BRTIEx, TEIEx)                                                     */
      __IM  uint32 GIF12      : 1;            /*!< [12..12] Channel x global interrupt flag (x=...) This bit is
                                                     set and reset by hardware. It is a logical OR of all the
                                                     Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx)
                                                     which are enabled in the interrupt mask register (CTCIEx,
                                                     BTIEx, BRTIEx, TEIEx)                                                     */
      __IM  uint32 GIF13      : 1;            /*!< [13..13] Channel x global interrupt flag (x=...) This bit is
                                                     set and reset by hardware. It is a logical OR of all the
                                                     Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx)
                                                     which are enabled in the interrupt mask register (CTCIEx,
                                                     BTIEx, BRTIEx, TEIEx)                                                     */
      __IM  uint32 GIF14      : 1;            /*!< [14..14] Channel x global interrupt flag (x=...) This bit is
                                                     set and reset by hardware. It is a logical OR of all the
                                                     Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx)
                                                     which are enabled in the interrupt mask register (CTCIEx,
                                                     BTIEx, BRTIEx, TEIEx)                                                     */
      __IM  uint32 GIF15      : 1;            /*!< [15..15] Channel x global interrupt flag (x=...) This bit is
                                                     set and reset by hardware. It is a logical OR of all the
                                                     Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx)
                                                     which are enabled in the interrupt mask register (CTCIEx,
                                                     BTIEx, BRTIEx, TEIEx)                                                     */
            uint32            : 16;
    } bit;
  } MDMA_GISR0;
  __IM  uint32  RESERVED[15];
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000040) MDMA channel x interrupt/status register                   */
    
    struct {
      __IM  uint32 TEIF0      : 1;            /*!< [0..0] Channel x transfer error interrupt flag This bit is set
                                                     by hardware. It is cleared by software writing 1 to the
                                                     corresponding bit in the DMA_IFCRy register.                              */
      __IM  uint32 CTCIF0     : 1;            /*!< [1..1] Channel x Channel Transfer Complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register. CTC
                                                     is set when the last block was transferred and the channel
                                                     has been automatically disabled. CTC is also set when the
                                                     channel is suspended, as a result of writing EN bit to
                                                     0.                                                                        */
      __IM  uint32 BRTIF0     : 1;            /*!< [2..2] Channel x block repeat transfer complete interrupt flag
                                                     This bit is set by hardware. It is cleared by software
                                                     writing 1 to the corresponding bit in the DMA_IFCRy register.             */
      __IM  uint32 BTIF0      : 1;            /*!< [3..3] Channel x block transfer complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register.                     */
      __IM  uint32 TCIF0      : 1;            /*!< [4..4] channel x buffer transfer complete                                 */
            uint32            : 11;
      __IM  uint32 CRQA0      : 1;            /*!< [16..16] channel x request active flag                                    */
            uint32            : 15;
    } bit;
  } MDMA_C0ISR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000044) MDMA channel x interrupt flag clear register               */
    
    struct {
      __OM  uint32 CTEIF0     : 1;            /*!< [0..0] Channel x clear transfer error interrupt flag Writing
                                                     a 1 into this bit clears TEIFx in the MDMA_ISRy register                  */
      __OM  uint32 CCTCIF0    : 1;            /*!< [1..1] Clear Channel transfer complete interrupt flag for channel
                                                     x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CBRTIF0    : 1;            /*!< [2..2] Channel x clear block repeat transfer complete interrupt
                                                     flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CBTIF0     : 1;            /*!< [3..3] Channel x Clear block transfer complete interrupt flag
                                                     Writing a 1 into this bit clears BTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CLTCIF0    : 1;            /*!< [4..4] CLear buffer Transfer Complete Interrupt Flag for channel
                                                     x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy
                                                     register                                                                  */
            uint32            : 27;
    } bit;
  } MDMA_C0IFCR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000048) MDMA Channel x error status register                       */
    
    struct {
      __IM  uint32 TEA        : 7;            /*!< [6..0] Transfer Error Address These bits are set and cleared
                                                     by HW, in case of an MDMA data transfer error. It is used
                                                     in conjunction with TED. This field indicates the 7 LSBits
                                                     of the address which generated a transfer/access error.
                                                     It may be used by SW to retrieve the failing address, by
                                                     adding this value (truncated to the buffer transfer length
                                                     size) to the current SAR/DAR value. Note: The SAR/DAR                     */
      __IM  uint32 TED        : 1;            /*!< [7..7] Transfer Error Direction These bit is set and cleared
                                                     by HW, in case of an MDMA data transfer error.                            */
      __IM  uint32 TELD       : 1;            /*!< [8..8] Transfer Error Link Data These bit is set by HW, in case
                                                     of a transfer error while reading the block link data structure.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32 TEMD       : 1;            /*!< [9..9] Transfer Error Mask Data These bit is set by HW, in case
                                                     of a transfer error while writing the Mask Data. It is
                                                     cleared by software writing 1 to the CTEIFx bit in the
                                                     DMA_IFCRy register.                                                       */
      __IM  uint32 ASE        : 1;            /*!< [10..10] Address/Size Error These bit is set by HW, when the
                                                     programmed address is not aligned with the data size. TED
                                                     will indicate whether the problem is on the source or destination.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32 BSE        : 1;            /*!< [11..11] Block Size Error These bit is set by HW, when the block
                                                     size is not an integer multiple of the data size either
                                                     for source or destination. TED will indicate whether the
                                                     problem is on the source or destination. It is cleared
                                                     by software writing 1 to the CTEIFx bit in the DMA_IFCRy
                                                     register.                                                                 */
            uint32            : 20;
    } bit;
  } MDMA_C0ESR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000004C) This register is used to control the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32 EN         : 1;            /*!< [0..0] channel enable                                                     */
      __IOM uint32 TEIE       : 1;            /*!< [1..1] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 CTCIE      : 1;            /*!< [2..2] Channel Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32 BRTIE      : 1;            /*!< [3..3] Block Repeat transfer interrupt enable This bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32 BTIE       : 1;            /*!< [4..4] Block Transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 TCIE       : 1;            /*!< [5..5] buffer Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32 PL         : 2;            /*!< [7..6] Priority level These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0.                                                                     */
            uint32            : 4;
      __IOM uint32 BEX        : 1;            /*!< [12..12] byte Endianness exchange                                         */
      __IOM uint32 HEX        : 1;            /*!< [13..13] Half word Endianes exchange                                      */
      __IOM uint32 WEX        : 1;            /*!< [14..14] Word Endianness exchange                                         */
            uint32            : 1;
      __OM  uint32 SWRQ       : 1;            /*!< [16..16] SW ReQuest Writing a 1 into this bit sets the CRQAx
                                                     in MDMA_ISRy register, activating the request on Channel
                                                     x Note: Either the whole CxCR register or the 8-bit/16-bit
                                                     register @ Address offset: 0x4E + 0x40 chn may be used
                                                     for SWRQ activation. In case of a SW request, acknowledge
                                                     is not generated (neither HW signal, nor CxMAR write access).             */
            uint32            : 15;
    } bit;
  } MDMA_C0CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000050) This register is used to configure the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32 SINC       : 2;            /*!< [1..0] Source increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When source is AHB (SBUS=1), SINC
                                                     = 00 is forbidden. In Linked List Mode, at the end of a
                                                     block (single or last block in repeated block transfer
                                                     mode), this register will be loaded from memory (from address
                                                     given by current LAR[31:0] + 0x00).                                       */
      __IOM uint32 DINC       : 2;            /*!< [3..2] Destination increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When destination is AHB (DBUS=1),
                                                     DINC = 00 is forbidden.                                                   */
      __IOM uint32 SSIZE      : 2;            /*!< [5..4] Source data size These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0 Note: If a value of 11 is programmed for the TCM access/AHB
                                                     port, a transfer error will occur (TEIF bit set) If SINCOS
                                                     &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable.
                                                     Note: SSIZE = 11 (double-word) is forbidden when source
                                                     is TCM/AHB bus (SBUS=1).                                                  */
      __IOM uint32 DSIZE      : 2;            /*!< [7..6] Destination data size These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0. Note: If a value of 11 is programmed for
                                                     the TCM access/AHB port, a transfer error will occur (TEIF
                                                     bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the
                                                     result will be unpredictable. Note: DSIZE = 11 (double-word)
                                                     is forbidden when destination is TCM/AHB bus (                            */
      __IOM uint32 SINCOS     : 2;            /*!< [9..8] source increment offset size                                       */
      __IOM uint32 DINCOS     : 2;            /*!< [11..10] Destination increment offset                                     */
      __IOM uint32 SBURST     : 3;            /*!< [14..12] source burst transfer configuration                              */
      __IOM uint32 DBURST     : 3;            /*!< [17..15] Destination burst transfer configuration                         */
      __IOM uint32 TLEN       : 7;            /*!< [24..18] buffer transfer lengh                                            */
      __IOM uint32 PKE        : 1;            /*!< [25..25] PacK Enable These bit is set and cleared by software.
                                                     If the Source Size is smaller than the destination, it
                                                     will be padded according to the PAM value. If the Source
                                                     data size is larger than the destination one, it will be
                                                     truncated. The alignment will be done according to the
                                                     PAM[0] value. This bit is protected and can be written
                                                     only if EN is 0                                                           */
      __IOM uint32 PAM        : 2;            /*!< [27..26] Padding/Alignement Mode These bits are set and cleared
                                                     by software. Case 1: Source data size smaller than destination
                                                     data size - 3 options are valid. Case 2: Source data size
                                                     larger than destination data size. The remainder part is
                                                     discarded. When PKE = 1 or DSIZE=SSIZE, these bits are
                                                     ignored. These bits are protected and can be written only
                                                     if EN is 0                                                                */
      __IOM uint32 TRGM       : 2;            /*!< [29..28] Trigger Mode These bits are set and cleared by software.
                                                     Note: If TRGM is 11 for the current block, all the values
                                                     loaded at the end of the current block through the linked
                                                     list mechanism must keep the same value (TRGM=11) and the
                                                     same SWRM value, otherwise the result is undefined. These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32 SWRM       : 1;            /*!< [30..30] SW Request Mode This bit is set and cleared by software.
                                                     If a HW or SW request is currently active, the bit change
                                                     will be delayed until the current transfer is completed.
                                                     If the CxMAR contains a valid address, the CxMDR value
                                                     will also be written @ CxMAR address. This bit is protected
                                                     and can be written only if EN is 0.                                       */
      __IOM uint32 BWM        : 1;            /*!< [31..31] Bufferable Write Mode This bit is set and cleared by
                                                     software. This bit is protected and can be written only
                                                     if EN is 0. Note: All MDMA destination accesses are non-cacheable.        */
    } bit;
  } MDMA_C0TCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000054) MDMA Channel x block number of data register               */
    
    struct {
      __IOM uint32 BNDT       : 17;           /*!< [16..0] block number of data to transfer                                  */
            uint32            : 1;
      __IOM uint32 BRSUM      : 1;            /*!< [18..18] Block Repeat Source address Update Mode These bits
                                                     are protected and can be written only if EN is 0.                         */
      __IOM uint32 BRDUM      : 1;            /*!< [19..19] Block Repeat Destination address Update Mode These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32 BRC        : 12;           /*!< [31..20] Block Repeat Count This field contains the number of
                                                     repetitions of the current block (0 to 4095). When the
                                                     channel is enabled, this register is read-only, indicating
                                                     the remaining number of blocks, excluding the current one.
                                                     This register decrements after each complete block transfer.
                                                     Once the last block transfer has completed, this register
                                                     can either stay at zero or be reloaded automatically from                 */
    } bit;
  } MDMA_C0BNDTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000058) MDMA channel x source address register                     */
    
    struct {
      __IOM uint32 SAR        : 32;           /*!< [31..0] source adr base                                                   */
    } bit;
  } MDMA_C0SAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000005C) MDMA channel x destination address register                */
    
    struct {
      __IOM uint32 DAR        : 32;           /*!< [31..0] Destination adr base                                              */
    } bit;
  } MDMA_C0DAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000060) MDMA channel x Block Repeat address Update register        */
    
    struct {
      __IOM uint32 SUV        : 16;           /*!< [15..0] source adresse update value                                       */
      __IOM uint32 DUV        : 16;           /*!< [31..16] destination address update                                       */
    } bit;
  } MDMA_C0BRUR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000064) MDMA channel x Link Address register                       */
    
    struct {
      __IOM uint32 LAR        : 32;           /*!< [31..0] Link address register                                             */
    } bit;
  } MDMA_C0LAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000068) MDMA channel x Trigger and Bus selection Register          */
    
    struct {
      __IOM uint32 TSEL       : 6;            /*!< [5..0] Trigger selection                                                  */
            uint32            : 10;
      __IOM uint32 SBUS       : 1;            /*!< [16..16] Source BUS select This bit is protected and can be
                                                     written only if EN is 0.                                                  */
      __IOM uint32 DBUS       : 1;            /*!< [17..17] Destination BUS slect This bit is protected and can
                                                     be written only if EN is 0.                                               */
            uint32            : 14;
    } bit;
  } MDMA_C0TBR;
  __IM  uint32  RESERVED1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000070) MDMA channel x Mask address register                       */
    
    struct {
      __IOM uint32 MAR        : 32;           /*!< [31..0] Mask address                                                      */
    } bit;
  } MDMA_C0MAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000074) MDMA channel x Mask Data register                          */
    
    struct {
      __IOM uint32 MDR        : 32;           /*!< [31..0] Mask data                                                         */
    } bit;
  } MDMA_C0MDR;
  __IM  uint32  RESERVED2[2];
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000080) MDMA channel x interrupt/status register                   */
    
    struct {
      __IM  uint32 TEIF1      : 1;            /*!< [0..0] Channel x transfer error interrupt flag This bit is set
                                                     by hardware. It is cleared by software writing 1 to the
                                                     corresponding bit in the DMA_IFCRy register.                              */
      __IM  uint32 CTCIF1     : 1;            /*!< [1..1] Channel x Channel Transfer Complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register. CTC
                                                     is set when the last block was transferred and the channel
                                                     has been automatically disabled. CTC is also set when the
                                                     channel is suspended, as a result of writing EN bit to
                                                     0.                                                                        */
      __IM  uint32 BRTIF1     : 1;            /*!< [2..2] Channel x block repeat transfer complete interrupt flag
                                                     This bit is set by hardware. It is cleared by software
                                                     writing 1 to the corresponding bit in the DMA_IFCRy register.             */
      __IM  uint32 BTIF1      : 1;            /*!< [3..3] Channel x block transfer complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register.                     */
      __IM  uint32 TCIF1      : 1;            /*!< [4..4] channel x buffer transfer complete                                 */
            uint32            : 11;
      __IM  uint32 CRQA1      : 1;            /*!< [16..16] channel x request active flag                                    */
            uint32            : 15;
    } bit;
  } MDMA_C1ISR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000084) MDMA channel x interrupt flag clear register               */
    
    struct {
      __OM  uint32 CTEIF1     : 1;            /*!< [0..0] Channel x clear transfer error interrupt flag Writing
                                                     a 1 into this bit clears TEIFx in the MDMA_ISRy register                  */
      __OM  uint32 CCTCIF1    : 1;            /*!< [1..1] Clear Channel transfer complete interrupt flag for channel
                                                     x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CBRTIF1    : 1;            /*!< [2..2] Channel x clear block repeat transfer complete interrupt
                                                     flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CBTIF1     : 1;            /*!< [3..3] Channel x Clear block transfer complete interrupt flag
                                                     Writing a 1 into this bit clears BTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CLTCIF1    : 1;            /*!< [4..4] CLear buffer Transfer Complete Interrupt Flag for channel
                                                     x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy
                                                     register                                                                  */
            uint32            : 27;
    } bit;
  } MDMA_C1IFCR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000088) MDMA Channel x error status register                       */
    
    struct {
      __IM  uint32 TEA        : 7;            /*!< [6..0] Transfer Error Address These bits are set and cleared
                                                     by HW, in case of an MDMA data transfer error. It is used
                                                     in conjunction with TED. This field indicates the 7 LSBits
                                                     of the address which generated a transfer/access error.
                                                     It may be used by SW to retrieve the failing address, by
                                                     adding this value (truncated to the buffer transfer length
                                                     size) to the current SAR/DAR value. Note: The SAR/DAR                     */
      __IM  uint32 TED        : 1;            /*!< [7..7] Transfer Error Direction These bit is set and cleared
                                                     by HW, in case of an MDMA data transfer error.                            */
      __IM  uint32 TELD       : 1;            /*!< [8..8] Transfer Error Link Data These bit is set by HW, in case
                                                     of a transfer error while reading the block link data structure.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32 TEMD       : 1;            /*!< [9..9] Transfer Error Mask Data These bit is set by HW, in case
                                                     of a transfer error while writing the Mask Data. It is
                                                     cleared by software writing 1 to the CTEIFx bit in the
                                                     DMA_IFCRy register.                                                       */
      __IM  uint32 ASE        : 1;            /*!< [10..10] Address/Size Error These bit is set by HW, when the
                                                     programmed address is not aligned with the data size. TED
                                                     will indicate whether the problem is on the source or destination.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32 BSE        : 1;            /*!< [11..11] Block Size Error These bit is set by HW, when the block
                                                     size is not an integer multiple of the data size either
                                                     for source or destination. TED will indicate whether the
                                                     problem is on the source or destination. It is cleared
                                                     by software writing 1 to the CTEIFx bit in the DMA_IFCRy
                                                     register.                                                                 */
            uint32            : 20;
    } bit;
  } MDMA_C1ESR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000008C) This register is used to control the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32 EN         : 1;            /*!< [0..0] channel enable                                                     */
      __IOM uint32 TEIE       : 1;            /*!< [1..1] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 CTCIE      : 1;            /*!< [2..2] Channel Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32 BRTIE      : 1;            /*!< [3..3] Block Repeat transfer interrupt enable This bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32 BTIE       : 1;            /*!< [4..4] Block Transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 TCIE       : 1;            /*!< [5..5] buffer Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32 PL         : 2;            /*!< [7..6] Priority level These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0.                                                                     */
            uint32            : 4;
      __IOM uint32 BEX        : 1;            /*!< [12..12] byte Endianness exchange                                         */
      __IOM uint32 HEX        : 1;            /*!< [13..13] Half word Endianes exchange                                      */
      __IOM uint32 WEX        : 1;            /*!< [14..14] Word Endianness exchange                                         */
            uint32            : 1;
      __OM  uint32 SWRQ       : 1;            /*!< [16..16] SW ReQuest Writing a 1 into this bit sets the CRQAx
                                                     in MDMA_ISRy register, activating the request on Channel
                                                     x Note: Either the whole CxCR register or the 8-bit/16-bit
                                                     register @ Address offset: 0x4E + 0x40 chn may be used
                                                     for SWRQ activation. In case of a SW request, acknowledge
                                                     is not generated (neither HW signal, nor CxMAR write access).             */
            uint32            : 15;
    } bit;
  } MDMA_C1CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000090) This register is used to configure the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32 SINC       : 2;            /*!< [1..0] Source increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When source is AHB (SBUS=1), SINC
                                                     = 00 is forbidden. In Linked List Mode, at the end of a
                                                     block (single or last block in repeated block transfer
                                                     mode), this register will be loaded from memory (from address
                                                     given by current LAR[31:0] + 0x00).                                       */
      __IOM uint32 DINC       : 2;            /*!< [3..2] Destination increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When destination is AHB (DBUS=1),
                                                     DINC = 00 is forbidden.                                                   */
      __IOM uint32 SSIZE      : 2;            /*!< [5..4] Source data size These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0 Note: If a value of 11 is programmed for the TCM access/AHB
                                                     port, a transfer error will occur (TEIF bit set) If SINCOS
                                                     &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable.
                                                     Note: SSIZE = 11 (double-word) is forbidden when source
                                                     is TCM/AHB bus (SBUS=1).                                                  */
      __IOM uint32 DSIZE      : 2;            /*!< [7..6] Destination data size These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0. Note: If a value of 11 is programmed for
                                                     the TCM access/AHB port, a transfer error will occur (TEIF
                                                     bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the
                                                     result will be unpredictable. Note: DSIZE = 11 (double-word)
                                                     is forbidden when destination is TCM/AHB bus (                            */
      __IOM uint32 SINCOS     : 2;            /*!< [9..8] source increment offset size                                       */
      __IOM uint32 DINCOS     : 2;            /*!< [11..10] Destination increment offset                                     */
      __IOM uint32 SBURST     : 3;            /*!< [14..12] source burst transfer configuration                              */
      __IOM uint32 DBURST     : 3;            /*!< [17..15] Destination burst transfer configuration                         */
      __IOM uint32 TLEN       : 7;            /*!< [24..18] buffer transfer lengh                                            */
      __IOM uint32 PKE        : 1;            /*!< [25..25] PacK Enable These bit is set and cleared by software.
                                                     If the Source Size is smaller than the destination, it
                                                     will be padded according to the PAM value. If the Source
                                                     data size is larger than the destination one, it will be
                                                     truncated. The alignment will be done according to the
                                                     PAM[0] value. This bit is protected and can be written
                                                     only if EN is 0                                                           */
      __IOM uint32 PAM        : 2;            /*!< [27..26] Padding/Alignement Mode These bits are set and cleared
                                                     by software. Case 1: Source data size smaller than destination
                                                     data size - 3 options are valid. Case 2: Source data size
                                                     larger than destination data size. The remainder part is
                                                     discarded. When PKE = 1 or DSIZE=SSIZE, these bits are
                                                     ignored. These bits are protected and can be written only
                                                     if EN is 0                                                                */
      __IOM uint32 TRGM       : 2;            /*!< [29..28] Trigger Mode These bits are set and cleared by software.
                                                     Note: If TRGM is 11 for the current block, all the values
                                                     loaded at the end of the current block through the linked
                                                     list mechanism must keep the same value (TRGM=11) and the
                                                     same SWRM value, otherwise the result is undefined. These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32 SWRM       : 1;            /*!< [30..30] SW Request Mode This bit is set and cleared by software.
                                                     If a HW or SW request is currently active, the bit change
                                                     will be delayed until the current transfer is completed.
                                                     If the CxMAR contains a valid address, the CxMDR value
                                                     will also be written @ CxMAR address. This bit is protected
                                                     and can be written only if EN is 0.                                       */
      __IOM uint32 BWM        : 1;            /*!< [31..31] Bufferable Write Mode This bit is set and cleared by
                                                     software. This bit is protected and can be written only
                                                     if EN is 0. Note: All MDMA destination accesses are non-cacheable.        */
    } bit;
  } MDMA_C1TCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000094) MDMA Channel x block number of data register               */
    
    struct {
      __IOM uint32 BNDT       : 17;           /*!< [16..0] block number of data to transfer                                  */
            uint32            : 1;
      __IOM uint32 BRSUM      : 1;            /*!< [18..18] Block Repeat Source address Update Mode These bits
                                                     are protected and can be written only if EN is 0.                         */
      __IOM uint32 BRDUM      : 1;            /*!< [19..19] Block Repeat Destination address Update Mode These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32 BRC        : 12;           /*!< [31..20] Block Repeat Count This field contains the number of
                                                     repetitions of the current block (0 to 4095). When the
                                                     channel is enabled, this register is read-only, indicating
                                                     the remaining number of blocks, excluding the current one.
                                                     This register decrements after each complete block transfer.
                                                     Once the last block transfer has completed, this register
                                                     can either stay at zero or be reloaded automatically from                 */
    } bit;
  } MDMA_C1BNDTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000098) MDMA channel x source address register                     */
    
    struct {
      __IOM uint32 SAR        : 32;           /*!< [31..0] source adr base                                                   */
    } bit;
  } MDMA_C1SAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000009C) MDMA channel x destination address register                */
    
    struct {
      __IOM uint32 DAR        : 32;           /*!< [31..0] Destination adr base                                              */
    } bit;
  } MDMA_C1DAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000A0) MDMA channel x Block Repeat address Update register        */
    
    struct {
      __IOM uint32 SUV        : 16;           /*!< [15..0] source adresse update value                                       */
      __IOM uint32 DUV        : 16;           /*!< [31..16] destination address update                                       */
    } bit;
  } MDMA_C1BRUR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000A4) MDMA channel x Link Address register                       */
    
    struct {
      __IOM uint32 LAR        : 32;           /*!< [31..0] Link address register                                             */
    } bit;
  } MDMA_C1LAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000A8) MDMA channel x Trigger and Bus selection Register          */
    
    struct {
      __IOM uint32 TSEL       : 6;            /*!< [5..0] Trigger selection                                                  */
            uint32            : 10;
      __IOM uint32 SBUS       : 1;            /*!< [16..16] Source BUS select This bit is protected and can be
                                                     written only if EN is 0.                                                  */
      __IOM uint32 DBUS       : 1;            /*!< [17..17] Destination BUS slect This bit is protected and can
                                                     be written only if EN is 0.                                               */
            uint32            : 14;
    } bit;
  } MDMA_C1TBR;
  __IM  uint32  RESERVED3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000B0) MDMA channel x Mask address register                       */
    
    struct {
      __IOM uint32 MAR        : 32;           /*!< [31..0] Mask address                                                      */
    } bit;
  } MDMA_C1MAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000B4) MDMA channel x Mask Data register                          */
    
    struct {
      __IOM uint32 MDR        : 32;           /*!< [31..0] Mask data                                                         */
    } bit;
  } MDMA_C1MDR;
  __IM  uint32  RESERVED4[2];
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000000C0) MDMA channel x interrupt/status register                   */
    
    struct {
      __IM  uint32 TEIF2      : 1;            /*!< [0..0] Channel x transfer error interrupt flag This bit is set
                                                     by hardware. It is cleared by software writing 1 to the
                                                     corresponding bit in the DMA_IFCRy register.                              */
      __IM  uint32 CTCIF2     : 1;            /*!< [1..1] Channel x Channel Transfer Complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register. CTC
                                                     is set when the last block was transferred and the channel
                                                     has been automatically disabled. CTC is also set when the
                                                     channel is suspended, as a result of writing EN bit to
                                                     0.                                                                        */
      __IM  uint32 BRTIF2     : 1;            /*!< [2..2] Channel x block repeat transfer complete interrupt flag
                                                     This bit is set by hardware. It is cleared by software
                                                     writing 1 to the corresponding bit in the DMA_IFCRy register.             */
      __IM  uint32 BTIF2      : 1;            /*!< [3..3] Channel x block transfer complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register.                     */
      __IM  uint32 TCIF2      : 1;            /*!< [4..4] channel x buffer transfer complete                                 */
            uint32            : 11;
      __IM  uint32 CRQA2      : 1;            /*!< [16..16] channel x request active flag                                    */
            uint32            : 15;
    } bit;
  } MDMA_C2ISR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x000000C4) MDMA channel x interrupt flag clear register               */
    
    struct {
      __OM  uint32 CTEIF2     : 1;            /*!< [0..0] Channel x clear transfer error interrupt flag Writing
                                                     a 1 into this bit clears TEIFx in the MDMA_ISRy register                  */
      __OM  uint32 CCTCIF2    : 1;            /*!< [1..1] Clear Channel transfer complete interrupt flag for channel
                                                     x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CBRTIF2    : 1;            /*!< [2..2] Channel x clear block repeat transfer complete interrupt
                                                     flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CBTIF2     : 1;            /*!< [3..3] Channel x Clear block transfer complete interrupt flag
                                                     Writing a 1 into this bit clears BTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CLTCIF2    : 1;            /*!< [4..4] CLear buffer Transfer Complete Interrupt Flag for channel
                                                     x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy
                                                     register                                                                  */
            uint32            : 27;
    } bit;
  } MDMA_C2IFCR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000000C8) MDMA Channel x error status register                       */
    
    struct {
      __IM  uint32 TEA        : 7;            /*!< [6..0] Transfer Error Address These bits are set and cleared
                                                     by HW, in case of an MDMA data transfer error. It is used
                                                     in conjunction with TED. This field indicates the 7 LSBits
                                                     of the address which generated a transfer/access error.
                                                     It may be used by SW to retrieve the failing address, by
                                                     adding this value (truncated to the buffer transfer length
                                                     size) to the current SAR/DAR value. Note: The SAR/DAR                     */
      __IM  uint32 TED        : 1;            /*!< [7..7] Transfer Error Direction These bit is set and cleared
                                                     by HW, in case of an MDMA data transfer error.                            */
      __IM  uint32 TELD       : 1;            /*!< [8..8] Transfer Error Link Data These bit is set by HW, in case
                                                     of a transfer error while reading the block link data structure.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32 TEMD       : 1;            /*!< [9..9] Transfer Error Mask Data These bit is set by HW, in case
                                                     of a transfer error while writing the Mask Data. It is
                                                     cleared by software writing 1 to the CTEIFx bit in the
                                                     DMA_IFCRy register.                                                       */
      __IM  uint32 ASE        : 1;            /*!< [10..10] Address/Size Error These bit is set by HW, when the
                                                     programmed address is not aligned with the data size. TED
                                                     will indicate whether the problem is on the source or destination.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32 BSE        : 1;            /*!< [11..11] Block Size Error These bit is set by HW, when the block
                                                     size is not an integer multiple of the data size either
                                                     for source or destination. TED will indicate whether the
                                                     problem is on the source or destination. It is cleared
                                                     by software writing 1 to the CTEIFx bit in the DMA_IFCRy
                                                     register.                                                                 */
            uint32            : 20;
    } bit;
  } MDMA_C2ESR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000CC) This register is used to control the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32 EN         : 1;            /*!< [0..0] channel enable                                                     */
      __IOM uint32 TEIE       : 1;            /*!< [1..1] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 CTCIE      : 1;            /*!< [2..2] Channel Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32 BRTIE      : 1;            /*!< [3..3] Block Repeat transfer interrupt enable This bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32 BTIE       : 1;            /*!< [4..4] Block Transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 TCIE       : 1;            /*!< [5..5] buffer Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32 PL         : 2;            /*!< [7..6] Priority level These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0.                                                                     */
            uint32            : 4;
      __IOM uint32 BEX        : 1;            /*!< [12..12] byte Endianness exchange                                         */
      __IOM uint32 HEX        : 1;            /*!< [13..13] Half word Endianes exchange                                      */
      __IOM uint32 WEX        : 1;            /*!< [14..14] Word Endianness exchange                                         */
            uint32            : 1;
      __OM  uint32 SWRQ       : 1;            /*!< [16..16] SW ReQuest Writing a 1 into this bit sets the CRQAx
                                                     in MDMA_ISRy register, activating the request on Channel
                                                     x Note: Either the whole CxCR register or the 8-bit/16-bit
                                                     register @ Address offset: 0x4E + 0x40 chn may be used
                                                     for SWRQ activation. In case of a SW request, acknowledge
                                                     is not generated (neither HW signal, nor CxMAR write access).             */
            uint32            : 15;
    } bit;
  } MDMA_C2CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000D0) This register is used to configure the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32 SINC       : 2;            /*!< [1..0] Source increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When source is AHB (SBUS=1), SINC
                                                     = 00 is forbidden. In Linked List Mode, at the end of a
                                                     block (single or last block in repeated block transfer
                                                     mode), this register will be loaded from memory (from address
                                                     given by current LAR[31:0] + 0x00).                                       */
      __IOM uint32 DINC       : 2;            /*!< [3..2] Destination increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When destination is AHB (DBUS=1),
                                                     DINC = 00 is forbidden.                                                   */
      __IOM uint32 SSIZE      : 2;            /*!< [5..4] Source data size These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0 Note: If a value of 11 is programmed for the TCM access/AHB
                                                     port, a transfer error will occur (TEIF bit set) If SINCOS
                                                     &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable.
                                                     Note: SSIZE = 11 (double-word) is forbidden when source
                                                     is TCM/AHB bus (SBUS=1).                                                  */
      __IOM uint32 DSIZE      : 2;            /*!< [7..6] Destination data size These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0. Note: If a value of 11 is programmed for
                                                     the TCM access/AHB port, a transfer error will occur (TEIF
                                                     bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the
                                                     result will be unpredictable. Note: DSIZE = 11 (double-word)
                                                     is forbidden when destination is TCM/AHB bus (                            */
      __IOM uint32 SINCOS     : 2;            /*!< [9..8] source increment offset size                                       */
      __IOM uint32 DINCOS     : 2;            /*!< [11..10] Destination increment offset                                     */
      __IOM uint32 SBURST     : 3;            /*!< [14..12] source burst transfer configuration                              */
      __IOM uint32 DBURST     : 3;            /*!< [17..15] Destination burst transfer configuration                         */
      __IOM uint32 TLEN       : 7;            /*!< [24..18] buffer transfer lengh                                            */
      __IOM uint32 PKE        : 1;            /*!< [25..25] PacK Enable These bit is set and cleared by software.
                                                     If the Source Size is smaller than the destination, it
                                                     will be padded according to the PAM value. If the Source
                                                     data size is larger than the destination one, it will be
                                                     truncated. The alignment will be done according to the
                                                     PAM[0] value. This bit is protected and can be written
                                                     only if EN is 0                                                           */
      __IOM uint32 PAM        : 2;            /*!< [27..26] Padding/Alignement Mode These bits are set and cleared
                                                     by software. Case 1: Source data size smaller than destination
                                                     data size - 3 options are valid. Case 2: Source data size
                                                     larger than destination data size. The remainder part is
                                                     discarded. When PKE = 1 or DSIZE=SSIZE, these bits are
                                                     ignored. These bits are protected and can be written only
                                                     if EN is 0                                                                */
      __IOM uint32 TRGM       : 2;            /*!< [29..28] Trigger Mode These bits are set and cleared by software.
                                                     Note: If TRGM is 11 for the current block, all the values
                                                     loaded at the end of the current block through the linked
                                                     list mechanism must keep the same value (TRGM=11) and the
                                                     same SWRM value, otherwise the result is undefined. These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32 SWRM       : 1;            /*!< [30..30] SW Request Mode This bit is set and cleared by software.
                                                     If a HW or SW request is currently active, the bit change
                                                     will be delayed until the current transfer is completed.
                                                     If the CxMAR contains a valid address, the CxMDR value
                                                     will also be written @ CxMAR address. This bit is protected
                                                     and can be written only if EN is 0.                                       */
      __IOM uint32 BWM        : 1;            /*!< [31..31] Bufferable Write Mode This bit is set and cleared by
                                                     software. This bit is protected and can be written only
                                                     if EN is 0. Note: All MDMA destination accesses are non-cacheable.        */
    } bit;
  } MDMA_C2TCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000D4) MDMA Channel x block number of data register               */
    
    struct {
      __IOM uint32 BNDT       : 17;           /*!< [16..0] block number of data to transfer                                  */
            uint32            : 1;
      __IOM uint32 BRSUM      : 1;            /*!< [18..18] Block Repeat Source address Update Mode These bits
                                                     are protected and can be written only if EN is 0.                         */
      __IOM uint32 BRDUM      : 1;            /*!< [19..19] Block Repeat Destination address Update Mode These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32 BRC        : 12;           /*!< [31..20] Block Repeat Count This field contains the number of
                                                     repetitions of the current block (0 to 4095). When the
                                                     channel is enabled, this register is read-only, indicating
                                                     the remaining number of blocks, excluding the current one.
                                                     This register decrements after each complete block transfer.
                                                     Once the last block transfer has completed, this register
                                                     can either stay at zero or be reloaded automatically from                 */
    } bit;
  } MDMA_C2BNDTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000D8) MDMA channel x source address register                     */
    
    struct {
      __IOM uint32 SAR        : 32;           /*!< [31..0] source adr base                                                   */
    } bit;
  } MDMA_C2SAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000DC) MDMA channel x destination address register                */
    
    struct {
      __IOM uint32 DAR        : 32;           /*!< [31..0] Destination adr base                                              */
    } bit;
  } MDMA_C2DAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000E0) MDMA channel x Block Repeat address Update register        */
    
    struct {
      __IOM uint32 SUV        : 16;           /*!< [15..0] source adresse update value                                       */
      __IOM uint32 DUV        : 16;           /*!< [31..16] destination address update                                       */
    } bit;
  } MDMA_C2BRUR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000E4) MDMA channel x Link Address register                       */
    
    struct {
      __IOM uint32 LAR        : 32;           /*!< [31..0] Link address register                                             */
    } bit;
  } MDMA_C2LAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000E8) MDMA channel x Trigger and Bus selection Register          */
    
    struct {
      __IOM uint32 TSEL       : 6;            /*!< [5..0] Trigger selection                                                  */
            uint32            : 10;
      __IOM uint32 SBUS       : 1;            /*!< [16..16] Source BUS select This bit is protected and can be
                                                     written only if EN is 0.                                                  */
      __IOM uint32 DBUS       : 1;            /*!< [17..17] Destination BUS slect This bit is protected and can
                                                     be written only if EN is 0.                                               */
            uint32            : 14;
    } bit;
  } MDMA_C2TBR;
  __IM  uint32  RESERVED5;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000F0) MDMA channel x Mask address register                       */
    
    struct {
      __IOM uint32 MAR        : 32;           /*!< [31..0] Mask address                                                      */
    } bit;
  } MDMA_C2MAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000F4) MDMA channel x Mask Data register                          */
    
    struct {
      __IOM uint32 MDR        : 32;           /*!< [31..0] Mask data                                                         */
    } bit;
  } MDMA_C2MDR;
  __IM  uint32  RESERVED6[2];
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000100) MDMA channel x interrupt/status register                   */
    
    struct {
      __IM  uint32 TEIF3      : 1;            /*!< [0..0] Channel x transfer error interrupt flag This bit is set
                                                     by hardware. It is cleared by software writing 1 to the
                                                     corresponding bit in the DMA_IFCRy register.                              */
      __IM  uint32 CTCIF3     : 1;            /*!< [1..1] Channel x Channel Transfer Complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register. CTC
                                                     is set when the last block was transferred and the channel
                                                     has been automatically disabled. CTC is also set when the
                                                     channel is suspended, as a result of writing EN bit to
                                                     0.                                                                        */
      __IM  uint32 BRTIF3     : 1;            /*!< [2..2] Channel x block repeat transfer complete interrupt flag
                                                     This bit is set by hardware. It is cleared by software
                                                     writing 1 to the corresponding bit in the DMA_IFCRy register.             */
      __IM  uint32 BTIF3      : 1;            /*!< [3..3] Channel x block transfer complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register.                     */
      __IM  uint32 TCIF3      : 1;            /*!< [4..4] channel x buffer transfer complete                                 */
            uint32            : 11;
      __IM  uint32 CRQA3      : 1;            /*!< [16..16] channel x request active flag                                    */
            uint32            : 15;
    } bit;
  } MDMA_C3ISR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000104) MDMA channel x interrupt flag clear register               */
    
    struct {
      __OM  uint32 CTEIF3     : 1;            /*!< [0..0] Channel x clear transfer error interrupt flag Writing
                                                     a 1 into this bit clears TEIFx in the MDMA_ISRy register                  */
      __OM  uint32 CCTCIF3    : 1;            /*!< [1..1] Clear Channel transfer complete interrupt flag for channel
                                                     x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CBRTIF3    : 1;            /*!< [2..2] Channel x clear block repeat transfer complete interrupt
                                                     flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CBTIF3     : 1;            /*!< [3..3] Channel x Clear block transfer complete interrupt flag
                                                     Writing a 1 into this bit clears BTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CLTCIF3    : 1;            /*!< [4..4] CLear buffer Transfer Complete Interrupt Flag for channel
                                                     x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy
                                                     register                                                                  */
            uint32            : 27;
    } bit;
  } MDMA_C3IFCR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000108) MDMA Channel x error status register                       */
    
    struct {
      __IM  uint32 TEA        : 7;            /*!< [6..0] Transfer Error Address These bits are set and cleared
                                                     by HW, in case of an MDMA data transfer error. It is used
                                                     in conjunction with TED. This field indicates the 7 LSBits
                                                     of the address which generated a transfer/access error.
                                                     It may be used by SW to retrieve the failing address, by
                                                     adding this value (truncated to the buffer transfer length
                                                     size) to the current SAR/DAR value. Note: The SAR/DAR                     */
      __IM  uint32 TED        : 1;            /*!< [7..7] Transfer Error Direction These bit is set and cleared
                                                     by HW, in case of an MDMA data transfer error.                            */
      __IM  uint32 TELD       : 1;            /*!< [8..8] Transfer Error Link Data These bit is set by HW, in case
                                                     of a transfer error while reading the block link data structure.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32 TEMD       : 1;            /*!< [9..9] Transfer Error Mask Data These bit is set by HW, in case
                                                     of a transfer error while writing the Mask Data. It is
                                                     cleared by software writing 1 to the CTEIFx bit in the
                                                     DMA_IFCRy register.                                                       */
      __IM  uint32 ASE        : 1;            /*!< [10..10] Address/Size Error These bit is set by HW, when the
                                                     programmed address is not aligned with the data size. TED
                                                     will indicate whether the problem is on the source or destination.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32 BSE        : 1;            /*!< [11..11] Block Size Error These bit is set by HW, when the block
                                                     size is not an integer multiple of the data size either
                                                     for source or destination. TED will indicate whether the
                                                     problem is on the source or destination. It is cleared
                                                     by software writing 1 to the CTEIFx bit in the DMA_IFCRy
                                                     register.                                                                 */
            uint32            : 20;
    } bit;
  } MDMA_C3ESR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000010C) This register is used to control the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32 EN         : 1;            /*!< [0..0] channel enable                                                     */
      __IOM uint32 TEIE       : 1;            /*!< [1..1] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 CTCIE      : 1;            /*!< [2..2] Channel Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32 BRTIE      : 1;            /*!< [3..3] Block Repeat transfer interrupt enable This bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32 BTIE       : 1;            /*!< [4..4] Block Transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 TCIE       : 1;            /*!< [5..5] buffer Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32 PL         : 2;            /*!< [7..6] Priority level These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0.                                                                     */
            uint32            : 4;
      __IOM uint32 BEX        : 1;            /*!< [12..12] byte Endianness exchange                                         */
      __IOM uint32 HEX        : 1;            /*!< [13..13] Half word Endianes exchange                                      */
      __IOM uint32 WEX        : 1;            /*!< [14..14] Word Endianness exchange                                         */
            uint32            : 1;
      __OM  uint32 SWRQ       : 1;            /*!< [16..16] SW ReQuest Writing a 1 into this bit sets the CRQAx
                                                     in MDMA_ISRy register, activating the request on Channel
                                                     x Note: Either the whole CxCR register or the 8-bit/16-bit
                                                     register @ Address offset: 0x4E + 0x40 chn may be used
                                                     for SWRQ activation. In case of a SW request, acknowledge
                                                     is not generated (neither HW signal, nor CxMAR write access).             */
            uint32            : 15;
    } bit;
  } MDMA_C3CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000110) This register is used to configure the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32 SINC       : 2;            /*!< [1..0] Source increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When source is AHB (SBUS=1), SINC
                                                     = 00 is forbidden. In Linked List Mode, at the end of a
                                                     block (single or last block in repeated block transfer
                                                     mode), this register will be loaded from memory (from address
                                                     given by current LAR[31:0] + 0x00).                                       */
      __IOM uint32 DINC       : 2;            /*!< [3..2] Destination increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When destination is AHB (DBUS=1),
                                                     DINC = 00 is forbidden.                                                   */
      __IOM uint32 SSIZE      : 2;            /*!< [5..4] Source data size These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0 Note: If a value of 11 is programmed for the TCM access/AHB
                                                     port, a transfer error will occur (TEIF bit set) If SINCOS
                                                     &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable.
                                                     Note: SSIZE = 11 (double-word) is forbidden when source
                                                     is TCM/AHB bus (SBUS=1).                                                  */
      __IOM uint32 DSIZE      : 2;            /*!< [7..6] Destination data size These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0. Note: If a value of 11 is programmed for
                                                     the TCM access/AHB port, a transfer error will occur (TEIF
                                                     bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the
                                                     result will be unpredictable. Note: DSIZE = 11 (double-word)
                                                     is forbidden when destination is TCM/AHB bus (                            */
      __IOM uint32 SINCOS     : 2;            /*!< [9..8] source increment offset size                                       */
      __IOM uint32 DINCOS     : 2;            /*!< [11..10] Destination increment offset                                     */
      __IOM uint32 SBURST     : 3;            /*!< [14..12] source burst transfer configuration                              */
      __IOM uint32 DBURST     : 3;            /*!< [17..15] Destination burst transfer configuration                         */
      __IOM uint32 TLEN       : 7;            /*!< [24..18] buffer transfer lengh                                            */
      __IOM uint32 PKE        : 1;            /*!< [25..25] PacK Enable These bit is set and cleared by software.
                                                     If the Source Size is smaller than the destination, it
                                                     will be padded according to the PAM value. If the Source
                                                     data size is larger than the destination one, it will be
                                                     truncated. The alignment will be done according to the
                                                     PAM[0] value. This bit is protected and can be written
                                                     only if EN is 0                                                           */
      __IOM uint32 PAM        : 2;            /*!< [27..26] Padding/Alignement Mode These bits are set and cleared
                                                     by software. Case 1: Source data size smaller than destination
                                                     data size - 3 options are valid. Case 2: Source data size
                                                     larger than destination data size. The remainder part is
                                                     discarded. When PKE = 1 or DSIZE=SSIZE, these bits are
                                                     ignored. These bits are protected and can be written only
                                                     if EN is 0                                                                */
      __IOM uint32 TRGM       : 2;            /*!< [29..28] Trigger Mode These bits are set and cleared by software.
                                                     Note: If TRGM is 11 for the current block, all the values
                                                     loaded at the end of the current block through the linked
                                                     list mechanism must keep the same value (TRGM=11) and the
                                                     same SWRM value, otherwise the result is undefined. These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32 SWRM       : 1;            /*!< [30..30] SW Request Mode This bit is set and cleared by software.
                                                     If a HW or SW request is currently active, the bit change
                                                     will be delayed until the current transfer is completed.
                                                     If the CxMAR contains a valid address, the CxMDR value
                                                     will also be written @ CxMAR address. This bit is protected
                                                     and can be written only if EN is 0.                                       */
      __IOM uint32 BWM        : 1;            /*!< [31..31] Bufferable Write Mode This bit is set and cleared by
                                                     software. This bit is protected and can be written only
                                                     if EN is 0. Note: All MDMA destination accesses are non-cacheable.        */
    } bit;
  } MDMA_C3TCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000114) MDMA Channel x block number of data register               */
    
    struct {
      __IOM uint32 BNDT       : 17;           /*!< [16..0] block number of data to transfer                                  */
            uint32            : 1;
      __IOM uint32 BRSUM      : 1;            /*!< [18..18] Block Repeat Source address Update Mode These bits
                                                     are protected and can be written only if EN is 0.                         */
      __IOM uint32 BRDUM      : 1;            /*!< [19..19] Block Repeat Destination address Update Mode These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32 BRC        : 12;           /*!< [31..20] Block Repeat Count This field contains the number of
                                                     repetitions of the current block (0 to 4095). When the
                                                     channel is enabled, this register is read-only, indicating
                                                     the remaining number of blocks, excluding the current one.
                                                     This register decrements after each complete block transfer.
                                                     Once the last block transfer has completed, this register
                                                     can either stay at zero or be reloaded automatically from                 */
    } bit;
  } MDMA_C3BNDTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000118) MDMA channel x source address register                     */
    
    struct {
      __IOM uint32 SAR        : 32;           /*!< [31..0] source adr base                                                   */
    } bit;
  } MDMA_C3SAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000011C) MDMA channel x destination address register                */
    
    struct {
      __IOM uint32 DAR        : 32;           /*!< [31..0] Destination adr base                                              */
    } bit;
  } MDMA_C3DAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000120) MDMA channel x Block Repeat address Update register        */
    
    struct {
      __IOM uint32 SUV        : 16;           /*!< [15..0] source adresse update value                                       */
      __IOM uint32 DUV        : 16;           /*!< [31..16] destination address update                                       */
    } bit;
  } MDMA_C3BRUR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000124) MDMA channel x Link Address register                       */
    
    struct {
      __IOM uint32 LAR        : 32;           /*!< [31..0] Link address register                                             */
    } bit;
  } MDMA_C3LAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000128) MDMA channel x Trigger and Bus selection Register          */
    
    struct {
      __IOM uint32 TSEL       : 6;            /*!< [5..0] Trigger selection                                                  */
            uint32            : 10;
      __IOM uint32 SBUS       : 1;            /*!< [16..16] Source BUS select This bit is protected and can be
                                                     written only if EN is 0.                                                  */
      __IOM uint32 DBUS       : 1;            /*!< [17..17] Destination BUS slect This bit is protected and can
                                                     be written only if EN is 0.                                               */
            uint32            : 14;
    } bit;
  } MDMA_C3TBR;
  __IM  uint32  RESERVED7;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000130) MDMA channel x Mask address register                       */
    
    struct {
      __IOM uint32 MAR        : 32;           /*!< [31..0] Mask address                                                      */
    } bit;
  } MDMA_C3MAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000134) MDMA channel x Mask Data register                          */
    
    struct {
      __IOM uint32 MDR        : 32;           /*!< [31..0] Mask data                                                         */
    } bit;
  } MDMA_C3MDR;
  __IM  uint32  RESERVED8[2];
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000140) MDMA channel x interrupt/status register                   */
    
    struct {
      __IM  uint32 TEIF4      : 1;            /*!< [0..0] Channel x transfer error interrupt flag This bit is set
                                                     by hardware. It is cleared by software writing 1 to the
                                                     corresponding bit in the DMA_IFCRy register.                              */
      __IM  uint32 CTCIF4     : 1;            /*!< [1..1] Channel x Channel Transfer Complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register. CTC
                                                     is set when the last block was transferred and the channel
                                                     has been automatically disabled. CTC is also set when the
                                                     channel is suspended, as a result of writing EN bit to
                                                     0.                                                                        */
      __IM  uint32 BRTIF4     : 1;            /*!< [2..2] Channel x block repeat transfer complete interrupt flag
                                                     This bit is set by hardware. It is cleared by software
                                                     writing 1 to the corresponding bit in the DMA_IFCRy register.             */
      __IM  uint32 BTIF4      : 1;            /*!< [3..3] Channel x block transfer complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register.                     */
      __IM  uint32 TCIF4      : 1;            /*!< [4..4] channel x buffer transfer complete                                 */
            uint32            : 11;
      __IM  uint32 CRQA4      : 1;            /*!< [16..16] channel x request active flag                                    */
            uint32            : 15;
    } bit;
  } MDMA_C4ISR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000144) MDMA channel x interrupt flag clear register               */
    
    struct {
      __OM  uint32 CTEIF4     : 1;            /*!< [0..0] Channel x clear transfer error interrupt flag Writing
                                                     a 1 into this bit clears TEIFx in the MDMA_ISRy register                  */
      __OM  uint32 CCTCIF4    : 1;            /*!< [1..1] Clear Channel transfer complete interrupt flag for channel
                                                     x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CBRTIF4    : 1;            /*!< [2..2] Channel x clear block repeat transfer complete interrupt
                                                     flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CBTIF4     : 1;            /*!< [3..3] Channel x Clear block transfer complete interrupt flag
                                                     Writing a 1 into this bit clears BTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CLTCIF4    : 1;            /*!< [4..4] CLear buffer Transfer Complete Interrupt Flag for channel
                                                     x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy
                                                     register                                                                  */
            uint32            : 27;
    } bit;
  } MDMA_C4IFCR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000148) MDMA Channel x error status register                       */
    
    struct {
      __IM  uint32 TEA        : 7;            /*!< [6..0] Transfer Error Address These bits are set and cleared
                                                     by HW, in case of an MDMA data transfer error. It is used
                                                     in conjunction with TED. This field indicates the 7 LSBits
                                                     of the address which generated a transfer/access error.
                                                     It may be used by SW to retrieve the failing address, by
                                                     adding this value (truncated to the buffer transfer length
                                                     size) to the current SAR/DAR value. Note: The SAR/DAR                     */
      __IM  uint32 TED        : 1;            /*!< [7..7] Transfer Error Direction These bit is set and cleared
                                                     by HW, in case of an MDMA data transfer error.                            */
      __IM  uint32 TELD       : 1;            /*!< [8..8] Transfer Error Link Data These bit is set by HW, in case
                                                     of a transfer error while reading the block link data structure.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32 TEMD       : 1;            /*!< [9..9] Transfer Error Mask Data These bit is set by HW, in case
                                                     of a transfer error while writing the Mask Data. It is
                                                     cleared by software writing 1 to the CTEIFx bit in the
                                                     DMA_IFCRy register.                                                       */
      __IM  uint32 ASE        : 1;            /*!< [10..10] Address/Size Error These bit is set by HW, when the
                                                     programmed address is not aligned with the data size. TED
                                                     will indicate whether the problem is on the source or destination.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32 BSE        : 1;            /*!< [11..11] Block Size Error These bit is set by HW, when the block
                                                     size is not an integer multiple of the data size either
                                                     for source or destination. TED will indicate whether the
                                                     problem is on the source or destination. It is cleared
                                                     by software writing 1 to the CTEIFx bit in the DMA_IFCRy
                                                     register.                                                                 */
            uint32            : 20;
    } bit;
  } MDMA_C4ESR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000014C) This register is used to control the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32 EN         : 1;            /*!< [0..0] channel enable                                                     */
      __IOM uint32 TEIE       : 1;            /*!< [1..1] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 CTCIE      : 1;            /*!< [2..2] Channel Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32 BRTIE      : 1;            /*!< [3..3] Block Repeat transfer interrupt enable This bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32 BTIE       : 1;            /*!< [4..4] Block Transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 TCIE       : 1;            /*!< [5..5] buffer Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32 PL         : 2;            /*!< [7..6] Priority level These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0.                                                                     */
            uint32            : 4;
      __IOM uint32 BEX        : 1;            /*!< [12..12] byte Endianness exchange                                         */
      __IOM uint32 HEX        : 1;            /*!< [13..13] Half word Endianes exchange                                      */
      __IOM uint32 WEX        : 1;            /*!< [14..14] Word Endianness exchange                                         */
            uint32            : 1;
      __OM  uint32 SWRQ       : 1;            /*!< [16..16] SW ReQuest Writing a 1 into this bit sets the CRQAx
                                                     in MDMA_ISRy register, activating the request on Channel
                                                     x Note: Either the whole CxCR register or the 8-bit/16-bit
                                                     register @ Address offset: 0x4E + 0x40 chn may be used
                                                     for SWRQ activation. In case of a SW request, acknowledge
                                                     is not generated (neither HW signal, nor CxMAR write access).             */
            uint32            : 15;
    } bit;
  } MDMA_C4CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000150) This register is used to configure the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32 SINC       : 2;            /*!< [1..0] Source increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When source is AHB (SBUS=1), SINC
                                                     = 00 is forbidden. In Linked List Mode, at the end of a
                                                     block (single or last block in repeated block transfer
                                                     mode), this register will be loaded from memory (from address
                                                     given by current LAR[31:0] + 0x00).                                       */
      __IOM uint32 DINC       : 2;            /*!< [3..2] Destination increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When destination is AHB (DBUS=1),
                                                     DINC = 00 is forbidden.                                                   */
      __IOM uint32 SSIZE      : 2;            /*!< [5..4] Source data size These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0 Note: If a value of 11 is programmed for the TCM access/AHB
                                                     port, a transfer error will occur (TEIF bit set) If SINCOS
                                                     &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable.
                                                     Note: SSIZE = 11 (double-word) is forbidden when source
                                                     is TCM/AHB bus (SBUS=1).                                                  */
      __IOM uint32 DSIZE      : 2;            /*!< [7..6] Destination data size These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0. Note: If a value of 11 is programmed for
                                                     the TCM access/AHB port, a transfer error will occur (TEIF
                                                     bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the
                                                     result will be unpredictable. Note: DSIZE = 11 (double-word)
                                                     is forbidden when destination is TCM/AHB bus (                            */
      __IOM uint32 SINCOS     : 2;            /*!< [9..8] source increment offset size                                       */
      __IOM uint32 DINCOS     : 2;            /*!< [11..10] Destination increment offset                                     */
      __IOM uint32 SBURST     : 3;            /*!< [14..12] source burst transfer configuration                              */
      __IOM uint32 DBURST     : 3;            /*!< [17..15] Destination burst transfer configuration                         */
      __IOM uint32 TLEN       : 7;            /*!< [24..18] buffer transfer lengh                                            */
      __IOM uint32 PKE        : 1;            /*!< [25..25] PacK Enable These bit is set and cleared by software.
                                                     If the Source Size is smaller than the destination, it
                                                     will be padded according to the PAM value. If the Source
                                                     data size is larger than the destination one, it will be
                                                     truncated. The alignment will be done according to the
                                                     PAM[0] value. This bit is protected and can be written
                                                     only if EN is 0                                                           */
      __IOM uint32 PAM        : 2;            /*!< [27..26] Padding/Alignement Mode These bits are set and cleared
                                                     by software. Case 1: Source data size smaller than destination
                                                     data size - 3 options are valid. Case 2: Source data size
                                                     larger than destination data size. The remainder part is
                                                     discarded. When PKE = 1 or DSIZE=SSIZE, these bits are
                                                     ignored. These bits are protected and can be written only
                                                     if EN is 0                                                                */
      __IOM uint32 TRGM       : 2;            /*!< [29..28] Trigger Mode These bits are set and cleared by software.
                                                     Note: If TRGM is 11 for the current block, all the values
                                                     loaded at the end of the current block through the linked
                                                     list mechanism must keep the same value (TRGM=11) and the
                                                     same SWRM value, otherwise the result is undefined. These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32 SWRM       : 1;            /*!< [30..30] SW Request Mode This bit is set and cleared by software.
                                                     If a HW or SW request is currently active, the bit change
                                                     will be delayed until the current transfer is completed.
                                                     If the CxMAR contains a valid address, the CxMDR value
                                                     will also be written @ CxMAR address. This bit is protected
                                                     and can be written only if EN is 0.                                       */
      __IOM uint32 BWM        : 1;            /*!< [31..31] Bufferable Write Mode This bit is set and cleared by
                                                     software. This bit is protected and can be written only
                                                     if EN is 0. Note: All MDMA destination accesses are non-cacheable.        */
    } bit;
  } MDMA_C4TCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000154) MDMA Channel x block number of data register               */
    
    struct {
      __IOM uint32 BNDT       : 17;           /*!< [16..0] block number of data to transfer                                  */
            uint32            : 1;
      __IOM uint32 BRSUM      : 1;            /*!< [18..18] Block Repeat Source address Update Mode These bits
                                                     are protected and can be written only if EN is 0.                         */
      __IOM uint32 BRDUM      : 1;            /*!< [19..19] Block Repeat Destination address Update Mode These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32 BRC        : 12;           /*!< [31..20] Block Repeat Count This field contains the number of
                                                     repetitions of the current block (0 to 4095). When the
                                                     channel is enabled, this register is read-only, indicating
                                                     the remaining number of blocks, excluding the current one.
                                                     This register decrements after each complete block transfer.
                                                     Once the last block transfer has completed, this register
                                                     can either stay at zero or be reloaded automatically from                 */
    } bit;
  } MDMA_C4BNDTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000158) MDMA channel x source address register                     */
    
    struct {
      __IOM uint32 SAR        : 32;           /*!< [31..0] source adr base                                                   */
    } bit;
  } MDMA_C4SAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000015C) MDMA channel x destination address register                */
    
    struct {
      __IOM uint32 DAR        : 32;           /*!< [31..0] Destination adr base                                              */
    } bit;
  } MDMA_C4DAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000160) MDMA channel x Block Repeat address Update register        */
    
    struct {
      __IOM uint32 SUV        : 16;           /*!< [15..0] source adresse update value                                       */
      __IOM uint32 DUV        : 16;           /*!< [31..16] destination address update                                       */
    } bit;
  } MDMA_C4BRUR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000164) MDMA channel x Link Address register                       */
    
    struct {
      __IOM uint32 LAR        : 32;           /*!< [31..0] Link address register                                             */
    } bit;
  } MDMA_C4LAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000168) MDMA channel x Trigger and Bus selection Register          */
    
    struct {
      __IOM uint32 TSEL       : 6;            /*!< [5..0] Trigger selection                                                  */
            uint32            : 10;
      __IOM uint32 SBUS       : 1;            /*!< [16..16] Source BUS select This bit is protected and can be
                                                     written only if EN is 0.                                                  */
      __IOM uint32 DBUS       : 1;            /*!< [17..17] Destination BUS slect This bit is protected and can
                                                     be written only if EN is 0.                                               */
            uint32            : 14;
    } bit;
  } MDMA_C4TBR;
  __IM  uint32  RESERVED9;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000170) MDMA channel x Mask address register                       */
    
    struct {
      __IOM uint32 MAR        : 32;           /*!< [31..0] Mask address                                                      */
    } bit;
  } MDMA_C4MAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000174) MDMA channel x Mask Data register                          */
    
    struct {
      __IOM uint32 MDR        : 32;           /*!< [31..0] Mask data                                                         */
    } bit;
  } MDMA_C4MDR;
  __IM  uint32  RESERVED10[2];
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000180) MDMA channel x interrupt/status register                   */
    
    struct {
      __IM  uint32 TEIF5      : 1;            /*!< [0..0] Channel x transfer error interrupt flag This bit is set
                                                     by hardware. It is cleared by software writing 1 to the
                                                     corresponding bit in the DMA_IFCRy register.                              */
      __IM  uint32 CTCIF5     : 1;            /*!< [1..1] Channel x Channel Transfer Complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register. CTC
                                                     is set when the last block was transferred and the channel
                                                     has been automatically disabled. CTC is also set when the
                                                     channel is suspended, as a result of writing EN bit to
                                                     0.                                                                        */
      __IM  uint32 BRTIF5     : 1;            /*!< [2..2] Channel x block repeat transfer complete interrupt flag
                                                     This bit is set by hardware. It is cleared by software
                                                     writing 1 to the corresponding bit in the DMA_IFCRy register.             */
      __IM  uint32 BTIF5      : 1;            /*!< [3..3] Channel x block transfer complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register.                     */
      __IM  uint32 TCIF5      : 1;            /*!< [4..4] channel x buffer transfer complete                                 */
            uint32            : 11;
      __IM  uint32 CRQA5      : 1;            /*!< [16..16] channel x request active flag                                    */
            uint32            : 15;
    } bit;
  } MDMA_C5ISR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000184) MDMA channel x interrupt flag clear register               */
    
    struct {
      __OM  uint32 CTEIF5     : 1;            /*!< [0..0] Channel x clear transfer error interrupt flag Writing
                                                     a 1 into this bit clears TEIFx in the MDMA_ISRy register                  */
      __OM  uint32 CCTCIF5    : 1;            /*!< [1..1] Clear Channel transfer complete interrupt flag for channel
                                                     x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CBRTIF5    : 1;            /*!< [2..2] Channel x clear block repeat transfer complete interrupt
                                                     flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CBTIF5     : 1;            /*!< [3..3] Channel x Clear block transfer complete interrupt flag
                                                     Writing a 1 into this bit clears BTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CLTCIF5    : 1;            /*!< [4..4] CLear buffer Transfer Complete Interrupt Flag for channel
                                                     x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy
                                                     register                                                                  */
            uint32            : 27;
    } bit;
  } MDMA_C5IFCR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000188) MDMA Channel x error status register                       */
    
    struct {
      __IM  uint32 TEA        : 7;            /*!< [6..0] Transfer Error Address These bits are set and cleared
                                                     by HW, in case of an MDMA data transfer error. It is used
                                                     in conjunction with TED. This field indicates the 7 LSBits
                                                     of the address which generated a transfer/access error.
                                                     It may be used by SW to retrieve the failing address, by
                                                     adding this value (truncated to the buffer transfer length
                                                     size) to the current SAR/DAR value. Note: The SAR/DAR                     */
      __IM  uint32 TED        : 1;            /*!< [7..7] Transfer Error Direction These bit is set and cleared
                                                     by HW, in case of an MDMA data transfer error.                            */
      __IM  uint32 TELD       : 1;            /*!< [8..8] Transfer Error Link Data These bit is set by HW, in case
                                                     of a transfer error while reading the block link data structure.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32 TEMD       : 1;            /*!< [9..9] Transfer Error Mask Data These bit is set by HW, in case
                                                     of a transfer error while writing the Mask Data. It is
                                                     cleared by software writing 1 to the CTEIFx bit in the
                                                     DMA_IFCRy register.                                                       */
      __IM  uint32 ASE        : 1;            /*!< [10..10] Address/Size Error These bit is set by HW, when the
                                                     programmed address is not aligned with the data size. TED
                                                     will indicate whether the problem is on the source or destination.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32 BSE        : 1;            /*!< [11..11] Block Size Error These bit is set by HW, when the block
                                                     size is not an integer multiple of the data size either
                                                     for source or destination. TED will indicate whether the
                                                     problem is on the source or destination. It is cleared
                                                     by software writing 1 to the CTEIFx bit in the DMA_IFCRy
                                                     register.                                                                 */
            uint32            : 20;
    } bit;
  } MDMA_C5ESR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000018C) This register is used to control the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32 EN         : 1;            /*!< [0..0] channel enable                                                     */
      __IOM uint32 TEIE       : 1;            /*!< [1..1] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 CTCIE      : 1;            /*!< [2..2] Channel Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32 BRTIE      : 1;            /*!< [3..3] Block Repeat transfer interrupt enable This bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32 BTIE       : 1;            /*!< [4..4] Block Transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 TCIE       : 1;            /*!< [5..5] buffer Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32 PL         : 2;            /*!< [7..6] Priority level These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0.                                                                     */
            uint32            : 4;
      __IOM uint32 BEX        : 1;            /*!< [12..12] byte Endianness exchange                                         */
      __IOM uint32 HEX        : 1;            /*!< [13..13] Half word Endianes exchange                                      */
      __IOM uint32 WEX        : 1;            /*!< [14..14] Word Endianness exchange                                         */
            uint32            : 1;
      __OM  uint32 SWRQ       : 1;            /*!< [16..16] SW ReQuest Writing a 1 into this bit sets the CRQAx
                                                     in MDMA_ISRy register, activating the request on Channel
                                                     x Note: Either the whole CxCR register or the 8-bit/16-bit
                                                     register @ Address offset: 0x4E + 0x40 chn may be used
                                                     for SWRQ activation. In case of a SW request, acknowledge
                                                     is not generated (neither HW signal, nor CxMAR write access).             */
            uint32            : 15;
    } bit;
  } MDMA_C5CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000190) This register is used to configure the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32 SINC       : 2;            /*!< [1..0] Source increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When source is AHB (SBUS=1), SINC
                                                     = 00 is forbidden. In Linked List Mode, at the end of a
                                                     block (single or last block in repeated block transfer
                                                     mode), this register will be loaded from memory (from address
                                                     given by current LAR[31:0] + 0x00).                                       */
      __IOM uint32 DINC       : 2;            /*!< [3..2] Destination increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When destination is AHB (DBUS=1),
                                                     DINC = 00 is forbidden.                                                   */
      __IOM uint32 SSIZE      : 2;            /*!< [5..4] Source data size These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0 Note: If a value of 11 is programmed for the TCM access/AHB
                                                     port, a transfer error will occur (TEIF bit set) If SINCOS
                                                     &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable.
                                                     Note: SSIZE = 11 (double-word) is forbidden when source
                                                     is TCM/AHB bus (SBUS=1).                                                  */
      __IOM uint32 DSIZE      : 2;            /*!< [7..6] Destination data size These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0. Note: If a value of 11 is programmed for
                                                     the TCM access/AHB port, a transfer error will occur (TEIF
                                                     bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the
                                                     result will be unpredictable. Note: DSIZE = 11 (double-word)
                                                     is forbidden when destination is TCM/AHB bus (                            */
      __IOM uint32 SINCOS     : 2;            /*!< [9..8] source increment offset size                                       */
      __IOM uint32 DINCOS     : 2;            /*!< [11..10] Destination increment offset                                     */
      __IOM uint32 SBURST     : 3;            /*!< [14..12] source burst transfer configuration                              */
      __IOM uint32 DBURST     : 3;            /*!< [17..15] Destination burst transfer configuration                         */
      __IOM uint32 TLEN       : 7;            /*!< [24..18] buffer transfer lengh                                            */
      __IOM uint32 PKE        : 1;            /*!< [25..25] PacK Enable These bit is set and cleared by software.
                                                     If the Source Size is smaller than the destination, it
                                                     will be padded according to the PAM value. If the Source
                                                     data size is larger than the destination one, it will be
                                                     truncated. The alignment will be done according to the
                                                     PAM[0] value. This bit is protected and can be written
                                                     only if EN is 0                                                           */
      __IOM uint32 PAM        : 2;            /*!< [27..26] Padding/Alignement Mode These bits are set and cleared
                                                     by software. Case 1: Source data size smaller than destination
                                                     data size - 3 options are valid. Case 2: Source data size
                                                     larger than destination data size. The remainder part is
                                                     discarded. When PKE = 1 or DSIZE=SSIZE, these bits are
                                                     ignored. These bits are protected and can be written only
                                                     if EN is 0                                                                */
      __IOM uint32 TRGM       : 2;            /*!< [29..28] Trigger Mode These bits are set and cleared by software.
                                                     Note: If TRGM is 11 for the current block, all the values
                                                     loaded at the end of the current block through the linked
                                                     list mechanism must keep the same value (TRGM=11) and the
                                                     same SWRM value, otherwise the result is undefined. These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32 SWRM       : 1;            /*!< [30..30] SW Request Mode This bit is set and cleared by software.
                                                     If a HW or SW request is currently active, the bit change
                                                     will be delayed until the current transfer is completed.
                                                     If the CxMAR contains a valid address, the CxMDR value
                                                     will also be written @ CxMAR address. This bit is protected
                                                     and can be written only if EN is 0.                                       */
      __IOM uint32 BWM        : 1;            /*!< [31..31] Bufferable Write Mode This bit is set and cleared by
                                                     software. This bit is protected and can be written only
                                                     if EN is 0. Note: All MDMA destination accesses are non-cacheable.        */
    } bit;
  } MDMA_C5TCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000194) MDMA Channel x block number of data register               */
    
    struct {
      __IOM uint32 BNDT       : 17;           /*!< [16..0] block number of data to transfer                                  */
            uint32            : 1;
      __IOM uint32 BRSUM      : 1;            /*!< [18..18] Block Repeat Source address Update Mode These bits
                                                     are protected and can be written only if EN is 0.                         */
      __IOM uint32 BRDUM      : 1;            /*!< [19..19] Block Repeat Destination address Update Mode These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32 BRC        : 12;           /*!< [31..20] Block Repeat Count This field contains the number of
                                                     repetitions of the current block (0 to 4095). When the
                                                     channel is enabled, this register is read-only, indicating
                                                     the remaining number of blocks, excluding the current one.
                                                     This register decrements after each complete block transfer.
                                                     Once the last block transfer has completed, this register
                                                     can either stay at zero or be reloaded automatically from                 */
    } bit;
  } MDMA_C5BNDTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000198) MDMA channel x source address register                     */
    
    struct {
      __IOM uint32 SAR        : 32;           /*!< [31..0] source adr base                                                   */
    } bit;
  } MDMA_C5SAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000019C) MDMA channel x destination address register                */
    
    struct {
      __IOM uint32 DAR        : 32;           /*!< [31..0] Destination adr base                                              */
    } bit;
  } MDMA_C5DAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001A0) MDMA channel x Block Repeat address Update register        */
    
    struct {
      __IOM uint32 SUV        : 16;           /*!< [15..0] source adresse update value                                       */
      __IOM uint32 DUV        : 16;           /*!< [31..16] destination address update                                       */
    } bit;
  } MDMA_C5BRUR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001A4) MDMA channel x Link Address register                       */
    
    struct {
      __IOM uint32 LAR        : 32;           /*!< [31..0] Link address register                                             */
    } bit;
  } MDMA_C5LAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001A8) MDMA channel x Trigger and Bus selection Register          */
    
    struct {
      __IOM uint32 TSEL       : 6;            /*!< [5..0] Trigger selection                                                  */
            uint32            : 10;
      __IOM uint32 SBUS       : 1;            /*!< [16..16] Source BUS select This bit is protected and can be
                                                     written only if EN is 0.                                                  */
      __IOM uint32 DBUS       : 1;            /*!< [17..17] Destination BUS slect This bit is protected and can
                                                     be written only if EN is 0.                                               */
            uint32            : 14;
    } bit;
  } MDMA_C5TBR;
  __IM  uint32  RESERVED11;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001B0) MDMA channel x Mask address register                       */
    
    struct {
      __IOM uint32 MAR        : 32;           /*!< [31..0] Mask address                                                      */
    } bit;
  } MDMA_C5MAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001B4) MDMA channel x Mask Data register                          */
    
    struct {
      __IOM uint32 MDR        : 32;           /*!< [31..0] Mask data                                                         */
    } bit;
  } MDMA_C5MDR;
  __IM  uint32  RESERVED12[2];
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000001C0) MDMA channel x interrupt/status register                   */
    
    struct {
      __IM  uint32 TEIF6      : 1;            /*!< [0..0] Channel x transfer error interrupt flag This bit is set
                                                     by hardware. It is cleared by software writing 1 to the
                                                     corresponding bit in the DMA_IFCRy register.                              */
      __IM  uint32 CTCIF6     : 1;            /*!< [1..1] Channel x Channel Transfer Complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register. CTC
                                                     is set when the last block was transferred and the channel
                                                     has been automatically disabled. CTC is also set when the
                                                     channel is suspended, as a result of writing EN bit to
                                                     0.                                                                        */
      __IM  uint32 BRTIF6     : 1;            /*!< [2..2] Channel x block repeat transfer complete interrupt flag
                                                     This bit is set by hardware. It is cleared by software
                                                     writing 1 to the corresponding bit in the DMA_IFCRy register.             */
      __IM  uint32 BTIF6      : 1;            /*!< [3..3] Channel x block transfer complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register.                     */
      __IM  uint32 TCIF6      : 1;            /*!< [4..4] channel x buffer transfer complete                                 */
            uint32            : 11;
      __IM  uint32 CRQA6      : 1;            /*!< [16..16] channel x request active flag                                    */
            uint32            : 15;
    } bit;
  } MDMA_C6ISR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x000001C4) MDMA channel x interrupt flag clear register               */
    
    struct {
      __OM  uint32 CTEIF6     : 1;            /*!< [0..0] Channel x clear transfer error interrupt flag Writing
                                                     a 1 into this bit clears TEIFx in the MDMA_ISRy register                  */
      __OM  uint32 CCTCIF6    : 1;            /*!< [1..1] Clear Channel transfer complete interrupt flag for channel
                                                     x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CBRTIF6    : 1;            /*!< [2..2] Channel x clear block repeat transfer complete interrupt
                                                     flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CBTIF6     : 1;            /*!< [3..3] Channel x Clear block transfer complete interrupt flag
                                                     Writing a 1 into this bit clears BTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CLTCIF6    : 1;            /*!< [4..4] CLear buffer Transfer Complete Interrupt Flag for channel
                                                     x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy
                                                     register                                                                  */
            uint32            : 27;
    } bit;
  } MDMA_C6IFCR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000001C8) MDMA Channel x error status register                       */
    
    struct {
      __IM  uint32 TEA        : 7;            /*!< [6..0] Transfer Error Address These bits are set and cleared
                                                     by HW, in case of an MDMA data transfer error. It is used
                                                     in conjunction with TED. This field indicates the 7 LSBits
                                                     of the address which generated a transfer/access error.
                                                     It may be used by SW to retrieve the failing address, by
                                                     adding this value (truncated to the buffer transfer length
                                                     size) to the current SAR/DAR value. Note: The SAR/DAR                     */
      __IM  uint32 TED        : 1;            /*!< [7..7] Transfer Error Direction These bit is set and cleared
                                                     by HW, in case of an MDMA data transfer error.                            */
      __IM  uint32 TELD       : 1;            /*!< [8..8] Transfer Error Link Data These bit is set by HW, in case
                                                     of a transfer error while reading the block link data structure.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32 TEMD       : 1;            /*!< [9..9] Transfer Error Mask Data These bit is set by HW, in case
                                                     of a transfer error while writing the Mask Data. It is
                                                     cleared by software writing 1 to the CTEIFx bit in the
                                                     DMA_IFCRy register.                                                       */
      __IM  uint32 ASE        : 1;            /*!< [10..10] Address/Size Error These bit is set by HW, when the
                                                     programmed address is not aligned with the data size. TED
                                                     will indicate whether the problem is on the source or destination.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32 BSE        : 1;            /*!< [11..11] Block Size Error These bit is set by HW, when the block
                                                     size is not an integer multiple of the data size either
                                                     for source or destination. TED will indicate whether the
                                                     problem is on the source or destination. It is cleared
                                                     by software writing 1 to the CTEIFx bit in the DMA_IFCRy
                                                     register.                                                                 */
            uint32            : 20;
    } bit;
  } MDMA_C6ESR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001CC) This register is used to control the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32 EN         : 1;            /*!< [0..0] channel enable                                                     */
      __IOM uint32 TEIE       : 1;            /*!< [1..1] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 CTCIE      : 1;            /*!< [2..2] Channel Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32 BRTIE      : 1;            /*!< [3..3] Block Repeat transfer interrupt enable This bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32 BTIE       : 1;            /*!< [4..4] Block Transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 TCIE       : 1;            /*!< [5..5] buffer Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32 PL         : 2;            /*!< [7..6] Priority level These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0.                                                                     */
            uint32            : 4;
      __IOM uint32 BEX        : 1;            /*!< [12..12] byte Endianness exchange                                         */
      __IOM uint32 HEX        : 1;            /*!< [13..13] Half word Endianes exchange                                      */
      __IOM uint32 WEX        : 1;            /*!< [14..14] Word Endianness exchange                                         */
            uint32            : 1;
      __OM  uint32 SWRQ       : 1;            /*!< [16..16] SW ReQuest Writing a 1 into this bit sets the CRQAx
                                                     in MDMA_ISRy register, activating the request on Channel
                                                     x Note: Either the whole CxCR register or the 8-bit/16-bit
                                                     register @ Address offset: 0x4E + 0x40 chn may be used
                                                     for SWRQ activation. In case of a SW request, acknowledge
                                                     is not generated (neither HW signal, nor CxMAR write access).             */
            uint32            : 15;
    } bit;
  } MDMA_C6CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001D0) This register is used to configure the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32 SINC       : 2;            /*!< [1..0] Source increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When source is AHB (SBUS=1), SINC
                                                     = 00 is forbidden. In Linked List Mode, at the end of a
                                                     block (single or last block in repeated block transfer
                                                     mode), this register will be loaded from memory (from address
                                                     given by current LAR[31:0] + 0x00).                                       */
      __IOM uint32 DINC       : 2;            /*!< [3..2] Destination increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When destination is AHB (DBUS=1),
                                                     DINC = 00 is forbidden.                                                   */
      __IOM uint32 SSIZE      : 2;            /*!< [5..4] Source data size These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0 Note: If a value of 11 is programmed for the TCM access/AHB
                                                     port, a transfer error will occur (TEIF bit set) If SINCOS
                                                     &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable.
                                                     Note: SSIZE = 11 (double-word) is forbidden when source
                                                     is TCM/AHB bus (SBUS=1).                                                  */
      __IOM uint32 DSIZE      : 2;            /*!< [7..6] Destination data size These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0. Note: If a value of 11 is programmed for
                                                     the TCM access/AHB port, a transfer error will occur (TEIF
                                                     bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the
                                                     result will be unpredictable. Note: DSIZE = 11 (double-word)
                                                     is forbidden when destination is TCM/AHB bus (                            */
      __IOM uint32 SINCOS     : 2;            /*!< [9..8] source increment offset size                                       */
      __IOM uint32 DINCOS     : 2;            /*!< [11..10] Destination increment offset                                     */
      __IOM uint32 SBURST     : 3;            /*!< [14..12] source burst transfer configuration                              */
      __IOM uint32 DBURST     : 3;            /*!< [17..15] Destination burst transfer configuration                         */
      __IOM uint32 TLEN       : 7;            /*!< [24..18] buffer transfer lengh                                            */
      __IOM uint32 PKE        : 1;            /*!< [25..25] PacK Enable These bit is set and cleared by software.
                                                     If the Source Size is smaller than the destination, it
                                                     will be padded according to the PAM value. If the Source
                                                     data size is larger than the destination one, it will be
                                                     truncated. The alignment will be done according to the
                                                     PAM[0] value. This bit is protected and can be written
                                                     only if EN is 0                                                           */
      __IOM uint32 PAM        : 2;            /*!< [27..26] Padding/Alignement Mode These bits are set and cleared
                                                     by software. Case 1: Source data size smaller than destination
                                                     data size - 3 options are valid. Case 2: Source data size
                                                     larger than destination data size. The remainder part is
                                                     discarded. When PKE = 1 or DSIZE=SSIZE, these bits are
                                                     ignored. These bits are protected and can be written only
                                                     if EN is 0                                                                */
      __IOM uint32 TRGM       : 2;            /*!< [29..28] Trigger Mode These bits are set and cleared by software.
                                                     Note: If TRGM is 11 for the current block, all the values
                                                     loaded at the end of the current block through the linked
                                                     list mechanism must keep the same value (TRGM=11) and the
                                                     same SWRM value, otherwise the result is undefined. These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32 SWRM       : 1;            /*!< [30..30] SW Request Mode This bit is set and cleared by software.
                                                     If a HW or SW request is currently active, the bit change
                                                     will be delayed until the current transfer is completed.
                                                     If the CxMAR contains a valid address, the CxMDR value
                                                     will also be written @ CxMAR address. This bit is protected
                                                     and can be written only if EN is 0.                                       */
      __IOM uint32 BWM        : 1;            /*!< [31..31] Bufferable Write Mode This bit is set and cleared by
                                                     software. This bit is protected and can be written only
                                                     if EN is 0. Note: All MDMA destination accesses are non-cacheable.        */
    } bit;
  } MDMA_C6TCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001D4) MDMA Channel x block number of data register               */
    
    struct {
      __IOM uint32 BNDT       : 17;           /*!< [16..0] block number of data to transfer                                  */
            uint32            : 1;
      __IOM uint32 BRSUM      : 1;            /*!< [18..18] Block Repeat Source address Update Mode These bits
                                                     are protected and can be written only if EN is 0.                         */
      __IOM uint32 BRDUM      : 1;            /*!< [19..19] Block Repeat Destination address Update Mode These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32 BRC        : 12;           /*!< [31..20] Block Repeat Count This field contains the number of
                                                     repetitions of the current block (0 to 4095). When the
                                                     channel is enabled, this register is read-only, indicating
                                                     the remaining number of blocks, excluding the current one.
                                                     This register decrements after each complete block transfer.
                                                     Once the last block transfer has completed, this register
                                                     can either stay at zero or be reloaded automatically from                 */
    } bit;
  } MDMA_C6BNDTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001D8) MDMA channel x source address register                     */
    
    struct {
      __IOM uint32 SAR        : 32;           /*!< [31..0] source adr base                                                   */
    } bit;
  } MDMA_C6SAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001DC) MDMA channel x destination address register                */
    
    struct {
      __IOM uint32 DAR        : 32;           /*!< [31..0] Destination adr base                                              */
    } bit;
  } MDMA_C6DAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001E0) MDMA channel x Block Repeat address Update register        */
    
    struct {
      __IOM uint32 SUV        : 16;           /*!< [15..0] source adresse update value                                       */
      __IOM uint32 DUV        : 16;           /*!< [31..16] destination address update                                       */
    } bit;
  } MDMA_C6BRUR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001E4) MDMA channel x Link Address register                       */
    
    struct {
      __IOM uint32 LAR        : 32;           /*!< [31..0] Link address register                                             */
    } bit;
  } MDMA_C6LAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001E8) MDMA channel x Trigger and Bus selection Register          */
    
    struct {
      __IOM uint32 TSEL       : 6;            /*!< [5..0] Trigger selection                                                  */
            uint32            : 10;
      __IOM uint32 SBUS       : 1;            /*!< [16..16] Source BUS select This bit is protected and can be
                                                     written only if EN is 0.                                                  */
      __IOM uint32 DBUS       : 1;            /*!< [17..17] Destination BUS slect This bit is protected and can
                                                     be written only if EN is 0.                                               */
            uint32            : 14;
    } bit;
  } MDMA_C6TBR;
  __IM  uint32  RESERVED13;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001F0) MDMA channel x Mask address register                       */
    
    struct {
      __IOM uint32 MAR        : 32;           /*!< [31..0] Mask address                                                      */
    } bit;
  } MDMA_C6MAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001F4) MDMA channel x Mask Data register                          */
    
    struct {
      __IOM uint32 MDR        : 32;           /*!< [31..0] Mask data                                                         */
    } bit;
  } MDMA_C6MDR;
  __IM  uint32  RESERVED14[2];
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000200) MDMA channel x interrupt/status register                   */
    
    struct {
      __IM  uint32 TEIF7      : 1;            /*!< [0..0] Channel x transfer error interrupt flag This bit is set
                                                     by hardware. It is cleared by software writing 1 to the
                                                     corresponding bit in the DMA_IFCRy register.                              */
      __IM  uint32 CTCIF7     : 1;            /*!< [1..1] Channel x Channel Transfer Complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register. CTC
                                                     is set when the last block was transferred and the channel
                                                     has been automatically disabled. CTC is also set when the
                                                     channel is suspended, as a result of writing EN bit to
                                                     0.                                                                        */
      __IM  uint32 BRTIF7     : 1;            /*!< [2..2] Channel x block repeat transfer complete interrupt flag
                                                     This bit is set by hardware. It is cleared by software
                                                     writing 1 to the corresponding bit in the DMA_IFCRy register.             */
      __IM  uint32 BTIF7      : 1;            /*!< [3..3] Channel x block transfer complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register.                     */
      __IM  uint32 TCIF7      : 1;            /*!< [4..4] channel x buffer transfer complete                                 */
            uint32            : 11;
      __IM  uint32 CRQA7      : 1;            /*!< [16..16] channel x request active flag                                    */
            uint32            : 15;
    } bit;
  } MDMA_C7ISR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000204) MDMA channel x interrupt flag clear register               */
    
    struct {
      __OM  uint32 CTEIF7     : 1;            /*!< [0..0] Channel x clear transfer error interrupt flag Writing
                                                     a 1 into this bit clears TEIFx in the MDMA_ISRy register                  */
      __OM  uint32 CCTCIF7    : 1;            /*!< [1..1] Clear Channel transfer complete interrupt flag for channel
                                                     x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CBRTIF7    : 1;            /*!< [2..2] Channel x clear block repeat transfer complete interrupt
                                                     flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CBTIF7     : 1;            /*!< [3..3] Channel x Clear block transfer complete interrupt flag
                                                     Writing a 1 into this bit clears BTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CLTCIF7    : 1;            /*!< [4..4] CLear buffer Transfer Complete Interrupt Flag for channel
                                                     x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy
                                                     register                                                                  */
            uint32            : 27;
    } bit;
  } MDMA_C7IFCR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000208) MDMA Channel x error status register                       */
    
    struct {
      __IM  uint32 TEA        : 7;            /*!< [6..0] Transfer Error Address These bits are set and cleared
                                                     by HW, in case of an MDMA data transfer error. It is used
                                                     in conjunction with TED. This field indicates the 7 LSBits
                                                     of the address which generated a transfer/access error.
                                                     It may be used by SW to retrieve the failing address, by
                                                     adding this value (truncated to the buffer transfer length
                                                     size) to the current SAR/DAR value. Note: The SAR/DAR                     */
      __IM  uint32 TED        : 1;            /*!< [7..7] Transfer Error Direction These bit is set and cleared
                                                     by HW, in case of an MDMA data transfer error.                            */
      __IM  uint32 TELD       : 1;            /*!< [8..8] Transfer Error Link Data These bit is set by HW, in case
                                                     of a transfer error while reading the block link data structure.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32 TEMD       : 1;            /*!< [9..9] Transfer Error Mask Data These bit is set by HW, in case
                                                     of a transfer error while writing the Mask Data. It is
                                                     cleared by software writing 1 to the CTEIFx bit in the
                                                     DMA_IFCRy register.                                                       */
      __IM  uint32 ASE        : 1;            /*!< [10..10] Address/Size Error These bit is set by HW, when the
                                                     programmed address is not aligned with the data size. TED
                                                     will indicate whether the problem is on the source or destination.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32 BSE        : 1;            /*!< [11..11] Block Size Error These bit is set by HW, when the block
                                                     size is not an integer multiple of the data size either
                                                     for source or destination. TED will indicate whether the
                                                     problem is on the source or destination. It is cleared
                                                     by software writing 1 to the CTEIFx bit in the DMA_IFCRy
                                                     register.                                                                 */
            uint32            : 20;
    } bit;
  } MDMA_C7ESR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000020C) This register is used to control the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32 EN         : 1;            /*!< [0..0] channel enable                                                     */
      __IOM uint32 TEIE       : 1;            /*!< [1..1] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 CTCIE      : 1;            /*!< [2..2] Channel Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32 BRTIE      : 1;            /*!< [3..3] Block Repeat transfer interrupt enable This bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32 BTIE       : 1;            /*!< [4..4] Block Transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 TCIE       : 1;            /*!< [5..5] buffer Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32 PL         : 2;            /*!< [7..6] Priority level These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0.                                                                     */
            uint32            : 4;
      __IOM uint32 BEX        : 1;            /*!< [12..12] byte Endianness exchange                                         */
      __IOM uint32 HEX        : 1;            /*!< [13..13] Half word Endianes exchange                                      */
      __IOM uint32 WEX        : 1;            /*!< [14..14] Word Endianness exchange                                         */
            uint32            : 1;
      __OM  uint32 SWRQ       : 1;            /*!< [16..16] SW ReQuest Writing a 1 into this bit sets the CRQAx
                                                     in MDMA_ISRy register, activating the request on Channel
                                                     x Note: Either the whole CxCR register or the 8-bit/16-bit
                                                     register @ Address offset: 0x4E + 0x40 chn may be used
                                                     for SWRQ activation. In case of a SW request, acknowledge
                                                     is not generated (neither HW signal, nor CxMAR write access).             */
            uint32            : 15;
    } bit;
  } MDMA_C7CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000210) This register is used to configure the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32 SINC       : 2;            /*!< [1..0] Source increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When source is AHB (SBUS=1), SINC
                                                     = 00 is forbidden. In Linked List Mode, at the end of a
                                                     block (single or last block in repeated block transfer
                                                     mode), this register will be loaded from memory (from address
                                                     given by current LAR[31:0] + 0x00).                                       */
      __IOM uint32 DINC       : 2;            /*!< [3..2] Destination increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When destination is AHB (DBUS=1),
                                                     DINC = 00 is forbidden.                                                   */
      __IOM uint32 SSIZE      : 2;            /*!< [5..4] Source data size These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0 Note: If a value of 11 is programmed for the TCM access/AHB
                                                     port, a transfer error will occur (TEIF bit set) If SINCOS
                                                     &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable.
                                                     Note: SSIZE = 11 (double-word) is forbidden when source
                                                     is TCM/AHB bus (SBUS=1).                                                  */
      __IOM uint32 DSIZE      : 2;            /*!< [7..6] Destination data size These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0. Note: If a value of 11 is programmed for
                                                     the TCM access/AHB port, a transfer error will occur (TEIF
                                                     bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the
                                                     result will be unpredictable. Note: DSIZE = 11 (double-word)
                                                     is forbidden when destination is TCM/AHB bus (                            */
      __IOM uint32 SINCOS     : 2;            /*!< [9..8] source increment offset size                                       */
      __IOM uint32 DINCOS     : 2;            /*!< [11..10] Destination increment offset                                     */
      __IOM uint32 SBURST     : 3;            /*!< [14..12] source burst transfer configuration                              */
      __IOM uint32 DBURST     : 3;            /*!< [17..15] Destination burst transfer configuration                         */
      __IOM uint32 TLEN       : 7;            /*!< [24..18] buffer transfer lengh                                            */
      __IOM uint32 PKE        : 1;            /*!< [25..25] PacK Enable These bit is set and cleared by software.
                                                     If the Source Size is smaller than the destination, it
                                                     will be padded according to the PAM value. If the Source
                                                     data size is larger than the destination one, it will be
                                                     truncated. The alignment will be done according to the
                                                     PAM[0] value. This bit is protected and can be written
                                                     only if EN is 0                                                           */
      __IOM uint32 PAM        : 2;            /*!< [27..26] Padding/Alignement Mode These bits are set and cleared
                                                     by software. Case 1: Source data size smaller than destination
                                                     data size - 3 options are valid. Case 2: Source data size
                                                     larger than destination data size. The remainder part is
                                                     discarded. When PKE = 1 or DSIZE=SSIZE, these bits are
                                                     ignored. These bits are protected and can be written only
                                                     if EN is 0                                                                */
      __IOM uint32 TRGM       : 2;            /*!< [29..28] Trigger Mode These bits are set and cleared by software.
                                                     Note: If TRGM is 11 for the current block, all the values
                                                     loaded at the end of the current block through the linked
                                                     list mechanism must keep the same value (TRGM=11) and the
                                                     same SWRM value, otherwise the result is undefined. These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32 SWRM       : 1;            /*!< [30..30] SW Request Mode This bit is set and cleared by software.
                                                     If a HW or SW request is currently active, the bit change
                                                     will be delayed until the current transfer is completed.
                                                     If the CxMAR contains a valid address, the CxMDR value
                                                     will also be written @ CxMAR address. This bit is protected
                                                     and can be written only if EN is 0.                                       */
      __IOM uint32 BWM        : 1;            /*!< [31..31] Bufferable Write Mode This bit is set and cleared by
                                                     software. This bit is protected and can be written only
                                                     if EN is 0. Note: All MDMA destination accesses are non-cacheable.        */
    } bit;
  } MDMA_C7TCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000214) MDMA Channel x block number of data register               */
    
    struct {
      __IOM uint32 BNDT       : 17;           /*!< [16..0] block number of data to transfer                                  */
            uint32            : 1;
      __IOM uint32 BRSUM      : 1;            /*!< [18..18] Block Repeat Source address Update Mode These bits
                                                     are protected and can be written only if EN is 0.                         */
      __IOM uint32 BRDUM      : 1;            /*!< [19..19] Block Repeat Destination address Update Mode These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32 BRC        : 12;           /*!< [31..20] Block Repeat Count This field contains the number of
                                                     repetitions of the current block (0 to 4095). When the
                                                     channel is enabled, this register is read-only, indicating
                                                     the remaining number of blocks, excluding the current one.
                                                     This register decrements after each complete block transfer.
                                                     Once the last block transfer has completed, this register
                                                     can either stay at zero or be reloaded automatically from                 */
    } bit;
  } MDMA_C7BNDTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000218) MDMA channel x source address register                     */
    
    struct {
      __IOM uint32 SAR        : 32;           /*!< [31..0] source adr base                                                   */
    } bit;
  } MDMA_C7SAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000021C) MDMA channel x destination address register                */
    
    struct {
      __IOM uint32 DAR        : 32;           /*!< [31..0] Destination adr base                                              */
    } bit;
  } MDMA_C7DAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000220) MDMA channel x Block Repeat address Update register        */
    
    struct {
      __IOM uint32 SUV        : 16;           /*!< [15..0] source adresse update value                                       */
      __IOM uint32 DUV        : 16;           /*!< [31..16] destination address update                                       */
    } bit;
  } MDMA_C7BRUR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000224) MDMA channel x Link Address register                       */
    
    struct {
      __IOM uint32 LAR        : 32;           /*!< [31..0] Link address register                                             */
    } bit;
  } MDMA_C7LAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000228) MDMA channel x Trigger and Bus selection Register          */
    
    struct {
      __IOM uint32 TSEL       : 6;            /*!< [5..0] Trigger selection                                                  */
            uint32            : 10;
      __IOM uint32 SBUS       : 1;            /*!< [16..16] Source BUS select This bit is protected and can be
                                                     written only if EN is 0.                                                  */
      __IOM uint32 DBUS       : 1;            /*!< [17..17] Destination BUS slect This bit is protected and can
                                                     be written only if EN is 0.                                               */
            uint32            : 14;
    } bit;
  } MDMA_C7TBR;
  __IM  uint32  RESERVED15;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000230) MDMA channel x Mask address register                       */
    
    struct {
      __IOM uint32 MAR        : 32;           /*!< [31..0] Mask address                                                      */
    } bit;
  } MDMA_C7MAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000234) MDMA channel x Mask Data register                          */
    
    struct {
      __IOM uint32 MDR        : 32;           /*!< [31..0] Mask data                                                         */
    } bit;
  } MDMA_C7MDR;
  __IM  uint32  RESERVED16[2];
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000240) MDMA channel x interrupt/status register                   */
    
    struct {
      __IM  uint32 TEIF8      : 1;            /*!< [0..0] Channel x transfer error interrupt flag This bit is set
                                                     by hardware. It is cleared by software writing 1 to the
                                                     corresponding bit in the DMA_IFCRy register.                              */
      __IM  uint32 CTCIF8     : 1;            /*!< [1..1] Channel x Channel Transfer Complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register. CTC
                                                     is set when the last block was transferred and the channel
                                                     has been automatically disabled. CTC is also set when the
                                                     channel is suspended, as a result of writing EN bit to
                                                     0.                                                                        */
      __IM  uint32 BRTIF8     : 1;            /*!< [2..2] Channel x block repeat transfer complete interrupt flag
                                                     This bit is set by hardware. It is cleared by software
                                                     writing 1 to the corresponding bit in the DMA_IFCRy register.             */
      __IM  uint32 BTIF8      : 1;            /*!< [3..3] Channel x block transfer complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register.                     */
      __IM  uint32 TCIF8      : 1;            /*!< [4..4] channel x buffer transfer complete                                 */
            uint32            : 11;
      __IM  uint32 CRQA8      : 1;            /*!< [16..16] channel x request active flag                                    */
            uint32            : 15;
    } bit;
  } MDMA_C8ISR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000244) MDMA channel x interrupt flag clear register               */
    
    struct {
      __OM  uint32 CTEIF8     : 1;            /*!< [0..0] Channel x clear transfer error interrupt flag Writing
                                                     a 1 into this bit clears TEIFx in the MDMA_ISRy register                  */
      __OM  uint32 CCTCIF8    : 1;            /*!< [1..1] Clear Channel transfer complete interrupt flag for channel
                                                     x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CBRTIF8    : 1;            /*!< [2..2] Channel x clear block repeat transfer complete interrupt
                                                     flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CBTIF8     : 1;            /*!< [3..3] Channel x Clear block transfer complete interrupt flag
                                                     Writing a 1 into this bit clears BTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CLTCIF8    : 1;            /*!< [4..4] CLear buffer Transfer Complete Interrupt Flag for channel
                                                     x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy
                                                     register                                                                  */
            uint32            : 27;
    } bit;
  } MDMA_C8IFCR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000248) MDMA Channel x error status register                       */
    
    struct {
      __IM  uint32 TEA        : 7;            /*!< [6..0] Transfer Error Address These bits are set and cleared
                                                     by HW, in case of an MDMA data transfer error. It is used
                                                     in conjunction with TED. This field indicates the 7 LSBits
                                                     of the address which generated a transfer/access error.
                                                     It may be used by SW to retrieve the failing address, by
                                                     adding this value (truncated to the buffer transfer length
                                                     size) to the current SAR/DAR value. Note: The SAR/DAR                     */
      __IM  uint32 TED        : 1;            /*!< [7..7] Transfer Error Direction These bit is set and cleared
                                                     by HW, in case of an MDMA data transfer error.                            */
      __IM  uint32 TELD       : 1;            /*!< [8..8] Transfer Error Link Data These bit is set by HW, in case
                                                     of a transfer error while reading the block link data structure.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32 TEMD       : 1;            /*!< [9..9] Transfer Error Mask Data These bit is set by HW, in case
                                                     of a transfer error while writing the Mask Data. It is
                                                     cleared by software writing 1 to the CTEIFx bit in the
                                                     DMA_IFCRy register.                                                       */
      __IM  uint32 ASE        : 1;            /*!< [10..10] Address/Size Error These bit is set by HW, when the
                                                     programmed address is not aligned with the data size. TED
                                                     will indicate whether the problem is on the source or destination.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32 BSE        : 1;            /*!< [11..11] Block Size Error These bit is set by HW, when the block
                                                     size is not an integer multiple of the data size either
                                                     for source or destination. TED will indicate whether the
                                                     problem is on the source or destination. It is cleared
                                                     by software writing 1 to the CTEIFx bit in the DMA_IFCRy
                                                     register.                                                                 */
            uint32            : 20;
    } bit;
  } MDMA_C8ESR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000024C) This register is used to control the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32 EN         : 1;            /*!< [0..0] channel enable                                                     */
      __IOM uint32 TEIE       : 1;            /*!< [1..1] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 CTCIE      : 1;            /*!< [2..2] Channel Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32 BRTIE      : 1;            /*!< [3..3] Block Repeat transfer interrupt enable This bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32 BTIE       : 1;            /*!< [4..4] Block Transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 TCIE       : 1;            /*!< [5..5] buffer Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32 PL         : 2;            /*!< [7..6] Priority level These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0.                                                                     */
            uint32            : 4;
      __IOM uint32 BEX        : 1;            /*!< [12..12] byte Endianness exchange                                         */
      __IOM uint32 HEX        : 1;            /*!< [13..13] Half word Endianes exchange                                      */
      __IOM uint32 WEX        : 1;            /*!< [14..14] Word Endianness exchange                                         */
            uint32            : 1;
      __OM  uint32 SWRQ       : 1;            /*!< [16..16] SW ReQuest Writing a 1 into this bit sets the CRQAx
                                                     in MDMA_ISRy register, activating the request on Channel
                                                     x Note: Either the whole CxCR register or the 8-bit/16-bit
                                                     register @ Address offset: 0x4E + 0x40 chn may be used
                                                     for SWRQ activation. In case of a SW request, acknowledge
                                                     is not generated (neither HW signal, nor CxMAR write access).             */
            uint32            : 15;
    } bit;
  } MDMA_C8CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000250) This register is used to configure the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32 SINC       : 2;            /*!< [1..0] Source increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When source is AHB (SBUS=1), SINC
                                                     = 00 is forbidden. In Linked List Mode, at the end of a
                                                     block (single or last block in repeated block transfer
                                                     mode), this register will be loaded from memory (from address
                                                     given by current LAR[31:0] + 0x00).                                       */
      __IOM uint32 DINC       : 2;            /*!< [3..2] Destination increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When destination is AHB (DBUS=1),
                                                     DINC = 00 is forbidden.                                                   */
      __IOM uint32 SSIZE      : 2;            /*!< [5..4] Source data size These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0 Note: If a value of 11 is programmed for the TCM access/AHB
                                                     port, a transfer error will occur (TEIF bit set) If SINCOS
                                                     &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable.
                                                     Note: SSIZE = 11 (double-word) is forbidden when source
                                                     is TCM/AHB bus (SBUS=1).                                                  */
      __IOM uint32 DSIZE      : 2;            /*!< [7..6] Destination data size These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0. Note: If a value of 11 is programmed for
                                                     the TCM access/AHB port, a transfer error will occur (TEIF
                                                     bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the
                                                     result will be unpredictable. Note: DSIZE = 11 (double-word)
                                                     is forbidden when destination is TCM/AHB bus (                            */
      __IOM uint32 SINCOS     : 2;            /*!< [9..8] source increment offset size                                       */
      __IOM uint32 DINCOS     : 2;            /*!< [11..10] Destination increment offset                                     */
      __IOM uint32 SBURST     : 3;            /*!< [14..12] source burst transfer configuration                              */
      __IOM uint32 DBURST     : 3;            /*!< [17..15] Destination burst transfer configuration                         */
      __IOM uint32 TLEN       : 7;            /*!< [24..18] buffer transfer lengh                                            */
      __IOM uint32 PKE        : 1;            /*!< [25..25] PacK Enable These bit is set and cleared by software.
                                                     If the Source Size is smaller than the destination, it
                                                     will be padded according to the PAM value. If the Source
                                                     data size is larger than the destination one, it will be
                                                     truncated. The alignment will be done according to the
                                                     PAM[0] value. This bit is protected and can be written
                                                     only if EN is 0                                                           */
      __IOM uint32 PAM        : 2;            /*!< [27..26] Padding/Alignement Mode These bits are set and cleared
                                                     by software. Case 1: Source data size smaller than destination
                                                     data size - 3 options are valid. Case 2: Source data size
                                                     larger than destination data size. The remainder part is
                                                     discarded. When PKE = 1 or DSIZE=SSIZE, these bits are
                                                     ignored. These bits are protected and can be written only
                                                     if EN is 0                                                                */
      __IOM uint32 TRGM       : 2;            /*!< [29..28] Trigger Mode These bits are set and cleared by software.
                                                     Note: If TRGM is 11 for the current block, all the values
                                                     loaded at the end of the current block through the linked
                                                     list mechanism must keep the same value (TRGM=11) and the
                                                     same SWRM value, otherwise the result is undefined. These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32 SWRM       : 1;            /*!< [30..30] SW Request Mode This bit is set and cleared by software.
                                                     If a HW or SW request is currently active, the bit change
                                                     will be delayed until the current transfer is completed.
                                                     If the CxMAR contains a valid address, the CxMDR value
                                                     will also be written @ CxMAR address. This bit is protected
                                                     and can be written only if EN is 0.                                       */
      __IOM uint32 BWM        : 1;            /*!< [31..31] Bufferable Write Mode This bit is set and cleared by
                                                     software. This bit is protected and can be written only
                                                     if EN is 0. Note: All MDMA destination accesses are non-cacheable.        */
    } bit;
  } MDMA_C8TCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000254) MDMA Channel x block number of data register               */
    
    struct {
      __IOM uint32 BNDT       : 17;           /*!< [16..0] block number of data to transfer                                  */
            uint32            : 1;
      __IOM uint32 BRSUM      : 1;            /*!< [18..18] Block Repeat Source address Update Mode These bits
                                                     are protected and can be written only if EN is 0.                         */
      __IOM uint32 BRDUM      : 1;            /*!< [19..19] Block Repeat Destination address Update Mode These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32 BRC        : 12;           /*!< [31..20] Block Repeat Count This field contains the number of
                                                     repetitions of the current block (0 to 4095). When the
                                                     channel is enabled, this register is read-only, indicating
                                                     the remaining number of blocks, excluding the current one.
                                                     This register decrements after each complete block transfer.
                                                     Once the last block transfer has completed, this register
                                                     can either stay at zero or be reloaded automatically from                 */
    } bit;
  } MDMA_C8BNDTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000258) MDMA channel x source address register                     */
    
    struct {
      __IOM uint32 SAR        : 32;           /*!< [31..0] source adr base                                                   */
    } bit;
  } MDMA_C8SAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000025C) MDMA channel x destination address register                */
    
    struct {
      __IOM uint32 DAR        : 32;           /*!< [31..0] Destination adr base                                              */
    } bit;
  } MDMA_C8DAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000260) MDMA channel x Block Repeat address Update register        */
    
    struct {
      __IOM uint32 SUV        : 16;           /*!< [15..0] source adresse update value                                       */
      __IOM uint32 DUV        : 16;           /*!< [31..16] destination address update                                       */
    } bit;
  } MDMA_C8BRUR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000264) MDMA channel x Link Address register                       */
    
    struct {
      __IOM uint32 LAR        : 32;           /*!< [31..0] Link address register                                             */
    } bit;
  } MDMA_C8LAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000268) MDMA channel x Trigger and Bus selection Register          */
    
    struct {
      __IOM uint32 TSEL       : 6;            /*!< [5..0] Trigger selection                                                  */
            uint32            : 10;
      __IOM uint32 SBUS       : 1;            /*!< [16..16] Source BUS select This bit is protected and can be
                                                     written only if EN is 0.                                                  */
      __IOM uint32 DBUS       : 1;            /*!< [17..17] Destination BUS slect This bit is protected and can
                                                     be written only if EN is 0.                                               */
            uint32            : 14;
    } bit;
  } MDMA_C8TBR;
  __IM  uint32  RESERVED17;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000270) MDMA channel x Mask address register                       */
    
    struct {
      __IOM uint32 MAR        : 32;           /*!< [31..0] Mask address                                                      */
    } bit;
  } MDMA_C8MAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000274) MDMA channel x Mask Data register                          */
    
    struct {
      __IOM uint32 MDR        : 32;           /*!< [31..0] Mask data                                                         */
    } bit;
  } MDMA_C8MDR;
  __IM  uint32  RESERVED18[2];
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000280) MDMA channel x interrupt/status register                   */
    
    struct {
      __IM  uint32 TEIF9      : 1;            /*!< [0..0] Channel x transfer error interrupt flag This bit is set
                                                     by hardware. It is cleared by software writing 1 to the
                                                     corresponding bit in the DMA_IFCRy register.                              */
      __IM  uint32 CTCIF9     : 1;            /*!< [1..1] Channel x Channel Transfer Complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register. CTC
                                                     is set when the last block was transferred and the channel
                                                     has been automatically disabled. CTC is also set when the
                                                     channel is suspended, as a result of writing EN bit to
                                                     0.                                                                        */
      __IM  uint32 BRTIF9     : 1;            /*!< [2..2] Channel x block repeat transfer complete interrupt flag
                                                     This bit is set by hardware. It is cleared by software
                                                     writing 1 to the corresponding bit in the DMA_IFCRy register.             */
      __IM  uint32 BTIF9      : 1;            /*!< [3..3] Channel x block transfer complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register.                     */
      __IM  uint32 TCIF9      : 1;            /*!< [4..4] channel x buffer transfer complete                                 */
            uint32            : 11;
      __IM  uint32 CRQA9      : 1;            /*!< [16..16] channel x request active flag                                    */
            uint32            : 15;
    } bit;
  } MDMA_C9ISR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000284) MDMA channel x interrupt flag clear register               */
    
    struct {
      __OM  uint32 CTEIF9     : 1;            /*!< [0..0] Channel x clear transfer error interrupt flag Writing
                                                     a 1 into this bit clears TEIFx in the MDMA_ISRy register                  */
      __OM  uint32 CCTCIF9    : 1;            /*!< [1..1] Clear Channel transfer complete interrupt flag for channel
                                                     x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CBRTIF9    : 1;            /*!< [2..2] Channel x clear block repeat transfer complete interrupt
                                                     flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CBTIF9     : 1;            /*!< [3..3] Channel x Clear block transfer complete interrupt flag
                                                     Writing a 1 into this bit clears BTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CLTCIF9    : 1;            /*!< [4..4] CLear buffer Transfer Complete Interrupt Flag for channel
                                                     x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy
                                                     register                                                                  */
            uint32            : 27;
    } bit;
  } MDMA_C9IFCR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000288) MDMA Channel x error status register                       */
    
    struct {
      __IM  uint32 TEA        : 7;            /*!< [6..0] Transfer Error Address These bits are set and cleared
                                                     by HW, in case of an MDMA data transfer error. It is used
                                                     in conjunction with TED. This field indicates the 7 LSBits
                                                     of the address which generated a transfer/access error.
                                                     It may be used by SW to retrieve the failing address, by
                                                     adding this value (truncated to the buffer transfer length
                                                     size) to the current SAR/DAR value. Note: The SAR/DAR                     */
      __IM  uint32 TED        : 1;            /*!< [7..7] Transfer Error Direction These bit is set and cleared
                                                     by HW, in case of an MDMA data transfer error.                            */
      __IM  uint32 TELD       : 1;            /*!< [8..8] Transfer Error Link Data These bit is set by HW, in case
                                                     of a transfer error while reading the block link data structure.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32 TEMD       : 1;            /*!< [9..9] Transfer Error Mask Data These bit is set by HW, in case
                                                     of a transfer error while writing the Mask Data. It is
                                                     cleared by software writing 1 to the CTEIFx bit in the
                                                     DMA_IFCRy register.                                                       */
      __IM  uint32 ASE        : 1;            /*!< [10..10] Address/Size Error These bit is set by HW, when the
                                                     programmed address is not aligned with the data size. TED
                                                     will indicate whether the problem is on the source or destination.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32 BSE        : 1;            /*!< [11..11] Block Size Error These bit is set by HW, when the block
                                                     size is not an integer multiple of the data size either
                                                     for source or destination. TED will indicate whether the
                                                     problem is on the source or destination. It is cleared
                                                     by software writing 1 to the CTEIFx bit in the DMA_IFCRy
                                                     register.                                                                 */
            uint32            : 20;
    } bit;
  } MDMA_C9ESR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000028C) This register is used to control the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32 EN         : 1;            /*!< [0..0] channel enable                                                     */
      __IOM uint32 TEIE       : 1;            /*!< [1..1] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 CTCIE      : 1;            /*!< [2..2] Channel Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32 BRTIE      : 1;            /*!< [3..3] Block Repeat transfer interrupt enable This bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32 BTIE       : 1;            /*!< [4..4] Block Transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 TCIE       : 1;            /*!< [5..5] buffer Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32 PL         : 2;            /*!< [7..6] Priority level These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0.                                                                     */
            uint32            : 4;
      __IOM uint32 BEX        : 1;            /*!< [12..12] byte Endianness exchange                                         */
      __IOM uint32 HEX        : 1;            /*!< [13..13] Half word Endianes exchange                                      */
      __IOM uint32 WEX        : 1;            /*!< [14..14] Word Endianness exchange                                         */
            uint32            : 1;
      __OM  uint32 SWRQ       : 1;            /*!< [16..16] SW ReQuest Writing a 1 into this bit sets the CRQAx
                                                     in MDMA_ISRy register, activating the request on Channel
                                                     x Note: Either the whole CxCR register or the 8-bit/16-bit
                                                     register @ Address offset: 0x4E + 0x40 chn may be used
                                                     for SWRQ activation. In case of a SW request, acknowledge
                                                     is not generated (neither HW signal, nor CxMAR write access).             */
            uint32            : 15;
    } bit;
  } MDMA_C9CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000290) This register is used to configure the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32 SINC       : 2;            /*!< [1..0] Source increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When source is AHB (SBUS=1), SINC
                                                     = 00 is forbidden. In Linked List Mode, at the end of a
                                                     block (single or last block in repeated block transfer
                                                     mode), this register will be loaded from memory (from address
                                                     given by current LAR[31:0] + 0x00).                                       */
      __IOM uint32 DINC       : 2;            /*!< [3..2] Destination increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When destination is AHB (DBUS=1),
                                                     DINC = 00 is forbidden.                                                   */
      __IOM uint32 SSIZE      : 2;            /*!< [5..4] Source data size These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0 Note: If a value of 11 is programmed for the TCM access/AHB
                                                     port, a transfer error will occur (TEIF bit set) If SINCOS
                                                     &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable.
                                                     Note: SSIZE = 11 (double-word) is forbidden when source
                                                     is TCM/AHB bus (SBUS=1).                                                  */
      __IOM uint32 DSIZE      : 2;            /*!< [7..6] Destination data size These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0. Note: If a value of 11 is programmed for
                                                     the TCM access/AHB port, a transfer error will occur (TEIF
                                                     bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the
                                                     result will be unpredictable. Note: DSIZE = 11 (double-word)
                                                     is forbidden when destination is TCM/AHB bus (                            */
      __IOM uint32 SINCOS     : 2;            /*!< [9..8] source increment offset size                                       */
      __IOM uint32 DINCOS     : 2;            /*!< [11..10] Destination increment offset                                     */
      __IOM uint32 SBURST     : 3;            /*!< [14..12] source burst transfer configuration                              */
      __IOM uint32 DBURST     : 3;            /*!< [17..15] Destination burst transfer configuration                         */
      __IOM uint32 TLEN       : 7;            /*!< [24..18] buffer transfer lengh                                            */
      __IOM uint32 PKE        : 1;            /*!< [25..25] PacK Enable These bit is set and cleared by software.
                                                     If the Source Size is smaller than the destination, it
                                                     will be padded according to the PAM value. If the Source
                                                     data size is larger than the destination one, it will be
                                                     truncated. The alignment will be done according to the
                                                     PAM[0] value. This bit is protected and can be written
                                                     only if EN is 0                                                           */
      __IOM uint32 PAM        : 2;            /*!< [27..26] Padding/Alignement Mode These bits are set and cleared
                                                     by software. Case 1: Source data size smaller than destination
                                                     data size - 3 options are valid. Case 2: Source data size
                                                     larger than destination data size. The remainder part is
                                                     discarded. When PKE = 1 or DSIZE=SSIZE, these bits are
                                                     ignored. These bits are protected and can be written only
                                                     if EN is 0                                                                */
      __IOM uint32 TRGM       : 2;            /*!< [29..28] Trigger Mode These bits are set and cleared by software.
                                                     Note: If TRGM is 11 for the current block, all the values
                                                     loaded at the end of the current block through the linked
                                                     list mechanism must keep the same value (TRGM=11) and the
                                                     same SWRM value, otherwise the result is undefined. These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32 SWRM       : 1;            /*!< [30..30] SW Request Mode This bit is set and cleared by software.
                                                     If a HW or SW request is currently active, the bit change
                                                     will be delayed until the current transfer is completed.
                                                     If the CxMAR contains a valid address, the CxMDR value
                                                     will also be written @ CxMAR address. This bit is protected
                                                     and can be written only if EN is 0.                                       */
      __IOM uint32 BWM        : 1;            /*!< [31..31] Bufferable Write Mode This bit is set and cleared by
                                                     software. This bit is protected and can be written only
                                                     if EN is 0. Note: All MDMA destination accesses are non-cacheable.        */
    } bit;
  } MDMA_C9TCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000294) MDMA Channel x block number of data register               */
    
    struct {
      __IOM uint32 BNDT       : 17;           /*!< [16..0] block number of data to transfer                                  */
            uint32            : 1;
      __IOM uint32 BRSUM      : 1;            /*!< [18..18] Block Repeat Source address Update Mode These bits
                                                     are protected and can be written only if EN is 0.                         */
      __IOM uint32 BRDUM      : 1;            /*!< [19..19] Block Repeat Destination address Update Mode These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32 BRC        : 12;           /*!< [31..20] Block Repeat Count This field contains the number of
                                                     repetitions of the current block (0 to 4095). When the
                                                     channel is enabled, this register is read-only, indicating
                                                     the remaining number of blocks, excluding the current one.
                                                     This register decrements after each complete block transfer.
                                                     Once the last block transfer has completed, this register
                                                     can either stay at zero or be reloaded automatically from                 */
    } bit;
  } MDMA_C9BNDTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000298) MDMA channel x source address register                     */
    
    struct {
      __IOM uint32 SAR        : 32;           /*!< [31..0] source adr base                                                   */
    } bit;
  } MDMA_C9SAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000029C) MDMA channel x destination address register                */
    
    struct {
      __IOM uint32 DAR        : 32;           /*!< [31..0] Destination adr base                                              */
    } bit;
  } MDMA_C9DAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000002A0) MDMA channel x Block Repeat address Update register        */
    
    struct {
      __IOM uint32 SUV        : 16;           /*!< [15..0] source adresse update value                                       */
      __IOM uint32 DUV        : 16;           /*!< [31..16] destination address update                                       */
    } bit;
  } MDMA_C9BRUR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000002A4) MDMA channel x Link Address register                       */
    
    struct {
      __IOM uint32 LAR        : 32;           /*!< [31..0] Link address register                                             */
    } bit;
  } MDMA_C9LAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000002A8) MDMA channel x Trigger and Bus selection Register          */
    
    struct {
      __IOM uint32 TSEL       : 6;            /*!< [5..0] Trigger selection                                                  */
            uint32            : 10;
      __IOM uint32 SBUS       : 1;            /*!< [16..16] Source BUS select This bit is protected and can be
                                                     written only if EN is 0.                                                  */
      __IOM uint32 DBUS       : 1;            /*!< [17..17] Destination BUS slect This bit is protected and can
                                                     be written only if EN is 0.                                               */
            uint32            : 14;
    } bit;
  } MDMA_C9TBR;
  __IM  uint32  RESERVED19;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000002B0) MDMA channel x Mask address register                       */
    
    struct {
      __IOM uint32 MAR        : 32;           /*!< [31..0] Mask address                                                      */
    } bit;
  } MDMA_C9MAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000002B4) MDMA channel x Mask Data register                          */
    
    struct {
      __IOM uint32 MDR        : 32;           /*!< [31..0] Mask data                                                         */
    } bit;
  } MDMA_C9MDR;
  __IM  uint32  RESERVED20[2];
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000002C0) MDMA channel x interrupt/status register                   */
    
    struct {
      __IM  uint32 TEIF10     : 1;            /*!< [0..0] Channel x transfer error interrupt flag This bit is set
                                                     by hardware. It is cleared by software writing 1 to the
                                                     corresponding bit in the DMA_IFCRy register.                              */
      __IM  uint32 CTCIF10    : 1;            /*!< [1..1] Channel x Channel Transfer Complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register. CTC
                                                     is set when the last block was transferred and the channel
                                                     has been automatically disabled. CTC is also set when the
                                                     channel is suspended, as a result of writing EN bit to
                                                     0.                                                                        */
      __IM  uint32 BRTIF10    : 1;            /*!< [2..2] Channel x block repeat transfer complete interrupt flag
                                                     This bit is set by hardware. It is cleared by software
                                                     writing 1 to the corresponding bit in the DMA_IFCRy register.             */
      __IM  uint32 BTIF10     : 1;            /*!< [3..3] Channel x block transfer complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register.                     */
      __IM  uint32 TCIF10     : 1;            /*!< [4..4] channel x buffer transfer complete                                 */
            uint32            : 11;
      __IM  uint32 CRQA10     : 1;            /*!< [16..16] channel x request active flag                                    */
            uint32            : 15;
    } bit;
  } MDMA_C10ISR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x000002C4) MDMA channel x interrupt flag clear register               */
    
    struct {
      __OM  uint32 CTEIF10    : 1;            /*!< [0..0] Channel x clear transfer error interrupt flag Writing
                                                     a 1 into this bit clears TEIFx in the MDMA_ISRy register                  */
      __OM  uint32 CCTCIF10   : 1;            /*!< [1..1] Clear Channel transfer complete interrupt flag for channel
                                                     x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CBRTIF10   : 1;            /*!< [2..2] Channel x clear block repeat transfer complete interrupt
                                                     flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CBTIF10    : 1;            /*!< [3..3] Channel x Clear block transfer complete interrupt flag
                                                     Writing a 1 into this bit clears BTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CLTCIF10   : 1;            /*!< [4..4] CLear buffer Transfer Complete Interrupt Flag for channel
                                                     x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy
                                                     register                                                                  */
            uint32            : 27;
    } bit;
  } MDMA_C10IFCR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000002C8) MDMA Channel x error status register                       */
    
    struct {
      __IM  uint32 TEA        : 7;            /*!< [6..0] Transfer Error Address These bits are set and cleared
                                                     by HW, in case of an MDMA data transfer error. It is used
                                                     in conjunction with TED. This field indicates the 7 LSBits
                                                     of the address which generated a transfer/access error.
                                                     It may be used by SW to retrieve the failing address, by
                                                     adding this value (truncated to the buffer transfer length
                                                     size) to the current SAR/DAR value. Note: The SAR/DAR                     */
      __IM  uint32 TED        : 1;            /*!< [7..7] Transfer Error Direction These bit is set and cleared
                                                     by HW, in case of an MDMA data transfer error.                            */
      __IM  uint32 TELD       : 1;            /*!< [8..8] Transfer Error Link Data These bit is set by HW, in case
                                                     of a transfer error while reading the block link data structure.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32 TEMD       : 1;            /*!< [9..9] Transfer Error Mask Data These bit is set by HW, in case
                                                     of a transfer error while writing the Mask Data. It is
                                                     cleared by software writing 1 to the CTEIFx bit in the
                                                     DMA_IFCRy register.                                                       */
      __IM  uint32 ASE        : 1;            /*!< [10..10] Address/Size Error These bit is set by HW, when the
                                                     programmed address is not aligned with the data size. TED
                                                     will indicate whether the problem is on the source or destination.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32 BSE        : 1;            /*!< [11..11] Block Size Error These bit is set by HW, when the block
                                                     size is not an integer multiple of the data size either
                                                     for source or destination. TED will indicate whether the
                                                     problem is on the source or destination. It is cleared
                                                     by software writing 1 to the CTEIFx bit in the DMA_IFCRy
                                                     register.                                                                 */
            uint32            : 20;
    } bit;
  } MDMA_C10ESR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000002CC) This register is used to control the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32 EN         : 1;            /*!< [0..0] channel enable                                                     */
      __IOM uint32 TEIE       : 1;            /*!< [1..1] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 CTCIE      : 1;            /*!< [2..2] Channel Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32 BRTIE      : 1;            /*!< [3..3] Block Repeat transfer interrupt enable This bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32 BTIE       : 1;            /*!< [4..4] Block Transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 TCIE       : 1;            /*!< [5..5] buffer Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32 PL         : 2;            /*!< [7..6] Priority level These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0.                                                                     */
            uint32            : 4;
      __IOM uint32 BEX        : 1;            /*!< [12..12] byte Endianness exchange                                         */
      __IOM uint32 HEX        : 1;            /*!< [13..13] Half word Endianes exchange                                      */
      __IOM uint32 WEX        : 1;            /*!< [14..14] Word Endianness exchange                                         */
            uint32            : 1;
      __OM  uint32 SWRQ       : 1;            /*!< [16..16] SW ReQuest Writing a 1 into this bit sets the CRQAx
                                                     in MDMA_ISRy register, activating the request on Channel
                                                     x Note: Either the whole CxCR register or the 8-bit/16-bit
                                                     register @ Address offset: 0x4E + 0x40 chn may be used
                                                     for SWRQ activation. In case of a SW request, acknowledge
                                                     is not generated (neither HW signal, nor CxMAR write access).             */
            uint32            : 15;
    } bit;
  } MDMA_C10CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000002D0) This register is used to configure the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32 SINC       : 2;            /*!< [1..0] Source increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When source is AHB (SBUS=1), SINC
                                                     = 00 is forbidden. In Linked List Mode, at the end of a
                                                     block (single or last block in repeated block transfer
                                                     mode), this register will be loaded from memory (from address
                                                     given by current LAR[31:0] + 0x00).                                       */
      __IOM uint32 DINC       : 2;            /*!< [3..2] Destination increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When destination is AHB (DBUS=1),
                                                     DINC = 00 is forbidden.                                                   */
      __IOM uint32 SSIZE      : 2;            /*!< [5..4] Source data size These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0 Note: If a value of 11 is programmed for the TCM access/AHB
                                                     port, a transfer error will occur (TEIF bit set) If SINCOS
                                                     &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable.
                                                     Note: SSIZE = 11 (double-word) is forbidden when source
                                                     is TCM/AHB bus (SBUS=1).                                                  */
      __IOM uint32 DSIZE      : 2;            /*!< [7..6] Destination data size These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0. Note: If a value of 11 is programmed for
                                                     the TCM access/AHB port, a transfer error will occur (TEIF
                                                     bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the
                                                     result will be unpredictable. Note: DSIZE = 11 (double-word)
                                                     is forbidden when destination is TCM/AHB bus (                            */
      __IOM uint32 SINCOS     : 2;            /*!< [9..8] source increment offset size                                       */
      __IOM uint32 DINCOS     : 2;            /*!< [11..10] Destination increment offset                                     */
      __IOM uint32 SBURST     : 3;            /*!< [14..12] source burst transfer configuration                              */
      __IOM uint32 DBURST     : 3;            /*!< [17..15] Destination burst transfer configuration                         */
      __IOM uint32 TLEN       : 7;            /*!< [24..18] buffer transfer lengh                                            */
      __IOM uint32 PKE        : 1;            /*!< [25..25] PacK Enable These bit is set and cleared by software.
                                                     If the Source Size is smaller than the destination, it
                                                     will be padded according to the PAM value. If the Source
                                                     data size is larger than the destination one, it will be
                                                     truncated. The alignment will be done according to the
                                                     PAM[0] value. This bit is protected and can be written
                                                     only if EN is 0                                                           */
      __IOM uint32 PAM        : 2;            /*!< [27..26] Padding/Alignement Mode These bits are set and cleared
                                                     by software. Case 1: Source data size smaller than destination
                                                     data size - 3 options are valid. Case 2: Source data size
                                                     larger than destination data size. The remainder part is
                                                     discarded. When PKE = 1 or DSIZE=SSIZE, these bits are
                                                     ignored. These bits are protected and can be written only
                                                     if EN is 0                                                                */
      __IOM uint32 TRGM       : 2;            /*!< [29..28] Trigger Mode These bits are set and cleared by software.
                                                     Note: If TRGM is 11 for the current block, all the values
                                                     loaded at the end of the current block through the linked
                                                     list mechanism must keep the same value (TRGM=11) and the
                                                     same SWRM value, otherwise the result is undefined. These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32 SWRM       : 1;            /*!< [30..30] SW Request Mode This bit is set and cleared by software.
                                                     If a HW or SW request is currently active, the bit change
                                                     will be delayed until the current transfer is completed.
                                                     If the CxMAR contains a valid address, the CxMDR value
                                                     will also be written @ CxMAR address. This bit is protected
                                                     and can be written only if EN is 0.                                       */
      __IOM uint32 BWM        : 1;            /*!< [31..31] Bufferable Write Mode This bit is set and cleared by
                                                     software. This bit is protected and can be written only
                                                     if EN is 0. Note: All MDMA destination accesses are non-cacheable.        */
    } bit;
  } MDMA_C10TCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000002D4) MDMA Channel x block number of data register               */
    
    struct {
      __IOM uint32 BNDT       : 17;           /*!< [16..0] block number of data to transfer                                  */
            uint32            : 1;
      __IOM uint32 BRSUM      : 1;            /*!< [18..18] Block Repeat Source address Update Mode These bits
                                                     are protected and can be written only if EN is 0.                         */
      __IOM uint32 BRDUM      : 1;            /*!< [19..19] Block Repeat Destination address Update Mode These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32 BRC        : 12;           /*!< [31..20] Block Repeat Count This field contains the number of
                                                     repetitions of the current block (0 to 4095). When the
                                                     channel is enabled, this register is read-only, indicating
                                                     the remaining number of blocks, excluding the current one.
                                                     This register decrements after each complete block transfer.
                                                     Once the last block transfer has completed, this register
                                                     can either stay at zero or be reloaded automatically from                 */
    } bit;
  } MDMA_C10BNDTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000002D8) MDMA channel x source address register                     */
    
    struct {
      __IOM uint32 SAR        : 32;           /*!< [31..0] source adr base                                                   */
    } bit;
  } MDMA_C10SAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000002DC) MDMA channel x destination address register                */
    
    struct {
      __IOM uint32 DAR        : 32;           /*!< [31..0] Destination adr base                                              */
    } bit;
  } MDMA_C10DAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000002E0) MDMA channel x Block Repeat address Update register        */
    
    struct {
      __IOM uint32 SUV        : 16;           /*!< [15..0] source adresse update value                                       */
      __IOM uint32 DUV        : 16;           /*!< [31..16] destination address update                                       */
    } bit;
  } MDMA_C10BRUR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000002E4) MDMA channel x Link Address register                       */
    
    struct {
      __IOM uint32 LAR        : 32;           /*!< [31..0] Link address register                                             */
    } bit;
  } MDMA_C10LAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000002E8) MDMA channel x Trigger and Bus selection Register          */
    
    struct {
      __IOM uint32 TSEL       : 6;            /*!< [5..0] Trigger selection                                                  */
            uint32            : 10;
      __IOM uint32 SBUS       : 1;            /*!< [16..16] Source BUS select This bit is protected and can be
                                                     written only if EN is 0.                                                  */
      __IOM uint32 DBUS       : 1;            /*!< [17..17] Destination BUS slect This bit is protected and can
                                                     be written only if EN is 0.                                               */
            uint32            : 14;
    } bit;
  } MDMA_C10TBR;
  __IM  uint32  RESERVED21;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000002F0) MDMA channel x Mask address register                       */
    
    struct {
      __IOM uint32 MAR        : 32;           /*!< [31..0] Mask address                                                      */
    } bit;
  } MDMA_C10MAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000002F4) MDMA channel x Mask Data register                          */
    
    struct {
      __IOM uint32 MDR        : 32;           /*!< [31..0] Mask data                                                         */
    } bit;
  } MDMA_C10MDR;
  __IM  uint32  RESERVED22[2];
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000300) MDMA channel x interrupt/status register                   */
    
    struct {
      __IM  uint32 TEIF11     : 1;            /*!< [0..0] Channel x transfer error interrupt flag This bit is set
                                                     by hardware. It is cleared by software writing 1 to the
                                                     corresponding bit in the DMA_IFCRy register.                              */
      __IM  uint32 CTCIF11    : 1;            /*!< [1..1] Channel x Channel Transfer Complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register. CTC
                                                     is set when the last block was transferred and the channel
                                                     has been automatically disabled. CTC is also set when the
                                                     channel is suspended, as a result of writing EN bit to
                                                     0.                                                                        */
      __IM  uint32 BRTIF11    : 1;            /*!< [2..2] Channel x block repeat transfer complete interrupt flag
                                                     This bit is set by hardware. It is cleared by software
                                                     writing 1 to the corresponding bit in the DMA_IFCRy register.             */
      __IM  uint32 BTIF11     : 1;            /*!< [3..3] Channel x block transfer complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register.                     */
      __IM  uint32 TCIF11     : 1;            /*!< [4..4] channel x buffer transfer complete                                 */
            uint32            : 11;
      __IM  uint32 CRQA11     : 1;            /*!< [16..16] channel x request active flag                                    */
            uint32            : 15;
    } bit;
  } MDMA_C11ISR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000304) MDMA channel x interrupt flag clear register               */
    
    struct {
      __OM  uint32 CTEIF11    : 1;            /*!< [0..0] Channel x clear transfer error interrupt flag Writing
                                                     a 1 into this bit clears TEIFx in the MDMA_ISRy register                  */
      __OM  uint32 CCTCIF11   : 1;            /*!< [1..1] Clear Channel transfer complete interrupt flag for channel
                                                     x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CBRTIF11   : 1;            /*!< [2..2] Channel x clear block repeat transfer complete interrupt
                                                     flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CBTIF11    : 1;            /*!< [3..3] Channel x Clear block transfer complete interrupt flag
                                                     Writing a 1 into this bit clears BTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CLTCIF11   : 1;            /*!< [4..4] CLear buffer Transfer Complete Interrupt Flag for channel
                                                     x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy
                                                     register                                                                  */
            uint32            : 27;
    } bit;
  } MDMA_C11IFCR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000308) MDMA Channel x error status register                       */
    
    struct {
      __IM  uint32 TEA        : 7;            /*!< [6..0] Transfer Error Address These bits are set and cleared
                                                     by HW, in case of an MDMA data transfer error. It is used
                                                     in conjunction with TED. This field indicates the 7 LSBits
                                                     of the address which generated a transfer/access error.
                                                     It may be used by SW to retrieve the failing address, by
                                                     adding this value (truncated to the buffer transfer length
                                                     size) to the current SAR/DAR value. Note: The SAR/DAR                     */
      __IM  uint32 TED        : 1;            /*!< [7..7] Transfer Error Direction These bit is set and cleared
                                                     by HW, in case of an MDMA data transfer error.                            */
      __IM  uint32 TELD       : 1;            /*!< [8..8] Transfer Error Link Data These bit is set by HW, in case
                                                     of a transfer error while reading the block link data structure.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32 TEMD       : 1;            /*!< [9..9] Transfer Error Mask Data These bit is set by HW, in case
                                                     of a transfer error while writing the Mask Data. It is
                                                     cleared by software writing 1 to the CTEIFx bit in the
                                                     DMA_IFCRy register.                                                       */
      __IM  uint32 ASE        : 1;            /*!< [10..10] Address/Size Error These bit is set by HW, when the
                                                     programmed address is not aligned with the data size. TED
                                                     will indicate whether the problem is on the source or destination.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32 BSE        : 1;            /*!< [11..11] Block Size Error These bit is set by HW, when the block
                                                     size is not an integer multiple of the data size either
                                                     for source or destination. TED will indicate whether the
                                                     problem is on the source or destination. It is cleared
                                                     by software writing 1 to the CTEIFx bit in the DMA_IFCRy
                                                     register.                                                                 */
            uint32            : 20;
    } bit;
  } MDMA_C11ESR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000030C) This register is used to control the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32 EN         : 1;            /*!< [0..0] channel enable                                                     */
      __IOM uint32 TEIE       : 1;            /*!< [1..1] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 CTCIE      : 1;            /*!< [2..2] Channel Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32 BRTIE      : 1;            /*!< [3..3] Block Repeat transfer interrupt enable This bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32 BTIE       : 1;            /*!< [4..4] Block Transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 TCIE       : 1;            /*!< [5..5] buffer Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32 PL         : 2;            /*!< [7..6] Priority level These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0.                                                                     */
            uint32            : 4;
      __IOM uint32 BEX        : 1;            /*!< [12..12] byte Endianness exchange                                         */
      __IOM uint32 HEX        : 1;            /*!< [13..13] Half word Endianes exchange                                      */
      __IOM uint32 WEX        : 1;            /*!< [14..14] Word Endianness exchange                                         */
            uint32            : 1;
      __OM  uint32 SWRQ       : 1;            /*!< [16..16] SW ReQuest Writing a 1 into this bit sets the CRQAx
                                                     in MDMA_ISRy register, activating the request on Channel
                                                     x Note: Either the whole CxCR register or the 8-bit/16-bit
                                                     register @ Address offset: 0x4E + 0x40 chn may be used
                                                     for SWRQ activation. In case of a SW request, acknowledge
                                                     is not generated (neither HW signal, nor CxMAR write access).             */
            uint32            : 15;
    } bit;
  } MDMA_C11CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000310) This register is used to configure the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32 SINC       : 2;            /*!< [1..0] Source increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When source is AHB (SBUS=1), SINC
                                                     = 00 is forbidden. In Linked List Mode, at the end of a
                                                     block (single or last block in repeated block transfer
                                                     mode), this register will be loaded from memory (from address
                                                     given by current LAR[31:0] + 0x00).                                       */
      __IOM uint32 DINC       : 2;            /*!< [3..2] Destination increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When destination is AHB (DBUS=1),
                                                     DINC = 00 is forbidden.                                                   */
      __IOM uint32 SSIZE      : 2;            /*!< [5..4] Source data size These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0 Note: If a value of 11 is programmed for the TCM access/AHB
                                                     port, a transfer error will occur (TEIF bit set) If SINCOS
                                                     &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable.
                                                     Note: SSIZE = 11 (double-word) is forbidden when source
                                                     is TCM/AHB bus (SBUS=1).                                                  */
      __IOM uint32 DSIZE      : 2;            /*!< [7..6] Destination data size These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0. Note: If a value of 11 is programmed for
                                                     the TCM access/AHB port, a transfer error will occur (TEIF
                                                     bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the
                                                     result will be unpredictable. Note: DSIZE = 11 (double-word)
                                                     is forbidden when destination is TCM/AHB bus (                            */
      __IOM uint32 SINCOS     : 2;            /*!< [9..8] source increment offset size                                       */
      __IOM uint32 DINCOS     : 2;            /*!< [11..10] Destination increment offset                                     */
      __IOM uint32 SBURST     : 3;            /*!< [14..12] source burst transfer configuration                              */
      __IOM uint32 DBURST     : 3;            /*!< [17..15] Destination burst transfer configuration                         */
      __IOM uint32 TLEN       : 7;            /*!< [24..18] buffer transfer lengh                                            */
      __IOM uint32 PKE        : 1;            /*!< [25..25] PacK Enable These bit is set and cleared by software.
                                                     If the Source Size is smaller than the destination, it
                                                     will be padded according to the PAM value. If the Source
                                                     data size is larger than the destination one, it will be
                                                     truncated. The alignment will be done according to the
                                                     PAM[0] value. This bit is protected and can be written
                                                     only if EN is 0                                                           */
      __IOM uint32 PAM        : 2;            /*!< [27..26] Padding/Alignement Mode These bits are set and cleared
                                                     by software. Case 1: Source data size smaller than destination
                                                     data size - 3 options are valid. Case 2: Source data size
                                                     larger than destination data size. The remainder part is
                                                     discarded. When PKE = 1 or DSIZE=SSIZE, these bits are
                                                     ignored. These bits are protected and can be written only
                                                     if EN is 0                                                                */
      __IOM uint32 TRGM       : 2;            /*!< [29..28] Trigger Mode These bits are set and cleared by software.
                                                     Note: If TRGM is 11 for the current block, all the values
                                                     loaded at the end of the current block through the linked
                                                     list mechanism must keep the same value (TRGM=11) and the
                                                     same SWRM value, otherwise the result is undefined. These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32 SWRM       : 1;            /*!< [30..30] SW Request Mode This bit is set and cleared by software.
                                                     If a HW or SW request is currently active, the bit change
                                                     will be delayed until the current transfer is completed.
                                                     If the CxMAR contains a valid address, the CxMDR value
                                                     will also be written @ CxMAR address. This bit is protected
                                                     and can be written only if EN is 0.                                       */
      __IOM uint32 BWM        : 1;            /*!< [31..31] Bufferable Write Mode This bit is set and cleared by
                                                     software. This bit is protected and can be written only
                                                     if EN is 0. Note: All MDMA destination accesses are non-cacheable.        */
    } bit;
  } MDMA_C11TCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000314) MDMA Channel x block number of data register               */
    
    struct {
      __IOM uint32 BNDT       : 17;           /*!< [16..0] block number of data to transfer                                  */
            uint32            : 1;
      __IOM uint32 BRSUM      : 1;            /*!< [18..18] Block Repeat Source address Update Mode These bits
                                                     are protected and can be written only if EN is 0.                         */
      __IOM uint32 BRDUM      : 1;            /*!< [19..19] Block Repeat Destination address Update Mode These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32 BRC        : 12;           /*!< [31..20] Block Repeat Count This field contains the number of
                                                     repetitions of the current block (0 to 4095). When the
                                                     channel is enabled, this register is read-only, indicating
                                                     the remaining number of blocks, excluding the current one.
                                                     This register decrements after each complete block transfer.
                                                     Once the last block transfer has completed, this register
                                                     can either stay at zero or be reloaded automatically from                 */
    } bit;
  } MDMA_C11BNDTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000318) MDMA channel x source address register                     */
    
    struct {
      __IOM uint32 SAR        : 32;           /*!< [31..0] source adr base                                                   */
    } bit;
  } MDMA_C11SAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000031C) MDMA channel x destination address register                */
    
    struct {
      __IOM uint32 DAR        : 32;           /*!< [31..0] Destination adr base                                              */
    } bit;
  } MDMA_C11DAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000320) MDMA channel x Block Repeat address Update register        */
    
    struct {
      __IOM uint32 SUV        : 16;           /*!< [15..0] source adresse update value                                       */
      __IOM uint32 DUV        : 16;           /*!< [31..16] destination address update                                       */
    } bit;
  } MDMA_C11BRUR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000324) MDMA channel x Link Address register                       */
    
    struct {
      __IOM uint32 LAR        : 32;           /*!< [31..0] Link address register                                             */
    } bit;
  } MDMA_C11LAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000328) MDMA channel x Trigger and Bus selection Register          */
    
    struct {
      __IOM uint32 TSEL       : 6;            /*!< [5..0] Trigger selection                                                  */
            uint32            : 10;
      __IOM uint32 SBUS       : 1;            /*!< [16..16] Source BUS select This bit is protected and can be
                                                     written only if EN is 0.                                                  */
      __IOM uint32 DBUS       : 1;            /*!< [17..17] Destination BUS slect This bit is protected and can
                                                     be written only if EN is 0.                                               */
            uint32            : 14;
    } bit;
  } MDMA_C11TBR;
  __IM  uint32  RESERVED23;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000330) MDMA channel x Mask address register                       */
    
    struct {
      __IOM uint32 MAR        : 32;           /*!< [31..0] Mask address                                                      */
    } bit;
  } MDMA_C11MAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000334) MDMA channel x Mask Data register                          */
    
    struct {
      __IOM uint32 MDR        : 32;           /*!< [31..0] Mask data                                                         */
    } bit;
  } MDMA_C11MDR;
  __IM  uint32  RESERVED24[2];
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000340) MDMA channel x interrupt/status register                   */
    
    struct {
      __IM  uint32 TEIF12     : 1;            /*!< [0..0] Channel x transfer error interrupt flag This bit is set
                                                     by hardware. It is cleared by software writing 1 to the
                                                     corresponding bit in the DMA_IFCRy register.                              */
      __IM  uint32 CTCIF12    : 1;            /*!< [1..1] Channel x Channel Transfer Complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register. CTC
                                                     is set when the last block was transferred and the channel
                                                     has been automatically disabled. CTC is also set when the
                                                     channel is suspended, as a result of writing EN bit to
                                                     0.                                                                        */
      __IM  uint32 BRTIF12    : 1;            /*!< [2..2] Channel x block repeat transfer complete interrupt flag
                                                     This bit is set by hardware. It is cleared by software
                                                     writing 1 to the corresponding bit in the DMA_IFCRy register.             */
      __IM  uint32 BTIF12     : 1;            /*!< [3..3] Channel x block transfer complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register.                     */
      __IM  uint32 TCIF12     : 1;            /*!< [4..4] channel x buffer transfer complete                                 */
            uint32            : 11;
      __IM  uint32 CRQA12     : 1;            /*!< [16..16] channel x request active flag                                    */
            uint32            : 15;
    } bit;
  } MDMA_C12ISR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000344) MDMA channel x interrupt flag clear register               */
    
    struct {
      __OM  uint32 CTEIF12    : 1;            /*!< [0..0] Channel x clear transfer error interrupt flag Writing
                                                     a 1 into this bit clears TEIFx in the MDMA_ISRy register                  */
      __OM  uint32 CCTCIF12   : 1;            /*!< [1..1] Clear Channel transfer complete interrupt flag for channel
                                                     x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CBRTIF12   : 1;            /*!< [2..2] Channel x clear block repeat transfer complete interrupt
                                                     flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CBTIF12    : 1;            /*!< [3..3] Channel x Clear block transfer complete interrupt flag
                                                     Writing a 1 into this bit clears BTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CLTCIF12   : 1;            /*!< [4..4] CLear buffer Transfer Complete Interrupt Flag for channel
                                                     x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy
                                                     register                                                                  */
            uint32            : 27;
    } bit;
  } MDMA_C12IFCR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000348) MDMA Channel x error status register                       */
    
    struct {
      __IM  uint32 TEA        : 7;            /*!< [6..0] Transfer Error Address These bits are set and cleared
                                                     by HW, in case of an MDMA data transfer error. It is used
                                                     in conjunction with TED. This field indicates the 7 LSBits
                                                     of the address which generated a transfer/access error.
                                                     It may be used by SW to retrieve the failing address, by
                                                     adding this value (truncated to the buffer transfer length
                                                     size) to the current SAR/DAR value. Note: The SAR/DAR                     */
      __IM  uint32 TED        : 1;            /*!< [7..7] Transfer Error Direction These bit is set and cleared
                                                     by HW, in case of an MDMA data transfer error.                            */
      __IM  uint32 TELD       : 1;            /*!< [8..8] Transfer Error Link Data These bit is set by HW, in case
                                                     of a transfer error while reading the block link data structure.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32 TEMD       : 1;            /*!< [9..9] Transfer Error Mask Data These bit is set by HW, in case
                                                     of a transfer error while writing the Mask Data. It is
                                                     cleared by software writing 1 to the CTEIFx bit in the
                                                     DMA_IFCRy register.                                                       */
      __IM  uint32 ASE        : 1;            /*!< [10..10] Address/Size Error These bit is set by HW, when the
                                                     programmed address is not aligned with the data size. TED
                                                     will indicate whether the problem is on the source or destination.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32 BSE        : 1;            /*!< [11..11] Block Size Error These bit is set by HW, when the block
                                                     size is not an integer multiple of the data size either
                                                     for source or destination. TED will indicate whether the
                                                     problem is on the source or destination. It is cleared
                                                     by software writing 1 to the CTEIFx bit in the DMA_IFCRy
                                                     register.                                                                 */
            uint32            : 20;
    } bit;
  } MDMA_C12ESR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000034C) This register is used to control the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32 EN         : 1;            /*!< [0..0] channel enable                                                     */
      __IOM uint32 TEIE       : 1;            /*!< [1..1] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 CTCIE      : 1;            /*!< [2..2] Channel Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32 BRTIE      : 1;            /*!< [3..3] Block Repeat transfer interrupt enable This bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32 BTIE       : 1;            /*!< [4..4] Block Transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 TCIE       : 1;            /*!< [5..5] buffer Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32 PL         : 2;            /*!< [7..6] Priority level These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0.                                                                     */
            uint32            : 4;
      __IOM uint32 BEX        : 1;            /*!< [12..12] byte Endianness exchange                                         */
      __IOM uint32 HEX        : 1;            /*!< [13..13] Half word Endianes exchange                                      */
      __IOM uint32 WEX        : 1;            /*!< [14..14] Word Endianness exchange                                         */
            uint32            : 1;
      __OM  uint32 SWRQ       : 1;            /*!< [16..16] SW ReQuest Writing a 1 into this bit sets the CRQAx
                                                     in MDMA_ISRy register, activating the request on Channel
                                                     x Note: Either the whole CxCR register or the 8-bit/16-bit
                                                     register @ Address offset: 0x4E + 0x40 chn may be used
                                                     for SWRQ activation. In case of a SW request, acknowledge
                                                     is not generated (neither HW signal, nor CxMAR write access).             */
            uint32            : 15;
    } bit;
  } MDMA_C12CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000350) This register is used to configure the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32 SINC       : 2;            /*!< [1..0] Source increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When source is AHB (SBUS=1), SINC
                                                     = 00 is forbidden. In Linked List Mode, at the end of a
                                                     block (single or last block in repeated block transfer
                                                     mode), this register will be loaded from memory (from address
                                                     given by current LAR[31:0] + 0x00).                                       */
      __IOM uint32 DINC       : 2;            /*!< [3..2] Destination increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When destination is AHB (DBUS=1),
                                                     DINC = 00 is forbidden.                                                   */
      __IOM uint32 SSIZE      : 2;            /*!< [5..4] Source data size These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0 Note: If a value of 11 is programmed for the TCM access/AHB
                                                     port, a transfer error will occur (TEIF bit set) If SINCOS
                                                     &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable.
                                                     Note: SSIZE = 11 (double-word) is forbidden when source
                                                     is TCM/AHB bus (SBUS=1).                                                  */
      __IOM uint32 DSIZE      : 2;            /*!< [7..6] Destination data size These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0. Note: If a value of 11 is programmed for
                                                     the TCM access/AHB port, a transfer error will occur (TEIF
                                                     bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the
                                                     result will be unpredictable. Note: DSIZE = 11 (double-word)
                                                     is forbidden when destination is TCM/AHB bus (                            */
      __IOM uint32 SINCOS     : 2;            /*!< [9..8] source increment offset size                                       */
      __IOM uint32 DINCOS     : 2;            /*!< [11..10] Destination increment offset                                     */
      __IOM uint32 SBURST     : 3;            /*!< [14..12] source burst transfer configuration                              */
      __IOM uint32 DBURST     : 3;            /*!< [17..15] Destination burst transfer configuration                         */
      __IOM uint32 TLEN       : 7;            /*!< [24..18] buffer transfer lengh                                            */
      __IOM uint32 PKE        : 1;            /*!< [25..25] PacK Enable These bit is set and cleared by software.
                                                     If the Source Size is smaller than the destination, it
                                                     will be padded according to the PAM value. If the Source
                                                     data size is larger than the destination one, it will be
                                                     truncated. The alignment will be done according to the
                                                     PAM[0] value. This bit is protected and can be written
                                                     only if EN is 0                                                           */
      __IOM uint32 PAM        : 2;            /*!< [27..26] Padding/Alignement Mode These bits are set and cleared
                                                     by software. Case 1: Source data size smaller than destination
                                                     data size - 3 options are valid. Case 2: Source data size
                                                     larger than destination data size. The remainder part is
                                                     discarded. When PKE = 1 or DSIZE=SSIZE, these bits are
                                                     ignored. These bits are protected and can be written only
                                                     if EN is 0                                                                */
      __IOM uint32 TRGM       : 2;            /*!< [29..28] Trigger Mode These bits are set and cleared by software.
                                                     Note: If TRGM is 11 for the current block, all the values
                                                     loaded at the end of the current block through the linked
                                                     list mechanism must keep the same value (TRGM=11) and the
                                                     same SWRM value, otherwise the result is undefined. These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32 SWRM       : 1;            /*!< [30..30] SW Request Mode This bit is set and cleared by software.
                                                     If a HW or SW request is currently active, the bit change
                                                     will be delayed until the current transfer is completed.
                                                     If the CxMAR contains a valid address, the CxMDR value
                                                     will also be written @ CxMAR address. This bit is protected
                                                     and can be written only if EN is 0.                                       */
      __IOM uint32 BWM        : 1;            /*!< [31..31] Bufferable Write Mode This bit is set and cleared by
                                                     software. This bit is protected and can be written only
                                                     if EN is 0. Note: All MDMA destination accesses are non-cacheable.        */
    } bit;
  } MDMA_C12TCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000354) MDMA Channel x block number of data register               */
    
    struct {
      __IOM uint32 BNDT       : 17;           /*!< [16..0] block number of data to transfer                                  */
            uint32            : 1;
      __IOM uint32 BRSUM      : 1;            /*!< [18..18] Block Repeat Source address Update Mode These bits
                                                     are protected and can be written only if EN is 0.                         */
      __IOM uint32 BRDUM      : 1;            /*!< [19..19] Block Repeat Destination address Update Mode These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32 BRC        : 12;           /*!< [31..20] Block Repeat Count This field contains the number of
                                                     repetitions of the current block (0 to 4095). When the
                                                     channel is enabled, this register is read-only, indicating
                                                     the remaining number of blocks, excluding the current one.
                                                     This register decrements after each complete block transfer.
                                                     Once the last block transfer has completed, this register
                                                     can either stay at zero or be reloaded automatically from                 */
    } bit;
  } MDMA_C12BNDTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000358) MDMA channel x source address register                     */
    
    struct {
      __IOM uint32 SAR        : 32;           /*!< [31..0] source adr base                                                   */
    } bit;
  } MDMA_C12SAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000035C) MDMA channel x destination address register                */
    
    struct {
      __IOM uint32 DAR        : 32;           /*!< [31..0] Destination adr base                                              */
    } bit;
  } MDMA_C12DAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000360) MDMA channel x Block Repeat address Update register        */
    
    struct {
      __IOM uint32 SUV        : 16;           /*!< [15..0] source adresse update value                                       */
      __IOM uint32 DUV        : 16;           /*!< [31..16] destination address update                                       */
    } bit;
  } MDMA_C12BRUR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000364) MDMA channel x Link Address register                       */
    
    struct {
      __IOM uint32 LAR        : 32;           /*!< [31..0] Link address register                                             */
    } bit;
  } MDMA_C12LAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000368) MDMA channel x Trigger and Bus selection Register          */
    
    struct {
      __IOM uint32 TSEL       : 6;            /*!< [5..0] Trigger selection                                                  */
            uint32            : 10;
      __IOM uint32 SBUS       : 1;            /*!< [16..16] Source BUS select This bit is protected and can be
                                                     written only if EN is 0.                                                  */
      __IOM uint32 DBUS       : 1;            /*!< [17..17] Destination BUS slect This bit is protected and can
                                                     be written only if EN is 0.                                               */
            uint32            : 14;
    } bit;
  } MDMA_C12TBR;
  __IM  uint32  RESERVED25;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000370) MDMA channel x Mask address register                       */
    
    struct {
      __IOM uint32 MAR        : 32;           /*!< [31..0] Mask address                                                      */
    } bit;
  } MDMA_C12MAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000374) MDMA channel x Mask Data register                          */
    
    struct {
      __IOM uint32 MDR        : 32;           /*!< [31..0] Mask data                                                         */
    } bit;
  } MDMA_C12MDR;
  __IM  uint32  RESERVED26[2];
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000380) MDMA channel x interrupt/status register                   */
    
    struct {
      __IM  uint32 TEIF13     : 1;            /*!< [0..0] Channel x transfer error interrupt flag This bit is set
                                                     by hardware. It is cleared by software writing 1 to the
                                                     corresponding bit in the DMA_IFCRy register.                              */
      __IM  uint32 CTCIF13    : 1;            /*!< [1..1] Channel x Channel Transfer Complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register. CTC
                                                     is set when the last block was transferred and the channel
                                                     has been automatically disabled. CTC is also set when the
                                                     channel is suspended, as a result of writing EN bit to
                                                     0.                                                                        */
      __IM  uint32 BRTIF13    : 1;            /*!< [2..2] Channel x block repeat transfer complete interrupt flag
                                                     This bit is set by hardware. It is cleared by software
                                                     writing 1 to the corresponding bit in the DMA_IFCRy register.             */
      __IM  uint32 BTIF13     : 1;            /*!< [3..3] Channel x block transfer complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register.                     */
      __IM  uint32 TCIF13     : 1;            /*!< [4..4] channel x buffer transfer complete                                 */
            uint32            : 11;
      __IM  uint32 CRQA13     : 1;            /*!< [16..16] channel x request active flag                                    */
            uint32            : 15;
    } bit;
  } MDMA_C13ISR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000384) MDMA channel x interrupt flag clear register               */
    
    struct {
      __OM  uint32 CTEIF13    : 1;            /*!< [0..0] Channel x clear transfer error interrupt flag Writing
                                                     a 1 into this bit clears TEIFx in the MDMA_ISRy register                  */
      __OM  uint32 CCTCIF13   : 1;            /*!< [1..1] Clear Channel transfer complete interrupt flag for channel
                                                     x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CBRTIF13   : 1;            /*!< [2..2] Channel x clear block repeat transfer complete interrupt
                                                     flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CBTIF13    : 1;            /*!< [3..3] Channel x Clear block transfer complete interrupt flag
                                                     Writing a 1 into this bit clears BTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CLTCIF13   : 1;            /*!< [4..4] CLear buffer Transfer Complete Interrupt Flag for channel
                                                     x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy
                                                     register                                                                  */
            uint32            : 27;
    } bit;
  } MDMA_C13IFCR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000388) MDMA Channel x error status register                       */
    
    struct {
      __IM  uint32 TEA        : 7;            /*!< [6..0] Transfer Error Address These bits are set and cleared
                                                     by HW, in case of an MDMA data transfer error. It is used
                                                     in conjunction with TED. This field indicates the 7 LSBits
                                                     of the address which generated a transfer/access error.
                                                     It may be used by SW to retrieve the failing address, by
                                                     adding this value (truncated to the buffer transfer length
                                                     size) to the current SAR/DAR value. Note: The SAR/DAR                     */
      __IM  uint32 TED        : 1;            /*!< [7..7] Transfer Error Direction These bit is set and cleared
                                                     by HW, in case of an MDMA data transfer error.                            */
      __IM  uint32 TELD       : 1;            /*!< [8..8] Transfer Error Link Data These bit is set by HW, in case
                                                     of a transfer error while reading the block link data structure.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32 TEMD       : 1;            /*!< [9..9] Transfer Error Mask Data These bit is set by HW, in case
                                                     of a transfer error while writing the Mask Data. It is
                                                     cleared by software writing 1 to the CTEIFx bit in the
                                                     DMA_IFCRy register.                                                       */
      __IM  uint32 ASE        : 1;            /*!< [10..10] Address/Size Error These bit is set by HW, when the
                                                     programmed address is not aligned with the data size. TED
                                                     will indicate whether the problem is on the source or destination.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32 BSE        : 1;            /*!< [11..11] Block Size Error These bit is set by HW, when the block
                                                     size is not an integer multiple of the data size either
                                                     for source or destination. TED will indicate whether the
                                                     problem is on the source or destination. It is cleared
                                                     by software writing 1 to the CTEIFx bit in the DMA_IFCRy
                                                     register.                                                                 */
            uint32            : 20;
    } bit;
  } MDMA_C13ESR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000038C) This register is used to control the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32 EN         : 1;            /*!< [0..0] channel enable                                                     */
      __IOM uint32 TEIE       : 1;            /*!< [1..1] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 CTCIE      : 1;            /*!< [2..2] Channel Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32 BRTIE      : 1;            /*!< [3..3] Block Repeat transfer interrupt enable This bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32 BTIE       : 1;            /*!< [4..4] Block Transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 TCIE       : 1;            /*!< [5..5] buffer Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32 PL         : 2;            /*!< [7..6] Priority level These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0.                                                                     */
            uint32            : 4;
      __IOM uint32 BEX        : 1;            /*!< [12..12] byte Endianness exchange                                         */
      __IOM uint32 HEX        : 1;            /*!< [13..13] Half word Endianes exchange                                      */
      __IOM uint32 WEX        : 1;            /*!< [14..14] Word Endianness exchange                                         */
            uint32            : 1;
      __OM  uint32 SWRQ       : 1;            /*!< [16..16] SW ReQuest Writing a 1 into this bit sets the CRQAx
                                                     in MDMA_ISRy register, activating the request on Channel
                                                     x Note: Either the whole CxCR register or the 8-bit/16-bit
                                                     register @ Address offset: 0x4E + 0x40 chn may be used
                                                     for SWRQ activation. In case of a SW request, acknowledge
                                                     is not generated (neither HW signal, nor CxMAR write access).             */
            uint32            : 15;
    } bit;
  } MDMA_C13CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000390) This register is used to configure the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32 SINC       : 2;            /*!< [1..0] Source increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When source is AHB (SBUS=1), SINC
                                                     = 00 is forbidden. In Linked List Mode, at the end of a
                                                     block (single or last block in repeated block transfer
                                                     mode), this register will be loaded from memory (from address
                                                     given by current LAR[31:0] + 0x00).                                       */
      __IOM uint32 DINC       : 2;            /*!< [3..2] Destination increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When destination is AHB (DBUS=1),
                                                     DINC = 00 is forbidden.                                                   */
      __IOM uint32 SSIZE      : 2;            /*!< [5..4] Source data size These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0 Note: If a value of 11 is programmed for the TCM access/AHB
                                                     port, a transfer error will occur (TEIF bit set) If SINCOS
                                                     &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable.
                                                     Note: SSIZE = 11 (double-word) is forbidden when source
                                                     is TCM/AHB bus (SBUS=1).                                                  */
      __IOM uint32 DSIZE      : 2;            /*!< [7..6] Destination data size These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0. Note: If a value of 11 is programmed for
                                                     the TCM access/AHB port, a transfer error will occur (TEIF
                                                     bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the
                                                     result will be unpredictable. Note: DSIZE = 11 (double-word)
                                                     is forbidden when destination is TCM/AHB bus (                            */
      __IOM uint32 SINCOS     : 2;            /*!< [9..8] source increment offset size                                       */
      __IOM uint32 DINCOS     : 2;            /*!< [11..10] Destination increment offset                                     */
      __IOM uint32 SBURST     : 3;            /*!< [14..12] source burst transfer configuration                              */
      __IOM uint32 DBURST     : 3;            /*!< [17..15] Destination burst transfer configuration                         */
      __IOM uint32 TLEN       : 7;            /*!< [24..18] buffer transfer lengh                                            */
      __IOM uint32 PKE        : 1;            /*!< [25..25] PacK Enable These bit is set and cleared by software.
                                                     If the Source Size is smaller than the destination, it
                                                     will be padded according to the PAM value. If the Source
                                                     data size is larger than the destination one, it will be
                                                     truncated. The alignment will be done according to the
                                                     PAM[0] value. This bit is protected and can be written
                                                     only if EN is 0                                                           */
      __IOM uint32 PAM        : 2;            /*!< [27..26] Padding/Alignement Mode These bits are set and cleared
                                                     by software. Case 1: Source data size smaller than destination
                                                     data size - 3 options are valid. Case 2: Source data size
                                                     larger than destination data size. The remainder part is
                                                     discarded. When PKE = 1 or DSIZE=SSIZE, these bits are
                                                     ignored. These bits are protected and can be written only
                                                     if EN is 0                                                                */
      __IOM uint32 TRGM       : 2;            /*!< [29..28] Trigger Mode These bits are set and cleared by software.
                                                     Note: If TRGM is 11 for the current block, all the values
                                                     loaded at the end of the current block through the linked
                                                     list mechanism must keep the same value (TRGM=11) and the
                                                     same SWRM value, otherwise the result is undefined. These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32 SWRM       : 1;            /*!< [30..30] SW Request Mode This bit is set and cleared by software.
                                                     If a HW or SW request is currently active, the bit change
                                                     will be delayed until the current transfer is completed.
                                                     If the CxMAR contains a valid address, the CxMDR value
                                                     will also be written @ CxMAR address. This bit is protected
                                                     and can be written only if EN is 0.                                       */
      __IOM uint32 BWM        : 1;            /*!< [31..31] Bufferable Write Mode This bit is set and cleared by
                                                     software. This bit is protected and can be written only
                                                     if EN is 0. Note: All MDMA destination accesses are non-cacheable.        */
    } bit;
  } MDMA_C13TCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000394) MDMA Channel x block number of data register               */
    
    struct {
      __IOM uint32 BNDT       : 17;           /*!< [16..0] block number of data to transfer                                  */
            uint32            : 1;
      __IOM uint32 BRSUM      : 1;            /*!< [18..18] Block Repeat Source address Update Mode These bits
                                                     are protected and can be written only if EN is 0.                         */
      __IOM uint32 BRDUM      : 1;            /*!< [19..19] Block Repeat Destination address Update Mode These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32 BRC        : 12;           /*!< [31..20] Block Repeat Count This field contains the number of
                                                     repetitions of the current block (0 to 4095). When the
                                                     channel is enabled, this register is read-only, indicating
                                                     the remaining number of blocks, excluding the current one.
                                                     This register decrements after each complete block transfer.
                                                     Once the last block transfer has completed, this register
                                                     can either stay at zero or be reloaded automatically from                 */
    } bit;
  } MDMA_C13BNDTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000398) MDMA channel x source address register                     */
    
    struct {
      __IOM uint32 SAR        : 32;           /*!< [31..0] source adr base                                                   */
    } bit;
  } MDMA_C13SAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000039C) MDMA channel x destination address register                */
    
    struct {
      __IOM uint32 DAR        : 32;           /*!< [31..0] Destination adr base                                              */
    } bit;
  } MDMA_C13DAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000003A0) MDMA channel x Block Repeat address Update register        */
    
    struct {
      __IOM uint32 SUV        : 16;           /*!< [15..0] source adresse update value                                       */
      __IOM uint32 DUV        : 16;           /*!< [31..16] destination address update                                       */
    } bit;
  } MDMA_C13BRUR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000003A4) MDMA channel x Link Address register                       */
    
    struct {
      __IOM uint32 LAR        : 32;           /*!< [31..0] Link address register                                             */
    } bit;
  } MDMA_C13LAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000003A8) MDMA channel x Trigger and Bus selection Register          */
    
    struct {
      __IOM uint32 TSEL       : 6;            /*!< [5..0] Trigger selection                                                  */
            uint32            : 10;
      __IOM uint32 SBUS       : 1;            /*!< [16..16] Source BUS select This bit is protected and can be
                                                     written only if EN is 0.                                                  */
      __IOM uint32 DBUS       : 1;            /*!< [17..17] Destination BUS slect This bit is protected and can
                                                     be written only if EN is 0.                                               */
            uint32            : 14;
    } bit;
  } MDMA_C13TBR;
  __IM  uint32  RESERVED27;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000003B0) MDMA channel x Mask address register                       */
    
    struct {
      __IOM uint32 MAR        : 32;           /*!< [31..0] Mask address                                                      */
    } bit;
  } MDMA_C13MAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000003B4) MDMA channel x Mask Data register                          */
    
    struct {
      __IOM uint32 MDR        : 32;           /*!< [31..0] Mask data                                                         */
    } bit;
  } MDMA_C13MDR;
  __IM  uint32  RESERVED28[2];
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000003C0) MDMA channel x interrupt/status register                   */
    
    struct {
      __IM  uint32 TEIF14     : 1;            /*!< [0..0] Channel x transfer error interrupt flag This bit is set
                                                     by hardware. It is cleared by software writing 1 to the
                                                     corresponding bit in the DMA_IFCRy register.                              */
      __IM  uint32 CTCIF14    : 1;            /*!< [1..1] Channel x Channel Transfer Complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register. CTC
                                                     is set when the last block was transferred and the channel
                                                     has been automatically disabled. CTC is also set when the
                                                     channel is suspended, as a result of writing EN bit to
                                                     0.                                                                        */
      __IM  uint32 BRTIF14    : 1;            /*!< [2..2] Channel x block repeat transfer complete interrupt flag
                                                     This bit is set by hardware. It is cleared by software
                                                     writing 1 to the corresponding bit in the DMA_IFCRy register.             */
      __IM  uint32 BTIF14     : 1;            /*!< [3..3] Channel x block transfer complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register.                     */
      __IM  uint32 TCIF14     : 1;            /*!< [4..4] channel x buffer transfer complete                                 */
            uint32            : 11;
      __IM  uint32 CRQA14     : 1;            /*!< [16..16] channel x request active flag                                    */
            uint32            : 15;
    } bit;
  } MDMA_C14ISR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x000003C4) MDMA channel x interrupt flag clear register               */
    
    struct {
      __OM  uint32 CTEIF14    : 1;            /*!< [0..0] Channel x clear transfer error interrupt flag Writing
                                                     a 1 into this bit clears TEIFx in the MDMA_ISRy register                  */
      __OM  uint32 CCTCIF14   : 1;            /*!< [1..1] Clear Channel transfer complete interrupt flag for channel
                                                     x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CBRTIF14   : 1;            /*!< [2..2] Channel x clear block repeat transfer complete interrupt
                                                     flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CBTIF14    : 1;            /*!< [3..3] Channel x Clear block transfer complete interrupt flag
                                                     Writing a 1 into this bit clears BTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CLTCIF14   : 1;            /*!< [4..4] CLear buffer Transfer Complete Interrupt Flag for channel
                                                     x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy
                                                     register                                                                  */
            uint32            : 27;
    } bit;
  } MDMA_C14IFCR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000003C8) MDMA Channel x error status register                       */
    
    struct {
      __IM  uint32 TEA        : 7;            /*!< [6..0] Transfer Error Address These bits are set and cleared
                                                     by HW, in case of an MDMA data transfer error. It is used
                                                     in conjunction with TED. This field indicates the 7 LSBits
                                                     of the address which generated a transfer/access error.
                                                     It may be used by SW to retrieve the failing address, by
                                                     adding this value (truncated to the buffer transfer length
                                                     size) to the current SAR/DAR value. Note: The SAR/DAR                     */
      __IM  uint32 TED        : 1;            /*!< [7..7] Transfer Error Direction These bit is set and cleared
                                                     by HW, in case of an MDMA data transfer error.                            */
      __IM  uint32 TELD       : 1;            /*!< [8..8] Transfer Error Link Data These bit is set by HW, in case
                                                     of a transfer error while reading the block link data structure.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32 TEMD       : 1;            /*!< [9..9] Transfer Error Mask Data These bit is set by HW, in case
                                                     of a transfer error while writing the Mask Data. It is
                                                     cleared by software writing 1 to the CTEIFx bit in the
                                                     DMA_IFCRy register.                                                       */
      __IM  uint32 ASE        : 1;            /*!< [10..10] Address/Size Error These bit is set by HW, when the
                                                     programmed address is not aligned with the data size. TED
                                                     will indicate whether the problem is on the source or destination.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32 BSE        : 1;            /*!< [11..11] Block Size Error These bit is set by HW, when the block
                                                     size is not an integer multiple of the data size either
                                                     for source or destination. TED will indicate whether the
                                                     problem is on the source or destination. It is cleared
                                                     by software writing 1 to the CTEIFx bit in the DMA_IFCRy
                                                     register.                                                                 */
            uint32            : 20;
    } bit;
  } MDMA_C14ESR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000003CC) This register is used to control the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32 EN         : 1;            /*!< [0..0] channel enable                                                     */
      __IOM uint32 TEIE       : 1;            /*!< [1..1] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 CTCIE      : 1;            /*!< [2..2] Channel Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32 BRTIE      : 1;            /*!< [3..3] Block Repeat transfer interrupt enable This bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32 BTIE       : 1;            /*!< [4..4] Block Transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 TCIE       : 1;            /*!< [5..5] buffer Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32 PL         : 2;            /*!< [7..6] Priority level These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0.                                                                     */
            uint32            : 4;
      __IOM uint32 BEX        : 1;            /*!< [12..12] byte Endianness exchange                                         */
      __IOM uint32 HEX        : 1;            /*!< [13..13] Half word Endianes exchange                                      */
      __IOM uint32 WEX        : 1;            /*!< [14..14] Word Endianness exchange                                         */
            uint32            : 1;
      __OM  uint32 SWRQ       : 1;            /*!< [16..16] SW ReQuest Writing a 1 into this bit sets the CRQAx
                                                     in MDMA_ISRy register, activating the request on Channel
                                                     x Note: Either the whole CxCR register or the 8-bit/16-bit
                                                     register @ Address offset: 0x4E + 0x40 chn may be used
                                                     for SWRQ activation. In case of a SW request, acknowledge
                                                     is not generated (neither HW signal, nor CxMAR write access).             */
            uint32            : 15;
    } bit;
  } MDMA_C14CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000003D0) This register is used to configure the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32 SINC       : 2;            /*!< [1..0] Source increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When source is AHB (SBUS=1), SINC
                                                     = 00 is forbidden. In Linked List Mode, at the end of a
                                                     block (single or last block in repeated block transfer
                                                     mode), this register will be loaded from memory (from address
                                                     given by current LAR[31:0] + 0x00).                                       */
      __IOM uint32 DINC       : 2;            /*!< [3..2] Destination increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When destination is AHB (DBUS=1),
                                                     DINC = 00 is forbidden.                                                   */
      __IOM uint32 SSIZE      : 2;            /*!< [5..4] Source data size These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0 Note: If a value of 11 is programmed for the TCM access/AHB
                                                     port, a transfer error will occur (TEIF bit set) If SINCOS
                                                     &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable.
                                                     Note: SSIZE = 11 (double-word) is forbidden when source
                                                     is TCM/AHB bus (SBUS=1).                                                  */
      __IOM uint32 DSIZE      : 2;            /*!< [7..6] Destination data size These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0. Note: If a value of 11 is programmed for
                                                     the TCM access/AHB port, a transfer error will occur (TEIF
                                                     bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the
                                                     result will be unpredictable. Note: DSIZE = 11 (double-word)
                                                     is forbidden when destination is TCM/AHB bus (                            */
      __IOM uint32 SINCOS     : 2;            /*!< [9..8] source increment offset size                                       */
      __IOM uint32 DINCOS     : 2;            /*!< [11..10] Destination increment offset                                     */
      __IOM uint32 SBURST     : 3;            /*!< [14..12] source burst transfer configuration                              */
      __IOM uint32 DBURST     : 3;            /*!< [17..15] Destination burst transfer configuration                         */
      __IOM uint32 TLEN       : 7;            /*!< [24..18] buffer transfer lengh                                            */
      __IOM uint32 PKE        : 1;            /*!< [25..25] PacK Enable These bit is set and cleared by software.
                                                     If the Source Size is smaller than the destination, it
                                                     will be padded according to the PAM value. If the Source
                                                     data size is larger than the destination one, it will be
                                                     truncated. The alignment will be done according to the
                                                     PAM[0] value. This bit is protected and can be written
                                                     only if EN is 0                                                           */
      __IOM uint32 PAM        : 2;            /*!< [27..26] Padding/Alignement Mode These bits are set and cleared
                                                     by software. Case 1: Source data size smaller than destination
                                                     data size - 3 options are valid. Case 2: Source data size
                                                     larger than destination data size. The remainder part is
                                                     discarded. When PKE = 1 or DSIZE=SSIZE, these bits are
                                                     ignored. These bits are protected and can be written only
                                                     if EN is 0                                                                */
      __IOM uint32 TRGM       : 2;            /*!< [29..28] Trigger Mode These bits are set and cleared by software.
                                                     Note: If TRGM is 11 for the current block, all the values
                                                     loaded at the end of the current block through the linked
                                                     list mechanism must keep the same value (TRGM=11) and the
                                                     same SWRM value, otherwise the result is undefined. These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32 SWRM       : 1;            /*!< [30..30] SW Request Mode This bit is set and cleared by software.
                                                     If a HW or SW request is currently active, the bit change
                                                     will be delayed until the current transfer is completed.
                                                     If the CxMAR contains a valid address, the CxMDR value
                                                     will also be written @ CxMAR address. This bit is protected
                                                     and can be written only if EN is 0.                                       */
      __IOM uint32 BWM        : 1;            /*!< [31..31] Bufferable Write Mode This bit is set and cleared by
                                                     software. This bit is protected and can be written only
                                                     if EN is 0. Note: All MDMA destination accesses are non-cacheable.        */
    } bit;
  } MDMA_C14TCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000003D4) MDMA Channel x block number of data register               */
    
    struct {
      __IOM uint32 BNDT       : 17;           /*!< [16..0] block number of data to transfer                                  */
            uint32            : 1;
      __IOM uint32 BRSUM      : 1;            /*!< [18..18] Block Repeat Source address Update Mode These bits
                                                     are protected and can be written only if EN is 0.                         */
      __IOM uint32 BRDUM      : 1;            /*!< [19..19] Block Repeat Destination address Update Mode These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32 BRC        : 12;           /*!< [31..20] Block Repeat Count This field contains the number of
                                                     repetitions of the current block (0 to 4095). When the
                                                     channel is enabled, this register is read-only, indicating
                                                     the remaining number of blocks, excluding the current one.
                                                     This register decrements after each complete block transfer.
                                                     Once the last block transfer has completed, this register
                                                     can either stay at zero or be reloaded automatically from                 */
    } bit;
  } MDMA_C14BNDTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000003D8) MDMA channel x source address register                     */
    
    struct {
      __IOM uint32 SAR        : 32;           /*!< [31..0] source adr base                                                   */
    } bit;
  } MDMA_C14SAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000003DC) MDMA channel x destination address register                */
    
    struct {
      __IOM uint32 DAR        : 32;           /*!< [31..0] Destination adr base                                              */
    } bit;
  } MDMA_C14DAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000003E0) MDMA channel x Block Repeat address Update register        */
    
    struct {
      __IOM uint32 SUV        : 16;           /*!< [15..0] source adresse update value                                       */
      __IOM uint32 DUV        : 16;           /*!< [31..16] destination address update                                       */
    } bit;
  } MDMA_C14BRUR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000003E4) MDMA channel x Link Address register                       */
    
    struct {
      __IOM uint32 LAR        : 32;           /*!< [31..0] Link address register                                             */
    } bit;
  } MDMA_C14LAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000003E8) MDMA channel x Trigger and Bus selection Register          */
    
    struct {
      __IOM uint32 TSEL       : 6;            /*!< [5..0] Trigger selection                                                  */
            uint32            : 10;
      __IOM uint32 SBUS       : 1;            /*!< [16..16] Source BUS select This bit is protected and can be
                                                     written only if EN is 0.                                                  */
      __IOM uint32 DBUS       : 1;            /*!< [17..17] Destination BUS slect This bit is protected and can
                                                     be written only if EN is 0.                                               */
            uint32            : 14;
    } bit;
  } MDMA_C14TBR;
  __IM  uint32  RESERVED29;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000003F0) MDMA channel x Mask address register                       */
    
    struct {
      __IOM uint32 MAR        : 32;           /*!< [31..0] Mask address                                                      */
    } bit;
  } MDMA_C14MAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000003F4) MDMA channel x Mask Data register                          */
    
    struct {
      __IOM uint32 MDR        : 32;           /*!< [31..0] Mask data                                                         */
    } bit;
  } MDMA_C14MDR;
  __IM  uint32  RESERVED30[2];
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000400) MDMA channel x interrupt/status register                   */
    
    struct {
      __IM  uint32 TEIF15     : 1;            /*!< [0..0] Channel x transfer error interrupt flag This bit is set
                                                     by hardware. It is cleared by software writing 1 to the
                                                     corresponding bit in the DMA_IFCRy register.                              */
      __IM  uint32 CTCIF15    : 1;            /*!< [1..1] Channel x Channel Transfer Complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register. CTC
                                                     is set when the last block was transferred and the channel
                                                     has been automatically disabled. CTC is also set when the
                                                     channel is suspended, as a result of writing EN bit to
                                                     0.                                                                        */
      __IM  uint32 BRTIF15    : 1;            /*!< [2..2] Channel x block repeat transfer complete interrupt flag
                                                     This bit is set by hardware. It is cleared by software
                                                     writing 1 to the corresponding bit in the DMA_IFCRy register.             */
      __IM  uint32 BTIF15     : 1;            /*!< [3..3] Channel x block transfer complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register.                     */
      __IM  uint32 TCIF15     : 1;            /*!< [4..4] channel x buffer transfer complete                                 */
            uint32            : 11;
      __IM  uint32 CRQA15     : 1;            /*!< [16..16] channel x request active flag                                    */
            uint32            : 15;
    } bit;
  } MDMA_C15ISR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000404) MDMA channel x interrupt flag clear register               */
    
    struct {
      __OM  uint32 CTEIF15    : 1;            /*!< [0..0] Channel x clear transfer error interrupt flag Writing
                                                     a 1 into this bit clears TEIFx in the MDMA_ISRy register                  */
      __OM  uint32 CCTCIF15   : 1;            /*!< [1..1] Clear Channel transfer complete interrupt flag for channel
                                                     x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CBRTIF15   : 1;            /*!< [2..2] Channel x clear block repeat transfer complete interrupt
                                                     flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CBTIF15    : 1;            /*!< [3..3] Channel x Clear block transfer complete interrupt flag
                                                     Writing a 1 into this bit clears BTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32 CLTCIF15   : 1;            /*!< [4..4] CLear buffer Transfer Complete Interrupt Flag for channel
                                                     x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy
                                                     register                                                                  */
            uint32            : 27;
    } bit;
  } MDMA_C15IFCR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000408) MDMA Channel x error status register                       */
    
    struct {
      __IM  uint32 TEA        : 7;            /*!< [6..0] Transfer Error Address These bits are set and cleared
                                                     by HW, in case of an MDMA data transfer error. It is used
                                                     in conjunction with TED. This field indicates the 7 LSBits
                                                     of the address which generated a transfer/access error.
                                                     It may be used by SW to retrieve the failing address, by
                                                     adding this value (truncated to the buffer transfer length
                                                     size) to the current SAR/DAR value. Note: The SAR/DAR                     */
      __IM  uint32 TED        : 1;            /*!< [7..7] Transfer Error Direction These bit is set and cleared
                                                     by HW, in case of an MDMA data transfer error.                            */
      __IM  uint32 TELD       : 1;            /*!< [8..8] Transfer Error Link Data These bit is set by HW, in case
                                                     of a transfer error while reading the block link data structure.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32 TEMD       : 1;            /*!< [9..9] Transfer Error Mask Data These bit is set by HW, in case
                                                     of a transfer error while writing the Mask Data. It is
                                                     cleared by software writing 1 to the CTEIFx bit in the
                                                     DMA_IFCRy register.                                                       */
      __IM  uint32 ASE        : 1;            /*!< [10..10] Address/Size Error These bit is set by HW, when the
                                                     programmed address is not aligned with the data size. TED
                                                     will indicate whether the problem is on the source or destination.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32 BSE        : 1;            /*!< [11..11] Block Size Error These bit is set by HW, when the block
                                                     size is not an integer multiple of the data size either
                                                     for source or destination. TED will indicate whether the
                                                     problem is on the source or destination. It is cleared
                                                     by software writing 1 to the CTEIFx bit in the DMA_IFCRy
                                                     register.                                                                 */
            uint32            : 20;
    } bit;
  } MDMA_C15ESR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000040C) This register is used to control the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32 EN         : 1;            /*!< [0..0] channel enable                                                     */
      __IOM uint32 TEIE       : 1;            /*!< [1..1] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 CTCIE      : 1;            /*!< [2..2] Channel Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32 BRTIE      : 1;            /*!< [3..3] Block Repeat transfer interrupt enable This bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32 BTIE       : 1;            /*!< [4..4] Block Transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32 TCIE       : 1;            /*!< [5..5] buffer Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32 PL         : 2;            /*!< [7..6] Priority level These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0.                                                                     */
            uint32            : 4;
      __IOM uint32 BEX        : 1;            /*!< [12..12] byte Endianness exchange                                         */
      __IOM uint32 HEX        : 1;            /*!< [13..13] Half word Endianes exchange                                      */
      __IOM uint32 WEX        : 1;            /*!< [14..14] Word Endianness exchange                                         */
            uint32            : 1;
      __OM  uint32 SWRQ       : 1;            /*!< [16..16] SW ReQuest Writing a 1 into this bit sets the CRQAx
                                                     in MDMA_ISRy register, activating the request on Channel
                                                     x Note: Either the whole CxCR register or the 8-bit/16-bit
                                                     register @ Address offset: 0x4E + 0x40 chn may be used
                                                     for SWRQ activation. In case of a SW request, acknowledge
                                                     is not generated (neither HW signal, nor CxMAR write access).             */
            uint32            : 15;
    } bit;
  } MDMA_C15CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000410) This register is used to configure the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32 SINC       : 2;            /*!< [1..0] Source increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When source is AHB (SBUS=1), SINC
                                                     = 00 is forbidden. In Linked List Mode, at the end of a
                                                     block (single or last block in repeated block transfer
                                                     mode), this register will be loaded from memory (from address
                                                     given by current LAR[31:0] + 0x00).                                       */
      __IOM uint32 DINC       : 2;            /*!< [3..2] Destination increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When destination is AHB (DBUS=1),
                                                     DINC = 00 is forbidden.                                                   */
      __IOM uint32 SSIZE      : 2;            /*!< [5..4] Source data size These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0 Note: If a value of 11 is programmed for the TCM access/AHB
                                                     port, a transfer error will occur (TEIF bit set) If SINCOS
                                                     &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable.
                                                     Note: SSIZE = 11 (double-word) is forbidden when source
                                                     is TCM/AHB bus (SBUS=1).                                                  */
      __IOM uint32 DSIZE      : 2;            /*!< [7..6] Destination data size These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0. Note: If a value of 11 is programmed for
                                                     the TCM access/AHB port, a transfer error will occur (TEIF
                                                     bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the
                                                     result will be unpredictable. Note: DSIZE = 11 (double-word)
                                                     is forbidden when destination is TCM/AHB bus (                            */
      __IOM uint32 SINCOS     : 2;            /*!< [9..8] source increment offset size                                       */
      __IOM uint32 DINCOS     : 2;            /*!< [11..10] Destination increment offset                                     */
      __IOM uint32 SBURST     : 3;            /*!< [14..12] source burst transfer configuration                              */
      __IOM uint32 DBURST     : 3;            /*!< [17..15] Destination burst transfer configuration                         */
      __IOM uint32 TLEN       : 7;            /*!< [24..18] buffer transfer lengh                                            */
      __IOM uint32 PKE        : 1;            /*!< [25..25] PacK Enable These bit is set and cleared by software.
                                                     If the Source Size is smaller than the destination, it
                                                     will be padded according to the PAM value. If the Source
                                                     data size is larger than the destination one, it will be
                                                     truncated. The alignment will be done according to the
                                                     PAM[0] value. This bit is protected and can be written
                                                     only if EN is 0                                                           */
      __IOM uint32 PAM        : 2;            /*!< [27..26] Padding/Alignement Mode These bits are set and cleared
                                                     by software. Case 1: Source data size smaller than destination
                                                     data size - 3 options are valid. Case 2: Source data size
                                                     larger than destination data size. The remainder part is
                                                     discarded. When PKE = 1 or DSIZE=SSIZE, these bits are
                                                     ignored. These bits are protected and can be written only
                                                     if EN is 0                                                                */
      __IOM uint32 TRGM       : 2;            /*!< [29..28] Trigger Mode These bits are set and cleared by software.
                                                     Note: If TRGM is 11 for the current block, all the values
                                                     loaded at the end of the current block through the linked
                                                     list mechanism must keep the same value (TRGM=11) and the
                                                     same SWRM value, otherwise the result is undefined. These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32 SWRM       : 1;            /*!< [30..30] SW Request Mode This bit is set and cleared by software.
                                                     If a HW or SW request is currently active, the bit change
                                                     will be delayed until the current transfer is completed.
                                                     If the CxMAR contains a valid address, the CxMDR value
                                                     will also be written @ CxMAR address. This bit is protected
                                                     and can be written only if EN is 0.                                       */
      __IOM uint32 BWM        : 1;            /*!< [31..31] Bufferable Write Mode This bit is set and cleared by
                                                     software. This bit is protected and can be written only
                                                     if EN is 0. Note: All MDMA destination accesses are non-cacheable.        */
    } bit;
  } MDMA_C15TCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000414) MDMA Channel x block number of data register               */
    
    struct {
      __IOM uint32 BNDT       : 17;           /*!< [16..0] block number of data to transfer                                  */
            uint32            : 1;
      __IOM uint32 BRSUM      : 1;            /*!< [18..18] Block Repeat Source address Update Mode These bits
                                                     are protected and can be written only if EN is 0.                         */
      __IOM uint32 BRDUM      : 1;            /*!< [19..19] Block Repeat Destination address Update Mode These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32 BRC        : 12;           /*!< [31..20] Block Repeat Count This field contains the number of
                                                     repetitions of the current block (0 to 4095). When the
                                                     channel is enabled, this register is read-only, indicating
                                                     the remaining number of blocks, excluding the current one.
                                                     This register decrements after each complete block transfer.
                                                     Once the last block transfer has completed, this register
                                                     can either stay at zero or be reloaded automatically from                 */
    } bit;
  } MDMA_C15BNDTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000418) MDMA channel x source address register                     */
    
    struct {
      __IOM uint32 SAR        : 32;           /*!< [31..0] source adr base                                                   */
    } bit;
  } MDMA_C15SAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000041C) MDMA channel x destination address register                */
    
    struct {
      __IOM uint32 DAR        : 32;           /*!< [31..0] Destination adr base                                              */
    } bit;
  } MDMA_C15DAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000420) MDMA channel x Block Repeat address Update register        */
    
    struct {
      __IOM uint32 SUV        : 16;           /*!< [15..0] source adresse update value                                       */
      __IOM uint32 DUV        : 16;           /*!< [31..16] destination address update                                       */
    } bit;
  } MDMA_C15BRUR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000424) MDMA channel x Link Address register                       */
    
    struct {
      __IOM uint32 LAR        : 32;           /*!< [31..0] Link address register                                             */
    } bit;
  } MDMA_C15LAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000428) MDMA channel x Trigger and Bus selection Register          */
    
    struct {
      __IOM uint32 TSEL       : 6;            /*!< [5..0] Trigger selection                                                  */
            uint32            : 10;
      __IOM uint32 SBUS       : 1;            /*!< [16..16] Source BUS select This bit is protected and can be
                                                     written only if EN is 0.                                                  */
      __IOM uint32 DBUS       : 1;            /*!< [17..17] Destination BUS slect This bit is protected and can
                                                     be written only if EN is 0.                                               */
            uint32            : 14;
    } bit;
  } MDMA_C15TBR;
  __IM  uint32  RESERVED31;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000430) MDMA channel x Mask address register                       */
    
    struct {
      __IOM uint32 MAR        : 32;           /*!< [31..0] Mask address                                                      */
    } bit;
  } MDMA_C15MAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000434) MDMA channel x Mask Data register                          */
    
    struct {
      __IOM uint32 MDR        : 32;           /*!< [31..0] Mask data                                                         */
    } bit;
  } MDMA_C15MDR;
} MDMA_Type;                                    /*!< Size = 1080 (0x438)                                                       */



/* =========================================================================================================================== */
/* ================                                          QUADSPI                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief QUADSPI (QUADSPI)
  */

typedef struct {                                /*!< (@ 0x52005000) QUADSPI Structure                                          */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) QUADSPI control register                                   */
    
    struct {
      __IOM uint32 EN         : 1;            /*!< [0..0] Enable Enable the QUADSPI.                                         */
      __IOM uint32 ABORT      : 1;            /*!< [1..1] Abort request This bit aborts the on-going command sequence.
                                                     It is automatically reset once the abort is complete. This
                                                     bit stops the current transfer. In polling mode or memory-mapped
                                                     mode, this bit also reset the APM bit or the DM bit.                      */
      __IOM uint32 DMAEN      : 1;            /*!< [2..2] DMA enable In indirect mode, DMA can be used to input
                                                     or output data via the QUADSPI_DR register. DMA transfers
                                                     are initiated when the FIFO threshold flag, FTF, is set.                  */
      __IOM uint32 TCEN       : 1;            /*!< [3..3] Timeout counter enable This bit is valid only when memory-mapped
                                                     mode (FMODE = 11) is selected. Activating this bit causes
                                                     the chip select (nCS) to be released (and thus reduces
                                                     consumption) if there has not been an access after a certain
                                                     amount of time, where this time is defined by TIMEOUT[15:0]
                                                     (QUADSPI_LPTR). Enable the timeout counter. By default,
                                                     the QUADSPI never stops its prefet                                        */
      __IOM uint32 SSHIFT     : 1;            /*!< [4..4] Sample shift By default, the QUADSPI samples data 1/2
                                                     of a CLK cycle after the data is driven by the Flash memory.
                                                     This bit allows the data is to be sampled later in order
                                                     to account for external signal delays. Firmware must assure
                                                     that SSHIFT = 0 when in DDR mode (when DDRM = 1). This
                                                     field can be modified only when BUSY = 0.                                 */
            uint32            : 1;
      __IOM uint32 DFM        : 1;            /*!< [6..6] Dual-flash mode This bit activates dual-flash mode, where
                                                     two external Flash memories are used simultaneously to
                                                     double throughput and capacity. This bit can be modified
                                                     only when BUSY = 0.                                                       */
      __IOM uint32 FSEL       : 1;            /*!< [7..7] Flash memory selection This bit selects the Flash memory
                                                     to be addressed in single flash mode (when DFM = 0). This
                                                     bit can be modified only when BUSY = 0. This bit is ignored
                                                     when DFM = 1.                                                             */
      __IOM uint32 FTHRES     : 5;            /*!< [12..8] FIFO threshold level Defines, in indirect mode, the
                                                     threshold number of bytes in the FIFO that will cause the
                                                     FIFO threshold flag (FTF, QUADSPI_SR[2]) to be set. In
                                                     indirect write mode (FMODE = 00): ... In indirect read
                                                     mode (FMODE = 01): ... If DMAEN = 1, then the DMA controller
                                                     for the corresponding channel must be disabled before changing
                                                     the FTHRES value.                                                         */
            uint32            : 3;
      __IOM uint32 TEIE       : 1;            /*!< [16..16] Transfer error interrupt enable This bit enables the
                                                     transfer error interrupt.                                                 */
      __IOM uint32 TCIE       : 1;            /*!< [17..17] Transfer complete interrupt enable This bit enables
                                                     the transfer complete interrupt.                                          */
      __IOM uint32 FTIE       : 1;            /*!< [18..18] FIFO threshold interrupt enable This bit enables the
                                                     FIFO threshold interrupt.                                                 */
      __IOM uint32 SMIE       : 1;            /*!< [19..19] Status match interrupt enable This bit enables the
                                                     status match interrupt.                                                   */
      __IOM uint32 TOIE       : 1;            /*!< [20..20] TimeOut interrupt enable This bit enables the TimeOut
                                                     interrupt.                                                                */
            uint32            : 1;
      __IOM uint32 APMS       : 1;            /*!< [22..22] Automatic poll mode stop This bit determines if automatic
                                                     polling is stopped after a match. This bit can be modified
                                                     only when BUSY = 0.                                                       */
      __IOM uint32 PMM        : 1;            /*!< [23..23] Polling match mode This bit indicates which method
                                                     should be used for determining a match during automatic
                                                     polling mode. This bit can be modified only when BUSY =
                                                     0.                                                                        */
      __IOM uint32 PRESCALER  : 8;            /*!< [31..24] clock prescaler                                                  */
    } bit;
  } QUADSPI_CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) QUADSPI device configuration register                      */
    
    struct {
      __IOM uint32 CKMODE     : 1;            /*!< [0..0] indicates the level that clk takes between command                 */
            uint32            : 7;
      __IOM uint32 CSHT       : 3;            /*!< [10..8] Chip select high time CSHT+1 defines the minimum number
                                                     of CLK cycles which the chip select (nCS) must remain high
                                                     between commands issued to the Flash memory. ... This field
                                                     can be modified only when BUSY = 0.                                       */
            uint32            : 5;
      __IOM uint32 FSIZE      : 5;            /*!< [20..16] Flash memory size This field defines the size of external
                                                     memory using the following formula: Number of bytes in
                                                     Flash memory = 2[FSIZE+1] FSIZE+1 is effectively the number
                                                     of address bits required to address the Flash memory. The
                                                     Flash memory capacity can be up to 4GB (addressed using
                                                     32 bits) in indirect mode, but the addressable space in
                                                     memory-mapped mode is limited to 256MB. If DFM = 1,                       */
            uint32            : 11;
    } bit;
  } QUADSPI_DCR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000008) QUADSPI status register                                    */
    
    struct {
      __IM  uint32 TEF        : 1;            /*!< [0..0] Transfer error flag This bit is set in indirect mode
                                                     when an invalid address is being accessed in indirect mode.
                                                     It is cleared by writing 1 to CTEF.                                       */
      __IM  uint32 TCF        : 1;            /*!< [1..1] Transfer complete flag This bit is set in indirect mode
                                                     when the programmed number of data has been transferred
                                                     or in any mode when the transfer has been aborted.It is
                                                     cleared by writing 1 to CTCF.                                             */
      __IM  uint32 FTF        : 1;            /*!< [2..2] FIFO threshold flag In indirect mode, this bit is set
                                                     when the FIFO threshold has been reached, or if there is
                                                     any data left in the FIFO after reads from the Flash memory
                                                     are complete. It is cleared automatically as soon as threshold
                                                     condition is no longer true. In automatic polling mode
                                                     this bit is set every time the status register is read,
                                                     and the bit is cleared when the data register is                          */
      __IM  uint32 SMF        : 1;            /*!< [3..3] Status match flag This bit is set in automatic polling
                                                     mode when the unmasked received data matches the corresponding
                                                     bits in the match register (QUADSPI_PSMAR). It is cleared
                                                     by writing 1 to CSMF.                                                     */
      __IM  uint32 TOF        : 1;            /*!< [4..4] Timeout flag This bit is set when timeout occurs. It
                                                     is cleared by writing 1 to CTOF.                                          */
      __IM  uint32 BUSY       : 1;            /*!< [5..5] Busy This bit is set when an operation is on going. This
                                                     bit clears automatically when the operation with the Flash
                                                     memory is finished and the FIFO is empty.                                 */
            uint32            : 2;
      __IM  uint32 FLEVEL     : 6;            /*!< [13..8] FIFO level This field gives the number of valid bytes
                                                     which are being held in the FIFO. FLEVEL = 0 when the FIFO
                                                     is empty, and 16 when it is full. In memory-mapped mode
                                                     and in automatic status polling mode, FLEVEL is zero.                     */
            uint32            : 18;
    } bit;
  } QUADSPI_SR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) QUADSPI flag clear register                                */
    
    struct {
      __IOM uint32 CTEF       : 1;            /*!< [0..0] Clear transfer error flag Writing 1 clears the TEF flag
                                                     in the QUADSPI_SR register                                                */
      __IOM uint32 CTCF       : 1;            /*!< [1..1] Clear transfer complete flag Writing 1 clears the TCF
                                                     flag in the QUADSPI_SR register                                           */
            uint32            : 1;
      __IOM uint32 CSMF       : 1;            /*!< [3..3] Clear status match flag Writing 1 clears the SMF flag
                                                     in the QUADSPI_SR register                                                */
      __IOM uint32 CTOF       : 1;            /*!< [4..4] Clear timeout flag Writing 1 clears the TOF flag in the
                                                     QUADSPI_SR register                                                       */
            uint32            : 27;
    } bit;
  } QUADSPI_FCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) QUADSPI data length register                               */
    
    struct {
      __IOM uint32 DL         : 32;           /*!< [31..0] Data length Number of data to be retrieved (value+1)
                                                     in indirect and status-polling modes. A value no greater
                                                     than 3 (indicating 4 bytes) should be used for status-polling
                                                     mode. All 1s in indirect mode means undefined length, where
                                                     QUADSPI will continue until the end of memory, as defined
                                                     by FSIZE. 0x0000_0000: 1 byte is to be transferred 0x0000_0001:
                                                     2 bytes are to be transferred 0x000                                       */
    } bit;
  } QUADSPI_DLR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000014) QUADSPI communication configuration register               */
    
    struct {
      __IOM uint32 INSTRUCTION : 8;           /*!< [7..0] Instruction Instruction to be send to the external SPI
                                                     device. This field can be written only when BUSY = 0.                     */
      __IOM uint32 IMODE      : 2;            /*!< [9..8] Instruction mode This field defines the instruction phase
                                                     mode of operation: This field can be written only when
                                                     BUSY = 0.                                                                 */
      __IOM uint32 ADMODE     : 2;            /*!< [11..10] Address mode This field defines the address phase mode
                                                     of operation: This field can be written only when BUSY
                                                     = 0.                                                                      */
      __IOM uint32 ADSIZE     : 2;            /*!< [13..12] Address size This bit defines address size: This field
                                                     can be written only when BUSY = 0.                                        */
      __IOM uint32 ABMODE     : 2;            /*!< [15..14] Alternate bytes mode This field defines the alternate-bytes
                                                     phase mode of operation: This field can be written only
                                                     when BUSY = 0.                                                            */
      __IOM uint32 ABSIZE     : 2;            /*!< [17..16] Alternate bytes size This bit defines alternate bytes
                                                     size: This field can be written only when BUSY = 0.                       */
      __IOM uint32 DCYC       : 5;            /*!< [22..18] Number of dummy cycles This field defines the duration
                                                     of the dummy phase. In both SDR and DDR modes, it specifies
                                                     a number of CLK cycles (0-31). This field can be written
                                                     only when BUSY = 0.                                                       */
            uint32            : 1;
      __IOM uint32 DMODE      : 2;            /*!< [25..24] Data mode This field defines the data phases mode of
                                                     operation: This field also determines the dummy phase mode
                                                     of operation. This field can be written only when BUSY
                                                     = 0.                                                                      */
      __IOM uint32 FMODE      : 2;            /*!< [27..26] Functional mode This field defines the QUADSPI functional
                                                     mode of operation. If DMAEN = 1 already, then the DMA controller
                                                     for the corresponding channel must be disabled before changing
                                                     the FMODE value. This field can be written only when BUSY
                                                     = 0.                                                                      */
      __IOM uint32 SIOO       : 1;            /*!< [28..28] Send instruction only once mode See Section15.3.11:
                                                     Sending the instruction only once on page13. This bit has
                                                     no effect when IMODE = 00. This field can be written only
                                                     when BUSY = 0.                                                            */
            uint32            : 1;
      __IOM uint32 DHHC       : 1;            /*!< [30..30] DDR hold Delay the data output by 1/4 of the QUADSPI
                                                     output clock cycle in DDR mode: This feature is only active
                                                     in DDR mode. This field can be written only when BUSY =
                                                     0.                                                                        */
      __IOM uint32 DDRM       : 1;            /*!< [31..31] Double data rate mode This bit sets the DDR mode for
                                                     the address, alternate byte and data phase: This field
                                                     can be written only when BUSY = 0.                                        */
    } bit;
  } QUADSPI_CCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000018) QUADSPI address register                                   */
    
    struct {
      __IOM uint32 ADDRESS    : 32;           /*!< [31..0] [31 0]: Address Address to be send to the external Flash
                                                     memory Writes to this field are ignored when BUSY = 0 or
                                                     when FMODE = 11 (memory-mapped mode). In dual flash mode,
                                                     ADDRESS[0] is automatically stuck to 0 as the address should
                                                     always be even                                                            */
    } bit;
  } QUADSPI_AR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000001C) QUADSPI alternate bytes registers                          */
    
    struct {
      __IOM uint32 ALTERNATE  : 32;           /*!< [31..0] Alternate Bytes Optional data to be send to the external
                                                     SPI device right after the address. This field can be written
                                                     only when BUSY = 0.                                                       */
    } bit;
  } QUADSPI_ABR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000020) QUADSPI data register                                      */
    
    struct {
      __IOM uint32 DATA       : 32;           /*!< [31..0] Data Data to be sent/received to/from the external SPI
                                                     device. In indirect write mode, data written to this register
                                                     is stored on the FIFO before it is sent to the Flash memory
                                                     during the data phase. If the FIFO is too full, a write
                                                     operation is stalled until the FIFO has enough space to
                                                     accept the amount of data being written. In indirect read
                                                     mode, reading this register gives (via the FIFO) the data                 */
    } bit;
  } QUADSPI_DR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000024) QUADSPI polling status mask register                       */
    
    struct {
      __IOM uint32 MASK       : 32;           /*!< [31..0] Status mask Mask to be applied to the status bytes received
                                                     in polling mode. For bit n: This field can be written only
                                                     when BUSY = 0.                                                            */
    } bit;
  } QUADSPI_PSMKR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000028) QUADSPI polling status match register                      */
    
    struct {
      __IOM uint32 MATCH      : 32;           /*!< [31..0] Status match Value to be compared with the masked status
                                                     register to get a match. This field can be written only
                                                     when BUSY = 0.                                                            */
    } bit;
  } QUADSPI_PSMAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000002C) QUADSPI polling interval register                          */
    
    struct {
      __IOM uint32 INTERVAL   : 16;           /*!< [15..0] Polling interval Number of CLK cycles between to read
                                                     during automatic polling phases. This field can be written
                                                     only when BUSY = 0.                                                       */
            uint32            : 16;
    } bit;
  } QUADSPI_PIR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000030) QUADSPI low-power timeout register                         */
    
    struct {
      __IOM uint32 TIMEOUT    : 16;           /*!< [15..0] Timeout period After each access in memory-mapped mode,
                                                     the QUADSPI prefetches the subsequent bytes and holds these
                                                     bytes in the FIFO. This field indicates how many CLK cycles
                                                     the QUADSPI waits after the FIFO becomes full until it
                                                     raises nCS, putting the Flash memory in a lower-consumption
                                                     state. This field can be written only when BUSY = 0.                      */
            uint32            : 16;
    } bit;
  } QUADSPI_LPTR;
} QUADSPI_Type;                                 /*!< Size = 52 (0x34)                                                          */



/* =========================================================================================================================== */
/* ================                                            RNG                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief RNG (RNG)
  */

typedef struct {                                /*!< (@ 0x48021800) RNG Structure                                              */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) RNG control register                                       */
    
    struct {
            uint32            : 2;
      __IOM uint32 RNGEN      : 1;            /*!< [2..2] Random number generator enable                                     */
      __IOM uint32 IE         : 1;            /*!< [3..3] Interrupt enable                                                   */
            uint32            : 1;
      __IOM uint32 CED        : 1;            /*!< [5..5] Clock error detection Note: The clock error detection
                                                     can be used only when ck_rc48 or ck_pll1_q (ck_pll1_q =
                                                     48MHz) source is selected otherwise, CED bit must be equal
                                                     to 1. The clock error detection cannot be enabled nor disabled
                                                     on the fly when RNG peripheral is enabled, to enable or
                                                     disable CED the RNG must be disabled.                                     */
            uint32            : 26;
    } bit;
  } RNG_CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) RNG status register                                        */
    
    struct {
      __IM  uint32 DRDY       : 1;            /*!< [0..0] Data ready Note: If IE=1 in RNG_CR, an interrupt is generated
                                                     when DRDY=1. It can rise when the peripheral is disabled.
                                                     When the output buffer becomes empty (after reading RNG_DR),
                                                     this bit returns to 0 until a new random value is generated.              */
      __IM  uint32 CECS       : 1;            /*!< [1..1] Clock error current status Note: This bit is meaningless
                                                     if CED (Clock error detection) bit in RNG_CR is equal to
                                                     1.                                                                        */
      __IM  uint32 SECS       : 1;            /*!< [2..2] Seed error current status ** More than 64 consecutive
                                                     bits at the same value (0 or 1) ** More than 32 consecutive
                                                     alternances of 0 and 1 (0101010101...01)                                  */
            uint32            : 2;
      __IOM uint32 CEIS       : 1;            /*!< [5..5] Clock error interrupt status This bit is set at the same
                                                     time as CECS. It is cleared by writing it to 0. An interrupt
                                                     is pending if IE = 1 in the RNG_CR register. Note: This
                                                     bit is meaningless if CED (Clock error detection) bit in
                                                     RNG_CR is equal to 1.                                                     */
      __IOM uint32 SEIS       : 1;            /*!< [6..6] Seed error interrupt status This bit is set at the same
                                                     time as SECS. It is cleared by writing it to 0. ** More
                                                     than 64 consecutive bits at the same value (0 or 1) **
                                                     More than 32 consecutive alternances of 0 and 1 (0101010101...01)
                                                     An interrupt is pending if IE = 1 in the RNG_CR register.                 */
            uint32            : 25;
    } bit;
  } RNG_SR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000008) The RNG_DR register is a read-only register that
                                                                    delivers a 32-bit random value when read.
                                                                    The content of this register is valid when
                                                                    DRDY= 1, even if RNGEN=0.                                  */
    
    struct {
      __IM  uint32 RNDATA     : 32;           /*!< [31..0] Random data 32-bit random data which are valid when
                                                     DRDY=1.                                                                   */
    } bit;
  } RNG_DR;
} RNG_Type;                                     /*!< Size = 12 (0xc)                                                           */



/* =========================================================================================================================== */
/* ================                                            RTC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief RTC (RTC)
  */

typedef struct {                                /*!< (@ 0x58004000) RTC Structure                                              */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) The RTC_TR is the calendar time shadow register.
                                                                    This register must be written in initialization
                                                                    mode only. Refer to Calendar initialization
                                                                    and configuration on page9 and Reading the
                                                                    calendar on page10.This register is write
                                                                    protected. The write access procedure is
                                                                    described in RTC register write protection
                                                                    on page9.                                                  */
    
    struct {
      __IOM uint32 SU         : 4;            /*!< [3..0] Second units in BCD format                                         */
      __IOM uint32 ST         : 3;            /*!< [6..4] Second tens in BCD format                                          */
            uint32            : 1;
      __IOM uint32 MNU        : 4;            /*!< [11..8] Minute units in BCD format                                        */
      __IOM uint32 MNT        : 3;            /*!< [14..12] Minute tens in BCD format                                        */
            uint32            : 1;
      __IOM uint32 HU         : 4;            /*!< [19..16] Hour units in BCD format                                         */
      __IOM uint32 HT         : 2;            /*!< [21..20] Hour tens in BCD format                                          */
      __IOM uint32 PM         : 1;            /*!< [22..22] AM/PM notation                                                   */
            uint32            : 9;
    } bit;
  } RTC_TR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) The RTC_DR is the calendar date shadow register.
                                                                    This register must be written in initialization
                                                                    mode only. Refer to Calendar initialization
                                                                    and configuration on page9 and Reading the
                                                                    calendar on page10.This register is write
                                                                    protected. The write access procedure is
                                                                    described in RTC register write protection
                                                                    on page9.                                                  */
    
    struct {
      __IOM uint32 DU         : 4;            /*!< [3..0] Date units in BCD format                                           */
      __IOM uint32 DT         : 2;            /*!< [5..4] Date tens in BCD format                                            */
            uint32            : 2;
      __IOM uint32 MU         : 4;            /*!< [11..8] Month units in BCD format                                         */
      __IOM uint32 MT         : 1;            /*!< [12..12] Month tens in BCD format                                         */
      __IOM uint32 WDU        : 3;            /*!< [15..13] Week day units                                                   */
      __IOM uint32 YU         : 4;            /*!< [19..16] Year units in BCD format                                         */
      __IOM uint32 YT         : 4;            /*!< [23..20] Year tens in BCD format                                          */
            uint32            : 8;
    } bit;
  } RTC_DR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) RTC control register                                       */
    
    struct {
      __IOM uint32 WUCKSEL    : 3;            /*!< [2..0] Wakeup clock selection                                             */
      __IOM uint32 TSEDGE     : 1;            /*!< [3..3] Time-stamp event active edge TSE must be reset when TSEDGE
                                                     is changed to avoid unwanted TSF setting.                                 */
      __IOM uint32 REFCKON    : 1;            /*!< [4..4] RTC_REFIN reference clock detection enable (50 or 60Hz)
                                                     Note: PREDIV_S must be 0x00FF.                                            */
      __IOM uint32 BYPSHAD    : 1;            /*!< [5..5] Bypass the shadow registers Note: If the frequency of
                                                     the APB clock is less than seven times the frequency of
                                                     RTCCLK, BYPSHAD must be set to 1.                                         */
      __IOM uint32 FMT        : 1;            /*!< [6..6] Hour format                                                        */
            uint32            : 1;
      __IOM uint32 ALRAE      : 1;            /*!< [8..8] Alarm A enable                                                     */
      __IOM uint32 ALRBE      : 1;            /*!< [9..9] Alarm B enable                                                     */
      __IOM uint32 WUTE       : 1;            /*!< [10..10] Wakeup timer enable                                              */
      __IOM uint32 TSE        : 1;            /*!< [11..11] timestamp enable                                                 */
      __IOM uint32 ALRAIE     : 1;            /*!< [12..12] Alarm A interrupt enable                                         */
      __IOM uint32 ALRBIE     : 1;            /*!< [13..13] Alarm B interrupt enable                                         */
      __IOM uint32 WUTIE      : 1;            /*!< [14..14] Wakeup timer interrupt enable                                    */
      __IOM uint32 TSIE       : 1;            /*!< [15..15] Time-stamp interrupt enable                                      */
      __OM  uint32 ADD1H      : 1;            /*!< [16..16] Add 1 hour (summer time change) When this bit is set
                                                     outside initialization mode, 1 hour is added to the calendar
                                                     time. This bit is always read as 0.                                       */
      __OM  uint32 SUB1H      : 1;            /*!< [17..17] Subtract 1 hour (winter time change) When this bit
                                                     is set outside initialization mode, 1 hour is subtracted
                                                     to the calendar time if the current hour is not 0. This
                                                     bit is always read as 0. Setting this bit has no effect
                                                     when current hour is 0.                                                   */
      __IOM uint32 BKP        : 1;            /*!< [18..18] Backup This bit can be written by the user to memorize
                                                     whether the daylight saving time change has been performed
                                                     or not.                                                                   */
      __IOM uint32 COSEL      : 1;            /*!< [19..19] Calibration output selection When COE=1, this bit selects
                                                     which signal is output on RTC_CALIB. These frequencies
                                                     are valid for RTCCLK at 32.768 kHz and prescalers at their
                                                     default values (PREDIV_A=127 and PREDIV_S=255). Refer to
                                                     Section24.3.15: Calibration clock output                                  */
      __IOM uint32 POL        : 1;            /*!< [20..20] Output polarity This bit is used to configure the polarity
                                                     of RTC_ALARM output                                                       */
      __IOM uint32 OSEL       : 2;            /*!< [22..21] Output selection These bits are used to select the
                                                     flag to be routed to RTC_ALARM output                                     */
      __IOM uint32 COE        : 1;            /*!< [23..23] Calibration output enable This bit enables the RTC_CALIB
                                                     output                                                                    */
      __IOM uint32 ITSE       : 1;            /*!< [24..24] timestamp on internal event enable                               */
            uint32            : 7;
    } bit;
  } RTC_CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) This register is write protected (except for
                                                                    RTC_ISR[13:8] bits). The write access procedure
                                                                    is described in RTC register write protection
                                                                    on page9.                                                  */
    
    struct {
      __IM  uint32 ALRAWF     : 1;            /*!< [0..0] Alarm A write flag This bit is set by hardware when Alarm
                                                     A values can be changed, after the ALRAE bit has been set
                                                     to 0 in RTC_CR. It is cleared by hardware in initialization
                                                     mode.                                                                     */
      __IM  uint32 ALRBWF     : 1;            /*!< [1..1] Alarm B write flag This bit is set by hardware when Alarm
                                                     B values can be changed, after the ALRBE bit has been set
                                                     to 0 in RTC_CR. It is cleared by hardware in initialization
                                                     mode.                                                                     */
      __IM  uint32 WUTWF      : 1;            /*!< [2..2] Wakeup timer write flag This bit is set by hardware up
                                                     to 2 RTCCLK cycles after the WUTE bit has been set to 0
                                                     in RTC_CR, and is cleared up to 2 RTCCLK cycles after the
                                                     WUTE bit has been set to 1. The wakeup timer values can
                                                     be changed when WUTE bit is cleared and WUTWF is set.                     */
      __IM  uint32 SHPF       : 1;            /*!< [3..3] Shift operation pending This flag is set by hardware
                                                     as soon as a shift operation is initiated by a write to
                                                     the RTC_SHIFTR register. It is cleared by hardware when
                                                     the corresponding shift operation has been executed. Writing
                                                     to the SHPF bit has no effect.                                            */
      __IM  uint32 INITS      : 1;            /*!< [4..4] Initialization status flag This bit is set by hardware
                                                     when the calendar year field is different from 0 (Backup
                                                     domain reset state).                                                      */
      __IOM uint32 RSF        : 1;            /*!< [5..5] Registers synchronization flag This bit is set by hardware
                                                     each time the calendar registers are copied into the shadow
                                                     registers (RTC_SSRx, RTC_TRx and RTC_DRx). This bit is
                                                     cleared by hardware in initialization mode, while a shift
                                                     operation is pending (SHPF=1), or when in bypass shadow
                                                     register mode (BYPSHAD=1). This bit can also be cleared
                                                     by software. It is cleared either by software or by                       */
      __IM  uint32 INITF      : 1;            /*!< [6..6] Initialization flag When this bit is set to 1, the RTC
                                                     is in initialization state, and the time, date and prescaler
                                                     registers can be updated.                                                 */
      __IOM uint32 INIT       : 1;            /*!< [7..7] Initialization mode                                                */
      __IOM uint32 ALRAF      : 1;            /*!< [8..8] Alarm A flag This flag is set by hardware when the time/date
                                                     registers (RTC_TR and RTC_DR) match the Alarm A register
                                                     (RTC_ALRMAR). This flag is cleared by software by writing
                                                     0.                                                                        */
      __IOM uint32 ALRBF      : 1;            /*!< [9..9] Alarm B flag This flag is set by hardware when the time/date
                                                     registers (RTC_TR and RTC_DR) match the Alarm B register
                                                     (RTC_ALRMBR). This flag is cleared by software by writing
                                                     0.                                                                        */
      __IOM uint32 WUTF       : 1;            /*!< [10..10] Wakeup timer flag This flag is set by hardware when
                                                     the wakeup auto-reload counter reaches 0. This flag is
                                                     cleared by software by writing 0. This flag must be cleared
                                                     by software at least 1.5 RTCCLK periods before WUTF is
                                                     set to 1 again.                                                           */
      __IOM uint32 TSF        : 1;            /*!< [11..11] Time-stamp flag This flag is set by hardware when a
                                                     time-stamp event occurs. This flag is cleared by software
                                                     by writing 0.                                                             */
      __IOM uint32 TSOVF      : 1;            /*!< [12..12] Time-stamp overflow flag This flag is set by hardware
                                                     when a time-stamp event occurs while TSF is already set.
                                                     This flag is cleared by software by writing 0. It is recommended
                                                     to check and then clear TSOVF only after clearing the TSF
                                                     bit. Otherwise, an overflow might not be noticed if a time-stamp
                                                     event occurs immediately before the TSF bit is cleared.                   */
      __IOM uint32 TAMP1F     : 1;            /*!< [13..13] RTC_TAMP1 detection flag This flag is set by hardware
                                                     when a tamper detection event is detected on the RTC_TAMP1
                                                     input. It is cleared by software writing 0                                */
      __IOM uint32 TAMP2F     : 1;            /*!< [14..14] RTC_TAMP2 detection flag This flag is set by hardware
                                                     when a tamper detection event is detected on the RTC_TAMP2
                                                     input. It is cleared by software writing 0                                */
      __IOM uint32 TAMP3F     : 1;            /*!< [15..15] RTC_TAMP3 detection flag This flag is set by hardware
                                                     when a tamper detection event is detected on the RTC_TAMP3
                                                     input. It is cleared by software writing 0                                */
      __IM  uint32 RECALPF    : 1;            /*!< [16..16] Recalibration pending Flag The RECALPF status flag
                                                     is automatically set to 1 when software writes to the RTC_CALR
                                                     register, indicating that the RTC_CALR register is blocked.
                                                     When the new calibration settings are taken into account,
                                                     this bit returns to 0. Refer to Re-calibration on-the-fly.                */
      __IOM uint32 ITSF       : 1;            /*!< [17..17] Internal tTime-stamp flag                                        */
            uint32            : 14;
    } bit;
  } RTC_ISR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) This register must be written in initialization
                                                                    mode only. The initialization must be performed
                                                                    in two separate write accesses. Refer to
                                                                    Calendar initialization and configuration
                                                                    on page9.This register is write protected.
                                                                    The write access procedure is described
                                                                    in RTC register write protection on page9.                 */
    
    struct {
      __IOM uint32 PREDIV_S   : 15;           /*!< [14..0] Synchronous prescaler factor This is the synchronous
                                                     division factor: ck_spre frequency = ck_apre frequency/(PREDIV_S+1)       */
            uint32            : 1;
      __IOM uint32 PREDIV_A   : 7;            /*!< [22..16] Asynchronous prescaler factor This is the asynchronous
                                                     division factor: ck_apre frequency = RTCCLK frequency/(PREDIV_A+1)        */
            uint32            : 9;
    } bit;
  } RTC_PRER;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000014) This register can be written only when WUTWF
                                                                    is set to 1 in RTC_ISR.This register is
                                                                    write protected. The write access procedure
                                                                    is described in RTC register write protection
                                                                    on page9.                                                  */
    
    struct {
      __IOM uint32 WUT        : 16;           /*!< [15..0] Wakeup auto-reload value bits When the wakeup timer
                                                     is enabled (WUTE set to 1), the WUTF flag is set every
                                                     (WUT[15:0] + 1) ck_wut cycles. The ck_wut period is selected
                                                     through WUCKSEL[2:0] bits of the RTC_CR register When WUCKSEL[2]
                                                     = 1, the wakeup timer becomes 17-bits and WUCKSEL[1] effectively
                                                     becomes WUT[16] the most-significant bit to be reloaded
                                                     into the timer. The first assertion of                                    */
            uint32            : 16;
    } bit;
  } RTC_WUTR;
  __IM  uint32  RESERVED;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000001C) This register can be written only when ALRAWF
                                                                    is set to 1 in RTC_ISR, or in initialization
                                                                    mode.This register is write protected. The
                                                                    write access procedure is described in RTC
                                                                    register write protection on page9.                        */
    
    struct {
      __IOM uint32 SU         : 4;            /*!< [3..0] Second units in BCD format.                                        */
      __IOM uint32 ST         : 3;            /*!< [6..4] Second tens in BCD format.                                         */
      __IOM uint32 MSK1       : 1;            /*!< [7..7] Alarm A seconds mask                                               */
      __IOM uint32 MNU        : 4;            /*!< [11..8] Minute units in BCD format.                                       */
      __IOM uint32 MNT        : 3;            /*!< [14..12] Minute tens in BCD format.                                       */
      __IOM uint32 MSK2       : 1;            /*!< [15..15] Alarm A minutes mask                                             */
      __IOM uint32 HU         : 4;            /*!< [19..16] Hour units in BCD format.                                        */
      __IOM uint32 HT         : 2;            /*!< [21..20] Hour tens in BCD format.                                         */
      __IOM uint32 PM         : 1;            /*!< [22..22] AM/PM notation                                                   */
      __IOM uint32 MSK3       : 1;            /*!< [23..23] Alarm A hours mask                                               */
      __IOM uint32 DU         : 4;            /*!< [27..24] Date units or day in BCD format.                                 */
      __IOM uint32 DT         : 2;            /*!< [29..28] Date tens in BCD format.                                         */
      __IOM uint32 WDSEL      : 1;            /*!< [30..30] Week day selection                                               */
      __IOM uint32 MSK4       : 1;            /*!< [31..31] Alarm A date mask                                                */
    } bit;
  } RTC_ALRMAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000020) This register can be written only when ALRBWF
                                                                    is set to 1 in RTC_ISR, or in initialization
                                                                    mode.This register is write protected. The
                                                                    write access procedure is described in RTC
                                                                    register write protection on page9.                        */
    
    struct {
      __IOM uint32 SU         : 4;            /*!< [3..0] Second units in BCD format                                         */
      __IOM uint32 ST         : 3;            /*!< [6..4] Second tens in BCD format                                          */
      __IOM uint32 MSK1       : 1;            /*!< [7..7] Alarm B seconds mask                                               */
      __IOM uint32 MNU        : 4;            /*!< [11..8] Minute units in BCD format                                        */
      __IOM uint32 MNT        : 3;            /*!< [14..12] Minute tens in BCD format                                        */
      __IOM uint32 MSK2       : 1;            /*!< [15..15] Alarm B minutes mask                                             */
      __IOM uint32 HU         : 4;            /*!< [19..16] Hour units in BCD format                                         */
      __IOM uint32 HT         : 2;            /*!< [21..20] Hour tens in BCD format                                          */
      __IOM uint32 PM         : 1;            /*!< [22..22] AM/PM notation                                                   */
      __IOM uint32 MSK3       : 1;            /*!< [23..23] Alarm B hours mask                                               */
      __IOM uint32 DU         : 4;            /*!< [27..24] Date units or day in BCD format                                  */
      __IOM uint32 DT         : 2;            /*!< [29..28] Date tens in BCD format                                          */
      __IOM uint32 WDSEL      : 1;            /*!< [30..30] Week day selection                                               */
      __IOM uint32 MSK4       : 1;            /*!< [31..31] Alarm B date mask                                                */
    } bit;
  } RTC_ALRMBR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000024) RTC write protection register                              */
    
    struct {
      __OM  uint32 KEY        : 8;            /*!< [7..0] Write protection key This byte is written by software.
                                                     Reading this byte always returns 0x00. Refer to RTC register
                                                     write protection for a description of how to unlock RTC
                                                     register write protection.                                                */
            uint32            : 24;
    } bit;
  } RTC_WPR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000028) RTC sub second register                                    */
    
    struct {
      __IM  uint32 SS         : 16;           /*!< [15..0] Sub second value SS[15:0] is the value in the synchronous
                                                     prescaler counter. The fraction of a second is given by
                                                     the formula below: Second fraction = (PREDIV_S - SS) /
                                                     (PREDIV_S + 1) Note: SS can be larger than PREDIV_S only
                                                     after a shift operation. In that case, the correct time/date
                                                     is one second less than as indicated by RTC_TR/RTC_DR.                    */
            uint32            : 16;
    } bit;
  } RTC_SSR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x0000002C) This register is write protected. The write access
                                                                    procedure is described in RTC register write
                                                                    protection on page9.                                       */
    
    struct {
      __OM  uint32 SUBFS      : 15;           /*!< [14..0] Subtract a fraction of a second These bits are write
                                                     only and is always read as zero. Writing to this bit has
                                                     no effect when a shift operation is pending (when SHPF=1,
                                                     in RTC_ISR). The value which is written to SUBFS is added
                                                     to the synchronous prescaler counter. Since this counter
                                                     counts down, this operation effectively subtracts from
                                                     (delays) the clock by: Delay (seconds) = SUBFS / (P                       */
            uint32            : 16;
      __OM  uint32 ADD1S      : 1;            /*!< [31..31] Add one second This bit is write only and is always
                                                     read as zero. Writing to this bit has no effect when a
                                                     shift operation is pending (when SHPF=1, in RTC_ISR). This
                                                     function is intended to be used with SUBFS (see description
                                                     below) in order to effectively add a fraction of a second
                                                     to the clock in an atomic operation.                                      */
    } bit;
  } RTC_SHIFTR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000030) The content of this register is valid only when
                                                                    TSF is set to 1 in RTC_ISR. It is cleared
                                                                    when TSF bit is reset.                                     */
    
    struct {
      __IM  uint32 SU         : 4;            /*!< [3..0] Second units in BCD format.                                        */
      __IM  uint32 ST         : 3;            /*!< [6..4] Second tens in BCD format.                                         */
            uint32            : 1;
      __IM  uint32 MNU        : 4;            /*!< [11..8] Minute units in BCD format.                                       */
      __IM  uint32 MNT        : 3;            /*!< [14..12] Minute tens in BCD format.                                       */
            uint32            : 1;
      __IM  uint32 HU         : 4;            /*!< [19..16] Hour units in BCD format.                                        */
      __IM  uint32 HT         : 2;            /*!< [21..20] Hour tens in BCD format.                                         */
      __IM  uint32 PM         : 1;            /*!< [22..22] AM/PM notation                                                   */
            uint32            : 9;
    } bit;
  } RTC_TSTR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000034) The content of this register is valid only when
                                                                    TSF is set to 1 in RTC_ISR. It is cleared
                                                                    when TSF bit is reset.                                     */
    
    struct {
      __IM  uint32 DU         : 4;            /*!< [3..0] Date units in BCD format                                           */
      __IM  uint32 DT         : 2;            /*!< [5..4] Date tens in BCD format                                            */
            uint32            : 2;
      __IM  uint32 MU         : 4;            /*!< [11..8] Month units in BCD format                                         */
      __IM  uint32 MT         : 1;            /*!< [12..12] Month tens in BCD format                                         */
      __IM  uint32 WDU        : 3;            /*!< [15..13] Week day units                                                   */
            uint32            : 16;
    } bit;
  } RTC_TSDR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000038) The content of this register is valid only when
                                                                    RTC_ISR/TSF is set. It is cleared when the
                                                                    RTC_ISR/TSF bit is reset.                                  */
    
    struct {
      __IM  uint32 SS         : 16;           /*!< [15..0] Sub second value SS[15:0] is the value of the synchronous
                                                     prescaler counter when the timestamp event occurred.                      */
            uint32            : 16;
    } bit;
  } RTC_TSSSR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000003C) This register is write protected. The write access
                                                                    procedure is described in RTC register write
                                                                    protection on page9.                                       */
    
    struct {
      __IOM uint32 CALM       : 9;            /*!< [8..0] Calibration minus The frequency of the calendar is reduced
                                                     by masking CALM out of 220 RTCCLK pulses (32 seconds if
                                                     the input frequency is 32768 Hz). This decreases the frequency
                                                     of the calendar with a resolution of 0.9537 ppm. To increase
                                                     the frequency of the calendar, this feature should be used
                                                     in conjunction with CALP. See Section24.3.12: RTC smooth
                                                     digital calibration on page13.                                            */
            uint32            : 4;
      __IOM uint32 CALW16     : 1;            /*!< [13..13] Use a 16-second calibration cycle period When CALW16
                                                     is set to 1, the 16-second calibration cycle period is
                                                     selected.This bit must not be set to 1 if CALW8=1. Note:
                                                     CALM[0] is stuck at 0 when CALW16= 1. Refer to Section24.3.12:
                                                     RTC smooth digital calibration.                                           */
      __IOM uint32 CALW8      : 1;            /*!< [14..14] Use an 8-second calibration cycle period When CALW8
                                                     is set to 1, the 8-second calibration cycle period is selected.
                                                     Note: CALM[1:0] are stuck at 00; when CALW8= 1. Refer to
                                                     Section24.3.12: RTC smooth digital calibration.                           */
      __IOM uint32 CALP       : 1;            /*!< [15..15] Increase frequency of RTC by 488.5 ppm This feature
                                                     is intended to be used in conjunction with CALM, which
                                                     lowers the frequency of the calendar with a fine resolution.
                                                     if the input frequency is 32768 Hz, the number of RTCCLK
                                                     pulses added during a 32-second window is calculated as
                                                     follows: (512 * CALP) - CALM. Refer to Section24.3.12:
                                                     RTC smooth digital calibration.                                           */
            uint32            : 16;
    } bit;
  } RTC_CALR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000040) RTC tamper and alternate function configuration
                                                                    register                                                   */
    
    struct {
      __IOM uint32 TAMP1E     : 1;            /*!< [0..0] RTC_TAMP1 input detection enable                                   */
      __IOM uint32 TAMP1TRG   : 1;            /*!< [1..1] Active level for RTC_TAMP1 input If TAMPFLT != 00 if
                                                     TAMPFLT = 00:                                                             */
      __IOM uint32 TAMPIE     : 1;            /*!< [2..2] Tamper interrupt enable                                            */
      __IOM uint32 TAMP2E     : 1;            /*!< [3..3] RTC_TAMP2 input detection enable                                   */
      __IOM uint32 TAMP2TRG   : 1;            /*!< [4..4] Active level for RTC_TAMP2 input if TAMPFLT != 00: if
                                                     TAMPFLT = 00:                                                             */
      __IOM uint32 TAMP3E     : 1;            /*!< [5..5] RTC_TAMP3 detection enable                                         */
      __IOM uint32 TAMP3TRG   : 1;            /*!< [6..6] Active level for RTC_TAMP3 input if TAMPFLT != 00: if
                                                     TAMPFLT = 00:                                                             */
      __IOM uint32 TAMPTS     : 1;            /*!< [7..7] Activate timestamp on tamper detection event TAMPTS is
                                                     valid even if TSE=0 in the RTC_CR register.                               */
      __IOM uint32 TAMPFREQ   : 3;            /*!< [10..8] Tamper sampling frequency Determines the frequency at
                                                     which each of the RTC_TAMPx inputs are sampled.                           */
      __IOM uint32 TAMPFLT    : 2;            /*!< [12..11] RTC_TAMPx filter count These bits determines the number
                                                     of consecutive samples at the specified level (TAMP*TRG)
                                                     needed to activate a Tamper event. TAMPFLT is valid for
                                                     each of the RTC_TAMPx inputs.                                             */
      __IOM uint32 TAMPPRCH   : 2;            /*!< [14..13] RTC_TAMPx precharge duration These bit determines the
                                                     duration of time during which the pull-up/is activated
                                                     before each sample. TAMPPRCH is valid for each of the RTC_TAMPx
                                                     inputs.                                                                   */
      __IOM uint32 TAMPPUDIS  : 1;            /*!< [15..15] RTC_TAMPx pull-up disable This bit determines if each
                                                     of the RTC_TAMPx pins are pre-charged before each sample.                 */
      __IOM uint32 TAMP1IE    : 1;            /*!< [16..16] Tamper 1 interrupt enable                                        */
      __IOM uint32 TAMP1NOERASE : 1;          /*!< [17..17] Tamper 1 no erase                                                */
      __IOM uint32 TAMP1MF    : 1;            /*!< [18..18] Tamper 1 mask flag                                               */
      __IOM uint32 TAMP2IE    : 1;            /*!< [19..19] Tamper 2 interrupt enable                                        */
      __IOM uint32 TAMP2NOERASE : 1;          /*!< [20..20] Tamper 2 no erase                                                */
      __IOM uint32 TAMP2MF    : 1;            /*!< [21..21] Tamper 2 mask flag                                               */
      __IOM uint32 TAMP3IE    : 1;            /*!< [22..22] Tamper 3 interrupt enable                                        */
      __IOM uint32 TAMP3NOERASE : 1;          /*!< [23..23] Tamper 3 no erase                                                */
      __IOM uint32 TAMP3MF    : 1;            /*!< [24..24] Tamper 3 mask flag                                               */
            uint32            : 7;
    } bit;
  } RTC_TAMPCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000044) This register can be written only when ALRAE
                                                                    is reset in RTC_CR register, or in initialization
                                                                    mode.This register is write protected. The
                                                                    write access procedure is described in RTC
                                                                    register write protection on page9                         */
    
    struct {
      __IOM uint32 SS         : 15;           /*!< [14..0] Sub seconds value This value is compared with the contents
                                                     of the synchronous prescaler counter to determine if Alarm
                                                     A is to be activated. Only bits 0 up MASKSS-1 are compared.               */
            uint32            : 9;
      __IOM uint32 MASKSS     : 4;            /*!< [27..24] Mask the most-significant bits starting at this bit
                                                     ... The overflow bits of the synchronous counter (bits
                                                     15) is never compared. This bit can be different from 0
                                                     only after a shift operation.                                             */
            uint32            : 4;
    } bit;
  } RTC_ALRMASSR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000048) This register can be written only when ALRBE
                                                                    is reset in RTC_CR register, or in initialization
                                                                    mode.This register is write protected.The
                                                                    write access procedure is described in Section:
                                                                    RTC register write protection.                             */
    
    struct {
      __IOM uint32 SS         : 15;           /*!< [14..0] Sub seconds value This value is compared with the contents
                                                     of the synchronous prescaler counter to determine if Alarm
                                                     B is to be activated. Only bits 0 up to MASKSS-1 are compared.            */
            uint32            : 9;
      __IOM uint32 MASKSS     : 4;            /*!< [27..24] Mask the most-significant bits starting at this bit
                                                     ... The overflow bits of the synchronous counter (bits
                                                     15) is never compared. This bit can be different from 0
                                                     only after a shift operation.                                             */
            uint32            : 4;
    } bit;
  } RTC_ALRMBSSR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000004C) RTC option register                                        */
    
    struct {
      __IOM uint32 RTC_ALARM_TYPE : 1;        /*!< [0..0] RTC_ALARM output type on PC13                                      */
      __IOM uint32 RTC_OUT_RMP : 1;           /*!< [1..1] RTC_OUT remap                                                      */
            uint32            : 30;
    } bit;
  } RTC_OR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000050) RTC backup registers                                       */
    
    struct {
      __IOM uint32 BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } bit;
  } RTC_BKP0R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000054) RTC backup registers                                       */
    
    struct {
      __IOM uint32 BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } bit;
  } RTC_BKP1R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000058) RTC backup registers                                       */
    
    struct {
      __IOM uint32 BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } bit;
  } RTC_BKP2R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000005C) RTC backup registers                                       */
    
    struct {
      __IOM uint32 BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } bit;
  } RTC_BKP3R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000060) RTC backup registers                                       */
    
    struct {
      __IOM uint32 BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } bit;
  } RTC_BKP4R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000064) RTC backup registers                                       */
    
    struct {
      __IOM uint32 BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } bit;
  } RTC_BKP5R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000068) RTC backup registers                                       */
    
    struct {
      __IOM uint32 BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } bit;
  } RTC_BKP6R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000006C) RTC backup registers                                       */
    
    struct {
      __IOM uint32 BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } bit;
  } RTC_BKP7R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000070) RTC backup registers                                       */
    
    struct {
      __IOM uint32 BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } bit;
  } RTC_BKP8R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000074) RTC backup registers                                       */
    
    struct {
      __IOM uint32 BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } bit;
  } RTC_BKP9R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000078) RTC backup registers                                       */
    
    struct {
      __IOM uint32 BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } bit;
  } RTC_BKP10R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000007C) RTC backup registers                                       */
    
    struct {
      __IOM uint32 BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } bit;
  } RTC_BKP11R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000080) RTC backup registers                                       */
    
    struct {
      __IOM uint32 BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } bit;
  } RTC_BKP12R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000084) RTC backup registers                                       */
    
    struct {
      __IOM uint32 BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } bit;
  } RTC_BKP13R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000088) RTC backup registers                                       */
    
    struct {
      __IOM uint32 BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } bit;
  } RTC_BKP14R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000008C) RTC backup registers                                       */
    
    struct {
      __IOM uint32 BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } bit;
  } RTC_BKP15R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000090) RTC backup registers                                       */
    
    struct {
      __IOM uint32 BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } bit;
  } RTC_BKP16R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000094) RTC backup registers                                       */
    
    struct {
      __IOM uint32 BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } bit;
  } RTC_BKP17R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000098) RTC backup registers                                       */
    
    struct {
      __IOM uint32 BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } bit;
  } RTC_BKP18R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000009C) RTC backup registers                                       */
    
    struct {
      __IOM uint32 BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } bit;
  } RTC_BKP19R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000A0) RTC backup registers                                       */
    
    struct {
      __IOM uint32 BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } bit;
  } RTC_BKP20R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000A4) RTC backup registers                                       */
    
    struct {
      __IOM uint32 BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } bit;
  } RTC_BKP21R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000A8) RTC backup registers                                       */
    
    struct {
      __IOM uint32 BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } bit;
  } RTC_BKP22R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000AC) RTC backup registers                                       */
    
    struct {
      __IOM uint32 BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } bit;
  } RTC_BKP23R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000B0) RTC backup registers                                       */
    
    struct {
      __IOM uint32 BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } bit;
  } RTC_BKP24R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000B4) RTC backup registers                                       */
    
    struct {
      __IOM uint32 BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } bit;
  } RTC_BKP25R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000B8) RTC backup registers                                       */
    
    struct {
      __IOM uint32 BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } bit;
  } RTC_BKP26R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000BC) RTC backup registers                                       */
    
    struct {
      __IOM uint32 BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } bit;
  } RTC_BKP27R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000C0) RTC backup registers                                       */
    
    struct {
      __IOM uint32 BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } bit;
  } RTC_BKP28R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000C4) RTC backup registers                                       */
    
    struct {
      __IOM uint32 BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } bit;
  } RTC_BKP29R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000C8) RTC backup registers                                       */
    
    struct {
      __IOM uint32 BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } bit;
  } RTC_BKP30R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000CC) RTC backup registers                                       */
    
    struct {
      __IOM uint32 BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } bit;
  } RTC_BKP31R;
} RTC_Type;                                     /*!< Size = 208 (0xd0)                                                         */



/* =========================================================================================================================== */
/* ================                                           SAI4                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief SAI (SAI4)
  */

typedef struct {                                /*!< (@ 0x58005400) SAI4 Structure                                             */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) Global configuration register                              */
    
    struct {
      __IOM uint32 SYNCIN     : 2;            /*!< [1..0] Synchronization inputs                                             */
            uint32            : 2;
      __IOM uint32 SYNCOUT    : 2;            /*!< [5..4] Synchronization outputs These bits are set and cleared
                                                     by software.                                                              */
            uint32            : 26;
    } bit;
  } SAI_GCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) Configuration register 1                                   */
    
    struct {
      __IOM uint32 MODE       : 2;            /*!< [1..0] SAIx audio block mode immediately                                  */
      __IOM uint32 PRTCFG     : 2;            /*!< [3..2] Protocol configuration. These bits are set and cleared
                                                     by software. These bits have to be configured when the
                                                     audio block is disabled.                                                  */
            uint32            : 1;
      __IOM uint32 DS         : 3;            /*!< [7..5] Data size. These bits are set and cleared by software.
                                                     These bits are ignored when the SPDIF protocols are selected
                                                     (bit PRTCFG[1:0]), because the frame and the data size
                                                     are fixed in such case. When the companding mode is selected
                                                     through COMP[1:0] bits, DS[1:0] are ignored since the data
                                                     size is fixed to 8 bits by the algorithm. These bits must
                                                     be configured when the audio block is di                                  */
      __IOM uint32 LSBFIRST   : 1;            /*!< [8..8] Least significant bit first. This bit is set and cleared
                                                     by software. It must be configured when the audio block
                                                     is disabled. This bit has no meaning in AC97 audio protocol
                                                     since AC97 data are always transferred with the MSB first.
                                                     This bit has no meaning in SPDIF audio protocol since in
                                                     SPDIF data are always transferred with LSB first.                         */
      __IOM uint32 CKSTR      : 1;            /*!< [9..9] Clock strobing edge. This bit is set and cleared by software.
                                                     It must be configured when the audio block is disabled.
                                                     This bit has no meaning in SPDIF audio protocol.                          */
      __IOM uint32 SYNCEN     : 2;            /*!< [11..10] Synchronization enable. These bits are set and cleared
                                                     by software. They must be configured when the audio sub-block
                                                     is disabled. Note: The audio sub-block should be configured
                                                     as asynchronous when SPDIF mode is enabled.                               */
      __IOM uint32 MONO       : 1;            /*!< [12..12] Mono mode. This bit is set and cleared by software.
                                                     It is meaningful only when the number of slots is equal
                                                     to 2. When the mono mode is selected, slot 0 data are duplicated
                                                     on slot 1 when the audio block operates as a transmitter.
                                                     In reception mode, the slot1 is discarded and only the
                                                     data received from slot 0 are stored. Refer to Section:
                                                     Mono/stereo mode for more details.                                        */
      __IOM uint32 OUTDRIV    : 1;            /*!< [13..13] Output drive. This bit is set and cleared by software.
                                                     Note: This bit has to be set before enabling the audio
                                                     block and after the audio block configuration.                            */
            uint32            : 2;
      __IOM uint32 SAIXEN     : 1;            /*!< [16..16] Audio block enable where x is A or B. This bit is set
                                                     by software. To switch off the audio block, the application
                                                     software must program this bit to 0 and poll the bit till
                                                     it reads back 0, meaning that the block is completely disabled.
                                                     Before setting this bit to 1, check that it is set to 0,
                                                     otherwise the enable command will not be taken into account.
                                                     This bit allows to control the state of SAIx audio                        */
      __IOM uint32 DMAEN      : 1;            /*!< [17..17] DMA enable. This bit is set and cleared by software.
                                                     Note: Since the audio block defaults to operate as a transmitter
                                                     after reset, the MODE[1:0] bits must be configured before
                                                     setting DMAEN to avoid a DMA request in receiver mode.                    */
            uint32            : 1;
      __IOM uint32 NOMCK      : 1;            /*!< [19..19] No divider                                                       */
      __IOM uint32 MCKDIV     : 4;            /*!< [23..20] Master clock divider. These bits are set and cleared
                                                     by software. These bits are meaningless when the audio
                                                     block operates in slave mode. They have to be configured
                                                     when the audio block is disabled. Others: the master clock
                                                     frequency is calculated accordingly to the following formula:             */
            uint32            : 2;
      __IOM uint32 OSR        : 1;            /*!< [26..26] Oversampling ratio for master clock                              */
            uint32            : 5;
    } bit;
  } SAI_ACR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) Configuration register 2                                   */
    
    struct {
      __IOM uint32 FTH        : 3;            /*!< [2..0] FIFO threshold. This bit is set and cleared by software.           */
      __OM  uint32 FFLUSH     : 1;            /*!< [3..3] FIFO flush. This bit is set by software. It is always
                                                     read as 0. This bit should be configured when the SAI is
                                                     disabled.                                                                 */
      __IOM uint32 TRIS       : 1;            /*!< [4..4] Tristate management on data line. This bit is set and
                                                     cleared by software. It is meaningful only if the audio
                                                     block is configured as a transmitter. This bit is not used
                                                     when the audio block is configured in SPDIF mode. It should
                                                     be configured when SAI is disabled. Refer to Section: Output
                                                     data line management on an inactive slot for more details.                */
      __IOM uint32 MUTE       : 1;            /*!< [5..5] Mute. This bit is set and cleared by software. It is
                                                     meaningful only when the audio block operates as a transmitter.
                                                     The MUTE value is linked to value of MUTEVAL if the number
                                                     of slots is lower or equal to 2, or equal to 0 if it is
                                                     greater than 2. Refer to Section: Mute mode for more details.
                                                     Note: This bit is meaningless and should not be used for
                                                     SPDIF audio blocks.                                                       */
      __IOM uint32 MUTEVAL    : 1;            /*!< [6..6] Mute value. This bit is set and cleared by software.It
                                                     must be written before enabling the audio block: SAIXEN.
                                                     This bit is meaningful only when the audio block operates
                                                     as a transmitter, the number of slots is lower or equal
                                                     to 2 and the MUTE bit is set. If more slots are declared,
                                                     the bit value sent during the transmission in mute mode
                                                     is equal to 0, whatever the value of MUTEVAL. if the number
                                                     of s                                                                      */
      __IOM uint32 MUTECNT    : 6;            /*!< [12..7] Mute counter. These bits are set and cleared by software.
                                                     They are used only in reception mode. The value set in
                                                     these bits is compared to the number of consecutive mute
                                                     frames detected in reception. When the number of mute frames
                                                     is equal to this value, the flag MUTEDET will be set and
                                                     an interrupt will be generated if bit MUTEDETIE is set.
                                                     Refer to Section: Mute mode for more details.                             */
      __IOM uint32 CPL        : 1;            /*!< [13..13] Complement bit. This bit is set and cleared by software.
                                                     It defines the type of complement to be used for companding
                                                     mode Note: This bit has effect only when the companding
                                                     mode is -Law algorithm or A-Law algorithm.                                */
      __IOM uint32 COMP       : 2;            /*!< [15..14] Companding mode. These bits are set and cleared by
                                                     software. The -Law and the A-Law log are a part of the
                                                     CCITT G.711 recommendation, the type of complement that
                                                     will be used depends on CPL bit. The data expansion or
                                                     data compression are determined by the state of bit MODE[0].
                                                     The data compression is applied if the audio block is configured
                                                     as a transmitter. The data expansion is automatically                     */
            uint32            : 16;
    } bit;
  } SAI_ACR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) This register has no meaning in AC97 and SPDIF
                                                                    audio protocol                                             */
    
    struct {
      __IOM uint32 FRL        : 8;            /*!< [7..0] Frame length. These bits are set and cleared by software.
                                                     They define the audio frame length expressed in number
                                                     of SCK clock cycles: the number of bits in the frame is
                                                     equal to FRL[7:0] + 1. The minimum number of bits to transfer
                                                     in an audio frame must be equal to 8, otherwise the audio
                                                     block will behaves in an unexpected way. This is the case
                                                     when the data size is 8 bits and only one slot 0 is                       */
      __IOM uint32 FSALL      : 7;            /*!< [14..8] Frame synchronization active level length. These bits
                                                     are set and cleared by software. They specify the length
                                                     in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the
                                                     active level of the FS signal in the audio frame These
                                                     bits are meaningless and are not used in AC97 or SPDIF
                                                     audio block configuration. They must be configured when
                                                     the audio block is disabled.                                              */
            uint32            : 1;
      __IM  uint32 FSDEF      : 1;            /*!< [16..16] Frame synchronization definition. This bit is set and
                                                     cleared by software. When the bit is set, the number of
                                                     slots defined in the SAI_xSLOTR register has to be even.
                                                     It means that half of this number of slots will be dedicated
                                                     to the left channel and the other slots for the right channel
                                                     (e.g: this bit has to be set for I2S or MSB/LSB-justified
                                                     protocols...). This bit is meaningless and is not                         */
      __IOM uint32 FSPOL      : 1;            /*!< [17..17] Frame synchronization polarity. This bit is set and
                                                     cleared by software. It is used to configure the level
                                                     of the start of frame on the FS signal. It is meaningless
                                                     and is not used in AC97 or SPDIF audio block configuration.
                                                     This bit must be configured when the audio block is disabled.             */
      __IOM uint32 FSOFF      : 1;            /*!< [18..18] Frame synchronization offset. This bit is set and cleared
                                                     by software. It is meaningless and is not used in AC97
                                                     or SPDIF audio block configuration. This bit must be configured
                                                     when the audio block is disabled.                                         */
            uint32            : 13;
    } bit;
  } SAI_AFRCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) This register has no meaning in AC97 and SPDIF
                                                                    audio protocol                                             */
    
    struct {
      __IOM uint32 FBOFF      : 5;            /*!< [4..0] First bit offset These bits are set and cleared by software.
                                                     The value set in this bitfield defines the position of
                                                     the first data transfer bit in the slot. It represents
                                                     an offset value. In transmission mode, the bits outside
                                                     the data field are forced to 0. In reception mode, the
                                                     extra received bits are discarded. These bits must be set
                                                     when the audio block is disabled. They are ignored in                     */
            uint32            : 1;
      __IOM uint32 SLOTSZ     : 2;            /*!< [7..6] Slot size This bits is set and cleared by software. The
                                                     slot size must be higher or equal to the data size. If
                                                     this condition is not respected, the behavior of the SAI
                                                     will be undetermined. Refer to Section: Output data line
                                                     management on an inactive slot for information on how to
                                                     drive SD line. These bits must be set when the audio block
                                                     is disabled. They are ignored in AC97 or SPDIF m                          */
      __IOM uint32 NBSLOT     : 4;            /*!< [11..8] Number of slots in an audio frame. These bits are set
                                                     and cleared by software. The value set in this bitfield
                                                     represents the number of slots + 1 in the audio frame (including
                                                     the number of inactive slots). The maximum number of slots
                                                     is 16. The number of slots should be even if FSDEF bit
                                                     in the SAI_xFRCR register is set. The number of slots must
                                                     be configured when the audio block is disabled. They are                  */
            uint32            : 4;
      __IOM uint32 SLOTEN     : 16;           /*!< [31..16] Slot enable. These bits are set and cleared by software.
                                                     Each SLOTEN bit corresponds to a slot position from 0 to
                                                     15 (maximum 16 slots). The slot must be enabled when the
                                                     audio block is disabled. They are ignored in AC97 or SPDIF
                                                     mode.                                                                     */
    } bit;
  } SAI_ASLOTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000014) Interrupt mask register 2                                  */
    
    struct {
      __IOM uint32 OVRUDRIE   : 1;            /*!< [0..0] Overrun/underrun interrupt enable. This bit is set and
                                                     cleared by software. When this bit is set, an interrupt
                                                     is generated if the OVRUDR bit in the SAI_xSR register
                                                     is set.                                                                   */
      __IOM uint32 MUTEDETIE  : 1;            /*!< [1..1] Mute detection interrupt enable. This bit is set and
                                                     cleared by software. When this bit is set, an interrupt
                                                     is generated if the MUTEDET bit in the SAI_xSR register
                                                     is set. This bit has a meaning only if the audio block
                                                     is configured in receiver mode.                                           */
      __IOM uint32 WCKCFGIE   : 1;            /*!< [2..2] Wrong clock configuration interrupt enable. This bit
                                                     is set and cleared by software. This bit is taken into
                                                     account only if the audio block is configured as a master
                                                     (MODE[1] = 0) and NODIV = 0. It generates an interrupt
                                                     if the WCKCFG flag in the SAI_xSR register is set. Note:
                                                     This bit is used only in TDM mode and is meaningless in
                                                     other modes.                                                              */
      __IOM uint32 FREQIE     : 1;            /*!< [3..3] FIFO request interrupt enable. This bit is set and cleared
                                                     by software. When this bit is set, an interrupt is generated
                                                     if the FREQ bit in the SAI_xSR register is set. Since the
                                                     audio block defaults to operate as a transmitter after
                                                     reset, the MODE bit must be configured before setting FREQIE
                                                     to avoid a parasitic interruption in receiver mode,                       */
      __IOM uint32 CNRDYIE    : 1;            /*!< [4..4] Codec not ready interrupt enable (AC97). This bit is
                                                     set and cleared by software. When the interrupt is enabled,
                                                     the audio block detects in the slot 0 (tag0) of the AC97
                                                     frame if the Codec connected to this line is ready or not.
                                                     If it is not ready, the CNRDY flag in the SAI_xSR register
                                                     is set and an interruption i generated. This bit has a
                                                     meaning only if the AC97 mode is selected through                         */
      __IOM uint32 AFSDETIE   : 1;            /*!< [5..5] Anticipated frame synchronization detection interrupt
                                                     enable. This bit is set and cleared by software. When this
                                                     bit is set, an interrupt will be generated if the AFSDET
                                                     bit in the SAI_xSR register is set. This bit is meaningless
                                                     in AC97, SPDIF mode or when the audio block operates as
                                                     a master.                                                                 */
      __IOM uint32 LFSDETIE   : 1;            /*!< [6..6] Late frame synchronization detection interrupt enable.
                                                     This bit is set and cleared by software. When this bit
                                                     is set, an interrupt will be generated if the LFSDET bit
                                                     is set in the SAI_xSR register. This bit is meaningless
                                                     in AC97, SPDIF mode or when the audio block operates as
                                                     a master.                                                                 */
            uint32            : 25;
    } bit;
  } SAI_AIM;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000018) Status register                                            */
    
    struct {
      __IM  uint32 OVRUDR     : 1;            /*!< [0..0] Overrun / underrun. This bit is read only. The overrun
                                                     and underrun conditions can occur only when the audio block
                                                     is configured as a receiver and a transmitter, respectively.
                                                     It can generate an interrupt if OVRUDRIE bit is set in
                                                     SAI_xIM register. This flag is cleared when the software
                                                     sets COVRUDR bit in SAI_xCLRFR register.                                  */
      __IM  uint32 MUTEDET    : 1;            /*!< [1..1] Mute detection. This bit is read only. This flag is set
                                                     if consecutive 0 values are received in each slot of a
                                                     given audio frame and for a consecutive number of audio
                                                     frames (set in the MUTECNT bit in the SAI_xCR2 register).
                                                     It can generate an interrupt if MUTEDETIE bit is set in
                                                     SAI_xIM register. This flag is cleared when the software
                                                     sets bit CMUTEDET in the SAI_xCLRFR register.                             */
      __IM  uint32 WCKCFG     : 1;            /*!< [2..2] Wrong clock configuration flag. This bit is read only.
                                                     This bit is used only when the audio block operates in
                                                     master mode (MODE[1] = 0) and NODIV = 0. It can generate
                                                     an interrupt if WCKCFGIE bit is set in SAI_xIM register.
                                                     This flag is cleared when the software sets CWCKCFG bit
                                                     in SAI_xCLRFR register.                                                   */
      __IM  uint32 FREQ       : 1;            /*!< [3..3] FIFO request. This bit is read only. The request depends
                                                     on the audio block configuration: If the block is configured
                                                     in transmission mode, the FIFO request is related to a
                                                     write request operation in the SAI_xDR. If the block configured
                                                     in reception, the FIFO request related to a read request
                                                     operation from the SAI_xDR. This flag can generate an interrupt
                                                     if FREQIE bit is set in SAI_xIM                                           */
      __IM  uint32 CNRDY      : 1;            /*!< [4..4] Codec not ready. This bit is read only. This bit is used
                                                     only when the AC97 audio protocol is selected in the SAI_xCR1
                                                     register and configured in receiver mode. It can generate
                                                     an interrupt if CNRDYIE bit is set in SAI_xIM register.
                                                     This flag is cleared when the software sets CCNRDY bit
                                                     in SAI_xCLRFR register.                                                   */
      __IM  uint32 AFSDET     : 1;            /*!< [5..5] Anticipated frame synchronization detection. This bit
                                                     is read only. This flag can be set only if the audio block
                                                     is configured in slave mode. It is not used in AC97or SPDIF
                                                     mode. It can generate an interrupt if AFSDETIE bit is set
                                                     in SAI_xIM register. This flag is cleared when the software
                                                     sets CAFSDET bit in SAI_xCLRFR register.                                  */
      __IM  uint32 LFSDET     : 1;            /*!< [6..6] Late frame synchronization detection. This bit is read
                                                     only. This flag can be set only if the audio block is configured
                                                     in slave mode. It is not used in AC97 or SPDIF mode. It
                                                     can generate an interrupt if LFSDETIE bit is set in the
                                                     SAI_xIM register. This flag is cleared when the software
                                                     sets bit CLFSDET in SAI_xCLRFR register                                   */
            uint32            : 9;
      __IM  uint32 FLVL       : 3;            /*!< [18..16] FIFO level threshold. This bit is read only. The FIFO
                                                     level threshold flag is managed only by hardware and its
                                                     setting depends on SAI block configuration (transmitter
                                                     or receiver mode). If the SAI block is configured as transmitter:
                                                     If SAI block is configured as receiver:                                   */
            uint32            : 13;
    } bit;
  } SAI_ASR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x0000001C) Clear flag register                                        */
    
    struct {
      __OM  uint32 COVRUDR    : 1;            /*!< [0..0] Clear overrun / underrun. This bit is write only. Programming
                                                     this bit to 1 clears the OVRUDR flag in the SAI_xSR register.
                                                     Reading this bit always returns the value 0.                              */
      __OM  uint32 CMUTEDET   : 1;            /*!< [1..1] Mute detection flag. This bit is write only. Programming
                                                     this bit to 1 clears the MUTEDET flag in the SAI_xSR register.
                                                     Reading this bit always returns the value 0.                              */
      __OM  uint32 CWCKCFG    : 1;            /*!< [2..2] Clear wrong clock configuration flag. This bit is write
                                                     only. Programming this bit to 1 clears the WCKCFG flag
                                                     in the SAI_xSR register. This bit is used only when the
                                                     audio block is set as master (MODE[1] = 0) and NODIV =
                                                     0 in the SAI_xCR1 register. Reading this bit always returns
                                                     the value 0.                                                              */
            uint32            : 1;
      __OM  uint32 CCNRDY     : 1;            /*!< [4..4] Clear Codec not ready flag. This bit is write only. Programming
                                                     this bit to 1 clears the CNRDY flag in the SAI_xSR register.
                                                     This bit is used only when the AC97 audio protocol is selected
                                                     in the SAI_xCR1 register. Reading this bit always returns
                                                     the value 0.                                                              */
      __OM  uint32 CAFSDET    : 1;            /*!< [5..5] Clear anticipated frame synchronization detection flag.
                                                     This bit is write only. Programming this bit to 1 clears
                                                     the AFSDET flag in the SAI_xSR register. It is not used
                                                     in AC97or SPDIF mode. Reading this bit always returns the
                                                     value 0.                                                                  */
      __OM  uint32 CLFSDET    : 1;            /*!< [6..6] Clear late frame synchronization detection flag. This
                                                     bit is write only. Programming this bit to 1 clears the
                                                     LFSDET flag in the SAI_xSR register. This bit is not used
                                                     in AC97or SPDIF mode Reading this bit always returns the
                                                     value 0.                                                                  */
            uint32            : 25;
    } bit;
  } SAI_ACLRFR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000020) Data register                                              */
    
    struct {
      __IOM uint32 DATA       : 32;           /*!< [31..0] Data A write to this register loads the FIFO provided
                                                     the FIFO is not full. A read from this register empties
                                                     the FIFO if the FIFO is not empty.                                        */
    } bit;
  } SAI_ADR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000024) Configuration register 1                                   */
    
    struct {
      __IOM uint32 MODE       : 2;            /*!< [1..0] SAIx audio block mode immediately                                  */
      __IOM uint32 PRTCFG     : 2;            /*!< [3..2] Protocol configuration. These bits are set and cleared
                                                     by software. These bits have to be configured when the
                                                     audio block is disabled.                                                  */
            uint32            : 1;
      __IOM uint32 DS         : 3;            /*!< [7..5] Data size. These bits are set and cleared by software.
                                                     These bits are ignored when the SPDIF protocols are selected
                                                     (bit PRTCFG[1:0]), because the frame and the data size
                                                     are fixed in such case. When the companding mode is selected
                                                     through COMP[1:0] bits, DS[1:0] are ignored since the data
                                                     size is fixed to 8 bits by the algorithm. These bits must
                                                     be configured when the audio block is di                                  */
      __IOM uint32 LSBFIRST   : 1;            /*!< [8..8] Least significant bit first. This bit is set and cleared
                                                     by software. It must be configured when the audio block
                                                     is disabled. This bit has no meaning in AC97 audio protocol
                                                     since AC97 data are always transferred with the MSB first.
                                                     This bit has no meaning in SPDIF audio protocol since in
                                                     SPDIF data are always transferred with LSB first.                         */
      __IOM uint32 CKSTR      : 1;            /*!< [9..9] Clock strobing edge. This bit is set and cleared by software.
                                                     It must be configured when the audio block is disabled.
                                                     This bit has no meaning in SPDIF audio protocol.                          */
      __IOM uint32 SYNCEN     : 2;            /*!< [11..10] Synchronization enable. These bits are set and cleared
                                                     by software. They must be configured when the audio sub-block
                                                     is disabled. Note: The audio sub-block should be configured
                                                     as asynchronous when SPDIF mode is enabled.                               */
      __IOM uint32 MONO       : 1;            /*!< [12..12] Mono mode. This bit is set and cleared by software.
                                                     It is meaningful only when the number of slots is equal
                                                     to 2. When the mono mode is selected, slot 0 data are duplicated
                                                     on slot 1 when the audio block operates as a transmitter.
                                                     In reception mode, the slot1 is discarded and only the
                                                     data received from slot 0 are stored. Refer to Section:
                                                     Mono/stereo mode for more details.                                        */
      __IOM uint32 OUTDRIV    : 1;            /*!< [13..13] Output drive. This bit is set and cleared by software.
                                                     Note: This bit has to be set before enabling the audio
                                                     block and after the audio block configuration.                            */
            uint32            : 2;
      __IOM uint32 SAIXEN     : 1;            /*!< [16..16] Audio block enable where x is A or B. This bit is set
                                                     by software. To switch off the audio block, the application
                                                     software must program this bit to 0 and poll the bit till
                                                     it reads back 0, meaning that the block is completely disabled.
                                                     Before setting this bit to 1, check that it is set to 0,
                                                     otherwise the enable command will not be taken into account.
                                                     This bit allows to control the state of SAIx audio                        */
      __IOM uint32 DMAEN      : 1;            /*!< [17..17] DMA enable. This bit is set and cleared by software.
                                                     Note: Since the audio block defaults to operate as a transmitter
                                                     after reset, the MODE[1:0] bits must be configured before
                                                     setting DMAEN to avoid a DMA request in receiver mode.                    */
            uint32            : 1;
      __IOM uint32 NOMCK      : 1;            /*!< [19..19] No divider                                                       */
      __IOM uint32 MCKDIV     : 4;            /*!< [23..20] Master clock divider. These bits are set and cleared
                                                     by software. These bits are meaningless when the audio
                                                     block operates in slave mode. They have to be configured
                                                     when the audio block is disabled. Others: the master clock
                                                     frequency is calculated accordingly to the following formula:             */
            uint32            : 2;
      __IOM uint32 OSR        : 1;            /*!< [26..26] Oversampling ratio for master clock                              */
            uint32            : 5;
    } bit;
  } SAI_BCR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000028) Configuration register 2                                   */
    
    struct {
      __IOM uint32 FTH        : 3;            /*!< [2..0] FIFO threshold. This bit is set and cleared by software.           */
      __OM  uint32 FFLUSH     : 1;            /*!< [3..3] FIFO flush. This bit is set by software. It is always
                                                     read as 0. This bit should be configured when the SAI is
                                                     disabled.                                                                 */
      __IOM uint32 TRIS       : 1;            /*!< [4..4] Tristate management on data line. This bit is set and
                                                     cleared by software. It is meaningful only if the audio
                                                     block is configured as a transmitter. This bit is not used
                                                     when the audio block is configured in SPDIF mode. It should
                                                     be configured when SAI is disabled. Refer to Section: Output
                                                     data line management on an inactive slot for more details.                */
      __IOM uint32 MUTE       : 1;            /*!< [5..5] Mute. This bit is set and cleared by software. It is
                                                     meaningful only when the audio block operates as a transmitter.
                                                     The MUTE value is linked to value of MUTEVAL if the number
                                                     of slots is lower or equal to 2, or equal to 0 if it is
                                                     greater than 2. Refer to Section: Mute mode for more details.
                                                     Note: This bit is meaningless and should not be used for
                                                     SPDIF audio blocks.                                                       */
      __IOM uint32 MUTEVAL    : 1;            /*!< [6..6] Mute value. This bit is set and cleared by software.It
                                                     must be written before enabling the audio block: SAIXEN.
                                                     This bit is meaningful only when the audio block operates
                                                     as a transmitter, the number of slots is lower or equal
                                                     to 2 and the MUTE bit is set. If more slots are declared,
                                                     the bit value sent during the transmission in mute mode
                                                     is equal to 0, whatever the value of MUTEVAL. if the number
                                                     of s                                                                      */
      __IOM uint32 MUTECNT    : 6;            /*!< [12..7] Mute counter. These bits are set and cleared by software.
                                                     They are used only in reception mode. The value set in
                                                     these bits is compared to the number of consecutive mute
                                                     frames detected in reception. When the number of mute frames
                                                     is equal to this value, the flag MUTEDET will be set and
                                                     an interrupt will be generated if bit MUTEDETIE is set.
                                                     Refer to Section: Mute mode for more details.                             */
      __IOM uint32 CPL        : 1;            /*!< [13..13] Complement bit. This bit is set and cleared by software.
                                                     It defines the type of complement to be used for companding
                                                     mode Note: This bit has effect only when the companding
                                                     mode is -Law algorithm or A-Law algorithm.                                */
      __IOM uint32 COMP       : 2;            /*!< [15..14] Companding mode. These bits are set and cleared by
                                                     software. The -Law and the A-Law log are a part of the
                                                     CCITT G.711 recommendation, the type of complement that
                                                     will be used depends on CPL bit. The data expansion or
                                                     data compression are determined by the state of bit MODE[0].
                                                     The data compression is applied if the audio block is configured
                                                     as a transmitter. The data expansion is automatically                     */
            uint32            : 16;
    } bit;
  } SAI_BCR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000002C) This register has no meaning in AC97 and SPDIF
                                                                    audio protocol                                             */
    
    struct {
      __IOM uint32 FRL        : 8;            /*!< [7..0] Frame length. These bits are set and cleared by software.
                                                     They define the audio frame length expressed in number
                                                     of SCK clock cycles: the number of bits in the frame is
                                                     equal to FRL[7:0] + 1. The minimum number of bits to transfer
                                                     in an audio frame must be equal to 8, otherwise the audio
                                                     block will behaves in an unexpected way. This is the case
                                                     when the data size is 8 bits and only one slot 0 is                       */
      __IOM uint32 FSALL      : 7;            /*!< [14..8] Frame synchronization active level length. These bits
                                                     are set and cleared by software. They specify the length
                                                     in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the
                                                     active level of the FS signal in the audio frame These
                                                     bits are meaningless and are not used in AC97 or SPDIF
                                                     audio block configuration. They must be configured when
                                                     the audio block is disabled.                                              */
            uint32            : 1;
      __IM  uint32 FSDEF      : 1;            /*!< [16..16] Frame synchronization definition. This bit is set and
                                                     cleared by software. When the bit is set, the number of
                                                     slots defined in the SAI_xSLOTR register has to be even.
                                                     It means that half of this number of slots will be dedicated
                                                     to the left channel and the other slots for the right channel
                                                     (e.g: this bit has to be set for I2S or MSB/LSB-justified
                                                     protocols...). This bit is meaningless and is not                         */
      __IOM uint32 FSPOL      : 1;            /*!< [17..17] Frame synchronization polarity. This bit is set and
                                                     cleared by software. It is used to configure the level
                                                     of the start of frame on the FS signal. It is meaningless
                                                     and is not used in AC97 or SPDIF audio block configuration.
                                                     This bit must be configured when the audio block is disabled.             */
      __IOM uint32 FSOFF      : 1;            /*!< [18..18] Frame synchronization offset. This bit is set and cleared
                                                     by software. It is meaningless and is not used in AC97
                                                     or SPDIF audio block configuration. This bit must be configured
                                                     when the audio block is disabled.                                         */
            uint32            : 13;
    } bit;
  } SAI_BFRCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000030) This register has no meaning in AC97 and SPDIF
                                                                    audio protocol                                             */
    
    struct {
      __IOM uint32 FBOFF      : 5;            /*!< [4..0] First bit offset These bits are set and cleared by software.
                                                     The value set in this bitfield defines the position of
                                                     the first data transfer bit in the slot. It represents
                                                     an offset value. In transmission mode, the bits outside
                                                     the data field are forced to 0. In reception mode, the
                                                     extra received bits are discarded. These bits must be set
                                                     when the audio block is disabled. They are ignored in                     */
            uint32            : 1;
      __IOM uint32 SLOTSZ     : 2;            /*!< [7..6] Slot size This bits is set and cleared by software. The
                                                     slot size must be higher or equal to the data size. If
                                                     this condition is not respected, the behavior of the SAI
                                                     will be undetermined. Refer to Section: Output data line
                                                     management on an inactive slot for information on how to
                                                     drive SD line. These bits must be set when the audio block
                                                     is disabled. They are ignored in AC97 or SPDIF m                          */
      __IOM uint32 NBSLOT     : 4;            /*!< [11..8] Number of slots in an audio frame. These bits are set
                                                     and cleared by software. The value set in this bitfield
                                                     represents the number of slots + 1 in the audio frame (including
                                                     the number of inactive slots). The maximum number of slots
                                                     is 16. The number of slots should be even if FSDEF bit
                                                     in the SAI_xFRCR register is set. The number of slots must
                                                     be configured when the audio block is disabled. They are                  */
            uint32            : 4;
      __IOM uint32 SLOTEN     : 16;           /*!< [31..16] Slot enable. These bits are set and cleared by software.
                                                     Each SLOTEN bit corresponds to a slot position from 0 to
                                                     15 (maximum 16 slots). The slot must be enabled when the
                                                     audio block is disabled. They are ignored in AC97 or SPDIF
                                                     mode.                                                                     */
    } bit;
  } SAI_BSLOTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000034) Interrupt mask register 2                                  */
    
    struct {
      __IOM uint32 OVRUDRIE   : 1;            /*!< [0..0] Overrun/underrun interrupt enable. This bit is set and
                                                     cleared by software. When this bit is set, an interrupt
                                                     is generated if the OVRUDR bit in the SAI_xSR register
                                                     is set.                                                                   */
      __IOM uint32 MUTEDETIE  : 1;            /*!< [1..1] Mute detection interrupt enable. This bit is set and
                                                     cleared by software. When this bit is set, an interrupt
                                                     is generated if the MUTEDET bit in the SAI_xSR register
                                                     is set. This bit has a meaning only if the audio block
                                                     is configured in receiver mode.                                           */
      __IOM uint32 WCKCFGIE   : 1;            /*!< [2..2] Wrong clock configuration interrupt enable. This bit
                                                     is set and cleared by software. This bit is taken into
                                                     account only if the audio block is configured as a master
                                                     (MODE[1] = 0) and NODIV = 0. It generates an interrupt
                                                     if the WCKCFG flag in the SAI_xSR register is set. Note:
                                                     This bit is used only in TDM mode and is meaningless in
                                                     other modes.                                                              */
      __IOM uint32 FREQIE     : 1;            /*!< [3..3] FIFO request interrupt enable. This bit is set and cleared
                                                     by software. When this bit is set, an interrupt is generated
                                                     if the FREQ bit in the SAI_xSR register is set. Since the
                                                     audio block defaults to operate as a transmitter after
                                                     reset, the MODE bit must be configured before setting FREQIE
                                                     to avoid a parasitic interruption in receiver mode,                       */
      __IOM uint32 CNRDYIE    : 1;            /*!< [4..4] Codec not ready interrupt enable (AC97). This bit is
                                                     set and cleared by software. When the interrupt is enabled,
                                                     the audio block detects in the slot 0 (tag0) of the AC97
                                                     frame if the Codec connected to this line is ready or not.
                                                     If it is not ready, the CNRDY flag in the SAI_xSR register
                                                     is set and an interruption i generated. This bit has a
                                                     meaning only if the AC97 mode is selected through                         */
      __IOM uint32 AFSDETIE   : 1;            /*!< [5..5] Anticipated frame synchronization detection interrupt
                                                     enable. This bit is set and cleared by software. When this
                                                     bit is set, an interrupt will be generated if the AFSDET
                                                     bit in the SAI_xSR register is set. This bit is meaningless
                                                     in AC97, SPDIF mode or when the audio block operates as
                                                     a master.                                                                 */
      __IOM uint32 LFSDETIE   : 1;            /*!< [6..6] Late frame synchronization detection interrupt enable.
                                                     This bit is set and cleared by software. When this bit
                                                     is set, an interrupt will be generated if the LFSDET bit
                                                     is set in the SAI_xSR register. This bit is meaningless
                                                     in AC97, SPDIF mode or when the audio block operates as
                                                     a master.                                                                 */
            uint32            : 25;
    } bit;
  } SAI_BIM;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000038) Status register                                            */
    
    struct {
      __IM  uint32 OVRUDR     : 1;            /*!< [0..0] Overrun / underrun. This bit is read only. The overrun
                                                     and underrun conditions can occur only when the audio block
                                                     is configured as a receiver and a transmitter, respectively.
                                                     It can generate an interrupt if OVRUDRIE bit is set in
                                                     SAI_xIM register. This flag is cleared when the software
                                                     sets COVRUDR bit in SAI_xCLRFR register.                                  */
      __IM  uint32 MUTEDET    : 1;            /*!< [1..1] Mute detection. This bit is read only. This flag is set
                                                     if consecutive 0 values are received in each slot of a
                                                     given audio frame and for a consecutive number of audio
                                                     frames (set in the MUTECNT bit in the SAI_xCR2 register).
                                                     It can generate an interrupt if MUTEDETIE bit is set in
                                                     SAI_xIM register. This flag is cleared when the software
                                                     sets bit CMUTEDET in the SAI_xCLRFR register.                             */
      __IM  uint32 WCKCFG     : 1;            /*!< [2..2] Wrong clock configuration flag. This bit is read only.
                                                     This bit is used only when the audio block operates in
                                                     master mode (MODE[1] = 0) and NODIV = 0. It can generate
                                                     an interrupt if WCKCFGIE bit is set in SAI_xIM register.
                                                     This flag is cleared when the software sets CWCKCFG bit
                                                     in SAI_xCLRFR register.                                                   */
      __IM  uint32 FREQ       : 1;            /*!< [3..3] FIFO request. This bit is read only. The request depends
                                                     on the audio block configuration: If the block is configured
                                                     in transmission mode, the FIFO request is related to a
                                                     write request operation in the SAI_xDR. If the block configured
                                                     in reception, the FIFO request related to a read request
                                                     operation from the SAI_xDR. This flag can generate an interrupt
                                                     if FREQIE bit is set in SAI_xIM                                           */
      __IM  uint32 CNRDY      : 1;            /*!< [4..4] Codec not ready. This bit is read only. This bit is used
                                                     only when the AC97 audio protocol is selected in the SAI_xCR1
                                                     register and configured in receiver mode. It can generate
                                                     an interrupt if CNRDYIE bit is set in SAI_xIM register.
                                                     This flag is cleared when the software sets CCNRDY bit
                                                     in SAI_xCLRFR register.                                                   */
      __IM  uint32 AFSDET     : 1;            /*!< [5..5] Anticipated frame synchronization detection. This bit
                                                     is read only. This flag can be set only if the audio block
                                                     is configured in slave mode. It is not used in AC97or SPDIF
                                                     mode. It can generate an interrupt if AFSDETIE bit is set
                                                     in SAI_xIM register. This flag is cleared when the software
                                                     sets CAFSDET bit in SAI_xCLRFR register.                                  */
      __IM  uint32 LFSDET     : 1;            /*!< [6..6] Late frame synchronization detection. This bit is read
                                                     only. This flag can be set only if the audio block is configured
                                                     in slave mode. It is not used in AC97 or SPDIF mode. It
                                                     can generate an interrupt if LFSDETIE bit is set in the
                                                     SAI_xIM register. This flag is cleared when the software
                                                     sets bit CLFSDET in SAI_xCLRFR register                                   */
            uint32            : 9;
      __IM  uint32 FLVL       : 3;            /*!< [18..16] FIFO level threshold. This bit is read only. The FIFO
                                                     level threshold flag is managed only by hardware and its
                                                     setting depends on SAI block configuration (transmitter
                                                     or receiver mode). If the SAI block is configured as transmitter:
                                                     If SAI block is configured as receiver:                                   */
            uint32            : 13;
    } bit;
  } SAI_BSR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x0000003C) Clear flag register                                        */
    
    struct {
      __OM  uint32 COVRUDR    : 1;            /*!< [0..0] Clear overrun / underrun. This bit is write only. Programming
                                                     this bit to 1 clears the OVRUDR flag in the SAI_xSR register.
                                                     Reading this bit always returns the value 0.                              */
      __OM  uint32 CMUTEDET   : 1;            /*!< [1..1] Mute detection flag. This bit is write only. Programming
                                                     this bit to 1 clears the MUTEDET flag in the SAI_xSR register.
                                                     Reading this bit always returns the value 0.                              */
      __OM  uint32 CWCKCFG    : 1;            /*!< [2..2] Clear wrong clock configuration flag. This bit is write
                                                     only. Programming this bit to 1 clears the WCKCFG flag
                                                     in the SAI_xSR register. This bit is used only when the
                                                     audio block is set as master (MODE[1] = 0) and NODIV =
                                                     0 in the SAI_xCR1 register. Reading this bit always returns
                                                     the value 0.                                                              */
            uint32            : 1;
      __OM  uint32 CCNRDY     : 1;            /*!< [4..4] Clear Codec not ready flag. This bit is write only. Programming
                                                     this bit to 1 clears the CNRDY flag in the SAI_xSR register.
                                                     This bit is used only when the AC97 audio protocol is selected
                                                     in the SAI_xCR1 register. Reading this bit always returns
                                                     the value 0.                                                              */
      __OM  uint32 CAFSDET    : 1;            /*!< [5..5] Clear anticipated frame synchronization detection flag.
                                                     This bit is write only. Programming this bit to 1 clears
                                                     the AFSDET flag in the SAI_xSR register. It is not used
                                                     in AC97or SPDIF mode. Reading this bit always returns the
                                                     value 0.                                                                  */
      __OM  uint32 CLFSDET    : 1;            /*!< [6..6] Clear late frame synchronization detection flag. This
                                                     bit is write only. Programming this bit to 1 clears the
                                                     LFSDET flag in the SAI_xSR register. This bit is not used
                                                     in AC97or SPDIF mode Reading this bit always returns the
                                                     value 0.                                                                  */
            uint32            : 25;
    } bit;
  } SAI_BCLRFR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000040) Data register                                              */
    
    struct {
      __IOM uint32 DATA       : 32;           /*!< [31..0] Data A write to this register loads the FIFO provided
                                                     the FIFO is not full. A read from this register empties
                                                     the FIFO if the FIFO is not empty.                                        */
    } bit;
  } SAI_BDR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000044) PDM control register                                       */
    
    struct {
      __IOM uint32 PDMEN      : 1;            /*!< [0..0] PDM enable                                                         */
            uint32            : 3;
      __IOM uint32 MICNBR     : 2;            /*!< [5..4] Number of microphones                                              */
            uint32            : 2;
      __IOM uint32 CKEN1      : 1;            /*!< [8..8] Clock enable of bitstream clock number 1                           */
      __IOM uint32 CKEN2      : 1;            /*!< [9..9] Clock enable of bitstream clock number 2                           */
      __IOM uint32 CKEN3      : 1;            /*!< [10..10] Clock enable of bitstream clock number 3                         */
      __IOM uint32 CKEN4      : 1;            /*!< [11..11] Clock enable of bitstream clock number 4                         */
            uint32            : 20;
    } bit;
  } SAI_PDMCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000048) PDM delay register                                         */
    
    struct {
      __IOM uint32 DLYM1L     : 3;            /*!< [2..0] Delay line adjust for first microphone of pair 1                   */
            uint32            : 1;
      __IOM uint32 DLYM1R     : 3;            /*!< [6..4] Delay line adjust for second microphone of pair 1                  */
            uint32            : 1;
      __IOM uint32 DLYM2L     : 3;            /*!< [10..8] Delay line for first microphone of pair 2                         */
            uint32            : 1;
      __IOM uint32 DLYM2R     : 3;            /*!< [14..12] Delay line for second microphone of pair 2                       */
            uint32            : 1;
      __IOM uint32 DLYM3L     : 3;            /*!< [18..16] Delay line for first microphone of pair 3                        */
            uint32            : 1;
      __IOM uint32 DLYM3R     : 3;            /*!< [22..20] Delay line for second microphone of pair 3                       */
            uint32            : 1;
      __IOM uint32 DLYM4L     : 3;            /*!< [26..24] Delay line for first microphone of pair 4                        */
            uint32            : 1;
      __IOM uint32 DLYM4R     : 3;            /*!< [30..28] Delay line for second microphone of pair 4                       */
            uint32            : 1;
    } bit;
  } SAI_PDMDLY;
} SAI4_Type;                                    /*!< Size = 76 (0x4c)                                                          */



/* =========================================================================================================================== */
/* ================                                          SDMMC1                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief SDMMC1 (SDMMC1)
  */

typedef struct {                                /*!< (@ 0x52007000) SDMMC1 Structure                                           */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) SDMMC power control register                               */
    
    struct {
      __IOM uint32 PWRCTRL    : 2;            /*!< [1..0] SDMMC state control bits. These bits can only be written
                                                     when the SDMMC is not in the power-on state (PWRCTRL?11).
                                                     These bits are used to define the functional state of the
                                                     SDMMC signals: Any further write will be ignored, PWRCTRL
                                                     value will keep 11.                                                       */
      __IOM uint32 VSWITCH    : 1;            /*!< [2..2] Voltage switch sequence start. This bit is used to start
                                                     the timing critical section of the voltage switch sequence:               */
      __IOM uint32 VSWITCHEN  : 1;            /*!< [3..3] Voltage switch procedure enable. This bit can only be
                                                     written by firmware when CPSM is disabled (CPSMEN = 0).
                                                     This bit is used to stop the SDMMC_CK after the voltage
                                                     switch command response:                                                  */
      __IOM uint32 DIRPOL     : 1;            /*!< [4..4] Data and command direction signals polarity selection.
                                                     This bit can only be written when the SDMMC is in the power-off
                                                     state (PWRCTRL = 00).                                                     */
            uint32            : 27;
    } bit;
  } SDMMC_POWER;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) The SDMMC_CLKCR register controls the SDMMC_CK
                                                                    output clock, the SDMMC_RX_CLK receive clock,
                                                                    and the bus width.                                         */
    
    struct {
      __IOM uint32 CLKDIV     : 10;           /*!< [9..0] Clock divide factor This bit can only be written when
                                                     the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT
                                                     = 0). This field defines the divide factor between the
                                                     input clock (SDMMCCLK) and the output clock (SDMMC_CK):
                                                     SDMMC_CK frequency = SDMMCCLK / [2 * CLKDIV]. 0xx: etc..
                                                     xxx: etc..                                                                */
            uint32            : 2;
      __IOM uint32 PWRSAV     : 1;            /*!< [12..12] Power saving configuration bit This bit can only be
                                                     written when the CPSM and DPSM are not active (CPSMACT
                                                     = 0 and DPSMACT = 0) For power saving, the SDMMC_CK clock
                                                     output can be disabled when the bus is idle by setting
                                                     PWRSAV:                                                                   */
            uint32            : 1;
      __IOM uint32 WIDBUS     : 2;            /*!< [15..14] Wide bus mode enable bit This bit can only be written
                                                     when the CPSM and DPSM are not active (CPSMACT = 0 and
                                                     DPSMACT = 0)                                                              */
      __IOM uint32 NEGEDGE    : 1;            /*!< [16..16] SDMMC_CK dephasing selection bit for data and Command.
                                                     This bit can only be written when the CPSM and DPSM are
                                                     not active (CPSMACT = 0 and DPSMACT = 0). When clock division
                                                     = 1 (CLKDIV = 0), this bit has no effect. Data and Command
                                                     change on SDMMC_CK falling edge. When clock division &gt;1
                                                     (CLKDIV &gt; 0) &amp; DDR = 0: - SDMMC_CK edge occurs on
                                                     SDMMCCLK rising edge. When clock division                                 */
      __IOM uint32 HWFC_EN    : 1;            /*!< [17..17] Hardware flow control enable This bit can only be written
                                                     when the CPSM and DPSM are not active (CPSMACT = 0 and
                                                     DPSMACT = 0) When Hardware flow control is enabled, the
                                                     meaning of the TXFIFOE and RXFIFOF flags change, please
                                                     see SDMMC status register definition in Section56.8.11.                   */
      __IOM uint32 DDR        : 1;            /*!< [18..18] Data rate signaling selection This bit can only be
                                                     written when the CPSM and DPSM are not active (CPSMACT
                                                     = 0 and DPSMACT = 0) DDR rate shall only be selected with
                                                     4-bit or 8-bit wide bus mode. (WIDBUS &gt; 00). DDR = 1
                                                     has no effect when WIDBUS = 00 (1-bit wide bus). DDR rate
                                                     shall only be selected with clock division &gt;1. (CLKDIV
                                                     &gt; 0)                                                                   */
      __IOM uint32 BUSSPEED   : 1;            /*!< [19..19] Bus speed mode selection between DS, HS, SDR12, SDR25
                                                     and SDR50, DDR50, SDR104. This bit can only be written
                                                     when the CPSM and DPSM are not active (CPSMACT = 0 and
                                                     DPSMACT = 0)                                                              */
      __IOM uint32 SELCLKRX   : 2;            /*!< [21..20] Receive clock selection. These bits can only be written
                                                     when the CPSM and DPSM are not active (CPSMACT = 0 and
                                                     DPSMACT = 0)                                                              */
            uint32            : 10;
    } bit;
  } SDMMC_CLKCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) The SDMMC_ARGR register contains a 32-bit command
                                                                    argument, which is sent to a card as part
                                                                    of a command message.                                      */
    
    struct {
      __IOM uint32 CMDARG     : 32;           /*!< [31..0] Command argument. These bits can only be written by
                                                     firmware when CPSM is disabled (CPSMEN = 0). Command argument
                                                     sent to a card as part of a command message. If a command
                                                     contains an argument, it must be loaded into this register
                                                     before writing a command to the command register.                         */
    } bit;
  } SDMMC_ARGR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) The SDMMC_CMDR register contains the command
                                                                    index and command type bits. The command
                                                                    index is sent to a card as part of a command
                                                                    message. The command type bits control the
                                                                    command path state machine (CPSM).                         */
    
    struct {
      __IOM uint32 CMDINDEX   : 6;            /*!< [5..0] Command index. This bit can only be written by firmware
                                                     when CPSM is disabled (CPSMEN = 0). The command index is
                                                     sent to the card as part of a command message.                            */
      __IOM uint32 CMDTRANS   : 1;            /*!< [6..6] The CPSM treats the command as a data transfer command,
                                                     stops the interrupt period, and signals DataEnable to the
                                                     DPSM This bit can only be written by firmware when CPSM
                                                     is disabled (CPSMEN = 0). If this bit is set, the CPSM
                                                     issues an end of interrupt period and issues DataEnable
                                                     signal to the DPSM when the command is sent.                              */
      __IOM uint32 CMDSTOP    : 1;            /*!< [7..7] The CPSM treats the command as a Stop Transmission command
                                                     and signals Abort to the DPSM. This bit can only be written
                                                     by firmware when CPSM is disabled (CPSMEN = 0). If this
                                                     bit is set, the CPSM issues the Abort signal to the DPSM
                                                     when the command is sent.                                                 */
      __IOM uint32 WAITRESP   : 2;            /*!< [9..8] Wait for response bits. This bit can only be written
                                                     by firmware when CPSM is disabled (CPSMEN = 0). They are
                                                     used to configure whether the CPSM is to wait for a response,
                                                     and if yes, which kind of response.                                       */
      __IOM uint32 WAITINT    : 1;            /*!< [10..10] CPSM waits for interrupt request. If this bit is set,
                                                     the CPSM disables command timeout and waits for an card
                                                     interrupt request (Response). If this bit is cleared in
                                                     the CPSM Wait state, will cause the abort of the interrupt
                                                     mode.                                                                     */
      __IOM uint32 WAITPEND   : 1;            /*!< [11..11] CPSM Waits for end of data transfer (CmdPend internal
                                                     signal) from DPSM. This bit when set, the CPSM waits for
                                                     the end of data transfer trigger before it starts sending
                                                     a command. WAITPEND is only taken into account when DTMODE
                                                     = MMC stream data transfer, WIDBUS = 1-bit wide bus mode,
                                                     DPSMACT = 1 and DTDIR = from host to card.                                */
      __IOM uint32 CPSMEN     : 1;            /*!< [12..12] Command path state machine (CPSM) Enable bit This bit
                                                     is written 1 by firmware, and cleared by hardware when
                                                     the CPSM enters the Idle state. If this bit is set, the
                                                     CPSM is enabled. When DTEN = 1, no command will be transfered
                                                     nor boot procedure will be started. CPSMEN is cleared to
                                                     0.                                                                        */
      __IOM uint32 DTHOLD     : 1;            /*!< [13..13] Hold new data block transmission and reception in the
                                                     DPSM. If this bit is set, the DPSM will not move from the
                                                     Wait_S state to the Send state or from the Wait_R state
                                                     to the Receive state.                                                     */
      __IOM uint32 BOOTMODE   : 1;            /*!< [14..14] Select the boot mode procedure to be used. This bit
                                                     can only be written by firmware when CPSM is disabled (CPSMEN
                                                     = 0)                                                                      */
      __IOM uint32 BOOTEN     : 1;            /*!< [15..15] Enable boot mode procedure.                                      */
      __IOM uint32 CMDSUSPEND : 1;            /*!< [16..16] The CPSM treats the command as a Suspend or Resume
                                                     command and signals interrupt period start/end. This bit
                                                     can only be written by firmware when CPSM is disabled (CPSMEN
                                                     = 0). CMDSUSPEND = 1 and CMDTRANS = 0 Suspend command,
                                                     start interrupt period when response bit BS=0. CMDSUSPEND
                                                     = 1 and CMDTRANS = 1 Resume command with data, end interrupt
                                                     period when response bit DF=1.                                            */
            uint32            : 15;
    } bit;
  } SDMMC_CMDR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000010) SDMMC command response register                            */
    
    struct {
      __IM  uint32 RESPCMD    : 6;            /*!< [5..0] Response command index                                             */
            uint32            : 26;
    } bit;
  } SDMMC_RESPCMDR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000014) The SDMMC_RESP1/2/3/4R registers contain the
                                                                    status of a card, which is part of the received
                                                                    response.                                                  */
    
    struct {
      __IM  uint32 CARDSTATUS1 : 32;          /*!< [31..0] see Table 432                                                     */
    } bit;
  } SDMMC_RESP1R;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000018) The SDMMC_RESP1/2/3/4R registers contain the
                                                                    status of a card, which is part of the received
                                                                    response.                                                  */
    
    struct {
      __IM  uint32 CARDSTATUS2 : 32;          /*!< [31..0] see Table404.                                                     */
    } bit;
  } SDMMC_RESP2R;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000001C) The SDMMC_RESP1/2/3/4R registers contain the
                                                                    status of a card, which is part of the received
                                                                    response.                                                  */
    
    struct {
      __IM  uint32 CARDSTATUS3 : 32;          /*!< [31..0] see Table404.                                                     */
    } bit;
  } SDMMC_RESP3R;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000020) The SDMMC_RESP1/2/3/4R registers contain the
                                                                    status of a card, which is part of the received
                                                                    response.                                                  */
    
    struct {
      __IM  uint32 CARDSTATUS4 : 32;          /*!< [31..0] see Table404.                                                     */
    } bit;
  } SDMMC_RESP4R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000024) The SDMMC_DTIMER register contains the data timeout
                                                                    period, in card bus clock periods. A counter
                                                                    loads the value from the SDMMC_DTIMER register,
                                                                    and starts decrementing when the data path
                                                                    state machine (DPSM) enters the Wait_R or
                                                                    Busy state. If the timer reaches 0 while
                                                                    the DPSM is in either of these states, the
                                                                    timeout status flag is set.                                */
    
    struct {
      __IOM uint32 DATATIME   : 32;           /*!< [31..0] Data and R1b busy timeout period This bit can only be
                                                     written when the CPSM and DPSM are not active (CPSMACT
                                                     = 0 and DPSMACT = 0). Data and R1b busy timeout period
                                                     expressed in card bus clock periods.                                      */
    } bit;
  } SDMMC_DTIMER;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000028) The SDMMC_DLENR register contains the number
                                                                    of data bytes to be transferred. The value
                                                                    is loaded into the data counter when data
                                                                    transfer starts.                                           */
    
    struct {
      __IOM uint32 DATALENGTH : 25;           /*!< [24..0] Data length value This register can only be written
                                                     by firmware when DPSM is inactive (DPSMACT = 0). Number
                                                     of data bytes to be transferred. When DDR = 1 DATALENGTH
                                                     is truncated to a multiple of 2. (The last odd byte is
                                                     not transfered) When DATALENGTH = 0 no data will be transfered,
                                                     when requested by a CPSMEN and CMDTRANS = 1 also no command
                                                     will be transfered. DTEN and CPSMEN are cleared to                        */
            uint32            : 7;
    } bit;
  } SDMMC_DLENR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000002C) The SDMMC_DCTRL register control the data path
                                                                    state machine (DPSM).                                      */
    
    struct {
      __IOM uint32 DTEN       : 1;            /*!< [0..0] Data transfer enable bit This bit can only be written
                                                     by firmware when DPSM is inactive (DPSMACT = 0). This bit
                                                     is cleared by Hardware when data transfer completes. This
                                                     bit shall only be used to transfer data when no associated
                                                     data transfer command is used, i.e. shall not be used with
                                                     SD or eMMC cards.                                                         */
      __IOM uint32 DTDIR      : 1;            /*!< [1..1] Data transfer direction selection This bit can only be
                                                     written by firmware when DPSM is inactive (DPSMACT = 0).                  */
      __IOM uint32 DTMODE     : 2;            /*!< [3..2] Data transfer mode selection. This bit can only be written
                                                     by firmware when DPSM is inactive (DPSMACT = 0).                          */
      __IOM uint32 DBLOCKSIZE : 4;            /*!< [7..4] Data block size This bit can only be written by firmware
                                                     when DPSM is inactive (DPSMACT = 0). Define the data block
                                                     length when the block data transfer mode is selected: When
                                                     DATALENGTH is not a multiple of DBLOCKSIZE, the transfered
                                                     data is truncated at a multiple of DBLOCKSIZE. (Any remain
                                                     data will not be transfered.) When DDR = 1, DBLOCKSIZE
                                                     = 0000 shall not be used. (No data will be                                */
      __IOM uint32 RWSTART    : 1;            /*!< [8..8] Read wait start. If this bit is set, read wait operation
                                                     starts.                                                                   */
      __IOM uint32 RWSTOP     : 1;            /*!< [9..9] Read wait stop This bit is written by firmware and auto
                                                     cleared by hardware when the DPSM moves from the READ_WAIT
                                                     state to the WAIT_R or IDLE state.                                        */
      __IOM uint32 RWMOD      : 1;            /*!< [10..10] Read wait mode. This bit can only be written by firmware
                                                     when DPSM is inactive (DPSMACT = 0).                                      */
      __IOM uint32 SDIOEN     : 1;            /*!< [11..11] SD I/O interrupt enable functions This bit can only
                                                     be written by firmware when DPSM is inactive (DPSMACT =
                                                     0). If this bit is set, the DPSM enables the SD I/O card
                                                     specific interrupt operation.                                             */
      __IOM uint32 BOOTACKEN  : 1;            /*!< [12..12] Enable the reception of the boot acknowledgment. This
                                                     bit can only be written by firmware when DPSM is inactive
                                                     (DPSMACT = 0).                                                            */
      __IOM uint32 FIFORST    : 1;            /*!< [13..13] FIFO reset, will flush any remaining data. This bit
                                                     can only be written by firmware when IDMAEN= 0 and DPSM
                                                     is active (DPSMACT = 1). This bit will only take effect
                                                     when a transfer error or transfer hold occurs.                            */
            uint32            : 18;
    } bit;
  } SDMMC_DCTRL;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000030) The SDMMC_DCNTR register loads the value from
                                                                    the data length register (see SDMMC_DLENR)
                                                                    when the DPSM moves from the Idle state
                                                                    to the Wait_R or Wait_S state. As data is
                                                                    transferred, the counter decrements the
                                                                    value until it reaches 0. The DPSM then
                                                                    moves to the Idle state and when there has
                                                                    been no error, the data status end flag
                                                                    (DATAEND) is set.                                          */
    
    struct {
      __IM  uint32 DATACOUNT  : 25;           /*!< [24..0] Data count value When read, the number of remaining
                                                     data bytes to be transferred is returned. Write has no
                                                     effect.                                                                   */
            uint32            : 7;
    } bit;
  } SDMMC_DCNTR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000034) The SDMMC_STAR register is a read-only register.
                                                                    It contains two types of flag:Static flags
                                                                    (bits [29,21,11:0]): these bits remain asserted
                                                                    until they are cleared by writing to the
                                                                    SDMMC interrupt Clear register (see SDMMC_ICR)Dynamic
                                                                    flags (bits [20:12]): these bits change
                                                                    state depending on the state of the underlying
                                                                    logic (for example, FIFO full and empty
                                                                    flags are asserted and de-asserted as data
                                                                    while writte                                               */
    
    struct {
      __IM  uint32 CCRCFAIL   : 1;            /*!< [0..0] Command response received (CRC check failed). Interrupt
                                                     flag is cleared by writing corresponding interrupt clear
                                                     bit in SDMMC_ICR.                                                         */
      __IM  uint32 DCRCFAIL   : 1;            /*!< [1..1] Data block sent/received (CRC check failed). Interrupt
                                                     flag is cleared by writing corresponding interrupt clear
                                                     bit in SDMMC_ICR.                                                         */
      __IM  uint32 CTIMEOUT   : 1;            /*!< [2..2] Command response timeout. Interrupt flag is cleared by
                                                     writing corresponding interrupt clear bit in SDMMC_ICR.
                                                     The Command Timeout period has a fixed value of 64 SDMMC_CK
                                                     clock periods.                                                            */
      __IM  uint32 DTIMEOUT   : 1;            /*!< [3..3] Data timeout. Interrupt flag is cleared by writing corresponding
                                                     interrupt clear bit in SDMMC_ICR.                                         */
      __IM  uint32 TXUNDERR   : 1;            /*!< [4..4] Transmit FIFO underrun error or IDMA read transfer error.
                                                     Interrupt flag is cleared by writing corresponding interrupt
                                                     clear bit in SDMMC_ICR.                                                   */
      __IM  uint32 RXOVERR    : 1;            /*!< [5..5] Received FIFO overrun error or IDMA write transfer error.
                                                     Interrupt flag is cleared by writing corresponding interrupt
                                                     clear bit in SDMMC_ICR.                                                   */
      __IM  uint32 CMDREND    : 1;            /*!< [6..6] Command response received (CRC check passed, or no CRC).
                                                     Interrupt flag is cleared by writing corresponding interrupt
                                                     clear bit in SDMMC_ICR.                                                   */
      __IM  uint32 CMDSENT    : 1;            /*!< [7..7] Command sent (no response required). Interrupt flag is
                                                     cleared by writing corresponding interrupt clear bit in
                                                     SDMMC_ICR.                                                                */
      __IM  uint32 DATAEND    : 1;            /*!< [8..8] Data transfer ended correctly. (data counter, DATACOUNT
                                                     is zero and no errors occur). Interrupt flag is cleared
                                                     by writing corresponding interrupt clear bit in SDMMC_ICR.                */
      __IM  uint32 DHOLD      : 1;            /*!< [9..9] Data transfer Hold. Interrupt flag is cleared by writing
                                                     corresponding interrupt clear bit in SDMMC_ICR.                           */
      __IM  uint32 DBCKEND    : 1;            /*!< [10..10] Data block sent/received. (CRC check passed) and DPSM
                                                     moves to the READWAIT state. Interrupt flag is cleared
                                                     by writing corresponding interrupt clear bit in SDMMC_ICR.                */
      __IM  uint32 DABORT     : 1;            /*!< [11..11] Data transfer aborted by CMD12. Interrupt flag is cleared
                                                     by writing corresponding interrupt clear bit in SDMMC_ICR.                */
      __IM  uint32 DPSMACT    : 1;            /*!< [12..12] Data path state machine active, i.e. not in Idle state.
                                                     This is a hardware status flag only, does not generate
                                                     an interrupt.                                                             */
      __IM  uint32 CPSMACT    : 1;            /*!< [13..13] Command path state machine active, i.e. not in Idle
                                                     state. This is a hardware status flag only, does not generate
                                                     an interrupt.                                                             */
      __IM  uint32 TXFIFOHE   : 1;            /*!< [14..14] Transmit FIFO half empty At least half the number of
                                                     words can be written into the FIFO. This bit is cleared
                                                     when the FIFO becomes half+1 full.                                        */
      __IM  uint32 RXFIFOHF   : 1;            /*!< [15..15] Receive FIFO half full There are at least half the
                                                     number of words in the FIFO. This bit is cleared when the
                                                     FIFO becomes half+1 empty.                                                */
      __IM  uint32 TXFIFOF    : 1;            /*!< [16..16] Transmit FIFO full This is a hardware status flag only,
                                                     does not generate an interrupt. This bit is cleared when
                                                     one FIFO location becomes empty.                                          */
      __IM  uint32 RXFIFOF    : 1;            /*!< [17..17] Receive FIFO full This bit is cleared when one FIFO
                                                     location becomes empty.                                                   */
      __IM  uint32 TXFIFOE    : 1;            /*!< [18..18] Transmit FIFO empty This bit is cleared when one FIFO
                                                     location becomes full.                                                    */
      __IM  uint32 RXFIFOE    : 1;            /*!< [19..19] Receive FIFO empty This is a hardware status flag only,
                                                     does not generate an interrupt. This bit is cleared when
                                                     one FIFO location becomes full.                                           */
      __IM  uint32 BUSYD0     : 1;            /*!< [20..20] Inverted value of SDMMC_D0 line (Busy), sampled at
                                                     the end of a CMD response and a second time 2 SDMMC_CK
                                                     cycles after the CMD response. This bit is reset to not
                                                     busy when the SDMMCD0 line changes from busy to not busy.
                                                     This bit does not signal busy due to data transfer. This
                                                     is a hardware status flag only, it does not generate an
                                                     interrupt.                                                                */
      __IM  uint32 BUSYD0END  : 1;            /*!< [21..21] end of SDMMC_D0 Busy following a CMD response detected.
                                                     This indicates only end of busy following a CMD response.
                                                     This bit does not signal busy due to data transfer. Interrupt
                                                     flag is cleared by writing corresponding interrupt clear
                                                     bit in SDMMC_ICR.                                                         */
      __IM  uint32 SDIOIT     : 1;            /*!< [22..22] SDIO interrupt received. Interrupt flag is cleared
                                                     by writing corresponding interrupt clear bit in SDMMC_ICR.                */
      __IM  uint32 ACKFAIL    : 1;            /*!< [23..23] Boot acknowledgment received (boot acknowledgment check
                                                     fail). Interrupt flag is cleared by writing corresponding
                                                     interrupt clear bit in SDMMC_ICR.                                         */
      __IM  uint32 ACKTIMEOUT : 1;            /*!< [24..24] Boot acknowledgment timeout. Interrupt flag is cleared
                                                     by writing corresponding interrupt clear bit in SDMMC_ICR.                */
      __IM  uint32 VSWEND     : 1;            /*!< [25..25] Voltage switch critical timing section completion.
                                                     Interrupt flag is cleared by writing corresponding interrupt
                                                     clear bit in SDMMC_ICR.                                                   */
      __IM  uint32 CKSTOP     : 1;            /*!< [26..26] SDMMC_CK stopped in Voltage switch procedure. Interrupt
                                                     flag is cleared by writing corresponding interrupt clear
                                                     bit in SDMMC_ICR.                                                         */
      __IM  uint32 IDMATE     : 1;            /*!< [27..27] IDMA transfer error. Interrupt flag is cleared by writing
                                                     corresponding interrupt clear bit in SDMMC_ICR.                           */
      __IM  uint32 IDMABTC    : 1;            /*!< [28..28] IDMA buffer transfer complete. interrupt flag is cleared
                                                     by writing corresponding interrupt clear bit in SDMMC_ICR.                */
            uint32            : 3;
    } bit;
  } SDMMC_STAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000038) The SDMMC_ICR register is a write-only register.
                                                                    Writing a bit with 1 clears the corresponding
                                                                    bit in the SDMMC_STAR status register.                     */
    
    struct {
      __IOM uint32 CCRCFAILC  : 1;            /*!< [0..0] CCRCFAIL flag clear bit Set by software to clear the
                                                     CCRCFAIL flag.                                                            */
      __IOM uint32 DCRCFAILC  : 1;            /*!< [1..1] DCRCFAIL flag clear bit Set by software to clear the
                                                     DCRCFAIL flag.                                                            */
      __IOM uint32 CTIMEOUTC  : 1;            /*!< [2..2] CTIMEOUT flag clear bit Set by software to clear the
                                                     CTIMEOUT flag.                                                            */
      __IOM uint32 DTIMEOUTC  : 1;            /*!< [3..3] DTIMEOUT flag clear bit Set by software to clear the
                                                     DTIMEOUT flag.                                                            */
      __IOM uint32 TXUNDERRC  : 1;            /*!< [4..4] TXUNDERR flag clear bit Set by software to clear TXUNDERR
                                                     flag.                                                                     */
      __IOM uint32 RXOVERRC   : 1;            /*!< [5..5] RXOVERR flag clear bit Set by software to clear the RXOVERR
                                                     flag.                                                                     */
      __IOM uint32 CMDRENDC   : 1;            /*!< [6..6] CMDREND flag clear bit Set by software to clear the CMDREND
                                                     flag.                                                                     */
      __IOM uint32 CMDSENTC   : 1;            /*!< [7..7] CMDSENT flag clear bit Set by software to clear the CMDSENT
                                                     flag.                                                                     */
      __IOM uint32 DATAENDC   : 1;            /*!< [8..8] DATAEND flag clear bit Set by software to clear the DATAEND
                                                     flag.                                                                     */
      __IOM uint32 DHOLDC     : 1;            /*!< [9..9] DHOLD flag clear bit Set by software to clear the DHOLD
                                                     flag.                                                                     */
      __IOM uint32 DBCKENDC   : 1;            /*!< [10..10] DBCKEND flag clear bit Set by software to clear the
                                                     DBCKEND flag.                                                             */
      __IOM uint32 DABORTC    : 1;            /*!< [11..11] DABORT flag clear bit Set by software to clear the
                                                     DABORT flag.                                                              */
            uint32            : 9;
      __IOM uint32 BUSYD0ENDC : 1;            /*!< [21..21] BUSYD0END flag clear bit Set by software to clear the
                                                     BUSYD0END flag.                                                           */
      __IOM uint32 SDIOITC    : 1;            /*!< [22..22] SDIOIT flag clear bit Set by software to clear the
                                                     SDIOIT flag.                                                              */
      __IOM uint32 ACKFAILC   : 1;            /*!< [23..23] ACKFAIL flag clear bit Set by software to clear the
                                                     ACKFAIL flag.                                                             */
      __IOM uint32 ACKTIMEOUTC : 1;           /*!< [24..24] ACKTIMEOUT flag clear bit Set by software to clear
                                                     the ACKTIMEOUT flag.                                                      */
      __IOM uint32 VSWENDC    : 1;            /*!< [25..25] VSWEND flag clear bit Set by software to clear the
                                                     VSWEND flag.                                                              */
      __IOM uint32 CKSTOPC    : 1;            /*!< [26..26] CKSTOP flag clear bit Set by software to clear the
                                                     CKSTOP flag.                                                              */
      __IOM uint32 IDMATEC    : 1;            /*!< [27..27] IDMA transfer error clear bit Set by software to clear
                                                     the IDMATE flag.                                                          */
      __IOM uint32 IDMABTCC   : 1;            /*!< [28..28] IDMA buffer transfer complete clear bit Set by software
                                                     to clear the IDMABTC flag.                                                */
            uint32            : 3;
    } bit;
  } SDMMC_ICR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000003C) The interrupt mask register determines which
                                                                    status flags generate an interrupt request
                                                                    by setting the corresponding bit to 1.                     */
    
    struct {
      __IOM uint32 CCRCFAILIE : 1;            /*!< [0..0] Command CRC fail interrupt enable Set and cleared by
                                                     software to enable/disable interrupt caused by command
                                                     CRC failure.                                                              */
      __IOM uint32 DCRCFAILIE : 1;            /*!< [1..1] Data CRC fail interrupt enable Set and cleared by software
                                                     to enable/disable interrupt caused by data CRC failure.                   */
      __IOM uint32 CTIMEOUTIE : 1;            /*!< [2..2] Command timeout interrupt enable Set and cleared by software
                                                     to enable/disable interrupt caused by command timeout.                    */
      __IOM uint32 DTIMEOUTIE : 1;            /*!< [3..3] Data timeout interrupt enable Set and cleared by software
                                                     to enable/disable interrupt caused by data timeout.                       */
      __IOM uint32 TXUNDERRIE : 1;            /*!< [4..4] Tx FIFO underrun error interrupt enable Set and cleared
                                                     by software to enable/disable interrupt caused by Tx FIFO
                                                     underrun error.                                                           */
      __IOM uint32 RXOVERRIE  : 1;            /*!< [5..5] Rx FIFO overrun error interrupt enable Set and cleared
                                                     by software to enable/disable interrupt caused by Rx FIFO
                                                     overrun error.                                                            */
      __IOM uint32 CMDRENDIE  : 1;            /*!< [6..6] Command response received interrupt enable Set and cleared
                                                     by software to enable/disable interrupt caused by receiving
                                                     command response.                                                         */
      __IOM uint32 CMDSENTIE  : 1;            /*!< [7..7] Command sent interrupt enable Set and cleared by software
                                                     to enable/disable interrupt caused by sending command.                    */
      __IOM uint32 DATAENDIE  : 1;            /*!< [8..8] Data end interrupt enable Set and cleared by software
                                                     to enable/disable interrupt caused by data end.                           */
      __IOM uint32 DHOLDIE    : 1;            /*!< [9..9] Data hold interrupt enable Set and cleared by software
                                                     to enable/disable the interrupt generated when sending
                                                     new data is hold in the DPSM Wait_S state.                                */
      __IOM uint32 DBCKENDIE  : 1;            /*!< [10..10] Data block end interrupt enable Set and cleared by
                                                     software to enable/disable interrupt caused by data block
                                                     end.                                                                      */
      __IOM uint32 DABORTIE   : 1;            /*!< [11..11] Data transfer aborted interrupt enable Set and cleared
                                                     by software to enable/disable interrupt caused by a data
                                                     transfer being aborted.                                                   */
            uint32            : 2;
      __IOM uint32 TXFIFOHEIE : 1;            /*!< [14..14] Tx FIFO half empty interrupt enable Set and cleared
                                                     by software to enable/disable interrupt caused by Tx FIFO
                                                     half empty.                                                               */
      __IOM uint32 RXFIFOHFIE : 1;            /*!< [15..15] Rx FIFO half full interrupt enable Set and cleared
                                                     by software to enable/disable interrupt caused by Rx FIFO
                                                     half full.                                                                */
            uint32            : 1;
      __IOM uint32 RXFIFOFIE  : 1;            /*!< [17..17] Rx FIFO full interrupt enable Set and cleared by software
                                                     to enable/disable interrupt caused by Rx FIFO full.                       */
      __IOM uint32 TXFIFOEIE  : 1;            /*!< [18..18] Tx FIFO empty interrupt enable Set and cleared by software
                                                     to enable/disable interrupt caused by Tx FIFO empty.                      */
            uint32            : 2;
      __IOM uint32 BUSYD0ENDIE : 1;           /*!< [21..21] BUSYD0END interrupt enable Set and cleared by software
                                                     to enable/disable the interrupt generated when SDMMC_D0
                                                     signal changes from busy to NOT busy following a CMD response.            */
      __IOM uint32 SDIOITIE   : 1;            /*!< [22..22] SDIO mode interrupt received interrupt enable Set and
                                                     cleared by software to enable/disable the interrupt generated
                                                     when receiving the SDIO mode interrupt.                                   */
      __IOM uint32 ACKFAILIE  : 1;            /*!< [23..23] Acknowledgment Fail interrupt enable Set and cleared
                                                     by software to enable/disable interrupt caused by acknowledgment
                                                     Fail.                                                                     */
      __IOM uint32 ACKTIMEOUTIE : 1;          /*!< [24..24] Acknowledgment timeout interrupt enable Set and cleared
                                                     by software to enable/disable interrupt caused by acknowledgment
                                                     timeout.                                                                  */
      __IOM uint32 VSWENDIE   : 1;            /*!< [25..25] Voltage switch critical timing section completion interrupt
                                                     enable Set and cleared by software to enable/disable the
                                                     interrupt generated when voltage switch critical timing
                                                     section completion.                                                       */
      __IOM uint32 CKSTOPIE   : 1;            /*!< [26..26] Voltage Switch clock stopped interrupt enable Set and
                                                     cleared by software to enable/disable interrupt caused
                                                     by Voltage Switch clock stopped.                                          */
            uint32            : 1;
      __IOM uint32 IDMABTCIE  : 1;            /*!< [28..28] IDMA buffer transfer complete interrupt enable Set
                                                     and cleared by software to enable/disable the interrupt
                                                     generated when the IDMA has transferred all data belonging
                                                     to a memory buffer.                                                       */
            uint32            : 3;
    } bit;
  } SDMMC_MASKR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000040) The SDMMC_ACKTIMER register contains the acknowledgment
                                                                    timeout period, in SDMMC_CK bus clock periods.
                                                                    A counter loads the value from the SDMMC_ACKTIMER
                                                                    register, and starts decrementing when the
                                                                    data path state machine (DPSM) enters the
                                                                    Wait_Ack state. If the timer reaches 0 while
                                                                    the DPSM is in this states, the acknowledgment
                                                                    timeout status flag is set.                                */
    
    struct {
      __IOM uint32 ACKTIME    : 25;           /*!< [24..0] Boot acknowledgment timeout period This bit can only
                                                     be written by firmware when CPSM is disabled (CPSMEN =
                                                     0). Boot acknowledgment timeout period expressed in card
                                                     bus clock periods.                                                        */
            uint32            : 7;
    } bit;
  } SDMMC_ACKTIMER;
  __IM  uint32  RESERVED[3];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000050) The receive and transmit FIFOs can be read or
                                                                    written as 32-bit wide registers. The FIFOs
                                                                    contain 32 entries on 32 sequential addresses.
                                                                    This allows the CPU to use its load and
                                                                    store multiple operands to read from/write
                                                                    to the FIFO.                                               */
    
    struct {
      __IOM uint32 IDMAEN     : 1;            /*!< [0..0] IDMA enable This bit can only be written by firmware
                                                     when DPSM is inactive (DPSMACT = 0).                                      */
      __IOM uint32 IDMABMODE  : 1;            /*!< [1..1] Buffer mode selection. This bit can only be written by
                                                     firmware when DPSM is inactive (DPSMACT = 0).                             */
      __IOM uint32 IDMABACT   : 1;            /*!< [2..2] Double buffer mode active buffer indication This bit
                                                     can only be written by firmware when DPSM is inactive (DPSMACT
                                                     = 0). When IDMA is enabled this bit is toggled by hardware.               */
            uint32            : 29;
    } bit;
  } SDMMC_IDMACTRLR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000054) The SDMMC_IDMABSIZER register contains the buffers
                                                                    size when in double buffer configuration.                  */
    
    struct {
            uint32            : 5;
      __IOM uint32 IDMABNDT   : 8;            /*!< [12..5] Number of transfers per buffer. This 8-bit value shall
                                                     be multiplied by 8 to get the size of the buffer in 32-bit
                                                     words and by 32 to get the size of the buffer in bytes.
                                                     Example: IDMABNDT = 0x01: buffer size = 8 words = 32 bytes.
                                                     These bits can only be written by firmware when DPSM is
                                                     inactive (DPSMACT = 0).                                                   */
            uint32            : 19;
    } bit;
  } SDMMC_IDMABSIZER;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000058) The SDMMC_IDMABASE0R register contains the memory
                                                                    buffer base address in single buffer configuration
                                                                    and the buffer 0 base address in double
                                                                    buffer configuration.                                      */
    
    struct {
      __IOM uint32 IDMABASE0  : 32;           /*!< [31..0] Buffer 0 memory base address bits [31:2], shall be word
                                                     aligned (bit [1:0] are always 0 and read only). This register
                                                     can be written by firmware when DPSM is inactive (DPSMACT
                                                     = 0), and can dynamically be written by firmware when DPSM
                                                     active (DPSMACT = 1) and memory buffer 0 is inactive (IDMABACT
                                                     = 1).                                                                     */
    } bit;
  } SDMMC_IDMABASE0R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000005C) The SDMMC_IDMABASE1R register contains the double
                                                                    buffer configuration second buffer memory
                                                                    base address.                                              */
    
    struct {
      __IOM uint32 IDMABASE1  : 32;           /*!< [31..0] Buffer 1 memory base address, shall be word aligned
                                                     (bit [1:0] are always 0 and read only). This register can
                                                     be written by firmware when DPSM is inactive (DPSMACT =
                                                     0), and can dynamically be written by firmware when DPSM
                                                     active (DPSMACT = 1) and memory buffer 1 is inactive (IDMABACT
                                                     = 0).                                                                     */
    } bit;
  } SDMMC_IDMABASE1R;
  __IM  uint32  RESERVED1[8];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000080) The receive and transmit FIFOs can be only read
                                                                    or written as word (32-bit) wide registers.
                                                                    The FIFOs contain 16 entries on sequential
                                                                    addresses. This allows the CPU to use its
                                                                    load and store multiple operands to read
                                                                    from/write to the FIFO.When accessing SDMMC_FIFOR
                                                                    with half word or byte access an AHB bus
                                                                    fault is generated.                                        */
    
    struct {
      __IOM uint32 FIFODATA   : 32;           /*!< [31..0] Receive and transmit FIFO data This register can only
                                                     be read or written by firmware when the DPSM is active
                                                     (DPSMACT=1). The FIFO data occupies 16 entries of 32-bit
                                                     words.                                                                    */
    } bit;
  } SDMMC_FIFOR;
  __IM  uint32  RESERVED2[220];
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000003F4) SDMMC IP version register                                  */
    
    struct {
      __IM  uint32 MINREV     : 4;            /*!< [3..0] IP minor revision number.                                          */
      __IM  uint32 MAJREV     : 4;            /*!< [7..4] IP major revision number.                                          */
            uint32            : 24;
    } bit;
  } SDMMC_VER;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000003F8) SDMMC IP identification register                           */
    
    struct {
      __IM  uint32 IP_ID      : 32;           /*!< [31..0] SDMMC IP identification.                                          */
    } bit;
  } SDMMC_ID;
} SDMMC1_Type;                                  /*!< Size = 1020 (0x3fc)                                                       */



/* =========================================================================================================================== */
/* ================                                          VREFBUF                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief VREFBUF (VREFBUF)
  */

typedef struct {                                /*!< (@ 0x58003C00) VREFBUF Structure                                          */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) VREFBUF control and status register                        */
    
    struct {
      __IOM uint32 ENVR       : 1;            /*!< [0..0] Voltage reference buffer mode enable This bit is used
                                                     to enable the voltage reference buffer mode.                              */
      __IOM uint32 HIZ        : 1;            /*!< [1..1] High impedance mode This bit controls the analog switch
                                                     to connect or not the VREF+ pin. Refer to Table196: VREF
                                                     buffer modes for the mode descriptions depending on ENVR
                                                     bit configuration.                                                        */
            uint32            : 1;
      __IM  uint32 VRR        : 1;            /*!< [3..3] Voltage reference buffer ready                                     */
      __IOM uint32 VRS        : 3;            /*!< [6..4] Voltage reference scale These bits select the value generated
                                                     by the voltage reference buffer. Other: Reserved                          */
            uint32            : 25;
    } bit;
  } VREFBUF_CSR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) VREFBUF calibration control register                       */
    
    struct {
      __IOM uint32 TRIM       : 6;            /*!< [5..0] Trimming code These bits are automatically initialized
                                                     after reset with the trimming value stored in the Flash
                                                     memory during the production test. Writing into these bits
                                                     allows to tune the internal reference buffer voltage.                     */
            uint32            : 26;
    } bit;
  } VREFBUF_CCR;
} VREFBUF_Type;                                 /*!< Size = 8 (0x8)                                                            */



/* =========================================================================================================================== */
/* ================                                           IWDG                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief IWDG (IWDG)
  */

typedef struct {                                /*!< (@ 0x58004800) IWDG Structure                                             */
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000000) Key register                                               */
    
    struct {
      __OM  uint32 KEY        : 16;           /*!< [15..0] Key value (write only, read 0x0000) These bits must
                                                     be written by software at regular intervals with the key
                                                     value 0xAAAA, otherwise the watchdog generates a reset
                                                     when the counter reaches 0. Writing the key value 0x5555
                                                     to enable access to the IWDG_PR, IWDG_RLR and IWDG_WINR
                                                     registers (see Section23.3.6: Register access protection)
                                                     Writing the key value CCCCh starts the watchdog (except
                                                     if                                                                        */
            uint32            : 16;
    } bit;
  } IWDG_KR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) Prescaler register                                         */
    
    struct {
      __IOM uint32 PR         : 3;            /*!< [2..0] Prescaler divider These bits are write access protected
                                                     see Section23.3.6: Register access protection. They are
                                                     written by software to select the prescaler divider feeding
                                                     the counter clock. PVU bit of IWDG_SR must be reset in
                                                     order to be able to change the prescaler divider. Note:
                                                     Reading this register returns the prescaler value from
                                                     the VDD voltage domain. This value may not be up to                       */
            uint32            : 29;
    } bit;
  } IWDG_PR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) Reload register                                            */
    
    struct {
      __IOM uint32 RL         : 12;           /*!< [11..0] Watchdog counter reload value These bits are write access
                                                     protected see Section23.3.6. They are written by software
                                                     to define the value to be loaded in the watchdog counter
                                                     each time the value 0xAAAA is written in the IWDG_KR register.
                                                     The watchdog counter counts down from this value. The timeout
                                                     period is a function of this value and the clock prescaler.
                                                     Refer to the datasheet for the                                            */
            uint32            : 20;
    } bit;
  } IWDG_RLR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000000C) Status register                                            */
    
    struct {
      __IM  uint32 PVU        : 1;            /*!< [0..0] Watchdog prescaler value update This bit is set by hardware
                                                     to indicate that an update of the prescaler value is ongoing.
                                                     It is reset by hardware when the prescaler update operation
                                                     is completed in the VDD voltage domain (takes up to 5 RC
                                                     40 kHz cycles). Prescaler value can be updated only when
                                                     PVU bit is reset.                                                         */
      __IM  uint32 RVU        : 1;            /*!< [1..1] Watchdog counter reload value update This bit is set
                                                     by hardware to indicate that an update of the reload value
                                                     is ongoing. It is reset by hardware when the reload value
                                                     update operation is completed in the VDD voltage domain
                                                     (takes up to 5 RC 40 kHz cycles). Reload value can be updated
                                                     only when RVU bit is reset.                                               */
      __IM  uint32 WVU        : 1;            /*!< [2..2] Watchdog counter window value update This bit is set
                                                     by hardware to indicate that an update of the window value
                                                     is ongoing. It is reset by hardware when the reload value
                                                     update operation is completed in the VDD voltage domain
                                                     (takes up to 5 RC 40 kHz cycles). Window value can be updated
                                                     only when WVU bit is reset. This bit is generated only
                                                     if generic window = 1                                                     */
            uint32            : 29;
    } bit;
  } IWDG_SR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) Window register                                            */
    
    struct {
      __IOM uint32 WIN        : 12;           /*!< [11..0] Watchdog counter window value These bits are write access
                                                     protected see Section23.3.6. These bits contain the high
                                                     limit of the window value to be compared to the downcounter.
                                                     To prevent a reset, the downcounter must be reloaded when
                                                     its value is lower than the window register value and greater
                                                     than 0x0 The WVU bit in the IWDG_SR register must be reset
                                                     in order to be able to change the reload value. N                         */
            uint32            : 20;
    } bit;
  } IWDG_WINR;
} IWDG_Type;                                    /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                           WWDG                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief WWDG (WWDG)
  */

typedef struct {                                /*!< (@ 0x50003000) WWDG Structure                                             */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) Control register                                           */
    
    struct {
      __IOM uint32 T          : 7;            /*!< [6..0] 7-bit counter (MSB to LSB) These bits contain the value
                                                     of the watchdog counter. It is decremented every (4096
                                                     x 2WDGTB[1:0]) PCLK cycles. A reset is produced when it
                                                     is decremented from 0x40 to 0x3F (T6 becomes cleared).                    */
      __IOM uint32 WDGA       : 1;            /*!< [7..7] Activation bit This bit is set by software and only cleared
                                                     by hardware after a reset. When WDGA=1, the watchdog can
                                                     generate a reset.                                                         */
            uint32            : 24;
    } bit;
  } WWDG_CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) Configuration register                                     */
    
    struct {
      __IOM uint32 W          : 7;            /*!< [6..0] 7-bit window value These bits contain the window value
                                                     to be compared to the downcounter.                                        */
            uint32            : 2;
      __IOM uint32 EWI        : 1;            /*!< [9..9] Early wakeup interrupt When set, an interrupt occurs
                                                     whenever the counter reaches the value 0x40. This interrupt
                                                     is only cleared by hardware after a reset.                                */
            uint32            : 1;
      __IOM uint32 WDGTB      : 2;            /*!< [12..11] Timer base The time base of the prescaler can be modified
                                                     as follows:                                                               */
            uint32            : 19;
    } bit;
  } WWDG_CFR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) Status register                                            */
    
    struct {
      __IOM uint32 EWIF       : 1;            /*!< [0..0] Early wakeup interrupt flag This bit is set by hardware
                                                     when the counter has reached the value 0x40. It must be
                                                     cleared by software by writing 0. A write of 1 has no effect.
                                                     This bit is also set if the interrupt is not enabled.                     */
            uint32            : 31;
    } bit;
  } WWDG_SR;
} WWDG_Type;                                    /*!< Size = 12 (0xc)                                                           */



/* =========================================================================================================================== */
/* ================                                            PWR                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief PWR (PWR)
  */

typedef struct {                                /*!< (@ 0x58024800) PWR Structure                                              */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) PWR control register 1                                     */
    
    struct {
      __IOM uint32 LPDS       : 1;            /*!< [0..0] Low-power Deepsleep with SVOS3 (SVOS4 and SVOS5 always
                                                     use low-power, regardless of the setting of this bit)                     */
            uint32            : 3;
      __IOM uint32 PVDE       : 1;            /*!< [4..4] Programmable voltage detector enable                               */
      __IOM uint32 PLS        : 3;            /*!< [7..5] Programmable voltage detector level selection These bits
                                                     select the voltage threshold detected by the PVD. Note:
                                                     Refer to Section Electrical characteristics of the product
                                                     datasheet for more details.                                               */
      __IOM uint32 DBP        : 1;            /*!< [8..8] Disable backup domain write protection In reset state,
                                                     the RCC_BDCR register, the RTC registers (including the
                                                     backup registers), BREN and MOEN bits in PWR_CR2 register,
                                                     are protected against parasitic write access. This bit
                                                     must be set to enable write access to these registers.                    */
      __IOM uint32 FLPS       : 1;            /*!< [9..9] Flash low-power mode in DStop mode This bit allows to
                                                     obtain the best trade-off between low-power consumption
                                                     and restart time when exiting from DStop mode. When it
                                                     is set, the Flash memory enters low-power mode when D1
                                                     domain is in DStop mode.                                                  */
            uint32            : 4;
      __IOM uint32 SVOS       : 2;            /*!< [15..14] System Stop mode voltage scaling selection These bits
                                                     control the VCORE voltage level in system Stop mode, to
                                                     obtain the best trade-off between power consumption and
                                                     performance.                                                              */
      __IOM uint32 AVDEN      : 1;            /*!< [16..16] Peripheral voltage monitor on VDDA enable                        */
      __IOM uint32 ALS        : 2;            /*!< [18..17] Analog voltage detector level selection These bits
                                                     select the voltage threshold detected by the AVD.                         */
            uint32            : 13;
    } bit;
  } PWR_CR1;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000004) PWR control status register 1                              */
    
    struct {
            uint32            : 4;
      __IM  uint32 PVDO       : 1;            /*!< [4..4] Programmable voltage detect output This bit is set and
                                                     cleared by hardware. It is valid only if the PVD has been
                                                     enabled by the PVDE bit. Note: since the PVD is disabled
                                                     in Standby mode, this bit is equal to 0 after Standby or
                                                     reset until the PVDE bit is set.                                          */
            uint32            : 8;
      __IM  uint32 ACTVOSRDY  : 1;            /*!< [13..13] Voltage levels ready bit for currently used VOS and
                                                     SDLEVEL This bit is set to 1 by hardware when the voltage
                                                     regulator and the SD converter are both disabled and Bypass
                                                     mode is selected in PWR control register 3 (PWR_CR3).                     */
      __IM  uint32 ACTVOS     : 2;            /*!< [15..14] VOS currently applied for VCORE voltage scaling selection.
                                                     These bits reflect the last VOS value applied to the PMU.                 */
      __IM  uint32 AVDO       : 1;            /*!< [16..16] Analog voltage detector output on VDDA This bit is
                                                     set and cleared by hardware. It is valid only if AVD on
                                                     VDDA is enabled by the AVDEN bit. Note: Since the AVD is
                                                     disabled in Standby mode, this bit is equal to 0 after
                                                     Standby or reset until the AVDEN bit is set.                              */
            uint32            : 15;
    } bit;
  } PWR_CSR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) This register is not reset by wakeup from Standby
                                                                    mode, RESET signal and VDD POR. It is only
                                                                    reset by VSW POR and VSWRST reset. This
                                                                    register shall not be accessed when VSWRST
                                                                    bit in RCC_BDCR register resets the VSW
                                                                    domain.After reset, PWR_CR2 register is
                                                                    write-protected. Prior to modifying its
                                                                    content, the DBP bit in PWR_CR1 register
                                                                    must be set to disable the write protection.               */
    
    struct {
      __IOM uint32 BREN       : 1;            /*!< [0..0] Backup regulator enable When set, the Backup regulator
                                                     (used to maintain the backup RAM content in Standby and
                                                     VBAT modes) is enabled. If BREN is reset, the backup regulator
                                                     is switched off. The backup RAM can still be used in Run
                                                     and Stop modes. However, its content will be lost in Standby
                                                     and VBAT modes. If BREN is set, the application must wait
                                                     till the Backup Regulator Ready flag (BRRDY) is                           */
            uint32            : 3;
      __IOM uint32 MONEN      : 1;            /*!< [4..4] VBAT and temperature monitoring enable When set, the
                                                     VBAT supply and temperature monitoring is enabled.                        */
            uint32            : 11;
      __IM  uint32 BRRDY      : 1;            /*!< [16..16] Backup regulator ready This bit is set by hardware
                                                     to indicate that the Backup regulator is ready.                           */
            uint32            : 3;
      __IM  uint32 VBATL      : 1;            /*!< [20..20] VBAT level monitoring versus low threshold                       */
      __IM  uint32 VBATH      : 1;            /*!< [21..21] VBAT level monitoring versus high threshold                      */
      __IM  uint32 TEMPL      : 1;            /*!< [22..22] Temperature level monitoring versus low threshold                */
      __IM  uint32 TEMPH      : 1;            /*!< [23..23] Temperature level monitoring versus high threshold               */
            uint32            : 8;
    } bit;
  } PWR_CR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) Reset only by POR only, not reset by wakeup from
                                                                    Standby mode and RESET pad. The lower byte
                                                                    of this register is written once after POR
                                                                    and shall be written before changing VOS
                                                                    level or ck_sys clock frequency. No limitation
                                                                    applies to the upper bytes.Programming data
                                                                    corresponding to an invalid combination
                                                                    of SDLEVEL, SDEXTHP, SDEN, LDOEN and BYPASS
                                                                    bits (see Table9) will be ignored: data
                                                                    will not be written, the w                                 */
    
    struct {
      __IOM uint32 BYPASS     : 1;            /*!< [0..0] Power management unit bypass                                       */
      __IOM uint32 LDOEN      : 1;            /*!< [1..1] Low drop-out regulator enable                                      */
      __IOM uint32 SDEN       : 1;            /*!< [2..2] SD converter Enable                                                */
            uint32            : 5;
      __IOM uint32 VBE        : 1;            /*!< [8..8] VBAT charging enable                                               */
      __IOM uint32 VBRS       : 1;            /*!< [9..9] VBAT charging resistor selection                                   */
            uint32            : 14;
      __OM  uint32 USB33DEN   : 1;            /*!< [24..24] VDD33USB voltage level detector enable.                          */
      __IOM uint32 USBREGEN   : 1;            /*!< [25..25] USB regulator enable.                                            */
      __IM  uint32 USB33RDY   : 1;            /*!< [26..26] USB supply ready.                                                */
            uint32            : 5;
    } bit;
  } PWR_CR3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) This register allows controlling CPU1 power.               */
    
    struct {
      __IOM uint32 PDDS_D1    : 1;            /*!< [0..0] D1 domain Power Down Deepsleep selection. This bit allows
                                                     CPU1 to define the Deepsleep mode for D1 domain.                          */
      __IOM uint32 PDDS_D2    : 1;            /*!< [1..1] D2 domain Power Down Deepsleep. This bit allows CPU1
                                                     to define the Deepsleep mode for D2 domain.                               */
      __IOM uint32 PDDS_D3    : 1;            /*!< [2..2] System D3 domain Power Down Deepsleep. This bit allows
                                                     CPU1 to define the Deepsleep mode for System D3 domain.                   */
            uint32            : 2;
      __IM  uint32 STOPF      : 1;            /*!< [5..5] STOP flag This bit is set by hardware and cleared only
                                                     by any reset or by setting the CPU1 CSSF bit.                             */
      __IM  uint32 SBF        : 1;            /*!< [6..6] System Standby flag This bit is set by hardware and cleared
                                                     only by a POR (Power-on Reset) or by setting the CPU1 CSSF
                                                     bit                                                                       */
      __IM  uint32 SBF_D1     : 1;            /*!< [7..7] D1 domain DStandby flag This bit is set by hardware and
                                                     cleared by any system reset or by setting the CPU1 CSSF
                                                     bit. Once set, this bit can be cleared only when the D1
                                                     domain is no longer in DStandby mode.                                     */
      __IM  uint32 SBF_D2     : 1;            /*!< [8..8] D2 domain DStandby flag This bit is set by hardware and
                                                     cleared by any system reset or by setting the CPU1 CSSF
                                                     bit. Once set, this bit can be cleared only when the D2
                                                     domain is no longer in DStandby mode.                                     */
      __IOM uint32 CSSF       : 1;            /*!< [9..9] Clear D1 domain CPU1 Standby, Stop and HOLD flags (always
                                                     read as 0) This bit is cleared to 0 by hardware.                          */
            uint32            : 1;
      __IOM uint32 RUN_D3     : 1;            /*!< [11..11] Keep system D3 domain in Run mode regardless of the
                                                     CPU sub-systems modes                                                     */
            uint32            : 20;
    } bit;
  } PWR_CPUCR;
  __IM  uint32  RESERVED;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000018) This register allows controlling D3 domain power.Following
                                                                    reset VOSRDY will be read 1 by software                    */
    
    struct {
            uint32            : 13;
      __IM  uint32 VOSRDY     : 1;            /*!< [13..13] VOS Ready bit for VCORE voltage scaling output selection.
                                                     This bit is set to 1 by hardware when Bypass mode is selected
                                                     in PWR control register 3 (PWR_CR3).                                      */
      __IOM uint32 VOS        : 2;            /*!< [15..14] Voltage scaling selection according to performance
                                                     These bits control the VCORE voltage level and allow to
                                                     obtains the best trade-off between power consumption and
                                                     performance: When increasing the performance, the voltage
                                                     scaling shall be changed before increasing the system frequency.
                                                     When decreasing performance, the system frequency shall
                                                     first be decreased before changing the voltage                            */
            uint32            : 16;
    } bit;
  } PWR_D3CR;
  __IM  uint32  RESERVED1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000020) reset only by system reset, not reset by wakeup
                                                                    from Standby mode5 wait states are required
                                                                    when writing this register (when clearing
                                                                    a WKUPF bit in PWR_WKUPFR, the AHB write
                                                                    access will complete after the WKUPF has
                                                                    been cleared).                                             */
    
    struct {
      __IOM uint32 WKUPC      : 6;            /*!< [5..0] Clear Wakeup pin flag for WKUP. These bits are always
                                                     read as 0.                                                                */
            uint32            : 26;
    } bit;
  } PWR_WKUPCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000024) reset only by system reset, not reset by wakeup
                                                                    from Standby mode                                          */
    
    struct {
      __IOM uint32 WKUPF1     : 1;            /*!< [0..0] Wakeup pin WKUPF flag. This bit is set by hardware and
                                                     cleared only by a Reset pin or by setting the WKUPCn+1
                                                     bit in the PWR wakeup clear register (PWR_WKUPCR).                        */
      __IOM uint32 WKUPF2     : 1;            /*!< [1..1] Wakeup pin WKUPF flag. This bit is set by hardware and
                                                     cleared only by a Reset pin or by setting the WKUPCn+1
                                                     bit in the PWR wakeup clear register (PWR_WKUPCR).                        */
      __IOM uint32 WKUPF3     : 1;            /*!< [2..2] Wakeup pin WKUPF flag. This bit is set by hardware and
                                                     cleared only by a Reset pin or by setting the WKUPCn+1
                                                     bit in the PWR wakeup clear register (PWR_WKUPCR).                        */
      __IOM uint32 WKUPF4     : 1;            /*!< [3..3] Wakeup pin WKUPF flag. This bit is set by hardware and
                                                     cleared only by a Reset pin or by setting the WKUPCn+1
                                                     bit in the PWR wakeup clear register (PWR_WKUPCR).                        */
      __IOM uint32 WKUPF5     : 1;            /*!< [4..4] Wakeup pin WKUPF flag. This bit is set by hardware and
                                                     cleared only by a Reset pin or by setting the WKUPCn+1
                                                     bit in the PWR wakeup clear register (PWR_WKUPCR).                        */
      __IOM uint32 WKUPF6     : 1;            /*!< [5..5] Wakeup pin WKUPF flag. This bit is set by hardware and
                                                     cleared only by a Reset pin or by setting the WKUPCn+1
                                                     bit in the PWR wakeup clear register (PWR_WKUPCR).                        */
            uint32            : 26;
    } bit;
  } PWR_WKUPFR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000028) Reset only by system reset, not reset by wakeup
                                                                    from Standby mode                                          */
    
    struct {
      __IOM uint32 WKUPEN1    : 1;            /*!< [0..0] Enable Wakeup Pin WKUPn+1 Each bit is set and cleared
                                                     by software. Note: An additional wakeup event is detected
                                                     if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit)
                                                     when WKUPn+1 pin level is already high when WKUPPn+1 selects
                                                     rising edge, or low when WKUPPn+1 selects falling edge.                   */
      __IOM uint32 WKUPEN2    : 1;            /*!< [1..1] Enable Wakeup Pin WKUPn+1 Each bit is set and cleared
                                                     by software. Note: An additional wakeup event is detected
                                                     if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit)
                                                     when WKUPn+1 pin level is already high when WKUPPn+1 selects
                                                     rising edge, or low when WKUPPn+1 selects falling edge.                   */
      __IOM uint32 WKUPEN3    : 1;            /*!< [2..2] Enable Wakeup Pin WKUPn+1 Each bit is set and cleared
                                                     by software. Note: An additional wakeup event is detected
                                                     if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit)
                                                     when WKUPn+1 pin level is already high when WKUPPn+1 selects
                                                     rising edge, or low when WKUPPn+1 selects falling edge.                   */
      __IOM uint32 WKUPEN4    : 1;            /*!< [3..3] Enable Wakeup Pin WKUPn+1 Each bit is set and cleared
                                                     by software. Note: An additional wakeup event is detected
                                                     if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit)
                                                     when WKUPn+1 pin level is already high when WKUPPn+1 selects
                                                     rising edge, or low when WKUPPn+1 selects falling edge.                   */
      __IOM uint32 WKUPEN5    : 1;            /*!< [4..4] Enable Wakeup Pin WKUPn+1 Each bit is set and cleared
                                                     by software. Note: An additional wakeup event is detected
                                                     if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit)
                                                     when WKUPn+1 pin level is already high when WKUPPn+1 selects
                                                     rising edge, or low when WKUPPn+1 selects falling edge.                   */
      __IOM uint32 WKUPEN6    : 1;            /*!< [5..5] Enable Wakeup Pin WKUPn+1 Each bit is set and cleared
                                                     by software. Note: An additional wakeup event is detected
                                                     if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit)
                                                     when WKUPn+1 pin level is already high when WKUPPn+1 selects
                                                     rising edge, or low when WKUPPn+1 selects falling edge.                   */
            uint32            : 2;
      __IOM uint32 WKUPP1     : 1;            /*!< [8..8] Wakeup pin polarity bit for WKUPn-7 These bits define
                                                     the polarity used for event detection on WKUPn-7 external
                                                     wakeup pin.                                                               */
      __IOM uint32 WKUPP2     : 1;            /*!< [9..9] Wakeup pin polarity bit for WKUPn-7 These bits define
                                                     the polarity used for event detection on WKUPn-7 external
                                                     wakeup pin.                                                               */
      __IOM uint32 WKUPP3     : 1;            /*!< [10..10] Wakeup pin polarity bit for WKUPn-7 These bits define
                                                     the polarity used for event detection on WKUPn-7 external
                                                     wakeup pin.                                                               */
      __IOM uint32 WKUPP4     : 1;            /*!< [11..11] Wakeup pin polarity bit for WKUPn-7 These bits define
                                                     the polarity used for event detection on WKUPn-7 external
                                                     wakeup pin.                                                               */
      __IOM uint32 WKUPP5     : 1;            /*!< [12..12] Wakeup pin polarity bit for WKUPn-7 These bits define
                                                     the polarity used for event detection on WKUPn-7 external
                                                     wakeup pin.                                                               */
      __IOM uint32 WKUPP6     : 1;            /*!< [13..13] Wakeup pin polarity bit for WKUPn-7 These bits define
                                                     the polarity used for event detection on WKUPn-7 external
                                                     wakeup pin.                                                               */
            uint32            : 2;
      __IOM uint32 WKUPPUPD1  : 2;            /*!< [17..16] Wakeup pin pull configuration                                    */
      __IOM uint32 WKUPPUPD2  : 2;            /*!< [19..18] Wakeup pin pull configuration                                    */
      __IOM uint32 WKUPPUPD3  : 2;            /*!< [21..20] Wakeup pin pull configuration                                    */
      __IOM uint32 WKUPPUPD4  : 2;            /*!< [23..22] Wakeup pin pull configuration                                    */
      __IOM uint32 WKUPPUPD5  : 2;            /*!< [25..24] Wakeup pin pull configuration                                    */
      __IOM uint32 WKUPPUPD6  : 2;            /*!< [27..26] Wakeup pin pull configuration for WKUP(truncate(n/2)-7)
                                                     These bits define the I/O pad pull configuration used when
                                                     WKUPEN(truncate(n/2)-7) = 1. The associated GPIO port pull
                                                     configuration shall be set to the same value or to 00.
                                                     The Wakeup pin pull configuration is kept in Standby mode.                */
            uint32            : 4;
    } bit;
  } PWR_WKUPEPR;
} PWR_Type;                                     /*!< Size = 44 (0x2c)                                                          */



/* =========================================================================================================================== */
/* ================                                           SPI1                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Serial peripheral interface (SPI1)
  */

typedef struct {                                /*!< (@ 0x40013000) SPI1 Structure                                             */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) control register 1                                         */
    
    struct {
      __IOM uint32 SPE        : 1;            /*!< [0..0] Serial Peripheral Enable                                           */
            uint32            : 7;
      __IOM uint32 MASRX      : 1;            /*!< [8..8] Master automatic SUSP in Receive mode                              */
      __IM  uint32 CSTART     : 1;            /*!< [9..9] Master transfer start                                              */
      __OM  uint32 CSUSP      : 1;            /*!< [10..10] Master SUSPend request                                           */
      __IOM uint32 HDDIR      : 1;            /*!< [11..11] Rx/Tx direction at Half-duplex mode                              */
      __IOM uint32 SSI        : 1;            /*!< [12..12] Internal SS signal input level                                   */
      __IOM uint32 CRC33_17   : 1;            /*!< [13..13] 32-bit CRC polynomial configuration                              */
      __IOM uint32 RCRCI      : 1;            /*!< [14..14] CRC calculation initialization pattern control for
                                                     receiver                                                                  */
      __IOM uint32 TCRCI      : 1;            /*!< [15..15] CRC calculation initialization pattern control for
                                                     transmitter                                                               */
      __IM  uint32 IOLOCK     : 1;            /*!< [16..16] Locking the AF configuration of associated IOs                   */
            uint32            : 15;
    } bit;
  } CR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) control register 2                                         */
    
    struct {
      __IOM uint32 TSIZE      : 16;           /*!< [15..0] Number of data at current transfer                                */
      __IM  uint32 TSER       : 16;           /*!< [31..16] Number of data transfer extension to be reload into
                                                     TSIZE just when a previous                                                */
    } bit;
  } CR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) configuration register 1                                   */
    
    struct {
      __IOM uint32 DSIZE      : 5;            /*!< [4..0] Number of bits in at single SPI data frame                         */
      __IOM uint32 FTHVL      : 4;            /*!< [8..5] threshold level                                                    */
      __IOM uint32 UDRCFG     : 2;            /*!< [10..9] Behavior of slave transmitter at underrun condition               */
      __IOM uint32 UDRDET     : 2;            /*!< [12..11] Detection of underrun condition at slave transmitter             */
            uint32            : 1;
      __IOM uint32 RXDMAEN    : 1;            /*!< [14..14] Rx DMA stream enable                                             */
      __IOM uint32 TXDMAEN    : 1;            /*!< [15..15] Tx DMA stream enable                                             */
      __IOM uint32 CRCSIZE    : 5;            /*!< [20..16] Length of CRC frame to be transacted and compared                */
            uint32            : 1;
      __IOM uint32 CRCEN      : 1;            /*!< [22..22] Hardware CRC computation enable                                  */
            uint32            : 5;
      __IOM uint32 MBR        : 3;            /*!< [30..28] Master baud rate                                                 */
            uint32            : 1;
    } bit;
  } CFG1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) configuration register 2                                   */
    
    struct {
      __IOM uint32 MSSI       : 4;            /*!< [3..0] Master SS Idleness                                                 */
      __IOM uint32 MIDI       : 4;            /*!< [7..4] Master Inter-Data Idleness                                         */
            uint32            : 7;
      __IOM uint32 IOSWP      : 1;            /*!< [15..15] Swap functionality of MISO and MOSI pins                         */
            uint32            : 1;
      __IOM uint32 COMM       : 2;            /*!< [18..17] SPI Communication Mode                                           */
      __IOM uint32 SP         : 3;            /*!< [21..19] Serial Protocol                                                  */
      __IOM uint32 MASTER     : 1;            /*!< [22..22] SPI Master                                                       */
      __IOM uint32 LSBFRST    : 1;            /*!< [23..23] Data frame format                                                */
      __IOM uint32 CPHA       : 1;            /*!< [24..24] Clock phase                                                      */
      __IOM uint32 CPOL       : 1;            /*!< [25..25] Clock polarity                                                   */
      __IOM uint32 SSM        : 1;            /*!< [26..26] Software management of SS signal input                           */
            uint32            : 1;
      __IOM uint32 SSIOP      : 1;            /*!< [28..28] SS input/output polarity                                         */
      __IOM uint32 SSOE       : 1;            /*!< [29..29] SS output enable                                                 */
      __IOM uint32 SSOM       : 1;            /*!< [30..30] SS output management in master mode                              */
      __IOM uint32 AFCNTR     : 1;            /*!< [31..31] Alternate function GPIOs control                                 */
    } bit;
  } CFG2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) Interrupt Enable Register                                  */
    
    struct {
      __IOM uint32 RXPIE      : 1;            /*!< [0..0] RXP Interrupt Enable                                               */
      __IM  uint32 TXPIE      : 1;            /*!< [1..1] TXP interrupt enable                                               */
      __IM  uint32 DPXPIE     : 1;            /*!< [2..2] DXP interrupt enabled                                              */
      __IOM uint32 EOTIE      : 1;            /*!< [3..3] EOT, SUSP and TXC interrupt enable                                 */
      __IOM uint32 TXTFIE     : 1;            /*!< [4..4] TXTFIE interrupt enable                                            */
      __IOM uint32 UDRIE      : 1;            /*!< [5..5] UDR interrupt enable                                               */
      __IOM uint32 OVRIE      : 1;            /*!< [6..6] OVR interrupt enable                                               */
      __IOM uint32 CRCEIE     : 1;            /*!< [7..7] CRC Interrupt enable                                               */
      __IOM uint32 TIFREIE    : 1;            /*!< [8..8] TIFRE interrupt enable                                             */
      __IOM uint32 MODFIE     : 1;            /*!< [9..9] Mode Fault interrupt enable                                        */
      __IOM uint32 TSERFIE    : 1;            /*!< [10..10] Additional number of transactions reload interrupt
                                                     enable                                                                    */
            uint32            : 21;
    } bit;
  } IER;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000014) Status Register                                            */
    
    struct {
      __IM  uint32 RXP        : 1;            /*!< [0..0] Rx-Packet available                                                */
      __IM  uint32 TXP        : 1;            /*!< [1..1] Tx-Packet space available                                          */
      __IM  uint32 DXP        : 1;            /*!< [2..2] Duplex Packet                                                      */
      __IM  uint32 EOT        : 1;            /*!< [3..3] End Of Transfer                                                    */
      __IM  uint32 TXTF       : 1;            /*!< [4..4] Transmission Transfer Filled                                       */
      __IM  uint32 UDR        : 1;            /*!< [5..5] Underrun at slave transmission mode                                */
      __IM  uint32 OVR        : 1;            /*!< [6..6] Overrun                                                            */
      __IM  uint32 CRCE       : 1;            /*!< [7..7] CRC Error                                                          */
      __IM  uint32 TIFRE      : 1;            /*!< [8..8] TI frame format error                                              */
      __IM  uint32 MODF       : 1;            /*!< [9..9] Mode Fault                                                         */
      __IM  uint32 TSERF      : 1;            /*!< [10..10] Additional number of SPI data to be transacted was
                                                     reload                                                                    */
      __IM  uint32 SUSP       : 1;            /*!< [11..11] SUSPend                                                          */
      __IM  uint32 TXC        : 1;            /*!< [12..12] TxFIFO transmission complete                                     */
      __IM  uint32 RXPLVL     : 2;            /*!< [14..13] RxFIFO Packing LeVeL                                             */
      __IM  uint32 RXWNE      : 1;            /*!< [15..15] RxFIFO Word Not Empty                                            */
      __IM  uint32 CTSIZE     : 16;           /*!< [31..16] Number of data frames remaining in current TSIZE session         */
    } bit;
  } SR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000018) Interrupt/Status Flags Clear Register                      */
    
    struct {
            uint32            : 3;
      __OM  uint32 EOTC       : 1;            /*!< [3..3] End Of Transfer flag clear                                         */
      __OM  uint32 TXTFC      : 1;            /*!< [4..4] Transmission Transfer Filled flag clear                            */
      __OM  uint32 UDRC       : 1;            /*!< [5..5] Underrun flag clear                                                */
      __OM  uint32 OVRC       : 1;            /*!< [6..6] Overrun flag clear                                                 */
      __OM  uint32 CRCEC      : 1;            /*!< [7..7] CRC Error flag clear                                               */
      __OM  uint32 TIFREC     : 1;            /*!< [8..8] TI frame format error flag clear                                   */
      __OM  uint32 MODFC      : 1;            /*!< [9..9] Mode Fault flag clear                                              */
      __OM  uint32 TSERFC     : 1;            /*!< [10..10] TSERFC flag clear                                                */
      __OM  uint32 SUSPC      : 1;            /*!< [11..11] SUSPend flag clear                                               */
            uint32            : 20;
    } bit;
  } IFCR;
  __IM  uint32  RESERVED;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000020) Transmit Data Register                                     */
    
    struct {
      __OM  uint32 TXDR       : 32;           /*!< [31..0] Transmit data register                                            */
    } bit;
  } TXDR;
  __IM  uint32  RESERVED1[3];
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000030) Receive Data Register                                      */
    
    struct {
      __IM  uint32 RXDR       : 32;           /*!< [31..0] Receive data register                                             */
    } bit;
  } RXDR;
  __IM  uint32  RESERVED2[3];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000040) Polynomial Register                                        */
    
    struct {
      __IOM uint32 CRCPOLY    : 32;           /*!< [31..0] CRC polynomial register                                           */
    } bit;
  } CRCPOLY;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000044) Transmitter CRC Register                                   */
    
    struct {
      __IOM uint32 TXCRC      : 32;           /*!< [31..0] CRC register for transmitter                                      */
    } bit;
  } TXCRC;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000048) Receiver CRC Register                                      */
    
    struct {
      __IOM uint32 RXCRC      : 32;           /*!< [31..0] CRC register for receiver                                         */
    } bit;
  } RXCRC;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000004C) Underrun Data Register                                     */
    
    struct {
      __IOM uint32 UDRDR      : 32;           /*!< [31..0] Data at slave underrun condition                                  */
    } bit;
  } UDRDR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000050) configuration register                                     */
    
    struct {
      __IOM uint32 I2SMOD     : 1;            /*!< [0..0] I2S mode selection                                                 */
      __IOM uint32 I2SCFG     : 3;            /*!< [3..1] I2S configuration mode                                             */
      __IOM uint32 I2SSTD     : 2;            /*!< [5..4] I2S standard selection                                             */
            uint32            : 1;
      __IOM uint32 PCMSYNC    : 1;            /*!< [7..7] PCM frame synchronization                                          */
      __IOM uint32 DATLEN     : 2;            /*!< [9..8] Data length to be transferred                                      */
      __IOM uint32 CHLEN      : 1;            /*!< [10..10] Channel length (number of bits per audio channel)                */
      __IOM uint32 CKPOL      : 1;            /*!< [11..11] Serial audio clock polarity                                      */
      __IOM uint32 FIXCH      : 1;            /*!< [12..12] Word select inversion                                            */
      __IOM uint32 WSINV      : 1;            /*!< [13..13] Fixed channel length in SLAVE                                    */
      __IOM uint32 DATFMT     : 1;            /*!< [14..14] Data format                                                      */
            uint32            : 1;
      __IOM uint32 I2SDIV     : 8;            /*!< [23..16] I2S linear prescaler                                             */
      __IOM uint32 ODD        : 1;            /*!< [24..24] Odd factor for the prescaler                                     */
      __IOM uint32 MCKOE      : 1;            /*!< [25..25] Master clock output enable                                       */
            uint32            : 6;
    } bit;
  } CGFR;
} SPI1_Type;                                    /*!< Size = 84 (0x54)                                                          */



/* =========================================================================================================================== */
/* ================                                           LTDC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief LCD-TFT Controller (LTDC)
  */

typedef struct {                                /*!< (@ 0x50001000) LTDC Structure                                             */
  __IM  uint32  RESERVED[2];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) Synchronization Size Configuration Register                */
    
    struct {
      __IOM uint32 VSH        : 11;           /*!< [10..0] Vertical Synchronization Height (in units of horizontal
                                                     scan line)                                                                */
            uint32            : 5;
      __IOM uint32 HSW        : 10;           /*!< [25..16] Horizontal Synchronization Width (in units of pixel
                                                     clock period)                                                             */
            uint32            : 6;
    } bit;
  } SSCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) Back Porch Configuration Register                          */
    
    struct {
      __IOM uint32 AVBP       : 11;           /*!< [10..0] Accumulated Vertical back porch (in units of horizontal
                                                     scan line)                                                                */
            uint32            : 5;
      __IOM uint32 AHBP       : 12;           /*!< [27..16] Accumulated Horizontal back porch (in units of pixel
                                                     clock period)                                                             */
            uint32            : 4;
    } bit;
  } BPCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) Active Width Configuration Register                        */
    
    struct {
      __IOM uint32 AAH        : 11;           /*!< [10..0] Accumulated Active Height (in units of horizontal scan
                                                     line)                                                                     */
            uint32            : 5;
      __IOM uint32 AAV        : 12;           /*!< [27..16] AAV                                                              */
            uint32            : 4;
    } bit;
  } AWCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000014) Total Width Configuration Register                         */
    
    struct {
      __IOM uint32 TOTALH     : 11;           /*!< [10..0] Total Height (in units of horizontal scan line)                   */
            uint32            : 5;
      __IOM uint32 TOTALW     : 12;           /*!< [27..16] Total Width (in units of pixel clock period)                     */
            uint32            : 4;
    } bit;
  } TWCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000018) Global Control Register                                    */
    
    struct {
      __IOM uint32 LTDCEN     : 1;            /*!< [0..0] LCD-TFT controller enable bit                                      */
            uint32            : 3;
      __IM  uint32 DBW        : 3;            /*!< [6..4] Dither Blue Width                                                  */
            uint32            : 1;
      __IM  uint32 DGW        : 3;            /*!< [10..8] Dither Green Width                                                */
            uint32            : 1;
      __IM  uint32 DRW        : 3;            /*!< [14..12] Dither Red Width                                                 */
            uint32            : 1;
      __IOM uint32 DEN        : 1;            /*!< [16..16] Dither Enable                                                    */
            uint32            : 11;
      __IOM uint32 PCPOL      : 1;            /*!< [28..28] Pixel Clock Polarity                                             */
      __IOM uint32 DEPOL      : 1;            /*!< [29..29] Data Enable Polarity                                             */
      __IOM uint32 VSPOL      : 1;            /*!< [30..30] Vertical Synchronization Polarity                                */
      __IOM uint32 HSPOL      : 1;            /*!< [31..31] Horizontal Synchronization Polarity                              */
    } bit;
  } GCR;
  __IM  uint32  RESERVED1[2];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000024) Shadow Reload Configuration Register                       */
    
    struct {
      __IOM uint32 IMR        : 1;            /*!< [0..0] Immediate Reload                                                   */
      __IOM uint32 VBR        : 1;            /*!< [1..1] Vertical Blanking Reload                                           */
            uint32            : 30;
    } bit;
  } SRCR;
  __IM  uint32  RESERVED2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000002C) Background Color Configuration Register                    */
    
    struct {
      __IOM uint32 BCBLUE     : 8;            /*!< [7..0] Background Color Blue value                                        */
      __IOM uint32 BCGREEN    : 8;            /*!< [15..8] Background Color Green value                                      */
      __IOM uint32 BCRED      : 8;            /*!< [23..16] Background Color Red value                                       */
            uint32            : 8;
    } bit;
  } BCCR;
  __IM  uint32  RESERVED3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000034) Interrupt Enable Register                                  */
    
    struct {
      __IOM uint32 LIE        : 1;            /*!< [0..0] Line Interrupt Enable                                              */
      __IOM uint32 FUIE       : 1;            /*!< [1..1] FIFO Underrun Interrupt Enable                                     */
      __IOM uint32 TERRIE     : 1;            /*!< [2..2] Transfer Error Interrupt Enable                                    */
      __IOM uint32 RRIE       : 1;            /*!< [3..3] Register Reload interrupt enable                                   */
            uint32            : 28;
    } bit;
  } IER;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000038) Interrupt Status Register                                  */
    
    struct {
      __IM  uint32 LIF        : 1;            /*!< [0..0] Line Interrupt flag                                                */
      __IM  uint32 FUIF       : 1;            /*!< [1..1] FIFO Underrun Interrupt flag                                       */
      __IM  uint32 TERRIF     : 1;            /*!< [2..2] Transfer Error interrupt flag                                      */
      __IM  uint32 RRIF       : 1;            /*!< [3..3] Register Reload Interrupt Flag                                     */
            uint32            : 28;
    } bit;
  } ISR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x0000003C) Interrupt Clear Register                                   */
    
    struct {
      __OM  uint32 CLIF       : 1;            /*!< [0..0] Clears the Line Interrupt Flag                                     */
      __OM  uint32 CFUIF      : 1;            /*!< [1..1] Clears the FIFO Underrun Interrupt flag                            */
      __OM  uint32 CTERRIF    : 1;            /*!< [2..2] Clears the Transfer Error Interrupt Flag                           */
      __OM  uint32 CRRIF      : 1;            /*!< [3..3] Clears Register Reload Interrupt Flag                              */
            uint32            : 28;
    } bit;
  } ICR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000040) Line Interrupt Position Configuration Register             */
    
    struct {
      __IOM uint32 LIPOS      : 11;           /*!< [10..0] Line Interrupt Position                                           */
            uint32            : 21;
    } bit;
  } LIPCR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000044) Current Position Status Register                           */
    
    struct {
      __IM  uint32 CYPOS      : 16;           /*!< [15..0] Current Y Position                                                */
      __IM  uint32 CXPOS      : 16;           /*!< [31..16] Current X Position                                               */
    } bit;
  } CPSR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000048) Current Display Status Register                            */
    
    struct {
      __IM  uint32 VDES       : 1;            /*!< [0..0] Vertical Data Enable display Status                                */
      __IM  uint32 HDES       : 1;            /*!< [1..1] Horizontal Data Enable display Status                              */
      __IM  uint32 VSYNCS     : 1;            /*!< [2..2] Vertical Synchronization display Status                            */
      __IM  uint32 HSYNCS     : 1;            /*!< [3..3] Horizontal Synchronization display Status                          */
            uint32            : 28;
    } bit;
  } CDSR;
  __IM  uint32  RESERVED4[14];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000084) Layerx Control Register                                    */
    
    struct {
      __IOM uint32 LEN        : 1;            /*!< [0..0] Layer Enable                                                       */
      __IOM uint32 COLKEN     : 1;            /*!< [1..1] Color Keying Enable                                                */
            uint32            : 2;
      __IOM uint32 CLUTEN     : 1;            /*!< [4..4] Color Look-Up Table Enable                                         */
            uint32            : 27;
    } bit;
  } L1CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000088) Layerx Window Horizontal Position Configuration
                                                                    Register                                                   */
    
    struct {
      __IOM uint32 WHSTPOS    : 12;           /*!< [11..0] Window Horizontal Start Position                                  */
            uint32            : 4;
      __IOM uint32 WHSPPOS    : 12;           /*!< [27..16] Window Horizontal Stop Position                                  */
            uint32            : 4;
    } bit;
  } L1WHPCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000008C) Layerx Window Vertical Position Configuration
                                                                    Register                                                   */
    
    struct {
      __IOM uint32 WVSTPOS    : 11;           /*!< [10..0] Window Vertical Start Position                                    */
            uint32            : 5;
      __IOM uint32 WVSPPOS    : 11;           /*!< [26..16] Window Vertical Stop Position                                    */
            uint32            : 5;
    } bit;
  } L1WVPCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000090) Layerx Color Keying Configuration Register                 */
    
    struct {
      __IOM uint32 CKBLUE     : 8;            /*!< [7..0] Color Key Blue value                                               */
      __IOM uint32 CKGREEN    : 8;            /*!< [15..8] Color Key Green value                                             */
      __IOM uint32 CKRED      : 8;            /*!< [23..16] Color Key Red value                                              */
            uint32            : 8;
    } bit;
  } L1CKCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000094) Layerx Pixel Format Configuration Register                 */
    
    struct {
      __IOM uint32 PF         : 3;            /*!< [2..0] Pixel Format                                                       */
            uint32            : 29;
    } bit;
  } L1PFCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000098) Layerx Constant Alpha Configuration Register               */
    
    struct {
      __IOM uint32 CONSTA     : 8;            /*!< [7..0] Constant Alpha                                                     */
            uint32            : 24;
    } bit;
  } L1CACR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000009C) Layerx Default Color Configuration Register                */
    
    struct {
      __IOM uint32 DCBLUE     : 8;            /*!< [7..0] Default Color Blue                                                 */
      __IOM uint32 DCGREEN    : 8;            /*!< [15..8] Default Color Green                                               */
      __IOM uint32 DCRED      : 8;            /*!< [23..16] Default Color Red                                                */
      __IOM uint32 DCALPHA    : 8;            /*!< [31..24] Default Color Alpha                                              */
    } bit;
  } L1DCCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000A0) Layerx Blending Factors Configuration Register             */
    
    struct {
      __IOM uint32 BF2        : 3;            /*!< [2..0] Blending Factor 2                                                  */
            uint32            : 5;
      __IOM uint32 BF1        : 3;            /*!< [10..8] Blending Factor 1                                                 */
            uint32            : 21;
    } bit;
  } L1BFCR;
  __IM  uint32  RESERVED5[2];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000AC) Layerx Color Frame Buffer Address Register                 */
    
    struct {
      __IOM uint32 CFBADD     : 32;           /*!< [31..0] Color Frame Buffer Start Address                                  */
    } bit;
  } L1CFBAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000B0) Layerx Color Frame Buffer Length Register                  */
    
    struct {
      __IOM uint32 CFBLL      : 13;           /*!< [12..0] Color Frame Buffer Line Length                                    */
            uint32            : 3;
      __IOM uint32 CFBP       : 13;           /*!< [28..16] Color Frame Buffer Pitch in bytes                                */
            uint32            : 3;
    } bit;
  } L1CFBLR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000B4) Layerx ColorFrame Buffer Line Number Register              */
    
    struct {
      __IOM uint32 CFBLNBR    : 11;           /*!< [10..0] Frame Buffer Line Number                                          */
            uint32            : 21;
    } bit;
  } L1CFBLNR;
  __IM  uint32  RESERVED6[3];
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x000000C4) Layerx CLUT Write Register                                 */
    
    struct {
      __OM  uint32 BLUE       : 8;            /*!< [7..0] Blue value                                                         */
      __OM  uint32 GREEN      : 8;            /*!< [15..8] Green value                                                       */
      __OM  uint32 RED        : 8;            /*!< [23..16] Red value                                                        */
      __OM  uint32 CLUTADD    : 8;            /*!< [31..24] CLUT Address                                                     */
    } bit;
  } L1CLUTWR;
  __IM  uint32  RESERVED7[15];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000104) Layerx Control Register                                    */
    
    struct {
      __IOM uint32 LEN        : 1;            /*!< [0..0] Layer Enable                                                       */
      __IOM uint32 COLKEN     : 1;            /*!< [1..1] Color Keying Enable                                                */
            uint32            : 2;
      __IOM uint32 CLUTEN     : 1;            /*!< [4..4] Color Look-Up Table Enable                                         */
            uint32            : 27;
    } bit;
  } L2CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000108) Layerx Window Horizontal Position Configuration
                                                                    Register                                                   */
    
    struct {
      __IOM uint32 WHSTPOS    : 12;           /*!< [11..0] Window Horizontal Start Position                                  */
            uint32            : 4;
      __IOM uint32 WHSPPOS    : 12;           /*!< [27..16] Window Horizontal Stop Position                                  */
            uint32            : 4;
    } bit;
  } L2WHPCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000010C) Layerx Window Vertical Position Configuration
                                                                    Register                                                   */
    
    struct {
      __IOM uint32 WVSTPOS    : 11;           /*!< [10..0] Window Vertical Start Position                                    */
            uint32            : 5;
      __IOM uint32 WVSPPOS    : 11;           /*!< [26..16] Window Vertical Stop Position                                    */
            uint32            : 5;
    } bit;
  } L2WVPCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000110) Layerx Color Keying Configuration Register                 */
    
    struct {
      __IOM uint32 CKBLUE     : 8;            /*!< [7..0] Color Key Blue value                                               */
      __IOM uint32 CKGREEN    : 8;            /*!< [15..8] Color Key Green value                                             */
      __IOM uint32 CKRED      : 8;            /*!< [23..16] Color Key Red value                                              */
            uint32            : 8;
    } bit;
  } L2CKCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000114) Layerx Pixel Format Configuration Register                 */
    
    struct {
      __IOM uint32 PF         : 3;            /*!< [2..0] Pixel Format                                                       */
            uint32            : 29;
    } bit;
  } L2PFCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000118) Layerx Constant Alpha Configuration Register               */
    
    struct {
      __IOM uint32 CONSTA     : 8;            /*!< [7..0] Constant Alpha                                                     */
            uint32            : 24;
    } bit;
  } L2CACR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000011C) Layerx Default Color Configuration Register                */
    
    struct {
      __IOM uint32 DCBLUE     : 8;            /*!< [7..0] Default Color Blue                                                 */
      __IOM uint32 DCGREEN    : 8;            /*!< [15..8] Default Color Green                                               */
      __IOM uint32 DCRED      : 8;            /*!< [23..16] Default Color Red                                                */
      __IOM uint32 DCALPHA    : 8;            /*!< [31..24] Default Color Alpha                                              */
    } bit;
  } L2DCCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000120) Layerx Blending Factors Configuration Register             */
    
    struct {
      __IOM uint32 BF2        : 3;            /*!< [2..0] Blending Factor 2                                                  */
            uint32            : 5;
      __IOM uint32 BF1        : 3;            /*!< [10..8] Blending Factor 1                                                 */
            uint32            : 21;
    } bit;
  } L2BFCR;
  __IM  uint32  RESERVED8[2];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000012C) Layerx Color Frame Buffer Address Register                 */
    
    struct {
      __IOM uint32 CFBADD     : 32;           /*!< [31..0] Color Frame Buffer Start Address                                  */
    } bit;
  } L2CFBAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000130) Layerx Color Frame Buffer Length Register                  */
    
    struct {
      __IOM uint32 CFBLL      : 13;           /*!< [12..0] Color Frame Buffer Line Length                                    */
            uint32            : 3;
      __IOM uint32 CFBP       : 13;           /*!< [28..16] Color Frame Buffer Pitch in bytes                                */
            uint32            : 3;
    } bit;
  } L2CFBLR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000134) Layerx ColorFrame Buffer Line Number Register              */
    
    struct {
      __IOM uint32 CFBLNBR    : 11;           /*!< [10..0] Frame Buffer Line Number                                          */
            uint32            : 21;
    } bit;
  } L2CFBLNR;
  __IM  uint32  RESERVED9[3];
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000144) Layerx CLUT Write Register                                 */
    
    struct {
      __OM  uint32 BLUE       : 8;            /*!< [7..0] Blue value                                                         */
      __OM  uint32 GREEN      : 8;            /*!< [15..8] Green value                                                       */
      __OM  uint32 RED        : 8;            /*!< [23..16] Red value                                                        */
      __OM  uint32 CLUTADD    : 8;            /*!< [31..24] CLUT Address                                                     */
    } bit;
  } L2CLUTWR;
} LTDC_Type;                                    /*!< Size = 328 (0x148)                                                        */



/* =========================================================================================================================== */
/* ================                                          SPDIFRX                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Receiver Interface (SPDIFRX)
  */

typedef struct {                                /*!< (@ 0x40004000) SPDIFRX Structure                                          */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) Control register                                           */
    
    struct {
      __IOM uint32 SPDIFRXEN  : 2;            /*!< [1..0] Peripheral Block Enable                                            */
      __IOM uint32 RXDMAEN    : 1;            /*!< [2..2] Receiver DMA ENable for data flow                                  */
      __IOM uint32 RXSTEO     : 1;            /*!< [3..3] STerEO Mode                                                        */
      __IOM uint32 DRFMT      : 2;            /*!< [5..4] RX Data format                                                     */
      __IOM uint32 PMSK       : 1;            /*!< [6..6] Mask Parity error bit                                              */
      __IOM uint32 VMSK       : 1;            /*!< [7..7] Mask of Validity bit                                               */
      __IOM uint32 CUMSK      : 1;            /*!< [8..8] Mask of channel status and user bits                               */
      __IOM uint32 PTMSK      : 1;            /*!< [9..9] Mask of Preamble Type bits                                         */
      __IOM uint32 CBDMAEN    : 1;            /*!< [10..10] Control Buffer DMA ENable for control flow                       */
      __IOM uint32 CHSEL      : 1;            /*!< [11..11] Channel Selection                                                */
      __IOM uint32 NBTR       : 2;            /*!< [13..12] Maximum allowed re-tries during synchronization phase            */
      __IOM uint32 WFA        : 1;            /*!< [14..14] Wait For Activity                                                */
            uint32            : 1;
      __IOM uint32 INSEL      : 3;            /*!< [18..16] input selection                                                  */
            uint32            : 1;
      __IOM uint32 CKSEN      : 1;            /*!< [20..20] Symbol Clock Enable                                              */
      __IOM uint32 CKSBKPEN   : 1;            /*!< [21..21] Backup Symbol Clock Enable                                       */
            uint32            : 10;
    } bit;
  } CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) Interrupt mask register                                    */
    
    struct {
      __IOM uint32 RXNEIE     : 1;            /*!< [0..0] RXNE interrupt enable                                              */
      __IOM uint32 CSRNEIE    : 1;            /*!< [1..1] Control Buffer Ready Interrupt Enable                              */
      __IOM uint32 PERRIE     : 1;            /*!< [2..2] Parity error interrupt enable                                      */
      __IOM uint32 OVRIE      : 1;            /*!< [3..3] Overrun error Interrupt Enable                                     */
      __IOM uint32 SBLKIE     : 1;            /*!< [4..4] Synchronization Block Detected Interrupt Enable                    */
      __IOM uint32 SYNCDIE    : 1;            /*!< [5..5] Synchronization Done                                               */
      __IOM uint32 IFEIE      : 1;            /*!< [6..6] Serial Interface Error Interrupt Enable                            */
            uint32            : 25;
    } bit;
  } IMR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000008) Status register                                            */
    
    struct {
      __IM  uint32 RXNE       : 1;            /*!< [0..0] Read data register not empty                                       */
      __IM  uint32 CSRNE      : 1;            /*!< [1..1] Control Buffer register is not empty                               */
      __IM  uint32 PERR       : 1;            /*!< [2..2] Parity error                                                       */
      __IM  uint32 OVR        : 1;            /*!< [3..3] Overrun error                                                      */
      __IM  uint32 SBD        : 1;            /*!< [4..4] Synchronization Block Detected                                     */
      __IM  uint32 SYNCD      : 1;            /*!< [5..5] Synchronization Done                                               */
      __IM  uint32 FERR       : 1;            /*!< [6..6] Framing error                                                      */
      __IM  uint32 SERR       : 1;            /*!< [7..7] Synchronization error                                              */
      __IM  uint32 TERR       : 1;            /*!< [8..8] Time-out error                                                     */
            uint32            : 7;
      __IM  uint32 WIDTH5     : 15;           /*!< [30..16] Duration of 5 symbols counted with SPDIF_CLK                     */
            uint32            : 1;
    } bit;
  } SR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x0000000C) Interrupt Flag Clear register                              */
    
    struct {
            uint32            : 2;
      __OM  uint32 PERRCF     : 1;            /*!< [2..2] Clears the Parity error flag                                       */
      __OM  uint32 OVRCF      : 1;            /*!< [3..3] Clears the Overrun error flag                                      */
      __OM  uint32 SBDCF      : 1;            /*!< [4..4] Clears the Synchronization Block Detected flag                     */
      __OM  uint32 SYNCDCF    : 1;            /*!< [5..5] Clears the Synchronization Done flag                               */
            uint32            : 26;
    } bit;
  } IFCR;
  
  union {
    union {
      __IM  uint32 reg;                       /*!< (@ 0x00000010) Data input register                                        */
      
      struct {
        __IM  uint32 DR       : 24;           /*!< [23..0] Parity Error bit                                                  */
        __IM  uint32 PE       : 1;            /*!< [24..24] Parity Error bit                                                 */
        __IM  uint32 V        : 1;            /*!< [25..25] Validity bit                                                     */
        __IM  uint32 U        : 1;            /*!< [26..26] User bit                                                         */
        __IM  uint32 C        : 1;            /*!< [27..27] Channel Status bit                                               */
        __IM  uint32 PT       : 2;            /*!< [29..28] Preamble Type                                                    */
              uint32          : 2;
      } bit;
    } DR_00;
    
    union {
      __IM  uint32 reg;                       /*!< (@ 0x00000010) Data input register                                        */
      
      struct {
        __IM  uint32 PE       : 1;            /*!< [0..0] Parity Error bit                                                   */
        __IM  uint32 V        : 1;            /*!< [1..1] Validity bit                                                       */
        __IM  uint32 U        : 1;            /*!< [2..2] User bit                                                           */
        __IM  uint32 C        : 1;            /*!< [3..3] Channel Status bit                                                 */
        __IM  uint32 PT       : 2;            /*!< [5..4] Preamble Type                                                      */
              uint32          : 2;
        __IM  uint32 DR       : 24;           /*!< [31..8] Data value                                                        */
      } bit;
    } DR_01;
    
    union {
      __IM  uint32 reg;                       /*!< (@ 0x00000010) Data input register                                        */
      
      struct {
        __IM  uint32 DRNL1    : 16;           /*!< [15..0] Data value                                                        */
        __IM  uint32 DRNL2    : 16;           /*!< [31..16] Data value                                                       */
      } bit;
    } DR_10;
  };
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000014) Channel Status register                                    */
    
    struct {
      __IM  uint32 USR        : 16;           /*!< [15..0] User data information                                             */
      __IM  uint32 CS         : 8;            /*!< [23..16] Channel A status information                                     */
      __IM  uint32 SOB        : 1;            /*!< [24..24] Start Of Block                                                   */
            uint32            : 7;
    } bit;
  } CSR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000018) Debug Information register                                 */
    
    struct {
      __IM  uint32 THI        : 13;           /*!< [12..0] Threshold HIGH                                                    */
            uint32            : 3;
      __IM  uint32 TLO        : 13;           /*!< [28..16] Threshold LOW                                                    */
            uint32            : 3;
    } bit;
  } DIR;
  __IM  uint32  RESERVED[246];
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000003F4) SPDIFRX version register                                   */
    
    struct {
      __IM  uint32 MINREV     : 4;            /*!< [3..0] Minor revision                                                     */
      __IM  uint32 MAJREV     : 4;            /*!< [7..4] Major revision                                                     */
            uint32            : 24;
    } bit;
  } VERR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000003F8) SPDIFRX identification register                            */
    
    struct {
      __IM  uint32 ID         : 32;           /*!< [31..0] SPDIFRX identifier                                                */
    } bit;
  } IDR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000003FC) SPDIFRX size identification register                       */
    
    struct {
      __IM  uint32 SID        : 32;           /*!< [31..0] Size identification                                               */
    } bit;
  } SIDR;
} SPDIFRX_Type;                                 /*!< Size = 1024 (0x400)                                                       */



/* =========================================================================================================================== */
/* ================                                           ADC3                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Analog to Digital Converter (ADC3)
  */

typedef struct {                                /*!< (@ 0x58026000) ADC3 Structure                                             */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) ADC interrupt and status register                          */
    
    struct {
      __IOM uint32 ADRDY      : 1;            /*!< [0..0] ADC ready flag                                                     */
      __IOM uint32 EOSMP      : 1;            /*!< [1..1] ADC group regular end of sampling flag                             */
      __IOM uint32 EOC        : 1;            /*!< [2..2] ADC group regular end of unitary conversion flag                   */
      __IOM uint32 EOS        : 1;            /*!< [3..3] ADC group regular end of sequence conversions flag                 */
      __IOM uint32 OVR        : 1;            /*!< [4..4] ADC group regular overrun flag                                     */
      __IOM uint32 JEOC       : 1;            /*!< [5..5] ADC group injected end of unitary conversion flag                  */
      __IOM uint32 JEOS       : 1;            /*!< [6..6] ADC group injected end of sequence conversions flag                */
      __IOM uint32 AWD1       : 1;            /*!< [7..7] ADC analog watchdog 1 flag                                         */
      __IOM uint32 AWD2       : 1;            /*!< [8..8] ADC analog watchdog 2 flag                                         */
      __IOM uint32 AWD3       : 1;            /*!< [9..9] ADC analog watchdog 3 flag                                         */
      __IOM uint32 JQOVF      : 1;            /*!< [10..10] ADC group injected contexts queue overflow flag                  */
            uint32            : 21;
    } bit;
  } ISR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) ADC interrupt enable register                              */
    
    struct {
      __IOM uint32 ADRDYIE    : 1;            /*!< [0..0] ADC ready interrupt                                                */
      __IOM uint32 EOSMPIE    : 1;            /*!< [1..1] ADC group regular end of sampling interrupt                        */
      __IOM uint32 EOCIE      : 1;            /*!< [2..2] ADC group regular end of unitary conversion interrupt              */
      __IOM uint32 EOSIE      : 1;            /*!< [3..3] ADC group regular end of sequence conversions interrupt            */
      __IOM uint32 OVRIE      : 1;            /*!< [4..4] ADC group regular overrun interrupt                                */
      __IOM uint32 JEOCIE     : 1;            /*!< [5..5] ADC group injected end of unitary conversion interrupt             */
      __IOM uint32 JEOSIE     : 1;            /*!< [6..6] ADC group injected end of sequence conversions interrupt           */
      __IOM uint32 AWD1IE     : 1;            /*!< [7..7] ADC analog watchdog 1 interrupt                                    */
      __IOM uint32 AWD2IE     : 1;            /*!< [8..8] ADC analog watchdog 2 interrupt                                    */
      __IOM uint32 AWD3IE     : 1;            /*!< [9..9] ADC analog watchdog 3 interrupt                                    */
      __IOM uint32 JQOVFIE    : 1;            /*!< [10..10] ADC group injected contexts queue overflow interrupt             */
            uint32            : 21;
    } bit;
  } IER;
  
  union {
    union {
      __IOM uint32 reg;                       /*!< (@ 0x00000008) ADC control register                                       */
      
      struct {
        __IOM uint32 ADEN     : 1;            /*!< [0..0] ADC enable                                                         */
        __IOM uint32 ADDIS    : 1;            /*!< [1..1] ADC disable                                                        */
        __IOM uint32 ADSTART  : 1;            /*!< [2..2] ADC group regular conversion start                                 */
        __IOM uint32 JADSTART : 1;            /*!< [3..3] ADC group injected conversion start                                */
        __IOM uint32 ADSTP    : 1;            /*!< [4..4] ADC group regular conversion stop                                  */
        __IOM uint32 JADSTP   : 1;            /*!< [5..5] ADC group injected conversion stop                                 */
              uint32          : 2;
        __IOM uint32 BOOST    : 1;            /*!< [8..8] Boost mode control                                                 */
              uint32          : 7;
        __IOM uint32 ADCALLIN : 1;            /*!< [16..16] Linearity calibration                                            */
              uint32          : 5;
        __IOM uint32 LINCALRDYW1 : 1;         /*!< [22..22] Linearity calibration ready Word 1                               */
        __IOM uint32 LINCALRDYW2 : 1;         /*!< [23..23] Linearity calibration ready Word 2                               */
        __IOM uint32 LINCALRDYW3 : 1;         /*!< [24..24] Linearity calibration ready Word 3                               */
        __IOM uint32 LINCALRDYW4 : 1;         /*!< [25..25] Linearity calibration ready Word 4                               */
        __IOM uint32 LINCALRDYW5 : 1;         /*!< [26..26] Linearity calibration ready Word 5                               */
        __IOM uint32 LINCALRDYW6 : 1;         /*!< [27..27] Linearity calibration ready Word 6                               */
        __IOM uint32 ADVREGEN : 1;            /*!< [28..28] ADC voltage regulator enable                                     */
        __IOM uint32 DEEPPWD  : 1;            /*!< [29..29] ADC deep power down enable                                       */
        __IOM uint32 ADCALDIF : 1;            /*!< [30..30] ADC differential mode for calibration                            */
        __IOM uint32 ADCAL    : 1;            /*!< [31..31] ADC calibration                                                  */
      } bit;
    } CR;
    
    union {
      __IOM uint32 reg;                       /*!< (@ 0x00000008) ADC common control register                                */
      
      struct {
              uint32          : 16;
        __IOM uint32 CKMODE   : 2;            /*!< [17..16] ADC clock mode                                                   */
        __IOM uint32 PRESC    : 4;            /*!< [21..18] ADC prescaler                                                    */
        __IOM uint32 VREFEN   : 1;            /*!< [22..22] VREFINT enable                                                   */
        __IOM uint32 TSEN     : 1;            /*!< [23..23] Temperature sensor enable                                        */
        __IOM uint32 VBATEN   : 1;            /*!< [24..24] VBAT enable                                                      */
              uint32          : 7;
      } bit;
    } CCR;
  };
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) ADC configuration register 1                               */
    
    struct {
      __IOM uint32 DMNGT      : 2;            /*!< [1..0] ADC DMA transfer enable                                            */
      __IOM uint32 RES        : 2;            /*!< [3..2] ADC data resolution                                                */
            uint32            : 1;
      __IOM uint32 EXTSEL     : 5;            /*!< [9..5] ADC group regular external trigger source                          */
      __IOM uint32 EXTEN      : 2;            /*!< [11..10] ADC group regular external trigger polarity                      */
      __IOM uint32 OVRMOD     : 1;            /*!< [12..12] ADC group regular overrun configuration                          */
      __IOM uint32 CONT       : 1;            /*!< [13..13] ADC group regular continuous conversion mode                     */
      __IOM uint32 AUTDLY     : 1;            /*!< [14..14] ADC low power auto wait                                          */
            uint32            : 1;
      __IOM uint32 DISCEN     : 1;            /*!< [16..16] ADC group regular sequencer discontinuous mode                   */
      __IOM uint32 DISCNUM    : 3;            /*!< [19..17] ADC group regular sequencer discontinuous number of
                                                     ranks                                                                     */
      __IOM uint32 JDISCEN    : 1;            /*!< [20..20] ADC group injected sequencer discontinuous mode                  */
      __IOM uint32 JQM        : 1;            /*!< [21..21] ADC group injected contexts queue mode                           */
      __IOM uint32 AWD1SGL    : 1;            /*!< [22..22] ADC analog watchdog 1 monitoring a single channel or
                                                     all channels                                                              */
      __IOM uint32 AWD1EN     : 1;            /*!< [23..23] ADC analog watchdog 1 enable on scope ADC group regular          */
      __IOM uint32 JAWD1EN    : 1;            /*!< [24..24] ADC analog watchdog 1 enable on scope ADC group injected         */
      __IOM uint32 JAUTO      : 1;            /*!< [25..25] ADC group injected automatic trigger mode                        */
      __IOM uint32 AWDCH1CH   : 5;            /*!< [30..26] ADC analog watchdog 1 monitored channel selection                */
      __IOM uint32 JQDIS      : 1;            /*!< [31..31] ADC group injected contexts queue disable                        */
    } bit;
  } CFGR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) ADC configuration register 2                               */
    
    struct {
      __IOM uint32 ROVSE      : 1;            /*!< [0..0] ADC oversampler enable on scope ADC group regular                  */
      __IOM uint32 JOVSE      : 1;            /*!< [1..1] ADC oversampler enable on scope ADC group injected                 */
            uint32            : 3;
      __IOM uint32 OVSS       : 4;            /*!< [8..5] ADC oversampling shift                                             */
      __IOM uint32 TROVS      : 1;            /*!< [9..9] ADC oversampling discontinuous mode (triggered mode)
                                                     for ADC group regular                                                     */
      __IOM uint32 ROVSM      : 1;            /*!< [10..10] Regular Oversampling mode                                        */
      __IOM uint32 RSHIFT1    : 1;            /*!< [11..11] Right-shift data after Offset 1 correction                       */
      __IOM uint32 RSHIFT2    : 1;            /*!< [12..12] Right-shift data after Offset 2 correction                       */
      __IOM uint32 RSHIFT3    : 1;            /*!< [13..13] Right-shift data after Offset 3 correction                       */
      __IOM uint32 RSHIFT4    : 1;            /*!< [14..14] Right-shift data after Offset 4 correction                       */
            uint32            : 1;
      __IOM uint32 OSR        : 10;           /*!< [25..16] Oversampling ratio                                               */
            uint32            : 2;
      __IOM uint32 LSHIFT     : 4;            /*!< [31..28] Left shift factor                                                */
    } bit;
  } CFGR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000014) ADC sampling time register 1                               */
    
    struct {
            uint32            : 3;
      __IOM uint32 SMP1       : 3;            /*!< [5..3] ADC channel 1 sampling time selection                              */
      __IOM uint32 SMP2       : 3;            /*!< [8..6] ADC channel 2 sampling time selection                              */
      __IOM uint32 SMP3       : 3;            /*!< [11..9] ADC channel 3 sampling time selection                             */
      __IOM uint32 SMP4       : 3;            /*!< [14..12] ADC channel 4 sampling time selection                            */
      __IOM uint32 SMP5       : 3;            /*!< [17..15] ADC channel 5 sampling time selection                            */
      __IOM uint32 SMP6       : 3;            /*!< [20..18] ADC channel 6 sampling time selection                            */
      __IOM uint32 SMP7       : 3;            /*!< [23..21] ADC channel 7 sampling time selection                            */
      __IOM uint32 SMP8       : 3;            /*!< [26..24] ADC channel 8 sampling time selection                            */
      __IOM uint32 SMP9       : 3;            /*!< [29..27] ADC channel 9 sampling time selection                            */
            uint32            : 2;
    } bit;
  } SMPR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000018) ADC sampling time register 2                               */
    
    struct {
      __IOM uint32 SMP10      : 3;            /*!< [2..0] ADC channel 10 sampling time selection                             */
      __IOM uint32 SMP11      : 3;            /*!< [5..3] ADC channel 11 sampling time selection                             */
      __IOM uint32 SMP12      : 3;            /*!< [8..6] ADC channel 12 sampling time selection                             */
      __IOM uint32 SMP13      : 3;            /*!< [11..9] ADC channel 13 sampling time selection                            */
      __IOM uint32 SMP14      : 3;            /*!< [14..12] ADC channel 14 sampling time selection                           */
      __IOM uint32 SMP15      : 3;            /*!< [17..15] ADC channel 15 sampling time selection                           */
      __IOM uint32 SMP16      : 3;            /*!< [20..18] ADC channel 16 sampling time selection                           */
      __IOM uint32 SMP17      : 3;            /*!< [23..21] ADC channel 17 sampling time selection                           */
      __IOM uint32 SMP18      : 3;            /*!< [26..24] ADC channel 18 sampling time selection                           */
      __IOM uint32 SMP19      : 3;            /*!< [29..27] ADC channel 18 sampling time selection                           */
            uint32            : 2;
    } bit;
  } SMPR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000001C) ADC pre channel selection register                         */
    
    struct {
      __IOM uint32 PCSEL      : 20;           /*!< [19..0] Channel x (VINP[i]) pre selection                                 */
            uint32            : 12;
    } bit;
  } PCSEL;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000020) ADC analog watchdog 1 threshold register                   */
    
    struct {
      __IOM uint32 LTR1       : 26;           /*!< [25..0] ADC analog watchdog 1 threshold low                               */
            uint32            : 6;
    } bit;
  } LTR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000024) ADC analog watchdog 2 threshold register                   */
    
    struct {
      __IOM uint32 LHTR1      : 26;           /*!< [25..0] ADC analog watchdog 2 threshold low                               */
            uint32            : 6;
    } bit;
  } LHTR1;
  __IM  uint32  RESERVED[2];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000030) ADC group regular sequencer ranks register 1               */
    
    struct {
      __IOM uint32 L3         : 4;            /*!< [3..0] L3                                                                 */
            uint32            : 2;
      __IOM uint32 SQ1        : 5;            /*!< [10..6] ADC group regular sequencer rank 1                                */
            uint32            : 1;
      __IOM uint32 SQ2        : 5;            /*!< [16..12] ADC group regular sequencer rank 2                               */
            uint32            : 1;
      __IOM uint32 SQ3        : 5;            /*!< [22..18] ADC group regular sequencer rank 3                               */
            uint32            : 1;
      __IOM uint32 SQ4        : 5;            /*!< [28..24] ADC group regular sequencer rank 4                               */
            uint32            : 3;
    } bit;
  } SQR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000034) ADC group regular sequencer ranks register 2               */
    
    struct {
      __IOM uint32 SQ5        : 5;            /*!< [4..0] ADC group regular sequencer rank 5                                 */
            uint32            : 1;
      __IOM uint32 SQ6        : 5;            /*!< [10..6] ADC group regular sequencer rank 6                                */
            uint32            : 1;
      __IOM uint32 SQ7        : 5;            /*!< [16..12] ADC group regular sequencer rank 7                               */
            uint32            : 1;
      __IOM uint32 SQ8        : 5;            /*!< [22..18] ADC group regular sequencer rank 8                               */
            uint32            : 1;
      __IOM uint32 SQ9        : 5;            /*!< [28..24] ADC group regular sequencer rank 9                               */
            uint32            : 3;
    } bit;
  } SQR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000038) ADC group regular sequencer ranks register 3               */
    
    struct {
      __IOM uint32 SQ10       : 5;            /*!< [4..0] ADC group regular sequencer rank 10                                */
            uint32            : 1;
      __IOM uint32 SQ11       : 5;            /*!< [10..6] ADC group regular sequencer rank 11                               */
            uint32            : 1;
      __IOM uint32 SQ12       : 5;            /*!< [16..12] ADC group regular sequencer rank 12                              */
            uint32            : 1;
      __IOM uint32 SQ13       : 5;            /*!< [22..18] ADC group regular sequencer rank 13                              */
            uint32            : 1;
      __IOM uint32 SQ14       : 5;            /*!< [28..24] ADC group regular sequencer rank 14                              */
            uint32            : 3;
    } bit;
  } SQR3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000003C) ADC group regular sequencer ranks register 4               */
    
    struct {
      __IOM uint32 SQ15       : 5;            /*!< [4..0] ADC group regular sequencer rank 15                                */
            uint32            : 1;
      __IOM uint32 SQ16       : 5;            /*!< [10..6] ADC group regular sequencer rank 16                               */
            uint32            : 21;
    } bit;
  } SQR4;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000040) ADC group regular conversion data register                 */
    
    struct {
      __IM  uint32 RDATA      : 16;           /*!< [15..0] ADC group regular conversion data                                 */
            uint32            : 16;
    } bit;
  } DR;
  __IM  uint32  RESERVED1[2];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000004C) ADC group injected sequencer register                      */
    
    struct {
      __IOM uint32 JL         : 2;            /*!< [1..0] ADC group injected sequencer scan length                           */
      __IOM uint32 JEXTSEL    : 5;            /*!< [6..2] ADC group injected external trigger source                         */
      __IOM uint32 JEXTEN     : 2;            /*!< [8..7] ADC group injected external trigger polarity                       */
      __IOM uint32 JSQ1       : 5;            /*!< [13..9] ADC group injected sequencer rank 1                               */
            uint32            : 1;
      __IOM uint32 JSQ2       : 5;            /*!< [19..15] ADC group injected sequencer rank 2                              */
            uint32            : 1;
      __IOM uint32 JSQ3       : 5;            /*!< [25..21] ADC group injected sequencer rank 3                              */
            uint32            : 1;
      __IOM uint32 JSQ4       : 5;            /*!< [31..27] ADC group injected sequencer rank 4                              */
    } bit;
  } JSQR;
  __IM  uint32  RESERVED2[4];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000060) ADC offset number 1 register                               */
    
    struct {
      __IOM uint32 OFFSET1    : 26;           /*!< [25..0] ADC offset number 1 offset level                                  */
      __IOM uint32 OFFSET1_CH : 5;            /*!< [30..26] ADC offset number 1 channel selection                            */
      __IOM uint32 SSATE      : 1;            /*!< [31..31] ADC offset number 1 enable                                       */
    } bit;
  } OFR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000064) ADC offset number 2 register                               */
    
    struct {
      __IOM uint32 OFFSET1    : 26;           /*!< [25..0] ADC offset number 1 offset level                                  */
      __IOM uint32 OFFSET1_CH : 5;            /*!< [30..26] ADC offset number 1 channel selection                            */
      __IOM uint32 SSATE      : 1;            /*!< [31..31] ADC offset number 1 enable                                       */
    } bit;
  } OFR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000068) ADC offset number 3 register                               */
    
    struct {
      __IOM uint32 OFFSET1    : 26;           /*!< [25..0] ADC offset number 1 offset level                                  */
      __IOM uint32 OFFSET1_CH : 5;            /*!< [30..26] ADC offset number 1 channel selection                            */
      __IOM uint32 SSATE      : 1;            /*!< [31..31] ADC offset number 1 enable                                       */
    } bit;
  } OFR3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000006C) ADC offset number 4 register                               */
    
    struct {
      __IOM uint32 OFFSET1    : 26;           /*!< [25..0] ADC offset number 1 offset level                                  */
      __IOM uint32 OFFSET1_CH : 5;            /*!< [30..26] ADC offset number 1 channel selection                            */
      __IOM uint32 SSATE      : 1;            /*!< [31..31] ADC offset number 1 enable                                       */
    } bit;
  } OFR4;
  __IM  uint32  RESERVED3[4];
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000080) ADC group injected sequencer rank 1 register               */
    
    struct {
      __IM  uint32 JDATA1     : 32;           /*!< [31..0] ADC group injected sequencer rank 1 conversion data               */
    } bit;
  } JDR1;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000084) ADC group injected sequencer rank 2 register               */
    
    struct {
      __IM  uint32 JDATA2     : 32;           /*!< [31..0] ADC group injected sequencer rank 2 conversion data               */
    } bit;
  } JDR2;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000088) ADC group injected sequencer rank 3 register               */
    
    struct {
      __IM  uint32 JDATA3     : 32;           /*!< [31..0] ADC group injected sequencer rank 3 conversion data               */
    } bit;
  } JDR3;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000008C) ADC group injected sequencer rank 4 register               */
    
    struct {
      __IM  uint32 JDATA4     : 32;           /*!< [31..0] ADC group injected sequencer rank 4 conversion data               */
    } bit;
  } JDR4;
  __IM  uint32  RESERVED4[4];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000A0) ADC analog watchdog 2 configuration register               */
    
    struct {
      __IOM uint32 AWD2CH     : 20;           /*!< [19..0] ADC analog watchdog 2 monitored channel selection                 */
            uint32            : 12;
    } bit;
  } AWD2CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000A4) ADC analog watchdog 3 configuration register               */
    
    struct {
            uint32            : 1;
      __IOM uint32 AWD3CH     : 20;           /*!< [20..1] ADC analog watchdog 3 monitored channel selection                 */
            uint32            : 11;
    } bit;
  } AWD3CR;
  __IM  uint32  RESERVED5[2];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000B0) ADC watchdog lower threshold register 2                    */
    
    struct {
      __IOM uint32 LTR2       : 26;           /*!< [25..0] Analog watchdog 2 lower threshold                                 */
            uint32            : 6;
    } bit;
  } LTR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000B4) ADC watchdog higher threshold register 2                   */
    
    struct {
      __IOM uint32 HTR2       : 26;           /*!< [25..0] Analog watchdog 2 higher threshold                                */
            uint32            : 6;
    } bit;
  } HTR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000B8) ADC watchdog lower threshold register 3                    */
    
    struct {
      __IOM uint32 LTR3       : 26;           /*!< [25..0] Analog watchdog 3 lower threshold                                 */
            uint32            : 6;
    } bit;
  } LTR3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000BC) ADC watchdog higher threshold register 3                   */
    
    struct {
      __IOM uint32 HTR3       : 26;           /*!< [25..0] Analog watchdog 3 higher threshold                                */
            uint32            : 6;
    } bit;
  } HTR3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000C0) ADC channel differential or single-ended mode
                                                                    selection register                                         */
    
    struct {
      __IOM uint32 DIFSEL     : 20;           /*!< [19..0] ADC channel differential or single-ended mode for channel         */
            uint32            : 12;
    } bit;
  } DIFSEL;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000C4) ADC calibration factors register                           */
    
    struct {
      __IOM uint32 CALFACT_S  : 11;           /*!< [10..0] ADC calibration factor in single-ended mode                       */
            uint32            : 5;
      __IOM uint32 CALFACT_D  : 11;           /*!< [26..16] ADC calibration factor in differential mode                      */
            uint32            : 5;
    } bit;
  } CALFACT;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000C8) ADC Calibration Factor register 2                          */
    
    struct {
      __IOM uint32 LINCALFACT : 30;           /*!< [29..0] Linearity Calibration Factor                                      */
            uint32            : 2;
    } bit;
  } CALFACT2;
} ADC3_Type;                                    /*!< Size = 204 (0xcc)                                                         */



/* =========================================================================================================================== */
/* ================                                        ADC3_Common                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief Analog-to-Digital Converter (ADC3_Common)
  */

typedef struct {                                /*!< (@ 0x58026300) ADC3_Common Structure                                      */
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000000) ADC Common status register                                 */
    
    struct {
      __IM  uint32 ADRDY_MST  : 1;            /*!< [0..0] Master ADC ready                                                   */
      __IM  uint32 EOSMP_MST  : 1;            /*!< [1..1] End of Sampling phase flag of the master ADC                       */
      __IM  uint32 EOC_MST    : 1;            /*!< [2..2] End of regular conversion of the master ADC                        */
      __IM  uint32 EOS_MST    : 1;            /*!< [3..3] End of regular sequence flag of the master ADC                     */
      __IM  uint32 OVR_MST    : 1;            /*!< [4..4] Overrun flag of the master ADC                                     */
      __IM  uint32 JEOC_MST   : 1;            /*!< [5..5] End of injected conversion flag of the master ADC                  */
      __IM  uint32 JEOS_MST   : 1;            /*!< [6..6] End of injected sequence flag of the master ADC                    */
      __IM  uint32 AWD1_MST   : 1;            /*!< [7..7] Analog watchdog 1 flag of the master ADC                           */
      __IM  uint32 AWD2_MST   : 1;            /*!< [8..8] Analog watchdog 2 flag of the master ADC                           */
      __IM  uint32 AWD3_MST   : 1;            /*!< [9..9] Analog watchdog 3 flag of the master ADC                           */
      __IM  uint32 JQOVF_MST  : 1;            /*!< [10..10] Injected Context Queue Overflow flag of the master
                                                     ADC                                                                       */
            uint32            : 5;
      __IM  uint32 ADRDY_SLV  : 1;            /*!< [16..16] Slave ADC ready                                                  */
      __IM  uint32 EOSMP_SLV  : 1;            /*!< [17..17] End of Sampling phase flag of the slave ADC                      */
      __IM  uint32 EOC_SLV    : 1;            /*!< [18..18] End of regular conversion of the slave ADC                       */
      __IM  uint32 EOS_SLV    : 1;            /*!< [19..19] End of regular sequence flag of the slave ADC                    */
      __IM  uint32 OVR_SLV    : 1;            /*!< [20..20] Overrun flag of the slave ADC                                    */
      __IM  uint32 JEOC_SLV   : 1;            /*!< [21..21] End of injected conversion flag of the slave ADC                 */
      __IM  uint32 JEOS_SLV   : 1;            /*!< [22..22] End of injected sequence flag of the slave ADC                   */
      __IM  uint32 AWD1_SLV   : 1;            /*!< [23..23] Analog watchdog 1 flag of the slave ADC                          */
      __IM  uint32 AWD2_SLV   : 1;            /*!< [24..24] Analog watchdog 2 flag of the slave ADC                          */
      __IM  uint32 AWD3_SLV   : 1;            /*!< [25..25] Analog watchdog 3 flag of the slave ADC                          */
      __IM  uint32 JQOVF_SLV  : 1;            /*!< [26..26] Injected Context Queue Overflow flag of the slave ADC            */
            uint32            : 5;
    } bit;
  } CSR;
  __IM  uint32  RESERVED;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) ADC common control register                                */
    
    struct {
      __IOM uint32 DUAL       : 5;            /*!< [4..0] Dual ADC mode selection                                            */
            uint32            : 3;
      __IOM uint32 DELAY      : 4;            /*!< [11..8] Delay between 2 sampling phases                                   */
            uint32            : 2;
      __IOM uint32 DAMDF      : 2;            /*!< [15..14] Dual ADC Mode Data Format                                        */
      __IOM uint32 CKMODE     : 2;            /*!< [17..16] ADC clock mode                                                   */
      __IOM uint32 PRESC      : 4;            /*!< [21..18] ADC prescaler                                                    */
      __IOM uint32 VREFEN     : 1;            /*!< [22..22] VREFINT enable                                                   */
      __IOM uint32 TSEN       : 1;            /*!< [23..23] Temperature sensor enable                                        */
      __IOM uint32 VBATEN     : 1;            /*!< [24..24] VBAT enable                                                      */
            uint32            : 7;
    } bit;
  } CCR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000000C) ADC common regular data register for dual and
                                                                    triple modes                                               */
    
    struct {
      __IM  uint32 RDATA_MST  : 16;           /*!< [15..0] Regular data of the master ADC                                    */
      __IM  uint32 RDATA_SLV  : 16;           /*!< [31..16] Regular data of the slave ADC                                    */
    } bit;
  } CDR;
} ADC3_Common_Type;                             /*!< Size = 16 (0x10)                                                          */



/* =========================================================================================================================== */
/* ================                                          DMAMUX1                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief DMAMUX (DMAMUX1)
  */

typedef struct {                                /*!< (@ 0x40020800) DMAMUX1 Structure                                          */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32 DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32 SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32 EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32            : 6;
      __IOM uint32 SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32 SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32 NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32 SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32            : 3;
    } bit;
  } DMAMUX1_C0CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32 DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32 SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32 EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32            : 6;
      __IOM uint32 SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32 SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32 NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32 SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32            : 3;
    } bit;
  } DMAMUX1_C1CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32 DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32 SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32 EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32            : 6;
      __IOM uint32 SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32 SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32 NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32 SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32            : 3;
    } bit;
  } DMAMUX1_C2CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32 DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32 SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32 EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32            : 6;
      __IOM uint32 SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32 SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32 NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32 SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32            : 3;
    } bit;
  } DMAMUX1_C3CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32 DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32 SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32 EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32            : 6;
      __IOM uint32 SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32 SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32 NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32 SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32            : 3;
    } bit;
  } DMAMUX1_C4CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000014) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32 DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32 SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32 EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32            : 6;
      __IOM uint32 SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32 SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32 NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32 SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32            : 3;
    } bit;
  } DMAMUX1_C5CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000018) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32 DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32 SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32 EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32            : 6;
      __IOM uint32 SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32 SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32 NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32 SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32            : 3;
    } bit;
  } DMAMUX1_C6CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000001C) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32 DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32 SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32 EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32            : 6;
      __IOM uint32 SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32 SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32 NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32 SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32            : 3;
    } bit;
  } DMAMUX1_C7CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000020) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32 DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32 SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32 EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32            : 6;
      __IOM uint32 SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32 SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32 NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32 SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32            : 3;
    } bit;
  } DMAMUX1_C8CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000024) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32 DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32 SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32 EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32            : 6;
      __IOM uint32 SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32 SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32 NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32 SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32            : 3;
    } bit;
  } DMAMUX1_C9CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000028) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32 DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32 SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32 EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32            : 6;
      __IOM uint32 SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32 SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32 NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32 SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32            : 3;
    } bit;
  } DMAMUX1_C10CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000002C) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32 DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32 SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32 EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32            : 6;
      __IOM uint32 SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32 SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32 NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32 SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32            : 3;
    } bit;
  } DMAMUX1_C11CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000030) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32 DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32 SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32 EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32            : 6;
      __IOM uint32 SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32 SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32 NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32 SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32            : 3;
    } bit;
  } DMAMUX1_C12CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000034) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32 DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32 SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32 EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32            : 6;
      __IOM uint32 SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32 SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32 NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32 SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32            : 3;
    } bit;
  } DMAMUX1_C13CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000038) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32 DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32 SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32 EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32            : 6;
      __IOM uint32 SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32 SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32 NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32 SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32            : 3;
    } bit;
  } DMAMUX1_C14CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000003C) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32 DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32 SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32 EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32            : 6;
      __IOM uint32 SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32 SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32 NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32 SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32            : 3;
    } bit;
  } DMAMUX1_C15CR;
  __IM  uint32  RESERVED[16];
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000080) DMAMUX request line multiplexer interrupt channel
                                                                    status register                                            */
    
    struct {
      __IM  uint32 SOF        : 16;           /*!< [15..0] Synchronization overrun event flag                                */
            uint32            : 16;
    } bit;
  } DMAMUX1_CSR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000084) DMAMUX request line multiplexer interrupt clear
                                                                    flag register                                              */
    
    struct {
      __OM  uint32 CSOF       : 16;           /*!< [15..0] Clear synchronization overrun event flag                          */
            uint32            : 16;
    } bit;
  } DMAMUX1_CFR;
  __IM  uint32  RESERVED1[30];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000100) DMAMux - DMA request generator channel x control
                                                                    register                                                   */
    
    struct {
      __IOM uint32 SIG_ID     : 5;            /*!< [4..0] DMA request trigger input selected                                 */
            uint32            : 3;
      __IOM uint32 OIE        : 1;            /*!< [8..8] Interrupt enable at trigger event overrun                          */
            uint32            : 7;
      __IOM uint32 GE         : 1;            /*!< [16..16] DMA request generator channel enable/disable                     */
      __IOM uint32 GPOL       : 2;            /*!< [18..17] DMA request generator trigger event type selection
                                                     Defines the trigger event on the selected DMA request trigger
                                                     input                                                                     */
      __IOM uint32 GNBREQ     : 5;            /*!< [23..19] Number of DMA requests to generate Defines the number
                                                     of DMA requests generated after a trigger event, then stop
                                                     generating. The actual number of generated DMA requests
                                                     is GNBREQ+1. Note: This field can only be written when
                                                     GE bit is reset.                                                          */
            uint32            : 8;
    } bit;
  } DMAMUX1_RG0CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000104) DMAMux - DMA request generator channel x control
                                                                    register                                                   */
    
    struct {
      __IOM uint32 SIG_ID     : 5;            /*!< [4..0] DMA request trigger input selected                                 */
            uint32            : 3;
      __IOM uint32 OIE        : 1;            /*!< [8..8] Interrupt enable at trigger event overrun                          */
            uint32            : 7;
      __IOM uint32 GE         : 1;            /*!< [16..16] DMA request generator channel enable/disable                     */
      __IOM uint32 GPOL       : 2;            /*!< [18..17] DMA request generator trigger event type selection
                                                     Defines the trigger event on the selected DMA request trigger
                                                     input                                                                     */
      __IOM uint32 GNBREQ     : 5;            /*!< [23..19] Number of DMA requests to generate Defines the number
                                                     of DMA requests generated after a trigger event, then stop
                                                     generating. The actual number of generated DMA requests
                                                     is GNBREQ+1. Note: This field can only be written when
                                                     GE bit is reset.                                                          */
            uint32            : 8;
    } bit;
  } DMAMUX1_RG1CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000108) DMAMux - DMA request generator channel x control
                                                                    register                                                   */
    
    struct {
      __IOM uint32 SIG_ID     : 5;            /*!< [4..0] DMA request trigger input selected                                 */
            uint32            : 3;
      __IOM uint32 OIE        : 1;            /*!< [8..8] Interrupt enable at trigger event overrun                          */
            uint32            : 7;
      __IOM uint32 GE         : 1;            /*!< [16..16] DMA request generator channel enable/disable                     */
      __IOM uint32 GPOL       : 2;            /*!< [18..17] DMA request generator trigger event type selection
                                                     Defines the trigger event on the selected DMA request trigger
                                                     input                                                                     */
      __IOM uint32 GNBREQ     : 5;            /*!< [23..19] Number of DMA requests to generate Defines the number
                                                     of DMA requests generated after a trigger event, then stop
                                                     generating. The actual number of generated DMA requests
                                                     is GNBREQ+1. Note: This field can only be written when
                                                     GE bit is reset.                                                          */
            uint32            : 8;
    } bit;
  } DMAMUX1_RG2CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000010C) DMAMux - DMA request generator channel x control
                                                                    register                                                   */
    
    struct {
      __IOM uint32 SIG_ID     : 5;            /*!< [4..0] DMA request trigger input selected                                 */
            uint32            : 3;
      __IOM uint32 OIE        : 1;            /*!< [8..8] Interrupt enable at trigger event overrun                          */
            uint32            : 7;
      __IOM uint32 GE         : 1;            /*!< [16..16] DMA request generator channel enable/disable                     */
      __IOM uint32 GPOL       : 2;            /*!< [18..17] DMA request generator trigger event type selection
                                                     Defines the trigger event on the selected DMA request trigger
                                                     input                                                                     */
      __IOM uint32 GNBREQ     : 5;            /*!< [23..19] Number of DMA requests to generate Defines the number
                                                     of DMA requests generated after a trigger event, then stop
                                                     generating. The actual number of generated DMA requests
                                                     is GNBREQ+1. Note: This field can only be written when
                                                     GE bit is reset.                                                          */
            uint32            : 8;
    } bit;
  } DMAMUX1_RG3CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000110) DMAMux - DMA request generator channel x control
                                                                    register                                                   */
    
    struct {
      __IOM uint32 SIG_ID     : 5;            /*!< [4..0] DMA request trigger input selected                                 */
            uint32            : 3;
      __IOM uint32 OIE        : 1;            /*!< [8..8] Interrupt enable at trigger event overrun                          */
            uint32            : 7;
      __IOM uint32 GE         : 1;            /*!< [16..16] DMA request generator channel enable/disable                     */
      __IOM uint32 GPOL       : 2;            /*!< [18..17] DMA request generator trigger event type selection
                                                     Defines the trigger event on the selected DMA request trigger
                                                     input                                                                     */
      __IOM uint32 GNBREQ     : 5;            /*!< [23..19] Number of DMA requests to generate Defines the number
                                                     of DMA requests generated after a trigger event, then stop
                                                     generating. The actual number of generated DMA requests
                                                     is GNBREQ+1. Note: This field can only be written when
                                                     GE bit is reset.                                                          */
            uint32            : 8;
    } bit;
  } DMAMUX1_RG4CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000114) DMAMux - DMA request generator channel x control
                                                                    register                                                   */
    
    struct {
      __IOM uint32 SIG_ID     : 5;            /*!< [4..0] DMA request trigger input selected                                 */
            uint32            : 3;
      __IOM uint32 OIE        : 1;            /*!< [8..8] Interrupt enable at trigger event overrun                          */
            uint32            : 7;
      __IOM uint32 GE         : 1;            /*!< [16..16] DMA request generator channel enable/disable                     */
      __IOM uint32 GPOL       : 2;            /*!< [18..17] DMA request generator trigger event type selection
                                                     Defines the trigger event on the selected DMA request trigger
                                                     input                                                                     */
      __IOM uint32 GNBREQ     : 5;            /*!< [23..19] Number of DMA requests to generate Defines the number
                                                     of DMA requests generated after a trigger event, then stop
                                                     generating. The actual number of generated DMA requests
                                                     is GNBREQ+1. Note: This field can only be written when
                                                     GE bit is reset.                                                          */
            uint32            : 8;
    } bit;
  } DMAMUX1_RG5CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000118) DMAMux - DMA request generator channel x control
                                                                    register                                                   */
    
    struct {
      __IOM uint32 SIG_ID     : 5;            /*!< [4..0] DMA request trigger input selected                                 */
            uint32            : 3;
      __IOM uint32 OIE        : 1;            /*!< [8..8] Interrupt enable at trigger event overrun                          */
            uint32            : 7;
      __IOM uint32 GE         : 1;            /*!< [16..16] DMA request generator channel enable/disable                     */
      __IOM uint32 GPOL       : 2;            /*!< [18..17] DMA request generator trigger event type selection
                                                     Defines the trigger event on the selected DMA request trigger
                                                     input                                                                     */
      __IOM uint32 GNBREQ     : 5;            /*!< [23..19] Number of DMA requests to generate Defines the number
                                                     of DMA requests generated after a trigger event, then stop
                                                     generating. The actual number of generated DMA requests
                                                     is GNBREQ+1. Note: This field can only be written when
                                                     GE bit is reset.                                                          */
            uint32            : 8;
    } bit;
  } DMAMUX1_RG6CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000011C) DMAMux - DMA request generator channel x control
                                                                    register                                                   */
    
    struct {
      __IOM uint32 SIG_ID     : 5;            /*!< [4..0] DMA request trigger input selected                                 */
            uint32            : 3;
      __IOM uint32 OIE        : 1;            /*!< [8..8] Interrupt enable at trigger event overrun                          */
            uint32            : 7;
      __IOM uint32 GE         : 1;            /*!< [16..16] DMA request generator channel enable/disable                     */
      __IOM uint32 GPOL       : 2;            /*!< [18..17] DMA request generator trigger event type selection
                                                     Defines the trigger event on the selected DMA request trigger
                                                     input                                                                     */
      __IOM uint32 GNBREQ     : 5;            /*!< [23..19] Number of DMA requests to generate Defines the number
                                                     of DMA requests generated after a trigger event, then stop
                                                     generating. The actual number of generated DMA requests
                                                     is GNBREQ+1. Note: This field can only be written when
                                                     GE bit is reset.                                                          */
            uint32            : 8;
    } bit;
  } DMAMUX1_RG7CR;
  __IM  uint32  RESERVED2[8];
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000140) DMAMux - DMA request generator status register             */
    
    struct {
      __IM  uint32 OF         : 8;            /*!< [7..0] Trigger event overrun flag The flag is set when a trigger
                                                     event occurs on DMA request generator channel x, while
                                                     the DMA request generator counter value is lower than GNBREQ.
                                                     The flag is cleared by writing 1 to the corresponding COFx
                                                     bit in DMAMUX_RGCFR register.                                             */
            uint32            : 24;
    } bit;
  } DMAMUX1_RGSR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000144) DMAMux - DMA request generator clear flag register         */
    
    struct {
      __OM  uint32 COF        : 8;            /*!< [7..0] Clear trigger event overrun flag Upon setting, this bit
                                                     clears the corresponding overrun flag OFx in the DMAMUX_RGCSR
                                                     register.                                                                 */
            uint32            : 24;
    } bit;
  } DMAMUX1_RGCFR;
} DMAMUX1_Type;                                 /*!< Size = 328 (0x148)                                                        */



/* =========================================================================================================================== */
/* ================                                            CRC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Cryptographic processor (CRC)
  */

typedef struct {                                /*!< (@ 0x58024C00) CRC Structure                                              */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) Data register                                              */
    
    struct {
      __IOM uint32 DR         : 32;           /*!< [31..0] Data Register                                                     */
    } bit;
  } DR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) Independent Data register                                  */
    
    struct {
      __IOM uint32 IDR        : 32;           /*!< [31..0] Independent Data register                                         */
    } bit;
  } IDR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) Control register                                           */
    
    struct {
      __OM  uint32 RESET      : 1;            /*!< [0..0] RESET bit                                                          */
            uint32            : 2;
      __IOM uint32 POLYSIZE   : 2;            /*!< [4..3] Polynomial size                                                    */
      __IOM uint32 REV_IN     : 2;            /*!< [6..5] Reverse input data                                                 */
      __IOM uint32 REV_OUT    : 1;            /*!< [7..7] Reverse output data                                                */
            uint32            : 24;
    } bit;
  } CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) Initial CRC value                                          */
    
    struct {
      __IOM uint32 CRC_INIT   : 32;           /*!< [31..0] Programmable initial CRC value                                    */
    } bit;
  } INIT;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) CRC polynomial                                             */
    
    struct {
      __IOM uint32 POL        : 32;           /*!< [31..0] Programmable polynomial                                           */
    } bit;
  } POL;
} CRC_Type;                                     /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                            RCC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Reset and clock control (RCC)
  */

typedef struct {                                /*!< (@ 0x58024400) RCC Structure                                              */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) clock control register                                     */
    
    struct {
      __IOM uint32 HSION      : 1;            /*!< [0..0] Internal high-speed clock enable                                   */
      __IOM uint32 HSIKERON   : 1;            /*!< [1..1] High Speed Internal clock enable in Stop mode                      */
      __IOM uint32 HSIRDY     : 1;            /*!< [2..2] HSI clock ready flag                                               */
      __IOM uint32 HSIDIV     : 2;            /*!< [4..3] HSI clock divider                                                  */
      __IOM uint32 HSIDIVF    : 1;            /*!< [5..5] HSI divider flag                                                   */
            uint32            : 1;
      __IOM uint32 CSION      : 1;            /*!< [7..7] CSI clock enable                                                   */
      __IOM uint32 CSIRDY     : 1;            /*!< [8..8] CSI clock ready flag                                               */
      __IOM uint32 CSIKERON   : 1;            /*!< [9..9] CSI clock enable in Stop mode                                      */
            uint32            : 2;
      __IOM uint32 RC48ON     : 1;            /*!< [12..12] RC48 clock enable                                                */
      __IOM uint32 RC48RDY    : 1;            /*!< [13..13] RC48 clock ready flag                                            */
      __IOM uint32 D1CKRDY    : 1;            /*!< [14..14] D1 domain clocks ready flag                                      */
      __IOM uint32 D2CKRDY    : 1;            /*!< [15..15] D2 domain clocks ready flag                                      */
      __IOM uint32 HSEON      : 1;            /*!< [16..16] HSE clock enable                                                 */
      __IOM uint32 HSERDY     : 1;            /*!< [17..17] HSE clock ready flag                                             */
      __IOM uint32 HSEBYP     : 1;            /*!< [18..18] HSE clock bypass                                                 */
      __IOM uint32 HSECSSON   : 1;            /*!< [19..19] HSE Clock Security System enable                                 */
            uint32            : 4;
      __IOM uint32 PLL1ON     : 1;            /*!< [24..24] PLL1 enable                                                      */
      __IOM uint32 PLL1RDY    : 1;            /*!< [25..25] PLL1 clock ready flag                                            */
      __IOM uint32 PLL2ON     : 1;            /*!< [26..26] PLL2 enable                                                      */
      __IOM uint32 PLL2RDY    : 1;            /*!< [27..27] PLL2 clock ready flag                                            */
      __IOM uint32 PLL3ON     : 1;            /*!< [28..28] PLL3 enable                                                      */
      __IOM uint32 PLL3RDY    : 1;            /*!< [29..29] PLL3 clock ready flag                                            */
            uint32            : 2;
    } bit;
  } CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) RCC Internal Clock Source Calibration Register             */
    
    struct {
      __IM  uint32 HSICAL     : 12;           /*!< [11..0] HSI clock calibration                                             */
      __IOM uint32 HSITRIM    : 6;            /*!< [17..12] HSI clock trimming                                               */
      __IM  uint32 CSICAL     : 8;            /*!< [25..18] CSI clock calibration                                            */
      __IOM uint32 CSITRIM    : 5;            /*!< [30..26] CSI clock trimming                                               */
            uint32            : 1;
    } bit;
  } ICSCR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000008) RCC Clock Recovery RC Register                             */
    
    struct {
      __IM  uint32 RC48CAL    : 10;           /*!< [9..0] Internal RC 48 MHz clock calibration                               */
            uint32            : 22;
    } bit;
  } CRRCR;
  __IM  uint32  RESERVED;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) RCC Clock Configuration Register                           */
    
    struct {
      __IOM uint32 SW         : 3;            /*!< [2..0] System clock switch                                                */
      __IOM uint32 SWS        : 3;            /*!< [5..3] System clock switch status                                         */
      __IOM uint32 STOPWUCK   : 1;            /*!< [6..6] System clock selection after a wake up from system Stop            */
      __IOM uint32 STOPKERWUCK : 1;           /*!< [7..7] Kernel clock selection after a wake up from system Stop            */
      __IOM uint32 RTCPRE     : 6;            /*!< [13..8] HSE division factor for RTC clock                                 */
      __IOM uint32 HRTIMSEL   : 1;            /*!< [14..14] High Resolution Timer clock prescaler selection                  */
      __IOM uint32 TIMPRE     : 1;            /*!< [15..15] Timers clocks prescaler selection                                */
            uint32            : 2;
      __IOM uint32 MCO1PRE    : 4;            /*!< [21..18] MCO1 prescaler                                                   */
      __IOM uint32 MCO1SEL    : 3;            /*!< [24..22] Micro-controller clock output 1                                  */
      __IOM uint32 MCO2PRE    : 4;            /*!< [28..25] MCO2 prescaler                                                   */
      __IOM uint32 MCO2SEL    : 3;            /*!< [31..29] Micro-controller clock output 2                                  */
    } bit;
  } CFGR;
  __IM  uint32  RESERVED1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000018) RCC Domain 1 Clock Configuration Register                  */
    
    struct {
      __IOM uint32 HPRE       : 4;            /*!< [3..0] D1 domain AHB prescaler                                            */
      __IOM uint32 D1PPRE     : 3;            /*!< [6..4] D1 domain APB3 prescaler                                           */
            uint32            : 1;
      __IOM uint32 D1CPRE     : 4;            /*!< [11..8] D1 domain Core prescaler                                          */
            uint32            : 20;
    } bit;
  } D1CFGR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000001C) RCC Domain 2 Clock Configuration Register                  */
    
    struct {
            uint32            : 4;
      __IOM uint32 D2PPRE1    : 3;            /*!< [6..4] D2 domain APB1 prescaler                                           */
            uint32            : 1;
      __IOM uint32 D2PPRE2    : 3;            /*!< [10..8] D2 domain APB2 prescaler                                          */
            uint32            : 21;
    } bit;
  } D2CFGR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000020) RCC Domain 3 Clock Configuration Register                  */
    
    struct {
            uint32            : 4;
      __IOM uint32 D3PPRE     : 3;            /*!< [6..4] D3 domain APB4 prescaler                                           */
            uint32            : 25;
    } bit;
  } D3CFGR;
  __IM  uint32  RESERVED2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000028) RCC PLLs Clock Source Selection Register                   */
    
    struct {
      __IOM uint32 PLLSRC     : 2;            /*!< [1..0] DIVMx and PLLs clock source selection                              */
            uint32            : 2;
      __IOM uint32 DIVM1      : 6;            /*!< [9..4] Prescaler for PLL1                                                 */
            uint32            : 2;
      __IOM uint32 DIVM2      : 6;            /*!< [17..12] Prescaler for PLL2                                               */
            uint32            : 2;
      __IOM uint32 DIVM3      : 6;            /*!< [25..20] Prescaler for PLL3                                               */
            uint32            : 6;
    } bit;
  } PLLCKSELR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000002C) RCC PLLs Configuration Register                            */
    
    struct {
      __IOM uint32 PLL1FRACEN : 1;            /*!< [0..0] PLL1 fractional latch enable                                       */
      __IOM uint32 PLL1VCOSEL : 1;            /*!< [1..1] PLL1 VCO selection                                                 */
      __IOM uint32 PLL1RGE    : 2;            /*!< [3..2] PLL1 input frequency range                                         */
      __IOM uint32 PLL2FRACEN : 1;            /*!< [4..4] PLL2 fractional latch enable                                       */
      __IOM uint32 PLL2VCOSEL : 1;            /*!< [5..5] PLL2 VCO selection                                                 */
      __IOM uint32 PLL2RGE    : 2;            /*!< [7..6] PLL2 input frequency range                                         */
      __IOM uint32 PLL3FRACEN : 1;            /*!< [8..8] PLL3 fractional latch enable                                       */
      __IOM uint32 PLL3VCOSEL : 1;            /*!< [9..9] PLL3 VCO selection                                                 */
      __IOM uint32 PLL3RGE    : 2;            /*!< [11..10] PLL3 input frequency range                                       */
            uint32            : 4;
      __IOM uint32 DIVP1EN    : 1;            /*!< [16..16] PLL1 DIVP divider output enable                                  */
      __IOM uint32 DIVQ1EN    : 1;            /*!< [17..17] PLL1 DIVQ divider output enable                                  */
      __IOM uint32 DIVR1EN    : 1;            /*!< [18..18] PLL1 DIVR divider output enable                                  */
      __IOM uint32 DIVP2EN    : 1;            /*!< [19..19] PLL2 DIVP divider output enable                                  */
      __IOM uint32 DIVQ2EN    : 1;            /*!< [20..20] PLL2 DIVQ divider output enable                                  */
      __IOM uint32 DIVR2EN    : 1;            /*!< [21..21] PLL2 DIVR divider output enable                                  */
      __IOM uint32 DIVP3EN    : 1;            /*!< [22..22] PLL3 DIVP divider output enable                                  */
      __IOM uint32 DIVQ3EN    : 1;            /*!< [23..23] PLL3 DIVQ divider output enable                                  */
      __IOM uint32 DIVR3EN    : 1;            /*!< [24..24] PLL3 DIVR divider output enable                                  */
            uint32            : 7;
    } bit;
  } PLLCFGR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000030) RCC PLL1 Dividers Configuration Register                   */
    
    struct {
      __IOM uint32 DIVN1      : 9;            /*!< [8..0] Multiplication factor for PLL1 VCO                                 */
      __IOM uint32 DIVP1      : 7;            /*!< [15..9] PLL1 DIVP division factor                                         */
      __IOM uint32 DIVQ1      : 7;            /*!< [22..16] PLL1 DIVQ division factor                                        */
            uint32            : 1;
      __IOM uint32 DIVR1      : 7;            /*!< [30..24] PLL1 DIVR division factor                                        */
            uint32            : 1;
    } bit;
  } PLL1DIVR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000034) RCC PLL1 Fractional Divider Register                       */
    
    struct {
            uint32            : 3;
      __IOM uint32 FRACN1     : 13;           /*!< [15..3] Fractional part of the multiplication factor for PLL1
                                                     VCO                                                                       */
            uint32            : 16;
    } bit;
  } PLL1FRACR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000038) RCC PLL2 Dividers Configuration Register                   */
    
    struct {
      __IOM uint32 DIVN1      : 9;            /*!< [8..0] Multiplication factor for PLL1 VCO                                 */
      __IOM uint32 DIVP1      : 7;            /*!< [15..9] PLL1 DIVP division factor                                         */
      __IOM uint32 DIVQ1      : 7;            /*!< [22..16] PLL1 DIVQ division factor                                        */
            uint32            : 1;
      __IOM uint32 DIVR1      : 7;            /*!< [30..24] PLL1 DIVR division factor                                        */
            uint32            : 1;
    } bit;
  } PLL2DIVR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000003C) RCC PLL2 Fractional Divider Register                       */
    
    struct {
            uint32            : 3;
      __IOM uint32 FRACN2     : 13;           /*!< [15..3] Fractional part of the multiplication factor for PLL
                                                     VCO                                                                       */
            uint32            : 16;
    } bit;
  } PLL2FRACR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000040) RCC PLL3 Dividers Configuration Register                   */
    
    struct {
      __IOM uint32 DIVN3      : 9;            /*!< [8..0] Multiplication factor for PLL1 VCO                                 */
      __IOM uint32 DIVP3      : 7;            /*!< [15..9] PLL DIVP division factor                                          */
      __IOM uint32 DIVQ3      : 7;            /*!< [22..16] PLL DIVQ division factor                                         */
            uint32            : 1;
      __IOM uint32 DIVR3      : 7;            /*!< [30..24] PLL DIVR division factor                                         */
            uint32            : 1;
    } bit;
  } PLL3DIVR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000044) RCC PLL3 Fractional Divider Register                       */
    
    struct {
            uint32            : 3;
      __IOM uint32 FRACN3     : 13;           /*!< [15..3] Fractional part of the multiplication factor for PLL3
                                                     VCO                                                                       */
            uint32            : 16;
    } bit;
  } PLL3FRACR;
  __IM  uint32  RESERVED3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000004C) RCC Domain 1 Kernel Clock Configuration Register           */
    
    struct {
      __IOM uint32 FMCSRC     : 2;            /*!< [1..0] FMC kernel clock source selection                                  */
            uint32            : 2;
      __IOM uint32 QSPISRC    : 2;            /*!< [5..4] QUADSPI kernel clock source selection                              */
            uint32            : 10;
      __IOM uint32 SDMMCSRC   : 1;            /*!< [16..16] SDMMC kernel clock source selection                              */
            uint32            : 11;
      __IOM uint32 CKPERSRC   : 2;            /*!< [29..28] per_ck clock source selection                                    */
            uint32            : 2;
    } bit;
  } D1CCIPR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000050) RCC Domain 2 Kernel Clock Configuration Register           */
    
    struct {
      __IOM uint32 SAI1SRC    : 3;            /*!< [2..0] SAI1 and DFSDM1 kernel Aclk clock source selection                 */
            uint32            : 3;
      __IOM uint32 SAI23SRC   : 3;            /*!< [8..6] SAI2 and SAI3 kernel clock source selection                        */
            uint32            : 3;
      __IOM uint32 SPI123SRC  : 3;            /*!< [14..12] SPI/I2S1,2 and 3 kernel clock source selection                   */
            uint32            : 1;
      __IOM uint32 SPI45SRC   : 3;            /*!< [18..16] SPI4 and 5 kernel clock source selection                         */
            uint32            : 1;
      __IOM uint32 SPDIFSRC   : 2;            /*!< [21..20] SPDIFRX kernel clock source selection                            */
            uint32            : 2;
      __IOM uint32 DFSDM1SRC  : 1;            /*!< [24..24] DFSDM1 kernel Clk clock source selection                         */
            uint32            : 3;
      __IOM uint32 FDCANSRC   : 2;            /*!< [29..28] FDCAN kernel clock source selection                              */
            uint32            : 1;
      __IOM uint32 SWPSRC     : 1;            /*!< [31..31] SWPMI kernel clock source selection                              */
    } bit;
  } D2CCIP1R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000054) RCC Domain 2 Kernel Clock Configuration Register           */
    
    struct {
      __IOM uint32 USART234578SRC : 3;        /*!< [2..0] USART2/3, UART4,5, 7/8 (APB1) kernel clock source selection        */
      __IOM uint32 USART16SRC : 3;            /*!< [5..3] USART1 and 6 kernel clock source selection                         */
            uint32            : 2;
      __IOM uint32 RNGSRC     : 2;            /*!< [9..8] RNG kernel clock source selection                                  */
            uint32            : 2;
      __IOM uint32 I2C123SRC  : 2;            /*!< [13..12] I2C1,2,3 kernel clock source selection                           */
            uint32            : 6;
      __IOM uint32 USBSRC     : 2;            /*!< [21..20] USBOTG 1 and 2 kernel clock source selection                     */
      __IOM uint32 CECSRC     : 2;            /*!< [23..22] HDMI-CEC kernel clock source selection                           */
            uint32            : 4;
      __IOM uint32 LPTIM1SRC  : 3;            /*!< [30..28] LPTIM1 kernel clock source selection                             */
            uint32            : 1;
    } bit;
  } D2CCIP2R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000058) RCC Domain 3 Kernel Clock Configuration Register           */
    
    struct {
      __IOM uint32 LPUART1SRC : 3;            /*!< [2..0] LPUART1 kernel clock source selection                              */
            uint32            : 5;
      __IOM uint32 I2C4SRC    : 2;            /*!< [9..8] I2C4 kernel clock source selection                                 */
      __IOM uint32 LPTIM2SRC  : 3;            /*!< [12..10] LPTIM2 kernel clock source selection                             */
      __IOM uint32 LPTIM345SRC : 3;           /*!< [15..13] LPTIM3,4,5 kernel clock source selection                         */
      __IOM uint32 ADCSRC     : 2;            /*!< [17..16] SAR ADC kernel clock source selection                            */
            uint32            : 3;
      __IOM uint32 SAI4ASRC   : 3;            /*!< [23..21] Sub-Block A of SAI4 kernel clock source selection                */
      __IOM uint32 SAI4BSRC   : 3;            /*!< [26..24] Sub-Block B of SAI4 kernel clock source selection                */
            uint32            : 1;
      __IOM uint32 SPI6SRC    : 3;            /*!< [30..28] SPI6 kernel clock source selection                               */
            uint32            : 1;
    } bit;
  } D3CCIPR;
  __IM  uint32  RESERVED4;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000060) RCC Clock Source Interrupt Enable Register                 */
    
    struct {
      __IOM uint32 LSIRDYIE   : 1;            /*!< [0..0] LSI ready Interrupt Enable                                         */
      __IOM uint32 LSERDYIE   : 1;            /*!< [1..1] LSE ready Interrupt Enable                                         */
      __IOM uint32 HSIRDYIE   : 1;            /*!< [2..2] HSI ready Interrupt Enable                                         */
      __IOM uint32 HSERDYIE   : 1;            /*!< [3..3] HSE ready Interrupt Enable                                         */
      __IOM uint32 CSIRDYIE   : 1;            /*!< [4..4] CSI ready Interrupt Enable                                         */
      __IOM uint32 RC48RDYIE  : 1;            /*!< [5..5] RC48 ready Interrupt Enable                                        */
      __IOM uint32 PLL1RDYIE  : 1;            /*!< [6..6] PLL1 ready Interrupt Enable                                        */
      __IOM uint32 PLL2RDYIE  : 1;            /*!< [7..7] PLL2 ready Interrupt Enable                                        */
      __IOM uint32 PLL3RDYIE  : 1;            /*!< [8..8] PLL3 ready Interrupt Enable                                        */
      __IOM uint32 LSECSSIE   : 1;            /*!< [9..9] LSE clock security system Interrupt Enable                         */
            uint32            : 22;
    } bit;
  } CIER;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000064) RCC Clock Source Interrupt Flag Register                   */
    
    struct {
      __IOM uint32 LSIRDYF    : 1;            /*!< [0..0] LSI ready Interrupt Flag                                           */
      __IOM uint32 LSERDYF    : 1;            /*!< [1..1] LSE ready Interrupt Flag                                           */
      __IOM uint32 HSIRDYF    : 1;            /*!< [2..2] HSI ready Interrupt Flag                                           */
      __IOM uint32 HSERDYF    : 1;            /*!< [3..3] HSE ready Interrupt Flag                                           */
      __IOM uint32 CSIRDY     : 1;            /*!< [4..4] CSI ready Interrupt Flag                                           */
      __IOM uint32 RC48RDYF   : 1;            /*!< [5..5] RC48 ready Interrupt Flag                                          */
      __IOM uint32 PLL1RDYF   : 1;            /*!< [6..6] PLL1 ready Interrupt Flag                                          */
      __IOM uint32 PLL2RDYF   : 1;            /*!< [7..7] PLL2 ready Interrupt Flag                                          */
      __IOM uint32 PLL3RDYF   : 1;            /*!< [8..8] PLL3 ready Interrupt Flag                                          */
      __IOM uint32 LSECSSF    : 1;            /*!< [9..9] LSE clock security system Interrupt Flag                           */
      __IOM uint32 HSECSSF    : 1;            /*!< [10..10] HSE clock security system Interrupt Flag                         */
            uint32            : 21;
    } bit;
  } CIFR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000068) RCC Clock Source Interrupt Clear Register                  */
    
    struct {
      __IOM uint32 LSIRDYC    : 1;            /*!< [0..0] LSI ready Interrupt Clear                                          */
      __IOM uint32 LSERDYC    : 1;            /*!< [1..1] LSE ready Interrupt Clear                                          */
      __IOM uint32 HSIRDYC    : 1;            /*!< [2..2] HSI ready Interrupt Clear                                          */
      __IOM uint32 HSERDYC    : 1;            /*!< [3..3] HSE ready Interrupt Clear                                          */
      __IOM uint32 HSE_ready_Interrupt_Clear : 1;/*!< [4..4] CSI ready Interrupt Clear                                       */
      __IOM uint32 RC48RDYC   : 1;            /*!< [5..5] RC48 ready Interrupt Clear                                         */
      __IOM uint32 PLL1RDYC   : 1;            /*!< [6..6] PLL1 ready Interrupt Clear                                         */
      __IOM uint32 PLL2RDYC   : 1;            /*!< [7..7] PLL2 ready Interrupt Clear                                         */
      __IOM uint32 PLL3RDYC   : 1;            /*!< [8..8] PLL3 ready Interrupt Clear                                         */
      __IOM uint32 LSECSSC    : 1;            /*!< [9..9] LSE clock security system Interrupt Clear                          */
      __IOM uint32 HSECSSC    : 1;            /*!< [10..10] HSE clock security system Interrupt Clear                        */
            uint32            : 21;
    } bit;
  } CICR;
  __IM  uint32  RESERVED5;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000070) RCC Backup Domain Control Register                         */
    
    struct {
      __IOM uint32 LSEON      : 1;            /*!< [0..0] LSE oscillator enabled                                             */
      __IOM uint32 LSERDY     : 1;            /*!< [1..1] LSE oscillator ready                                               */
      __IOM uint32 LSEBYP     : 1;            /*!< [2..2] LSE oscillator bypass                                              */
      __IOM uint32 LSEDRV     : 2;            /*!< [4..3] LSE oscillator driving capability                                  */
      __IOM uint32 LSECSSON   : 1;            /*!< [5..5] LSE clock security system enable                                   */
      __IOM uint32 LSECSSD    : 1;            /*!< [6..6] LSE clock security system failure detection                        */
            uint32            : 1;
      __IOM uint32 RTCSRC     : 2;            /*!< [9..8] RTC clock source selection                                         */
            uint32            : 5;
      __IOM uint32 RTCEN      : 1;            /*!< [15..15] RTC clock enable                                                 */
      __IOM uint32 VSWRST     : 1;            /*!< [16..16] VSwitch domain software reset                                    */
            uint32            : 15;
    } bit;
  } BDCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000074) RCC Clock Control and Status Register                      */
    
    struct {
      __IOM uint32 LSION      : 1;            /*!< [0..0] LSI oscillator enable                                              */
      __IOM uint32 LSIRDY     : 1;            /*!< [1..1] LSI oscillator ready                                               */
            uint32            : 30;
    } bit;
  } CSR;
  __IM  uint32  RESERVED6;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000007C) RCC AHB3 Reset Register                                    */
    
    struct {
      __IOM uint32 MDMARST    : 1;            /*!< [0..0] MDMA block reset                                                   */
            uint32            : 3;
      __IOM uint32 DMA2DRST   : 1;            /*!< [4..4] DMA2D block reset                                                  */
      __IOM uint32 JPGDECRST  : 1;            /*!< [5..5] JPGDEC block reset                                                 */
            uint32            : 6;
      __IOM uint32 FMCRST     : 1;            /*!< [12..12] FMC block reset                                                  */
            uint32            : 1;
      __IOM uint32 QSPIRST    : 1;            /*!< [14..14] QUADSPI and QUADSPI delay block reset                            */
            uint32            : 1;
      __IOM uint32 SDMMC1RST  : 1;            /*!< [16..16] SDMMC1 and SDMMC1 delay block reset                              */
            uint32            : 14;
      __IOM uint32 CPURST     : 1;            /*!< [31..31] CPU reset                                                        */
    } bit;
  } AHB3RSTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000080) RCC AHB1 Peripheral Reset Register                         */
    
    struct {
      __IOM uint32 DMA1RST    : 1;            /*!< [0..0] DMA1 block reset                                                   */
      __IOM uint32 DMA2RST    : 1;            /*!< [1..1] DMA2 block reset                                                   */
            uint32            : 3;
      __IOM uint32 ADC12RST   : 1;            /*!< [5..5] ADC1&2 block reset                                                 */
            uint32            : 9;
      __IOM uint32 ETH1MACRST : 1;            /*!< [15..15] ETH1MAC block reset                                              */
            uint32            : 9;
      __IOM uint32 USB1OTGRST : 1;            /*!< [25..25] USB1OTG block reset                                              */
            uint32            : 1;
      __IOM uint32 USB2OTGRST : 1;            /*!< [27..27] USB2OTG block reset                                              */
            uint32            : 4;
    } bit;
  } AHB1RSTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000084) RCC AHB2 Peripheral Reset Register                         */
    
    struct {
      __IOM uint32 CAMITFRST  : 1;            /*!< [0..0] CAMITF block reset                                                 */
            uint32            : 3;
      __IOM uint32 CRYPTRST   : 1;            /*!< [4..4] Cryptography block reset                                           */
      __IOM uint32 HASHRST    : 1;            /*!< [5..5] Hash block reset                                                   */
      __IOM uint32 RNGRST     : 1;            /*!< [6..6] Random Number Generator block reset                                */
            uint32            : 2;
      __IOM uint32 SDMMC2RST  : 1;            /*!< [9..9] SDMMC2 and SDMMC2 Delay block reset                                */
            uint32            : 22;
    } bit;
  } AHB2RSTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000088) RCC AHB4 Peripheral Reset Register                         */
    
    struct {
      __IOM uint32 GPIOARST   : 1;            /*!< [0..0] GPIO block reset                                                   */
      __IOM uint32 GPIOBRST   : 1;            /*!< [1..1] GPIO block reset                                                   */
      __IOM uint32 GPIOCRST   : 1;            /*!< [2..2] GPIO block reset                                                   */
      __IOM uint32 GPIODRST   : 1;            /*!< [3..3] GPIO block reset                                                   */
      __IOM uint32 GPIOERST   : 1;            /*!< [4..4] GPIO block reset                                                   */
      __IOM uint32 GPIOFRST   : 1;            /*!< [5..5] GPIO block reset                                                   */
      __IOM uint32 GPIOGRST   : 1;            /*!< [6..6] GPIO block reset                                                   */
      __IOM uint32 GPIOHRST   : 1;            /*!< [7..7] GPIO block reset                                                   */
      __IOM uint32 GPIOIRST   : 1;            /*!< [8..8] GPIO block reset                                                   */
      __IOM uint32 GPIOJRST   : 1;            /*!< [9..9] GPIO block reset                                                   */
      __IOM uint32 GPIOKRST   : 1;            /*!< [10..10] GPIO block reset                                                 */
            uint32            : 8;
      __IOM uint32 CRCRST     : 1;            /*!< [19..19] CRC block reset                                                  */
            uint32            : 1;
      __IOM uint32 BDMARST    : 1;            /*!< [21..21] BDMA block reset                                                 */
            uint32            : 2;
      __IOM uint32 ADC3RST    : 1;            /*!< [24..24] ADC3 block reset                                                 */
      __IOM uint32 HSEMRST    : 1;            /*!< [25..25] HSEM block reset                                                 */
            uint32            : 6;
    } bit;
  } AHB4RSTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000008C) RCC APB3 Peripheral Reset Register                         */
    
    struct {
            uint32            : 3;
      __IOM uint32 LTDCRST    : 1;            /*!< [3..3] LTDC block reset                                                   */
            uint32            : 28;
    } bit;
  } APB3RSTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000090) RCC APB1 Peripheral Reset Register                         */
    
    struct {
      __IOM uint32 TIM2RST    : 1;            /*!< [0..0] TIM block reset                                                    */
      __IOM uint32 TIM3RST    : 1;            /*!< [1..1] TIM block reset                                                    */
      __IOM uint32 TIM4RST    : 1;            /*!< [2..2] TIM block reset                                                    */
      __IOM uint32 TIM5RST    : 1;            /*!< [3..3] TIM block reset                                                    */
      __IOM uint32 TIM6RST    : 1;            /*!< [4..4] TIM block reset                                                    */
      __IOM uint32 TIM7RST    : 1;            /*!< [5..5] TIM block reset                                                    */
      __IOM uint32 TIM12RST   : 1;            /*!< [6..6] TIM block reset                                                    */
      __IOM uint32 TIM13RST   : 1;            /*!< [7..7] TIM block reset                                                    */
      __IOM uint32 TIM14RST   : 1;            /*!< [8..8] TIM block reset                                                    */
      __IOM uint32 LPTIM1RST  : 1;            /*!< [9..9] TIM block reset                                                    */
            uint32            : 4;
      __IOM uint32 SPI2RST    : 1;            /*!< [14..14] SPI2 block reset                                                 */
      __IOM uint32 SPI3RST    : 1;            /*!< [15..15] SPI3 block reset                                                 */
      __IOM uint32 SPDIFRXRST : 1;            /*!< [16..16] SPDIFRX block reset                                              */
      __IOM uint32 USART2RST  : 1;            /*!< [17..17] USART2 block reset                                               */
      __IOM uint32 USART3RST  : 1;            /*!< [18..18] USART3 block reset                                               */
      __IOM uint32 UART4RST   : 1;            /*!< [19..19] UART4 block reset                                                */
      __IOM uint32 UART5RST   : 1;            /*!< [20..20] UART5 block reset                                                */
      __IOM uint32 I2C1RST    : 1;            /*!< [21..21] I2C1 block reset                                                 */
      __IOM uint32 I2C2RST    : 1;            /*!< [22..22] I2C2 block reset                                                 */
      __IOM uint32 I2C3RST    : 1;            /*!< [23..23] I2C3 block reset                                                 */
            uint32            : 3;
      __IOM uint32 HDMICECRST : 1;            /*!< [27..27] HDMI-CEC block reset                                             */
            uint32            : 1;
      __IOM uint32 DAC12RST   : 1;            /*!< [29..29] DAC1 and 2 Blocks Reset                                          */
      __IOM uint32 USART7RST  : 1;            /*!< [30..30] USART7 block reset                                               */
      __IOM uint32 USART8RST  : 1;            /*!< [31..31] USART8 block reset                                               */
    } bit;
  } APB1LRSTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000094) RCC APB1 Peripheral Reset Register                         */
    
    struct {
            uint32            : 1;
      __IOM uint32 CRSRST     : 1;            /*!< [1..1] Clock Recovery System reset                                        */
      __IOM uint32 SWPRST     : 1;            /*!< [2..2] SWPMI block reset                                                  */
            uint32            : 1;
      __IOM uint32 OPAMPRST   : 1;            /*!< [4..4] OPAMP block reset                                                  */
      __IOM uint32 MDIOSRST   : 1;            /*!< [5..5] MDIOS block reset                                                  */
            uint32            : 2;
      __IOM uint32 FDCANRST   : 1;            /*!< [8..8] FDCAN block reset                                                  */
            uint32            : 23;
    } bit;
  } APB1HRSTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000098) RCC APB2 Peripheral Reset Register                         */
    
    struct {
      __IOM uint32 TIM1RST    : 1;            /*!< [0..0] TIM1 block reset                                                   */
      __IOM uint32 TIM8RST    : 1;            /*!< [1..1] TIM8 block reset                                                   */
            uint32            : 2;
      __IOM uint32 USART1RST  : 1;            /*!< [4..4] USART1 block reset                                                 */
      __IOM uint32 USART6RST  : 1;            /*!< [5..5] USART6 block reset                                                 */
            uint32            : 6;
      __IOM uint32 SPI1RST    : 1;            /*!< [12..12] SPI1 block reset                                                 */
      __IOM uint32 SPI4RST    : 1;            /*!< [13..13] SPI4 block reset                                                 */
            uint32            : 2;
      __IOM uint32 TIM15RST   : 1;            /*!< [16..16] TIM15 block reset                                                */
      __IOM uint32 TIM16RST   : 1;            /*!< [17..17] TIM16 block reset                                                */
      __IOM uint32 TIM17RST   : 1;            /*!< [18..18] TIM17 block reset                                                */
            uint32            : 1;
      __IOM uint32 SPI5RST    : 1;            /*!< [20..20] SPI5 block reset                                                 */
            uint32            : 1;
      __IOM uint32 SAI1RST    : 1;            /*!< [22..22] SAI1 block reset                                                 */
      __IOM uint32 SAI2RST    : 1;            /*!< [23..23] SAI2 block reset                                                 */
      __IOM uint32 SAI3RST    : 1;            /*!< [24..24] SAI3 block reset                                                 */
            uint32            : 3;
      __IOM uint32 DFSDM1RST  : 1;            /*!< [28..28] DFSDM1 block reset                                               */
      __IOM uint32 HRTIMRST   : 1;            /*!< [29..29] HRTIM block reset                                                */
            uint32            : 2;
    } bit;
  } APB2RSTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000009C) RCC APB4 Peripheral Reset Register                         */
    
    struct {
            uint32            : 1;
      __IOM uint32 SYSCFGRST  : 1;            /*!< [1..1] SYSCFG block reset                                                 */
            uint32            : 1;
      __IOM uint32 LPUART1RST : 1;            /*!< [3..3] LPUART1 block reset                                                */
            uint32            : 1;
      __IOM uint32 SPI6RST    : 1;            /*!< [5..5] SPI6 block reset                                                   */
            uint32            : 1;
      __IOM uint32 I2C4RST    : 1;            /*!< [7..7] I2C4 block reset                                                   */
            uint32            : 1;
      __IOM uint32 LPTIM2RST  : 1;            /*!< [9..9] LPTIM2 block reset                                                 */
      __IOM uint32 LPTIM3RST  : 1;            /*!< [10..10] LPTIM3 block reset                                               */
      __IOM uint32 LPTIM4RST  : 1;            /*!< [11..11] LPTIM4 block reset                                               */
      __IOM uint32 LPTIM5RST  : 1;            /*!< [12..12] LPTIM5 block reset                                               */
            uint32            : 1;
      __IOM uint32 COMP12RST  : 1;            /*!< [14..14] COMP12 Blocks Reset                                              */
      __IOM uint32 VREFRST    : 1;            /*!< [15..15] VREF block reset                                                 */
            uint32            : 5;
      __IOM uint32 SAI4RST    : 1;            /*!< [21..21] SAI4 block reset                                                 */
            uint32            : 10;
    } bit;
  } APB4RSTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000A0) RCC Global Control Register                                */
    
    struct {
      __IOM uint32 WW1RSC     : 1;            /*!< [0..0] WWDG1 reset scope control                                          */
            uint32            : 31;
    } bit;
  } GCR;
  __IM  uint32  RESERVED7;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000A8) RCC D3 Autonomous mode Register                            */
    
    struct {
      __IOM uint32 BDMAAMEN   : 1;            /*!< [0..0] BDMA and DMAMUX Autonomous mode enable                             */
            uint32            : 2;
      __IOM uint32 LPUART1AMEN : 1;           /*!< [3..3] LPUART1 Autonomous mode enable                                     */
            uint32            : 1;
      __IOM uint32 SPI6AMEN   : 1;            /*!< [5..5] SPI6 Autonomous mode enable                                        */
            uint32            : 1;
      __IOM uint32 I2C4AMEN   : 1;            /*!< [7..7] I2C4 Autonomous mode enable                                        */
            uint32            : 1;
      __IOM uint32 LPTIM2AMEN : 1;            /*!< [9..9] LPTIM2 Autonomous mode enable                                      */
      __IOM uint32 LPTIM3AMEN : 1;            /*!< [10..10] LPTIM3 Autonomous mode enable                                    */
      __IOM uint32 LPTIM4AMEN : 1;            /*!< [11..11] LPTIM4 Autonomous mode enable                                    */
      __IOM uint32 LPTIM5AMEN : 1;            /*!< [12..12] LPTIM5 Autonomous mode enable                                    */
            uint32            : 1;
      __IOM uint32 COMP12AMEN : 1;            /*!< [14..14] COMP12 Autonomous mode enable                                    */
      __IOM uint32 VREFAMEN   : 1;            /*!< [15..15] VREF Autonomous mode enable                                      */
      __IOM uint32 RTCAMEN    : 1;            /*!< [16..16] RTC Autonomous mode enable                                       */
            uint32            : 2;
      __IOM uint32 CRCAMEN    : 1;            /*!< [19..19] CRC Autonomous mode enable                                       */
            uint32            : 1;
      __IOM uint32 SAI4AMEN   : 1;            /*!< [21..21] SAI4 Autonomous mode enable                                      */
            uint32            : 2;
      __IOM uint32 ADC3AMEN   : 1;            /*!< [24..24] ADC3 Autonomous mode enable                                      */
            uint32            : 3;
      __IOM uint32 BKPSRAMAMEN : 1;           /*!< [28..28] Backup RAM Autonomous mode enable                                */
      __IOM uint32 SRAM4AMEN  : 1;            /*!< [29..29] SRAM4 Autonomous mode enable                                     */
            uint32            : 2;
    } bit;
  } D3AMR;
  __IM  uint32  RESERVED8[9];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000D0) RCC Reset Status Register                                  */
    
    struct {
            uint32            : 16;
      __IOM uint32 RMVF       : 1;            /*!< [16..16] Remove reset flag                                                */
      __IOM uint32 CPURSTF    : 1;            /*!< [17..17] CPU reset flag                                                   */
            uint32            : 1;
      __IOM uint32 D1RSTF     : 1;            /*!< [19..19] D1 domain power switch reset flag                                */
      __IOM uint32 D2RSTF     : 1;            /*!< [20..20] D2 domain power switch reset flag                                */
      __IOM uint32 BORRSTF    : 1;            /*!< [21..21] BOR reset flag                                                   */
      __IOM uint32 PINRSTF    : 1;            /*!< [22..22] Pin reset flag (NRST)                                            */
      __IOM uint32 PORRSTF    : 1;            /*!< [23..23] POR/PDR reset flag                                               */
      __IOM uint32 SFTRSTF    : 1;            /*!< [24..24] System reset from CPU reset flag                                 */
            uint32            : 1;
      __IOM uint32 IWDG1RSTF  : 1;            /*!< [26..26] Independent Watchdog reset flag                                  */
            uint32            : 1;
      __IOM uint32 WWDG1RSTF  : 1;            /*!< [28..28] Window Watchdog reset flag                                       */
            uint32            : 1;
      __IOM uint32 LPWRRSTF   : 1;            /*!< [30..30] Reset due to illegal D1 DStandby or CPU CStop flag               */
            uint32            : 1;
    } bit;
  } RSR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000D4) RCC AHB3 Clock Register                                    */
    
    struct {
      __IOM uint32 MDMAEN     : 1;            /*!< [0..0] MDMA Peripheral Clock Enable                                       */
            uint32            : 3;
      __IOM uint32 DMA2DEN    : 1;            /*!< [4..4] DMA2D Peripheral Clock Enable                                      */
      __IOM uint32 JPGDECEN   : 1;            /*!< [5..5] JPGDEC Peripheral Clock Enable                                     */
            uint32            : 6;
      __IOM uint32 FMCEN      : 1;            /*!< [12..12] FMC Peripheral Clocks Enable                                     */
            uint32            : 1;
      __IOM uint32 QSPIEN     : 1;            /*!< [14..14] QUADSPI and QUADSPI Delay Clock Enable                           */
            uint32            : 1;
      __IOM uint32 SDMMC1EN   : 1;            /*!< [16..16] SDMMC1 and SDMMC1 Delay Clock Enable                             */
            uint32            : 15;
    } bit;
  } AHB3ENR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000D8) RCC AHB1 Clock Register                                    */
    
    struct {
      __IOM uint32 DMA1EN     : 1;            /*!< [0..0] DMA1 Clock Enable                                                  */
      __IOM uint32 DMA2EN     : 1;            /*!< [1..1] DMA2 Clock Enable                                                  */
            uint32            : 3;
      __IOM uint32 ADC12EN    : 1;            /*!< [5..5] ADC1/2 Peripheral Clocks Enable                                    */
            uint32            : 9;
      __IOM uint32 ETH1MACEN  : 1;            /*!< [15..15] Ethernet MAC bus interface Clock Enable                          */
      __IOM uint32 ETH1TXEN   : 1;            /*!< [16..16] Ethernet Transmission Clock Enable                               */
      __IOM uint32 ETH1RXEN   : 1;            /*!< [17..17] Ethernet Reception Clock Enable                                  */
            uint32            : 7;
      __IOM uint32 USB1OTGEN  : 1;            /*!< [25..25] USB1OTG Peripheral Clocks Enable                                 */
      __IOM uint32 USB1ULPIEN : 1;            /*!< [26..26] USB_PHY1 Clocks Enable                                           */
      __IOM uint32 USB2OTGEN  : 1;            /*!< [27..27] USB2OTG Peripheral Clocks Enable                                 */
      __IOM uint32 USB2ULPIEN : 1;            /*!< [28..28] USB_PHY2 Clocks Enable                                           */
            uint32            : 3;
    } bit;
  } AHB1ENR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000DC) RCC AHB2 Clock Register                                    */
    
    struct {
      __IOM uint32 CAMITFEN   : 1;            /*!< [0..0] CAMITF peripheral clock enable                                     */
            uint32            : 3;
      __IOM uint32 CRYPTEN    : 1;            /*!< [4..4] CRYPT peripheral clock enable                                      */
      __IOM uint32 HASHEN     : 1;            /*!< [5..5] HASH peripheral clock enable                                       */
      __IOM uint32 RNGEN      : 1;            /*!< [6..6] RNG peripheral clocks enable                                       */
            uint32            : 2;
      __IOM uint32 SDMMC2EN   : 1;            /*!< [9..9] SDMMC2 and SDMMC2 delay clock enable                               */
            uint32            : 19;
      __IOM uint32 SRAM1EN    : 1;            /*!< [29..29] SRAM1 block enable                                               */
      __IOM uint32 SRAM2EN    : 1;            /*!< [30..30] SRAM2 block enable                                               */
      __IOM uint32 SRAM3EN    : 1;            /*!< [31..31] SRAM3 block enable                                               */
    } bit;
  } AHB2ENR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000E0) RCC AHB4 Clock Register                                    */
    
    struct {
      __IOM uint32 GPIOAEN    : 1;            /*!< [0..0] 0GPIO peripheral clock enable                                      */
      __IOM uint32 GPIOBEN    : 1;            /*!< [1..1] 0GPIO peripheral clock enable                                      */
      __IOM uint32 GPIOCEN    : 1;            /*!< [2..2] 0GPIO peripheral clock enable                                      */
      __IOM uint32 GPIODEN    : 1;            /*!< [3..3] 0GPIO peripheral clock enable                                      */
      __IOM uint32 GPIOEEN    : 1;            /*!< [4..4] 0GPIO peripheral clock enable                                      */
      __IOM uint32 GPIOFEN    : 1;            /*!< [5..5] 0GPIO peripheral clock enable                                      */
      __IOM uint32 GPIOGEN    : 1;            /*!< [6..6] 0GPIO peripheral clock enable                                      */
      __IOM uint32 GPIOHEN    : 1;            /*!< [7..7] 0GPIO peripheral clock enable                                      */
      __IOM uint32 GPIOIEN    : 1;            /*!< [8..8] 0GPIO peripheral clock enable                                      */
      __IOM uint32 GPIOJEN    : 1;            /*!< [9..9] 0GPIO peripheral clock enable                                      */
      __IOM uint32 GPIOKEN    : 1;            /*!< [10..10] 0GPIO peripheral clock enable                                    */
            uint32            : 8;
      __IOM uint32 CRCEN      : 1;            /*!< [19..19] CRC peripheral clock enable                                      */
            uint32            : 1;
      __IOM uint32 BDMAEN     : 1;            /*!< [21..21] BDMA and DMAMUX2 Clock Enable                                    */
            uint32            : 2;
      __IOM uint32 ADC3EN     : 1;            /*!< [24..24] ADC3 Peripheral Clocks Enable                                    */
      __IOM uint32 HSEMEN     : 1;            /*!< [25..25] HSEM peripheral clock enable                                     */
            uint32            : 2;
      __IOM uint32 BKPRAMEN   : 1;            /*!< [28..28] Backup RAM Clock Enable                                          */
            uint32            : 3;
    } bit;
  } AHB4ENR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000E4) RCC APB3 Clock Register                                    */
    
    struct {
            uint32            : 3;
      __IOM uint32 LTDCEN     : 1;            /*!< [3..3] LTDC peripheral clock enable                                       */
            uint32            : 2;
      __IOM uint32 WWDG1EN    : 1;            /*!< [6..6] WWDG1 Clock Enable                                                 */
            uint32            : 25;
    } bit;
  } APB3ENR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000E8) RCC APB1 Clock Register                                    */
    
    struct {
      __IOM uint32 TIM2EN     : 1;            /*!< [0..0] TIM peripheral clock enable                                        */
      __IOM uint32 TIM3EN     : 1;            /*!< [1..1] TIM peripheral clock enable                                        */
      __IOM uint32 TIM4EN     : 1;            /*!< [2..2] TIM peripheral clock enable                                        */
      __IOM uint32 TIM5EN     : 1;            /*!< [3..3] TIM peripheral clock enable                                        */
      __IOM uint32 TIM6EN     : 1;            /*!< [4..4] TIM peripheral clock enable                                        */
      __IOM uint32 TIM7EN     : 1;            /*!< [5..5] TIM peripheral clock enable                                        */
      __IOM uint32 TIM12EN    : 1;            /*!< [6..6] TIM peripheral clock enable                                        */
      __IOM uint32 TIM13EN    : 1;            /*!< [7..7] TIM peripheral clock enable                                        */
      __IOM uint32 TIM14EN    : 1;            /*!< [8..8] TIM peripheral clock enable                                        */
      __IOM uint32 LPTIM1EN   : 1;            /*!< [9..9] LPTIM1 Peripheral Clocks Enable                                    */
            uint32            : 4;
      __IOM uint32 SPI2EN     : 1;            /*!< [14..14] SPI2 Peripheral Clocks Enable                                    */
      __IOM uint32 SPI3EN     : 1;            /*!< [15..15] SPI3 Peripheral Clocks Enable                                    */
      __IOM uint32 SPDIFRXEN  : 1;            /*!< [16..16] SPDIFRX Peripheral Clocks Enable                                 */
      __IOM uint32 USART2EN   : 1;            /*!< [17..17] USART2 Peripheral Clocks Enable                                  */
      __IOM uint32 USART3EN   : 1;            /*!< [18..18] USART3 Peripheral Clocks Enable                                  */
      __IOM uint32 UART4EN    : 1;            /*!< [19..19] UART4 Peripheral Clocks Enable                                   */
      __IOM uint32 UART5EN    : 1;            /*!< [20..20] UART5 Peripheral Clocks Enable                                   */
      __IOM uint32 I2C1EN     : 1;            /*!< [21..21] I2C1 Peripheral Clocks Enable                                    */
      __IOM uint32 I2C2EN     : 1;            /*!< [22..22] I2C2 Peripheral Clocks Enable                                    */
      __IOM uint32 I2C3EN     : 1;            /*!< [23..23] I2C3 Peripheral Clocks Enable                                    */
            uint32            : 3;
      __IOM uint32 HDMICECEN  : 1;            /*!< [27..27] HDMI-CEC peripheral clock enable                                 */
            uint32            : 1;
      __IOM uint32 DAC12EN    : 1;            /*!< [29..29] DAC1&2 peripheral clock enable                                   */
      __IOM uint32 USART7EN   : 1;            /*!< [30..30] USART7 Peripheral Clocks Enable                                  */
      __IOM uint32 USART8EN   : 1;            /*!< [31..31] USART8 Peripheral Clocks Enable                                  */
    } bit;
  } APB1LENR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000EC) RCC APB1 Clock Register                                    */
    
    struct {
            uint32            : 1;
      __IOM uint32 CRSEN      : 1;            /*!< [1..1] Clock Recovery System peripheral clock enable                      */
      __IOM uint32 SWPEN      : 1;            /*!< [2..2] SWPMI Peripheral Clocks Enable                                     */
            uint32            : 1;
      __IOM uint32 OPAMPEN    : 1;            /*!< [4..4] OPAMP peripheral clock enable                                      */
      __IOM uint32 MDIOSEN    : 1;            /*!< [5..5] MDIOS peripheral clock enable                                      */
            uint32            : 2;
      __IOM uint32 FDCANEN    : 1;            /*!< [8..8] FDCAN Peripheral Clocks Enable                                     */
            uint32            : 23;
    } bit;
  } APB1HENR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000F0) RCC APB2 Clock Register                                    */
    
    struct {
      __IOM uint32 TIM1EN     : 1;            /*!< [0..0] TIM1 peripheral clock enable                                       */
      __IOM uint32 TIM8EN     : 1;            /*!< [1..1] TIM8 peripheral clock enable                                       */
            uint32            : 2;
      __IOM uint32 USART1EN   : 1;            /*!< [4..4] USART1 Peripheral Clocks Enable                                    */
      __IOM uint32 USART6EN   : 1;            /*!< [5..5] USART6 Peripheral Clocks Enable                                    */
            uint32            : 6;
      __IOM uint32 SPI1EN     : 1;            /*!< [12..12] SPI1 Peripheral Clocks Enable                                    */
      __IOM uint32 SPI4EN     : 1;            /*!< [13..13] SPI4 Peripheral Clocks Enable                                    */
            uint32            : 2;
      __IOM uint32 TIM15EN    : 1;            /*!< [16..16] TIM15 peripheral clock enable                                    */
      __IOM uint32 TIM16EN    : 1;            /*!< [17..17] TIM16 peripheral clock enable                                    */
      __IOM uint32 TIM17EN    : 1;            /*!< [18..18] TIM17 peripheral clock enable                                    */
            uint32            : 1;
      __IOM uint32 SPI5EN     : 1;            /*!< [20..20] SPI5 Peripheral Clocks Enable                                    */
            uint32            : 1;
      __IOM uint32 SAI1EN     : 1;            /*!< [22..22] SAI1 Peripheral Clocks Enable                                    */
      __IOM uint32 SAI2EN     : 1;            /*!< [23..23] SAI2 Peripheral Clocks Enable                                    */
      __IOM uint32 SAI3EN     : 1;            /*!< [24..24] SAI3 Peripheral Clocks Enable                                    */
            uint32            : 3;
      __IOM uint32 DFSDM1EN   : 1;            /*!< [28..28] DFSDM1 Peripheral Clocks Enable                                  */
      __IOM uint32 HRTIMEN    : 1;            /*!< [29..29] HRTIM peripheral clock enable                                    */
            uint32            : 2;
    } bit;
  } APB2ENR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000F4) RCC APB4 Clock Register                                    */
    
    struct {
            uint32            : 1;
      __IOM uint32 SYSCFGEN   : 1;            /*!< [1..1] SYSCFG peripheral clock enable                                     */
            uint32            : 1;
      __IOM uint32 LPUART1EN  : 1;            /*!< [3..3] LPUART1 Peripheral Clocks Enable                                   */
            uint32            : 1;
      __IOM uint32 SPI6EN     : 1;            /*!< [5..5] SPI6 Peripheral Clocks Enable                                      */
            uint32            : 1;
      __IOM uint32 I2C4EN     : 1;            /*!< [7..7] I2C4 Peripheral Clocks Enable                                      */
            uint32            : 1;
      __IOM uint32 LPTIM2EN   : 1;            /*!< [9..9] LPTIM2 Peripheral Clocks Enable                                    */
      __IOM uint32 LPTIM3EN   : 1;            /*!< [10..10] LPTIM3 Peripheral Clocks Enable                                  */
      __IOM uint32 LPTIM4EN   : 1;            /*!< [11..11] LPTIM4 Peripheral Clocks Enable                                  */
      __IOM uint32 LPTIM5EN   : 1;            /*!< [12..12] LPTIM5 Peripheral Clocks Enable                                  */
            uint32            : 1;
      __IOM uint32 COMP12EN   : 1;            /*!< [14..14] COMP1/2 peripheral clock enable                                  */
      __IOM uint32 VREFEN     : 1;            /*!< [15..15] VREF peripheral clock enable                                     */
      __IOM uint32 RTCAPBEN   : 1;            /*!< [16..16] RTC APB Clock Enable                                             */
            uint32            : 4;
      __IOM uint32 SAI4EN     : 1;            /*!< [21..21] SAI4 Peripheral Clocks Enable                                    */
            uint32            : 10;
    } bit;
  } APB4ENR;
  __IM  uint32  RESERVED9;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000FC) RCC AHB3 Sleep Clock Register                              */
    
    struct {
      __IOM uint32 MDMALPEN   : 1;            /*!< [0..0] MDMA Clock Enable During CSleep Mode                               */
            uint32            : 3;
      __IOM uint32 DMA2DLPEN  : 1;            /*!< [4..4] DMA2D Clock Enable During CSleep Mode                              */
      __IOM uint32 JPGDECLPEN : 1;            /*!< [5..5] JPGDEC Clock Enable During CSleep Mode                             */
            uint32            : 2;
      __IOM uint32 FLITFLPEN  : 1;            /*!< [8..8] FLITF Clock Enable During CSleep Mode                              */
            uint32            : 3;
      __IOM uint32 FMCLPEN    : 1;            /*!< [12..12] FMC Peripheral Clocks Enable During CSleep Mode                  */
            uint32            : 1;
      __IOM uint32 QSPILPEN   : 1;            /*!< [14..14] QUADSPI and QUADSPI Delay Clock Enable During CSleep
                                                     Mode                                                                      */
            uint32            : 1;
      __IOM uint32 SDMMC1LPEN : 1;            /*!< [16..16] SDMMC1 and SDMMC1 Delay Clock Enable During CSleep
                                                     Mode                                                                      */
            uint32            : 11;
      __IOM uint32 D1DTCM1LPEN : 1;           /*!< [28..28] D1DTCM1 Block Clock Enable During CSleep mode                    */
      __IOM uint32 DTCM2LPEN  : 1;            /*!< [29..29] D1 DTCM2 Block Clock Enable During CSleep mode                   */
      __IOM uint32 ITCMLPEN   : 1;            /*!< [30..30] D1ITCM Block Clock Enable During CSleep mode                     */
      __IOM uint32 AXISRAMLPEN : 1;           /*!< [31..31] AXISRAM Block Clock Enable During CSleep mode                    */
    } bit;
  } AHB3LPENR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000100) RCC AHB1 Sleep Clock Register                              */
    
    struct {
      __IOM uint32 DMA1LPEN   : 1;            /*!< [0..0] DMA1 Clock Enable During CSleep Mode                               */
      __IOM uint32 DMA2LPEN   : 1;            /*!< [1..1] DMA2 Clock Enable During CSleep Mode                               */
            uint32            : 3;
      __IOM uint32 ADC12LPEN  : 1;            /*!< [5..5] ADC1/2 Peripheral Clocks Enable During CSleep Mode                 */
            uint32            : 9;
      __IOM uint32 ETH1MACLPEN : 1;           /*!< [15..15] Ethernet MAC bus interface Clock Enable During CSleep
                                                     Mode                                                                      */
      __IOM uint32 ETH1TXLPEN : 1;            /*!< [16..16] Ethernet Transmission Clock Enable During CSleep Mode            */
      __IOM uint32 ETH1RXLPEN : 1;            /*!< [17..17] Ethernet Reception Clock Enable During CSleep Mode               */
            uint32            : 7;
      __IOM uint32 USB1OTGLPEN : 1;           /*!< [25..25] USB1OTG peripheral clock enable during CSleep mode               */
      __IOM uint32 USB1ULPILPEN : 1;          /*!< [26..26] USB_PHY1 clock enable during CSleep mode                         */
      __IOM uint32 USB2OTGLPEN : 1;           /*!< [27..27] USB2OTG peripheral clock enable during CSleep mode               */
      __IOM uint32 USB2ULPILPEN : 1;          /*!< [28..28] USB_PHY2 clocks enable during CSleep mode                        */
            uint32            : 3;
    } bit;
  } AHB1LPENR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000104) RCC AHB2 Sleep Clock Register                              */
    
    struct {
      __IOM uint32 CAMITFLPEN : 1;            /*!< [0..0] CAMITF peripheral clock enable during CSleep mode                  */
            uint32            : 3;
      __IOM uint32 CRYPTLPEN  : 1;            /*!< [4..4] CRYPT peripheral clock enable during CSleep mode                   */
      __IOM uint32 HASHLPEN   : 1;            /*!< [5..5] HASH peripheral clock enable during CSleep mode                    */
      __IOM uint32 RNGLPEN    : 1;            /*!< [6..6] RNG peripheral clock enable during CSleep mode                     */
            uint32            : 2;
      __IOM uint32 SDMMC2LPEN : 1;            /*!< [9..9] SDMMC2 and SDMMC2 Delay Clock Enable During CSleep Mode            */
            uint32            : 19;
      __IOM uint32 SRAM1LPEN  : 1;            /*!< [29..29] SRAM1 Clock Enable During CSleep Mode                            */
      __IOM uint32 SRAM2LPEN  : 1;            /*!< [30..30] SRAM2 Clock Enable During CSleep Mode                            */
      __IOM uint32 SRAM3LPEN  : 1;            /*!< [31..31] SRAM3 Clock Enable During CSleep Mode                            */
    } bit;
  } AHB2LPENR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000108) RCC AHB4 Sleep Clock Register                              */
    
    struct {
      __IOM uint32 GPIOALPEN  : 1;            /*!< [0..0] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32 GPIOBLPEN  : 1;            /*!< [1..1] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32 GPIOCLPEN  : 1;            /*!< [2..2] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32 GPIODLPEN  : 1;            /*!< [3..3] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32 GPIOELPEN  : 1;            /*!< [4..4] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32 GPIOFLPEN  : 1;            /*!< [5..5] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32 GPIOGLPEN  : 1;            /*!< [6..6] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32 GPIOHLPEN  : 1;            /*!< [7..7] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32 GPIOILPEN  : 1;            /*!< [8..8] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32 GPIOJLPEN  : 1;            /*!< [9..9] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32 GPIOKLPEN  : 1;            /*!< [10..10] GPIO peripheral clock enable during CSleep mode                  */
            uint32            : 8;
      __IOM uint32 CRCLPEN    : 1;            /*!< [19..19] CRC peripheral clock enable during CSleep mode                   */
            uint32            : 1;
      __IOM uint32 BDMALPEN   : 1;            /*!< [21..21] BDMA Clock Enable During CSleep Mode                             */
            uint32            : 2;
      __IOM uint32 ADC3LPEN   : 1;            /*!< [24..24] ADC3 Peripheral Clocks Enable During CSleep Mode                 */
            uint32            : 3;
      __IOM uint32 BKPRAMLPEN : 1;            /*!< [28..28] Backup RAM Clock Enable During CSleep Mode                       */
      __IOM uint32 SRAM4LPEN  : 1;            /*!< [29..29] SRAM4 Clock Enable During CSleep Mode                            */
            uint32            : 2;
    } bit;
  } AHB4LPENR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000010C) RCC APB3 Sleep Clock Register                              */
    
    struct {
            uint32            : 3;
      __IOM uint32 LTDCLPEN   : 1;            /*!< [3..3] LTDC peripheral clock enable during CSleep mode                    */
            uint32            : 2;
      __IOM uint32 WWDG1LPEN  : 1;            /*!< [6..6] WWDG1 Clock Enable During CSleep Mode                              */
            uint32            : 25;
    } bit;
  } APB3LPENR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000110) RCC APB1 Low Sleep Clock Register                          */
    
    struct {
      __IOM uint32 TIM2LPEN   : 1;            /*!< [0..0] TIM2 peripheral clock enable during CSleep mode                    */
      __IOM uint32 TIM3LPEN   : 1;            /*!< [1..1] TIM3 peripheral clock enable during CSleep mode                    */
      __IOM uint32 TIM4LPEN   : 1;            /*!< [2..2] TIM4 peripheral clock enable during CSleep mode                    */
      __IOM uint32 TIM5LPEN   : 1;            /*!< [3..3] TIM5 peripheral clock enable during CSleep mode                    */
      __IOM uint32 TIM6LPEN   : 1;            /*!< [4..4] TIM6 peripheral clock enable during CSleep mode                    */
      __IOM uint32 TIM7LPEN   : 1;            /*!< [5..5] TIM7 peripheral clock enable during CSleep mode                    */
      __IOM uint32 TIM12LPEN  : 1;            /*!< [6..6] TIM12 peripheral clock enable during CSleep mode                   */
      __IOM uint32 TIM13LPEN  : 1;            /*!< [7..7] TIM13 peripheral clock enable during CSleep mode                   */
      __IOM uint32 TIM14LPEN  : 1;            /*!< [8..8] TIM14 peripheral clock enable during CSleep mode                   */
      __IOM uint32 LPTIM1LPEN : 1;            /*!< [9..9] LPTIM1 Peripheral Clocks Enable During CSleep Mode                 */
            uint32            : 4;
      __IOM uint32 SPI2LPEN   : 1;            /*!< [14..14] SPI2 Peripheral Clocks Enable During CSleep Mode                 */
      __IOM uint32 SPI3LPEN   : 1;            /*!< [15..15] SPI3 Peripheral Clocks Enable During CSleep Mode                 */
      __IOM uint32 SPDIFRXLPEN : 1;           /*!< [16..16] SPDIFRX Peripheral Clocks Enable During CSleep Mode              */
      __IOM uint32 USART2LPEN : 1;            /*!< [17..17] USART2 Peripheral Clocks Enable During CSleep Mode               */
      __IOM uint32 USART3LPEN : 1;            /*!< [18..18] USART3 Peripheral Clocks Enable During CSleep Mode               */
      __IOM uint32 UART4LPEN  : 1;            /*!< [19..19] UART4 Peripheral Clocks Enable During CSleep Mode                */
      __IOM uint32 UART5LPEN  : 1;            /*!< [20..20] UART5 Peripheral Clocks Enable During CSleep Mode                */
      __IOM uint32 I2C1LPEN   : 1;            /*!< [21..21] I2C1 Peripheral Clocks Enable During CSleep Mode                 */
      __IOM uint32 I2C2LPEN   : 1;            /*!< [22..22] I2C2 Peripheral Clocks Enable During CSleep Mode                 */
      __IOM uint32 I2C3LPEN   : 1;            /*!< [23..23] I2C3 Peripheral Clocks Enable During CSleep Mode                 */
            uint32            : 3;
      __IOM uint32 HDMICECLPEN : 1;           /*!< [27..27] HDMI-CEC Peripheral Clocks Enable During CSleep Mode             */
            uint32            : 1;
      __IOM uint32 DAC12LPEN  : 1;            /*!< [29..29] DAC1/2 peripheral clock enable during CSleep mode                */
      __IOM uint32 USART7LPEN : 1;            /*!< [30..30] USART7 Peripheral Clocks Enable During CSleep Mode               */
      __IOM uint32 USART8LPEN : 1;            /*!< [31..31] USART8 Peripheral Clocks Enable During CSleep Mode               */
    } bit;
  } APB1LLPENR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000114) RCC APB1 High Sleep Clock Register                         */
    
    struct {
            uint32            : 1;
      __IOM uint32 CRSLPEN    : 1;            /*!< [1..1] Clock Recovery System peripheral clock enable during
                                                     CSleep mode                                                               */
      __IOM uint32 SWPLPEN    : 1;            /*!< [2..2] SWPMI Peripheral Clocks Enable During CSleep Mode                  */
            uint32            : 1;
      __IOM uint32 OPAMPLPEN  : 1;            /*!< [4..4] OPAMP peripheral clock enable during CSleep mode                   */
      __IOM uint32 MDIOSLPEN  : 1;            /*!< [5..5] MDIOS peripheral clock enable during CSleep mode                   */
            uint32            : 2;
      __IOM uint32 FDCANLPEN  : 1;            /*!< [8..8] FDCAN Peripheral Clocks Enable During CSleep Mode                  */
            uint32            : 23;
    } bit;
  } APB1HLPENR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000118) RCC APB2 Sleep Clock Register                              */
    
    struct {
      __IOM uint32 TIM1LPEN   : 1;            /*!< [0..0] TIM1 peripheral clock enable during CSleep mode                    */
      __IOM uint32 TIM8LPEN   : 1;            /*!< [1..1] TIM8 peripheral clock enable during CSleep mode                    */
            uint32            : 2;
      __IOM uint32 USART1LPEN : 1;            /*!< [4..4] USART1 Peripheral Clocks Enable During CSleep Mode                 */
      __IOM uint32 USART6LPEN : 1;            /*!< [5..5] USART6 Peripheral Clocks Enable During CSleep Mode                 */
            uint32            : 6;
      __IOM uint32 SPI1LPEN   : 1;            /*!< [12..12] SPI1 Peripheral Clocks Enable During CSleep Mode                 */
      __IOM uint32 SPI4LPEN   : 1;            /*!< [13..13] SPI4 Peripheral Clocks Enable During CSleep Mode                 */
            uint32            : 2;
      __IOM uint32 TIM15LPEN  : 1;            /*!< [16..16] TIM15 peripheral clock enable during CSleep mode                 */
      __IOM uint32 TIM16LPEN  : 1;            /*!< [17..17] TIM16 peripheral clock enable during CSleep mode                 */
      __IOM uint32 TIM17LPEN  : 1;            /*!< [18..18] TIM17 peripheral clock enable during CSleep mode                 */
            uint32            : 1;
      __IOM uint32 SPI5LPEN   : 1;            /*!< [20..20] SPI5 Peripheral Clocks Enable During CSleep Mode                 */
            uint32            : 1;
      __IOM uint32 SAI1LPEN   : 1;            /*!< [22..22] SAI1 Peripheral Clocks Enable During CSleep Mode                 */
      __IOM uint32 SAI2LPEN   : 1;            /*!< [23..23] SAI2 Peripheral Clocks Enable During CSleep Mode                 */
      __IOM uint32 SAI3LPEN   : 1;            /*!< [24..24] SAI3 Peripheral Clocks Enable During CSleep Mode                 */
            uint32            : 3;
      __IOM uint32 DFSDM1LPEN : 1;            /*!< [28..28] DFSDM1 Peripheral Clocks Enable During CSleep Mode               */
      __IOM uint32 HRTIMLPEN  : 1;            /*!< [29..29] HRTIM peripheral clock enable during CSleep mode                 */
            uint32            : 2;
    } bit;
  } APB2LPENR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000011C) RCC APB4 Sleep Clock Register                              */
    
    struct {
            uint32            : 1;
      __IOM uint32 SYSCFGLPEN : 1;            /*!< [1..1] SYSCFG peripheral clock enable during CSleep mode                  */
            uint32            : 1;
      __IOM uint32 LPUART1LPEN : 1;           /*!< [3..3] LPUART1 Peripheral Clocks Enable During CSleep Mode                */
            uint32            : 1;
      __IOM uint32 SPI6LPEN   : 1;            /*!< [5..5] SPI6 Peripheral Clocks Enable During CSleep Mode                   */
            uint32            : 1;
      __IOM uint32 I2C4LPEN   : 1;            /*!< [7..7] I2C4 Peripheral Clocks Enable During CSleep Mode                   */
            uint32            : 1;
      __IOM uint32 LPTIM2LPEN : 1;            /*!< [9..9] LPTIM2 Peripheral Clocks Enable During CSleep Mode                 */
      __IOM uint32 LPTIM3LPEN : 1;            /*!< [10..10] LPTIM3 Peripheral Clocks Enable During CSleep Mode               */
      __IOM uint32 LPTIM4LPEN : 1;            /*!< [11..11] LPTIM4 Peripheral Clocks Enable During CSleep Mode               */
      __IOM uint32 LPTIM5LPEN : 1;            /*!< [12..12] LPTIM5 Peripheral Clocks Enable During CSleep Mode               */
            uint32            : 1;
      __IOM uint32 COMP12LPEN : 1;            /*!< [14..14] COMP1/2 peripheral clock enable during CSleep mode               */
      __IOM uint32 VREFLPEN   : 1;            /*!< [15..15] VREF peripheral clock enable during CSleep mode                  */
      __IOM uint32 RTCAPBLPEN : 1;            /*!< [16..16] RTC APB Clock Enable During CSleep Mode                          */
            uint32            : 4;
      __IOM uint32 SAI4LPEN   : 1;            /*!< [21..21] SAI4 Peripheral Clocks Enable During CSleep Mode                 */
            uint32            : 10;
    } bit;
  } APB4LPENR;
  __IM  uint32  RESERVED10[4];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000130) RCC Reset Status Register                                  */
    
    struct {
            uint32            : 16;
      __IOM uint32 RMVF       : 1;            /*!< [16..16] Remove reset flag                                                */
      __IOM uint32 CPURSTF    : 1;            /*!< [17..17] CPU reset flag                                                   */
            uint32            : 1;
      __IOM uint32 D1RSTF     : 1;            /*!< [19..19] D1 domain power switch reset flag                                */
      __IOM uint32 D2RSTF     : 1;            /*!< [20..20] D2 domain power switch reset flag                                */
      __IOM uint32 BORRSTF    : 1;            /*!< [21..21] BOR reset flag                                                   */
      __IOM uint32 PINRSTF    : 1;            /*!< [22..22] Pin reset flag (NRST)                                            */
      __IOM uint32 PORRSTF    : 1;            /*!< [23..23] POR/PDR reset flag                                               */
      __IOM uint32 SFTRSTF    : 1;            /*!< [24..24] System reset from CPU reset flag                                 */
            uint32            : 1;
      __IOM uint32 IWDG1RSTF  : 1;            /*!< [26..26] Independent Watchdog reset flag                                  */
            uint32            : 1;
      __IOM uint32 WWDG1RSTF  : 1;            /*!< [28..28] Window Watchdog reset flag                                       */
            uint32            : 1;
      __IOM uint32 LPWRRSTF   : 1;            /*!< [30..30] Reset due to illegal D1 DStandby or CPU CStop flag               */
            uint32            : 1;
    } bit;
  } C1_RSR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000134) RCC AHB3 Clock Register                                    */
    
    struct {
      __IOM uint32 MDMAEN     : 1;            /*!< [0..0] MDMA Peripheral Clock Enable                                       */
            uint32            : 3;
      __IOM uint32 DMA2DEN    : 1;            /*!< [4..4] DMA2D Peripheral Clock Enable                                      */
      __IOM uint32 JPGDECEN   : 1;            /*!< [5..5] JPGDEC Peripheral Clock Enable                                     */
            uint32            : 6;
      __IOM uint32 FMCEN      : 1;            /*!< [12..12] FMC Peripheral Clocks Enable                                     */
            uint32            : 1;
      __IOM uint32 QSPIEN     : 1;            /*!< [14..14] QUADSPI and QUADSPI Delay Clock Enable                           */
            uint32            : 1;
      __IOM uint32 SDMMC1EN   : 1;            /*!< [16..16] SDMMC1 and SDMMC1 Delay Clock Enable                             */
            uint32            : 15;
    } bit;
  } C1_AHB3ENR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000138) RCC AHB1 Clock Register                                    */
    
    struct {
      __IOM uint32 DMA1EN     : 1;            /*!< [0..0] DMA1 Clock Enable                                                  */
      __IOM uint32 DMA2EN     : 1;            /*!< [1..1] DMA2 Clock Enable                                                  */
            uint32            : 3;
      __IOM uint32 ADC12EN    : 1;            /*!< [5..5] ADC1/2 Peripheral Clocks Enable                                    */
            uint32            : 9;
      __IOM uint32 ETH1MACEN  : 1;            /*!< [15..15] Ethernet MAC bus interface Clock Enable                          */
      __IOM uint32 ETH1TXEN   : 1;            /*!< [16..16] Ethernet Transmission Clock Enable                               */
      __IOM uint32 ETH1RXEN   : 1;            /*!< [17..17] Ethernet Reception Clock Enable                                  */
            uint32            : 7;
      __IOM uint32 USB1OTGEN  : 1;            /*!< [25..25] USB1OTG Peripheral Clocks Enable                                 */
      __IOM uint32 USB1ULPIEN : 1;            /*!< [26..26] USB_PHY1 Clocks Enable                                           */
      __IOM uint32 USB2OTGEN  : 1;            /*!< [27..27] USB2OTG Peripheral Clocks Enable                                 */
      __IOM uint32 USB2ULPIEN : 1;            /*!< [28..28] USB_PHY2 Clocks Enable                                           */
            uint32            : 3;
    } bit;
  } C1_AHB1ENR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000013C) RCC AHB2 Clock Register                                    */
    
    struct {
      __IOM uint32 CAMITFEN   : 1;            /*!< [0..0] CAMITF peripheral clock enable                                     */
            uint32            : 3;
      __IOM uint32 CRYPTEN    : 1;            /*!< [4..4] CRYPT peripheral clock enable                                      */
      __IOM uint32 HASHEN     : 1;            /*!< [5..5] HASH peripheral clock enable                                       */
      __IOM uint32 RNGEN      : 1;            /*!< [6..6] RNG peripheral clocks enable                                       */
            uint32            : 2;
      __IOM uint32 SDMMC2EN   : 1;            /*!< [9..9] SDMMC2 and SDMMC2 delay clock enable                               */
            uint32            : 19;
      __IOM uint32 SRAM1EN    : 1;            /*!< [29..29] SRAM1 block enable                                               */
      __IOM uint32 SRAM2EN    : 1;            /*!< [30..30] SRAM2 block enable                                               */
      __IOM uint32 SRAM3EN    : 1;            /*!< [31..31] SRAM3 block enable                                               */
    } bit;
  } C1_AHB2ENR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000140) RCC AHB4 Clock Register                                    */
    
    struct {
      __IOM uint32 GPIOAEN    : 1;            /*!< [0..0] 0GPIO peripheral clock enable                                      */
      __IOM uint32 GPIOBEN    : 1;            /*!< [1..1] 0GPIO peripheral clock enable                                      */
      __IOM uint32 GPIOCEN    : 1;            /*!< [2..2] 0GPIO peripheral clock enable                                      */
      __IOM uint32 GPIODEN    : 1;            /*!< [3..3] 0GPIO peripheral clock enable                                      */
      __IOM uint32 GPIOEEN    : 1;            /*!< [4..4] 0GPIO peripheral clock enable                                      */
      __IOM uint32 GPIOFEN    : 1;            /*!< [5..5] 0GPIO peripheral clock enable                                      */
      __IOM uint32 GPIOGEN    : 1;            /*!< [6..6] 0GPIO peripheral clock enable                                      */
      __IOM uint32 GPIOHEN    : 1;            /*!< [7..7] 0GPIO peripheral clock enable                                      */
      __IOM uint32 GPIOIEN    : 1;            /*!< [8..8] 0GPIO peripheral clock enable                                      */
      __IOM uint32 GPIOJEN    : 1;            /*!< [9..9] 0GPIO peripheral clock enable                                      */
      __IOM uint32 GPIOKEN    : 1;            /*!< [10..10] 0GPIO peripheral clock enable                                    */
            uint32            : 8;
      __IOM uint32 CRCEN      : 1;            /*!< [19..19] CRC peripheral clock enable                                      */
            uint32            : 1;
      __IOM uint32 BDMAEN     : 1;            /*!< [21..21] BDMA and DMAMUX2 Clock Enable                                    */
            uint32            : 2;
      __IOM uint32 ADC3EN     : 1;            /*!< [24..24] ADC3 Peripheral Clocks Enable                                    */
      __IOM uint32 HSEMEN     : 1;            /*!< [25..25] HSEM peripheral clock enable                                     */
            uint32            : 2;
      __IOM uint32 BKPRAMEN   : 1;            /*!< [28..28] Backup RAM Clock Enable                                          */
            uint32            : 3;
    } bit;
  } C1_AHB4ENR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000144) RCC APB3 Clock Register                                    */
    
    struct {
            uint32            : 3;
      __IOM uint32 LTDCEN     : 1;            /*!< [3..3] LTDC peripheral clock enable                                       */
            uint32            : 2;
      __IOM uint32 WWDG1EN    : 1;            /*!< [6..6] WWDG1 Clock Enable                                                 */
            uint32            : 25;
    } bit;
  } C1_APB3ENR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000148) RCC APB1 Clock Register                                    */
    
    struct {
      __IOM uint32 TIM2EN     : 1;            /*!< [0..0] TIM peripheral clock enable                                        */
      __IOM uint32 TIM3EN     : 1;            /*!< [1..1] TIM peripheral clock enable                                        */
      __IOM uint32 TIM4EN     : 1;            /*!< [2..2] TIM peripheral clock enable                                        */
      __IOM uint32 TIM5EN     : 1;            /*!< [3..3] TIM peripheral clock enable                                        */
      __IOM uint32 TIM6EN     : 1;            /*!< [4..4] TIM peripheral clock enable                                        */
      __IOM uint32 TIM7EN     : 1;            /*!< [5..5] TIM peripheral clock enable                                        */
      __IOM uint32 TIM12EN    : 1;            /*!< [6..6] TIM peripheral clock enable                                        */
      __IOM uint32 TIM13EN    : 1;            /*!< [7..7] TIM peripheral clock enable                                        */
      __IOM uint32 TIM14EN    : 1;            /*!< [8..8] TIM peripheral clock enable                                        */
      __IOM uint32 LPTIM1EN   : 1;            /*!< [9..9] LPTIM1 Peripheral Clocks Enable                                    */
            uint32            : 4;
      __IOM uint32 SPI2EN     : 1;            /*!< [14..14] SPI2 Peripheral Clocks Enable                                    */
      __IOM uint32 SPI3EN     : 1;            /*!< [15..15] SPI3 Peripheral Clocks Enable                                    */
      __IOM uint32 SPDIFRXEN  : 1;            /*!< [16..16] SPDIFRX Peripheral Clocks Enable                                 */
      __IOM uint32 USART2EN   : 1;            /*!< [17..17] USART2 Peripheral Clocks Enable                                  */
      __IOM uint32 USART3EN   : 1;            /*!< [18..18] USART3 Peripheral Clocks Enable                                  */
      __IOM uint32 UART4EN    : 1;            /*!< [19..19] UART4 Peripheral Clocks Enable                                   */
      __IOM uint32 UART5EN    : 1;            /*!< [20..20] UART5 Peripheral Clocks Enable                                   */
      __IOM uint32 I2C1EN     : 1;            /*!< [21..21] I2C1 Peripheral Clocks Enable                                    */
      __IOM uint32 I2C2EN     : 1;            /*!< [22..22] I2C2 Peripheral Clocks Enable                                    */
      __IOM uint32 I2C3EN     : 1;            /*!< [23..23] I2C3 Peripheral Clocks Enable                                    */
            uint32            : 3;
      __IOM uint32 HDMICECEN  : 1;            /*!< [27..27] HDMI-CEC peripheral clock enable                                 */
            uint32            : 1;
      __IOM uint32 DAC12EN    : 1;            /*!< [29..29] DAC1&2 peripheral clock enable                                   */
      __IOM uint32 USART7EN   : 1;            /*!< [30..30] USART7 Peripheral Clocks Enable                                  */
      __IOM uint32 USART8EN   : 1;            /*!< [31..31] USART8 Peripheral Clocks Enable                                  */
    } bit;
  } C1_APB1LENR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000014C) RCC APB1 Clock Register                                    */
    
    struct {
            uint32            : 1;
      __IOM uint32 CRSEN      : 1;            /*!< [1..1] Clock Recovery System peripheral clock enable                      */
      __IOM uint32 SWPEN      : 1;            /*!< [2..2] SWPMI Peripheral Clocks Enable                                     */
            uint32            : 1;
      __IOM uint32 OPAMPEN    : 1;            /*!< [4..4] OPAMP peripheral clock enable                                      */
      __IOM uint32 MDIOSEN    : 1;            /*!< [5..5] MDIOS peripheral clock enable                                      */
            uint32            : 2;
      __IOM uint32 FDCANEN    : 1;            /*!< [8..8] FDCAN Peripheral Clocks Enable                                     */
            uint32            : 23;
    } bit;
  } C1_APB1HENR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000150) RCC APB2 Clock Register                                    */
    
    struct {
      __IOM uint32 TIM1EN     : 1;            /*!< [0..0] TIM1 peripheral clock enable                                       */
      __IOM uint32 TIM8EN     : 1;            /*!< [1..1] TIM8 peripheral clock enable                                       */
            uint32            : 2;
      __IOM uint32 USART1EN   : 1;            /*!< [4..4] USART1 Peripheral Clocks Enable                                    */
      __IOM uint32 USART6EN   : 1;            /*!< [5..5] USART6 Peripheral Clocks Enable                                    */
            uint32            : 6;
      __IOM uint32 SPI1EN     : 1;            /*!< [12..12] SPI1 Peripheral Clocks Enable                                    */
      __IOM uint32 SPI4EN     : 1;            /*!< [13..13] SPI4 Peripheral Clocks Enable                                    */
            uint32            : 2;
      __IOM uint32 TIM15EN    : 1;            /*!< [16..16] TIM15 peripheral clock enable                                    */
      __IOM uint32 TIM16EN    : 1;            /*!< [17..17] TIM16 peripheral clock enable                                    */
      __IOM uint32 TIM17EN    : 1;            /*!< [18..18] TIM17 peripheral clock enable                                    */
            uint32            : 1;
      __IOM uint32 SPI5EN     : 1;            /*!< [20..20] SPI5 Peripheral Clocks Enable                                    */
            uint32            : 1;
      __IOM uint32 SAI1EN     : 1;            /*!< [22..22] SAI1 Peripheral Clocks Enable                                    */
      __IOM uint32 SAI2EN     : 1;            /*!< [23..23] SAI2 Peripheral Clocks Enable                                    */
      __IOM uint32 SAI3EN     : 1;            /*!< [24..24] SAI3 Peripheral Clocks Enable                                    */
            uint32            : 3;
      __IOM uint32 DFSDM1EN   : 1;            /*!< [28..28] DFSDM1 Peripheral Clocks Enable                                  */
      __IOM uint32 HRTIMEN    : 1;            /*!< [29..29] HRTIM peripheral clock enable                                    */
            uint32            : 2;
    } bit;
  } C1_APB2ENR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000154) RCC APB4 Clock Register                                    */
    
    struct {
            uint32            : 1;
      __IOM uint32 SYSCFGEN   : 1;            /*!< [1..1] SYSCFG peripheral clock enable                                     */
            uint32            : 1;
      __IOM uint32 LPUART1EN  : 1;            /*!< [3..3] LPUART1 Peripheral Clocks Enable                                   */
            uint32            : 1;
      __IOM uint32 SPI6EN     : 1;            /*!< [5..5] SPI6 Peripheral Clocks Enable                                      */
            uint32            : 1;
      __IOM uint32 I2C4EN     : 1;            /*!< [7..7] I2C4 Peripheral Clocks Enable                                      */
            uint32            : 1;
      __IOM uint32 LPTIM2EN   : 1;            /*!< [9..9] LPTIM2 Peripheral Clocks Enable                                    */
      __IOM uint32 LPTIM3EN   : 1;            /*!< [10..10] LPTIM3 Peripheral Clocks Enable                                  */
      __IOM uint32 LPTIM4EN   : 1;            /*!< [11..11] LPTIM4 Peripheral Clocks Enable                                  */
      __IOM uint32 LPTIM5EN   : 1;            /*!< [12..12] LPTIM5 Peripheral Clocks Enable                                  */
            uint32            : 1;
      __IOM uint32 COMP12EN   : 1;            /*!< [14..14] COMP1/2 peripheral clock enable                                  */
      __IOM uint32 VREFEN     : 1;            /*!< [15..15] VREF peripheral clock enable                                     */
      __IOM uint32 RTCAPBEN   : 1;            /*!< [16..16] RTC APB Clock Enable                                             */
            uint32            : 4;
      __IOM uint32 SAI4EN     : 1;            /*!< [21..21] SAI4 Peripheral Clocks Enable                                    */
            uint32            : 10;
    } bit;
  } C1_APB4ENR;
  __IM  uint32  RESERVED11;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000015C) RCC AHB3 Sleep Clock Register                              */
    
    struct {
      __IOM uint32 MDMALPEN   : 1;            /*!< [0..0] MDMA Clock Enable During CSleep Mode                               */
            uint32            : 3;
      __IOM uint32 DMA2DLPEN  : 1;            /*!< [4..4] DMA2D Clock Enable During CSleep Mode                              */
      __IOM uint32 JPGDECLPEN : 1;            /*!< [5..5] JPGDEC Clock Enable During CSleep Mode                             */
            uint32            : 2;
      __IOM uint32 FLITFLPEN  : 1;            /*!< [8..8] FLITF Clock Enable During CSleep Mode                              */
            uint32            : 3;
      __IOM uint32 FMCLPEN    : 1;            /*!< [12..12] FMC Peripheral Clocks Enable During CSleep Mode                  */
            uint32            : 1;
      __IOM uint32 QSPILPEN   : 1;            /*!< [14..14] QUADSPI and QUADSPI Delay Clock Enable During CSleep
                                                     Mode                                                                      */
            uint32            : 1;
      __IOM uint32 SDMMC1LPEN : 1;            /*!< [16..16] SDMMC1 and SDMMC1 Delay Clock Enable During CSleep
                                                     Mode                                                                      */
            uint32            : 11;
      __IOM uint32 D1DTCM1LPEN : 1;           /*!< [28..28] D1DTCM1 Block Clock Enable During CSleep mode                    */
      __IOM uint32 DTCM2LPEN  : 1;            /*!< [29..29] D1 DTCM2 Block Clock Enable During CSleep mode                   */
      __IOM uint32 ITCMLPEN   : 1;            /*!< [30..30] D1ITCM Block Clock Enable During CSleep mode                     */
      __IOM uint32 AXISRAMLPEN : 1;           /*!< [31..31] AXISRAM Block Clock Enable During CSleep mode                    */
    } bit;
  } C1_AHB3LPENR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000160) RCC AHB1 Sleep Clock Register                              */
    
    struct {
      __IOM uint32 DMA1LPEN   : 1;            /*!< [0..0] DMA1 Clock Enable During CSleep Mode                               */
      __IOM uint32 DMA2LPEN   : 1;            /*!< [1..1] DMA2 Clock Enable During CSleep Mode                               */
            uint32            : 3;
      __IOM uint32 ADC12LPEN  : 1;            /*!< [5..5] ADC1/2 Peripheral Clocks Enable During CSleep Mode                 */
            uint32            : 9;
      __IOM uint32 ETH1MACLPEN : 1;           /*!< [15..15] Ethernet MAC bus interface Clock Enable During CSleep
                                                     Mode                                                                      */
      __IOM uint32 ETH1TXLPEN : 1;            /*!< [16..16] Ethernet Transmission Clock Enable During CSleep Mode            */
      __IOM uint32 ETH1RXLPEN : 1;            /*!< [17..17] Ethernet Reception Clock Enable During CSleep Mode               */
            uint32            : 7;
      __IOM uint32 USB1OTGLPEN : 1;           /*!< [25..25] USB1OTG peripheral clock enable during CSleep mode               */
      __IOM uint32 USB1ULPILPEN : 1;          /*!< [26..26] USB_PHY1 clock enable during CSleep mode                         */
      __IOM uint32 USB2OTGLPEN : 1;           /*!< [27..27] USB2OTG peripheral clock enable during CSleep mode               */
      __IOM uint32 USB2ULPILPEN : 1;          /*!< [28..28] USB_PHY2 clocks enable during CSleep mode                        */
            uint32            : 3;
    } bit;
  } C1_AHB1LPENR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000164) RCC AHB2 Sleep Clock Register                              */
    
    struct {
      __IOM uint32 CAMITFLPEN : 1;            /*!< [0..0] CAMITF peripheral clock enable during CSleep mode                  */
            uint32            : 3;
      __IOM uint32 CRYPTLPEN  : 1;            /*!< [4..4] CRYPT peripheral clock enable during CSleep mode                   */
      __IOM uint32 HASHLPEN   : 1;            /*!< [5..5] HASH peripheral clock enable during CSleep mode                    */
      __IOM uint32 RNGLPEN    : 1;            /*!< [6..6] RNG peripheral clock enable during CSleep mode                     */
            uint32            : 2;
      __IOM uint32 SDMMC2LPEN : 1;            /*!< [9..9] SDMMC2 and SDMMC2 Delay Clock Enable During CSleep Mode            */
            uint32            : 19;
      __IOM uint32 SRAM1LPEN  : 1;            /*!< [29..29] SRAM1 Clock Enable During CSleep Mode                            */
      __IOM uint32 SRAM2LPEN  : 1;            /*!< [30..30] SRAM2 Clock Enable During CSleep Mode                            */
      __IOM uint32 SRAM3LPEN  : 1;            /*!< [31..31] SRAM3 Clock Enable During CSleep Mode                            */
    } bit;
  } C1_AHB2LPENR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000168) RCC AHB4 Sleep Clock Register                              */
    
    struct {
      __IOM uint32 GPIOALPEN  : 1;            /*!< [0..0] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32 GPIOBLPEN  : 1;            /*!< [1..1] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32 GPIOCLPEN  : 1;            /*!< [2..2] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32 GPIODLPEN  : 1;            /*!< [3..3] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32 GPIOELPEN  : 1;            /*!< [4..4] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32 GPIOFLPEN  : 1;            /*!< [5..5] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32 GPIOGLPEN  : 1;            /*!< [6..6] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32 GPIOHLPEN  : 1;            /*!< [7..7] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32 GPIOILPEN  : 1;            /*!< [8..8] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32 GPIOJLPEN  : 1;            /*!< [9..9] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32 GPIOKLPEN  : 1;            /*!< [10..10] GPIO peripheral clock enable during CSleep mode                  */
            uint32            : 8;
      __IOM uint32 CRCLPEN    : 1;            /*!< [19..19] CRC peripheral clock enable during CSleep mode                   */
            uint32            : 1;
      __IOM uint32 BDMALPEN   : 1;            /*!< [21..21] BDMA Clock Enable During CSleep Mode                             */
            uint32            : 2;
      __IOM uint32 ADC3LPEN   : 1;            /*!< [24..24] ADC3 Peripheral Clocks Enable During CSleep Mode                 */
            uint32            : 3;
      __IOM uint32 BKPRAMLPEN : 1;            /*!< [28..28] Backup RAM Clock Enable During CSleep Mode                       */
      __IOM uint32 SRAM4LPEN  : 1;            /*!< [29..29] SRAM4 Clock Enable During CSleep Mode                            */
            uint32            : 2;
    } bit;
  } C1_AHB4LPENR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000016C) RCC APB3 Sleep Clock Register                              */
    
    struct {
            uint32            : 3;
      __IOM uint32 LTDCLPEN   : 1;            /*!< [3..3] LTDC peripheral clock enable during CSleep mode                    */
            uint32            : 2;
      __IOM uint32 WWDG1LPEN  : 1;            /*!< [6..6] WWDG1 Clock Enable During CSleep Mode                              */
            uint32            : 25;
    } bit;
  } C1_APB3LPENR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000170) RCC APB1 Low Sleep Clock Register                          */
    
    struct {
      __IOM uint32 TIM2LPEN   : 1;            /*!< [0..0] TIM2 peripheral clock enable during CSleep mode                    */
      __IOM uint32 TIM3LPEN   : 1;            /*!< [1..1] TIM3 peripheral clock enable during CSleep mode                    */
      __IOM uint32 TIM4LPEN   : 1;            /*!< [2..2] TIM4 peripheral clock enable during CSleep mode                    */
      __IOM uint32 TIM5LPEN   : 1;            /*!< [3..3] TIM5 peripheral clock enable during CSleep mode                    */
      __IOM uint32 TIM6LPEN   : 1;            /*!< [4..4] TIM6 peripheral clock enable during CSleep mode                    */
      __IOM uint32 TIM7LPEN   : 1;            /*!< [5..5] TIM7 peripheral clock enable during CSleep mode                    */
      __IOM uint32 TIM12LPEN  : 1;            /*!< [6..6] TIM12 peripheral clock enable during CSleep mode                   */
      __IOM uint32 TIM13LPEN  : 1;            /*!< [7..7] TIM13 peripheral clock enable during CSleep mode                   */
      __IOM uint32 TIM14LPEN  : 1;            /*!< [8..8] TIM14 peripheral clock enable during CSleep mode                   */
      __IOM uint32 LPTIM1LPEN : 1;            /*!< [9..9] LPTIM1 Peripheral Clocks Enable During CSleep Mode                 */
            uint32            : 4;
      __IOM uint32 SPI2LPEN   : 1;            /*!< [14..14] SPI2 Peripheral Clocks Enable During CSleep Mode                 */
      __IOM uint32 SPI3LPEN   : 1;            /*!< [15..15] SPI3 Peripheral Clocks Enable During CSleep Mode                 */
      __IOM uint32 SPDIFRXLPEN : 1;           /*!< [16..16] SPDIFRX Peripheral Clocks Enable During CSleep Mode              */
      __IOM uint32 USART2LPEN : 1;            /*!< [17..17] USART2 Peripheral Clocks Enable During CSleep Mode               */
      __IOM uint32 USART3LPEN : 1;            /*!< [18..18] USART3 Peripheral Clocks Enable During CSleep Mode               */
      __IOM uint32 UART4LPEN  : 1;            /*!< [19..19] UART4 Peripheral Clocks Enable During CSleep Mode                */
      __IOM uint32 UART5LPEN  : 1;            /*!< [20..20] UART5 Peripheral Clocks Enable During CSleep Mode                */
      __IOM uint32 I2C1LPEN   : 1;            /*!< [21..21] I2C1 Peripheral Clocks Enable During CSleep Mode                 */
      __IOM uint32 I2C2LPEN   : 1;            /*!< [22..22] I2C2 Peripheral Clocks Enable During CSleep Mode                 */
      __IOM uint32 I2C3LPEN   : 1;            /*!< [23..23] I2C3 Peripheral Clocks Enable During CSleep Mode                 */
            uint32            : 3;
      __IOM uint32 HDMICECLPEN : 1;           /*!< [27..27] HDMI-CEC Peripheral Clocks Enable During CSleep Mode             */
            uint32            : 1;
      __IOM uint32 DAC12LPEN  : 1;            /*!< [29..29] DAC1/2 peripheral clock enable during CSleep mode                */
      __IOM uint32 USART7LPEN : 1;            /*!< [30..30] USART7 Peripheral Clocks Enable During CSleep Mode               */
      __IOM uint32 USART8LPEN : 1;            /*!< [31..31] USART8 Peripheral Clocks Enable During CSleep Mode               */
    } bit;
  } C1_APB1LLPENR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000174) RCC APB1 High Sleep Clock Register                         */
    
    struct {
            uint32            : 1;
      __IOM uint32 CRSLPEN    : 1;            /*!< [1..1] Clock Recovery System peripheral clock enable during
                                                     CSleep mode                                                               */
      __IOM uint32 SWPLPEN    : 1;            /*!< [2..2] SWPMI Peripheral Clocks Enable During CSleep Mode                  */
            uint32            : 1;
      __IOM uint32 OPAMPLPEN  : 1;            /*!< [4..4] OPAMP peripheral clock enable during CSleep mode                   */
      __IOM uint32 MDIOSLPEN  : 1;            /*!< [5..5] MDIOS peripheral clock enable during CSleep mode                   */
            uint32            : 2;
      __IOM uint32 FDCANLPEN  : 1;            /*!< [8..8] FDCAN Peripheral Clocks Enable During CSleep Mode                  */
            uint32            : 23;
    } bit;
  } C1_APB1HLPENR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000178) RCC APB2 Sleep Clock Register                              */
    
    struct {
      __IOM uint32 TIM1LPEN   : 1;            /*!< [0..0] TIM1 peripheral clock enable during CSleep mode                    */
      __IOM uint32 TIM8LPEN   : 1;            /*!< [1..1] TIM8 peripheral clock enable during CSleep mode                    */
            uint32            : 2;
      __IOM uint32 USART1LPEN : 1;            /*!< [4..4] USART1 Peripheral Clocks Enable During CSleep Mode                 */
      __IOM uint32 USART6LPEN : 1;            /*!< [5..5] USART6 Peripheral Clocks Enable During CSleep Mode                 */
            uint32            : 6;
      __IOM uint32 SPI1LPEN   : 1;            /*!< [12..12] SPI1 Peripheral Clocks Enable During CSleep Mode                 */
      __IOM uint32 SPI4LPEN   : 1;            /*!< [13..13] SPI4 Peripheral Clocks Enable During CSleep Mode                 */
            uint32            : 2;
      __IOM uint32 TIM15LPEN  : 1;            /*!< [16..16] TIM15 peripheral clock enable during CSleep mode                 */
      __IOM uint32 TIM16LPEN  : 1;            /*!< [17..17] TIM16 peripheral clock enable during CSleep mode                 */
      __IOM uint32 TIM17LPEN  : 1;            /*!< [18..18] TIM17 peripheral clock enable during CSleep mode                 */
            uint32            : 1;
      __IOM uint32 SPI5LPEN   : 1;            /*!< [20..20] SPI5 Peripheral Clocks Enable During CSleep Mode                 */
            uint32            : 1;
      __IOM uint32 SAI1LPEN   : 1;            /*!< [22..22] SAI1 Peripheral Clocks Enable During CSleep Mode                 */
      __IOM uint32 SAI2LPEN   : 1;            /*!< [23..23] SAI2 Peripheral Clocks Enable During CSleep Mode                 */
      __IOM uint32 SAI3LPEN   : 1;            /*!< [24..24] SAI3 Peripheral Clocks Enable During CSleep Mode                 */
            uint32            : 3;
      __IOM uint32 DFSDM1LPEN : 1;            /*!< [28..28] DFSDM1 Peripheral Clocks Enable During CSleep Mode               */
      __IOM uint32 HRTIMLPEN  : 1;            /*!< [29..29] HRTIM peripheral clock enable during CSleep mode                 */
            uint32            : 2;
    } bit;
  } C1_APB2LPENR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000017C) RCC APB4 Sleep Clock Register                              */
    
    struct {
            uint32            : 1;
      __IOM uint32 SYSCFGLPEN : 1;            /*!< [1..1] SYSCFG peripheral clock enable during CSleep mode                  */
            uint32            : 1;
      __IOM uint32 LPUART1LPEN : 1;           /*!< [3..3] LPUART1 Peripheral Clocks Enable During CSleep Mode                */
            uint32            : 1;
      __IOM uint32 SPI6LPEN   : 1;            /*!< [5..5] SPI6 Peripheral Clocks Enable During CSleep Mode                   */
            uint32            : 1;
      __IOM uint32 I2C4LPEN   : 1;            /*!< [7..7] I2C4 Peripheral Clocks Enable During CSleep Mode                   */
            uint32            : 1;
      __IOM uint32 LPTIM2LPEN : 1;            /*!< [9..9] LPTIM2 Peripheral Clocks Enable During CSleep Mode                 */
      __IOM uint32 LPTIM3LPEN : 1;            /*!< [10..10] LPTIM3 Peripheral Clocks Enable During CSleep Mode               */
      __IOM uint32 LPTIM4LPEN : 1;            /*!< [11..11] LPTIM4 Peripheral Clocks Enable During CSleep Mode               */
      __IOM uint32 LPTIM5LPEN : 1;            /*!< [12..12] LPTIM5 Peripheral Clocks Enable During CSleep Mode               */
            uint32            : 1;
      __IOM uint32 COMP12LPEN : 1;            /*!< [14..14] COMP1/2 peripheral clock enable during CSleep mode               */
      __IOM uint32 VREFLPEN   : 1;            /*!< [15..15] VREF peripheral clock enable during CSleep mode                  */
      __IOM uint32 RTCAPBLPEN : 1;            /*!< [16..16] RTC APB Clock Enable During CSleep Mode                          */
            uint32            : 4;
      __IOM uint32 SAI4LPEN   : 1;            /*!< [21..21] SAI4 Peripheral Clocks Enable During CSleep Mode                 */
            uint32            : 10;
    } bit;
  } C1_APB4LPENR;
} RCC_Type;                                     /*!< Size = 384 (0x180)                                                        */



/* =========================================================================================================================== */
/* ================                                          LPTIM1                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Low power timer (LPTIM1)
  */

typedef struct {                                /*!< (@ 0x40002400) LPTIM1 Structure                                           */
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000000) Interrupt and Status Register                              */
    
    struct {
      __IM  uint32 CMPM       : 1;            /*!< [0..0] Compare match                                                      */
      __IM  uint32 ARRM       : 1;            /*!< [1..1] Autoreload match                                                   */
      __IM  uint32 EXTTRIG    : 1;            /*!< [2..2] External trigger edge event                                        */
      __IM  uint32 CMPOK      : 1;            /*!< [3..3] Compare register update OK                                         */
      __IM  uint32 ARROK      : 1;            /*!< [4..4] Autoreload register update OK                                      */
      __IM  uint32 UP         : 1;            /*!< [5..5] Counter direction change down to up                                */
      __IM  uint32 DOWN       : 1;            /*!< [6..6] Counter direction change up to down                                */
            uint32            : 25;
    } bit;
  } ISR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000004) Interrupt Clear Register                                   */
    
    struct {
      __OM  uint32 CMPMCF     : 1;            /*!< [0..0] compare match Clear Flag                                           */
      __OM  uint32 ARRMCF     : 1;            /*!< [1..1] Autoreload match Clear Flag                                        */
      __OM  uint32 EXTTRIGCF  : 1;            /*!< [2..2] External trigger valid edge Clear Flag                             */
      __OM  uint32 CMPOKCF    : 1;            /*!< [3..3] Compare register update OK Clear Flag                              */
      __OM  uint32 ARROKCF    : 1;            /*!< [4..4] Autoreload register update OK Clear Flag                           */
      __OM  uint32 UPCF       : 1;            /*!< [5..5] Direction change to UP Clear Flag                                  */
      __OM  uint32 DOWNCF     : 1;            /*!< [6..6] Direction change to down Clear Flag                                */
            uint32            : 25;
    } bit;
  } ICR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) Interrupt Enable Register                                  */
    
    struct {
      __IOM uint32 CMPMIE     : 1;            /*!< [0..0] Compare match Interrupt Enable                                     */
      __IOM uint32 ARRMIE     : 1;            /*!< [1..1] Autoreload match Interrupt Enable                                  */
      __IOM uint32 EXTTRIGIE  : 1;            /*!< [2..2] External trigger valid edge Interrupt Enable                       */
      __IOM uint32 CMPOKIE    : 1;            /*!< [3..3] Compare register update OK Interrupt Enable                        */
      __IOM uint32 ARROKIE    : 1;            /*!< [4..4] Autoreload register update OK Interrupt Enable                     */
      __IOM uint32 UPIE       : 1;            /*!< [5..5] Direction change to UP Interrupt Enable                            */
      __IOM uint32 DOWNIE     : 1;            /*!< [6..6] Direction change to down Interrupt Enable                          */
            uint32            : 25;
    } bit;
  } IER;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) Configuration Register                                     */
    
    struct {
      __IOM uint32 CKSEL      : 1;            /*!< [0..0] Clock selector                                                     */
      __IOM uint32 CKPOL      : 2;            /*!< [2..1] Clock Polarity                                                     */
      __IOM uint32 CKFLT      : 2;            /*!< [4..3] Configurable digital filter for external clock                     */
            uint32            : 1;
      __IOM uint32 TRGFLT     : 2;            /*!< [7..6] Configurable digital filter for trigger                            */
            uint32            : 1;
      __IOM uint32 PRESC      : 3;            /*!< [11..9] Clock prescaler                                                   */
            uint32            : 1;
      __IOM uint32 TRIGSEL    : 3;            /*!< [15..13] Trigger selector                                                 */
            uint32            : 1;
      __IOM uint32 TRIGEN     : 2;            /*!< [18..17] Trigger enable and polarity                                      */
      __IOM uint32 TIMOUT     : 1;            /*!< [19..19] Timeout enable                                                   */
      __IOM uint32 WAVE       : 1;            /*!< [20..20] Waveform shape                                                   */
      __IOM uint32 WAVPOL     : 1;            /*!< [21..21] Waveform shape polarity                                          */
      __IOM uint32 PRELOAD    : 1;            /*!< [22..22] Registers update mode                                            */
      __IOM uint32 COUNTMODE  : 1;            /*!< [23..23] counter mode enabled                                             */
      __IOM uint32 ENC        : 1;            /*!< [24..24] Encoder mode enable                                              */
            uint32            : 7;
    } bit;
  } CFGR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) Control Register                                           */
    
    struct {
      __IOM uint32 ENABLE     : 1;            /*!< [0..0] LPTIM Enable                                                       */
      __IOM uint32 SNGSTRT    : 1;            /*!< [1..1] LPTIM start in single mode                                         */
      __IOM uint32 CNTSTRT    : 1;            /*!< [2..2] Timer start in continuous mode                                     */
      __IOM uint32 COUNTRST   : 1;            /*!< [3..3] Counter reset                                                      */
      __IOM uint32 RSTARE     : 1;            /*!< [4..4] Reset after read enable                                            */
            uint32            : 27;
    } bit;
  } CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000014) Compare Register                                           */
    
    struct {
      __IOM uint32 CMP        : 16;           /*!< [15..0] Compare value                                                     */
            uint32            : 16;
    } bit;
  } CMP;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000018) Autoreload Register                                        */
    
    struct {
      __IOM uint32 ARR        : 16;           /*!< [15..0] Auto reload value                                                 */
            uint32            : 16;
    } bit;
  } ARR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000001C) Counter Register                                           */
    
    struct {
      __IM  uint32 CNT        : 16;           /*!< [15..0] Counter value                                                     */
            uint32            : 16;
    } bit;
  } CNT;
  __IM  uint32  RESERVED;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000024) LPTIM configuration register 2                             */
    
    struct {
      __IOM uint32 IN1SEL     : 2;            /*!< [1..0] LPTIM Input 1 selection                                            */
            uint32            : 2;
      __IOM uint32 IN2SEL     : 2;            /*!< [5..4] LPTIM Input 2 selection                                            */
            uint32            : 26;
    } bit;
  } LPTIM_CFGR2;
} LPTIM1_Type;                                  /*!< Size = 40 (0x28)                                                          */



/* =========================================================================================================================== */
/* ================                                          LPTIM3                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Low power timer (LPTIM3)
  */

typedef struct {                                /*!< (@ 0x58002800) LPTIM3 Structure                                           */
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000000) Interrupt and Status Register                              */
    
    struct {
      __IM  uint32 CMPM       : 1;            /*!< [0..0] Compare match                                                      */
      __IM  uint32 ARRM       : 1;            /*!< [1..1] Autoreload match                                                   */
      __IM  uint32 EXTTRIG    : 1;            /*!< [2..2] External trigger edge event                                        */
      __IM  uint32 CMPOK      : 1;            /*!< [3..3] Compare register update OK                                         */
      __IM  uint32 ARROK      : 1;            /*!< [4..4] Autoreload register update OK                                      */
      __IM  uint32 UP         : 1;            /*!< [5..5] Counter direction change down to up                                */
      __IM  uint32 DOWN       : 1;            /*!< [6..6] Counter direction change up to down                                */
            uint32            : 25;
    } bit;
  } ISR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000004) Interrupt Clear Register                                   */
    
    struct {
      __OM  uint32 CMPMCF     : 1;            /*!< [0..0] compare match Clear Flag                                           */
      __OM  uint32 ARRMCF     : 1;            /*!< [1..1] Autoreload match Clear Flag                                        */
      __OM  uint32 EXTTRIGCF  : 1;            /*!< [2..2] External trigger valid edge Clear Flag                             */
      __OM  uint32 CMPOKCF    : 1;            /*!< [3..3] Compare register update OK Clear Flag                              */
      __OM  uint32 ARROKCF    : 1;            /*!< [4..4] Autoreload register update OK Clear Flag                           */
      __OM  uint32 UPCF       : 1;            /*!< [5..5] Direction change to UP Clear Flag                                  */
      __OM  uint32 DOWNCF     : 1;            /*!< [6..6] Direction change to down Clear Flag                                */
            uint32            : 25;
    } bit;
  } ICR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) Interrupt Enable Register                                  */
    
    struct {
      __IOM uint32 CMPMIE     : 1;            /*!< [0..0] Compare match Interrupt Enable                                     */
      __IOM uint32 ARRMIE     : 1;            /*!< [1..1] Autoreload match Interrupt Enable                                  */
      __IOM uint32 EXTTRIGIE  : 1;            /*!< [2..2] External trigger valid edge Interrupt Enable                       */
      __IOM uint32 CMPOKIE    : 1;            /*!< [3..3] Compare register update OK Interrupt Enable                        */
      __IOM uint32 ARROKIE    : 1;            /*!< [4..4] Autoreload register update OK Interrupt Enable                     */
      __IOM uint32 UPIE       : 1;            /*!< [5..5] Direction change to UP Interrupt Enable                            */
      __IOM uint32 DOWNIE     : 1;            /*!< [6..6] Direction change to down Interrupt Enable                          */
            uint32            : 25;
    } bit;
  } IER;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) Configuration Register                                     */
    
    struct {
      __IOM uint32 CKSEL      : 1;            /*!< [0..0] Clock selector                                                     */
      __IOM uint32 CKPOL      : 2;            /*!< [2..1] Clock Polarity                                                     */
      __IOM uint32 CKFLT      : 2;            /*!< [4..3] Configurable digital filter for external clock                     */
            uint32            : 1;
      __IOM uint32 TRGFLT     : 2;            /*!< [7..6] Configurable digital filter for trigger                            */
            uint32            : 1;
      __IOM uint32 PRESC      : 3;            /*!< [11..9] Clock prescaler                                                   */
            uint32            : 1;
      __IOM uint32 TRIGSEL    : 3;            /*!< [15..13] Trigger selector                                                 */
            uint32            : 1;
      __IOM uint32 TRIGEN     : 2;            /*!< [18..17] Trigger enable and polarity                                      */
      __IOM uint32 TIMOUT     : 1;            /*!< [19..19] Timeout enable                                                   */
      __IOM uint32 WAVE       : 1;            /*!< [20..20] Waveform shape                                                   */
      __IOM uint32 WAVPOL     : 1;            /*!< [21..21] Waveform shape polarity                                          */
      __IOM uint32 PRELOAD    : 1;            /*!< [22..22] Registers update mode                                            */
      __IOM uint32 COUNTMODE  : 1;            /*!< [23..23] counter mode enabled                                             */
      __IOM uint32 ENC        : 1;            /*!< [24..24] Encoder mode enable                                              */
            uint32            : 7;
    } bit;
  } CFGR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) Control Register                                           */
    
    struct {
      __IOM uint32 ENABLE     : 1;            /*!< [0..0] LPTIM Enable                                                       */
      __IOM uint32 SNGSTRT    : 1;            /*!< [1..1] LPTIM start in single mode                                         */
      __IOM uint32 CNTSTRT    : 1;            /*!< [2..2] Timer start in continuous mode                                     */
      __IOM uint32 COUNTRST   : 1;            /*!< [3..3] Counter reset                                                      */
      __IOM uint32 RSTARE     : 1;            /*!< [4..4] Reset after read enable                                            */
            uint32            : 27;
    } bit;
  } CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000014) Compare Register                                           */
    
    struct {
      __IOM uint32 CMP        : 16;           /*!< [15..0] Compare value                                                     */
            uint32            : 16;
    } bit;
  } CMP;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000018) Autoreload Register                                        */
    
    struct {
      __IOM uint32 ARR        : 16;           /*!< [15..0] Auto reload value                                                 */
            uint32            : 16;
    } bit;
  } ARR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000001C) Counter Register                                           */
    
    struct {
      __IM  uint32 CNT        : 16;           /*!< [15..0] Counter value                                                     */
            uint32            : 16;
    } bit;
  } CNT;
  __IM  uint32  RESERVED;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000024) LPTIM configuration register 2                             */
    
    struct {
      __IOM uint32 IN1SEL     : 2;            /*!< [1..0] LPTIM Input 1 selection                                            */
            uint32            : 30;
    } bit;
  } LPTIM_CFGR2;
} LPTIM3_Type;                                  /*!< Size = 40 (0x28)                                                          */



/* =========================================================================================================================== */
/* ================                                          LPUART1                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief LPUART1 (LPUART1)
  */

typedef struct {                                /*!< (@ 0x58000C00) LPUART1 Structure                                          */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) Control register 1                                         */
    
    struct {
      __IOM uint32 UE         : 1;            /*!< [0..0] USART enable                                                       */
      __IOM uint32 UESM       : 1;            /*!< [1..1] USART enable in Stop mode                                          */
      __IOM uint32 RE         : 1;            /*!< [2..2] Receiver enable                                                    */
      __IOM uint32 TE         : 1;            /*!< [3..3] Transmitter enable                                                 */
      __IOM uint32 IDLEIE     : 1;            /*!< [4..4] IDLE interrupt enable                                              */
      __IOM uint32 RXNEIE     : 1;            /*!< [5..5] RXNE interrupt enable                                              */
      __IOM uint32 TCIE       : 1;            /*!< [6..6] Transmission complete interrupt enable                             */
      __IOM uint32 TXEIE      : 1;            /*!< [7..7] interrupt enable                                                   */
      __IOM uint32 PEIE       : 1;            /*!< [8..8] PE interrupt enable                                                */
      __IOM uint32 PS         : 1;            /*!< [9..9] Parity selection                                                   */
      __IOM uint32 PCE        : 1;            /*!< [10..10] Parity control enable                                            */
      __IOM uint32 WAKE       : 1;            /*!< [11..11] Receiver wakeup method                                           */
      __IOM uint32 M0         : 1;            /*!< [12..12] Word length                                                      */
      __IOM uint32 MME        : 1;            /*!< [13..13] Mute mode enable                                                 */
      __IOM uint32 CMIE       : 1;            /*!< [14..14] Character match interrupt enable                                 */
            uint32            : 1;
      __IOM uint32 DEDT       : 5;            /*!< [20..16] Driver Enable deassertion time                                   */
      __IOM uint32 DEAT       : 5;            /*!< [25..21] Driver Enable assertion time                                     */
            uint32            : 2;
      __IOM uint32 M1         : 1;            /*!< [28..28] Word length                                                      */
      __IOM uint32 FIFOEN     : 1;            /*!< [29..29] FIFO mode enable                                                 */
      __IOM uint32 TXFEIE     : 1;            /*!< [30..30] TXFIFO empty interrupt enable                                    */
      __IOM uint32 RXFFIE     : 1;            /*!< [31..31] RXFIFO Full interrupt enable                                     */
    } bit;
  } CR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) Control register 2                                         */
    
    struct {
            uint32            : 4;
      __IOM uint32 ADDM7      : 1;            /*!< [4..4] 7-bit Address Detection/4-bit Address Detection                    */
            uint32            : 7;
      __IOM uint32 STOP       : 2;            /*!< [13..12] STOP bits                                                        */
            uint32            : 1;
      __IOM uint32 SWAP       : 1;            /*!< [15..15] Swap TX/RX pins                                                  */
      __IOM uint32 RXINV      : 1;            /*!< [16..16] RX pin active level inversion                                    */
      __IOM uint32 TXINV      : 1;            /*!< [17..17] TX pin active level inversion                                    */
      __IOM uint32 DATAINV    : 1;            /*!< [18..18] Binary data inversion                                            */
      __IOM uint32 MSBFIRST   : 1;            /*!< [19..19] Most significant bit first                                       */
            uint32            : 4;
      __IOM uint32 ADD        : 8;            /*!< [31..24] Address of the USART node                                        */
    } bit;
  } CR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) Control register 3                                         */
    
    struct {
      __IOM uint32 EIE        : 1;            /*!< [0..0] Error interrupt enable                                             */
            uint32            : 2;
      __IOM uint32 HDSEL      : 1;            /*!< [3..3] Half-duplex selection                                              */
            uint32            : 2;
      __IOM uint32 DMAR       : 1;            /*!< [6..6] DMA enable receiver                                                */
      __IOM uint32 DMAT       : 1;            /*!< [7..7] DMA enable transmitter                                             */
      __IOM uint32 RTSE       : 1;            /*!< [8..8] RTS enable                                                         */
      __IOM uint32 CTSE       : 1;            /*!< [9..9] CTS enable                                                         */
      __IOM uint32 CTSIE      : 1;            /*!< [10..10] CTS interrupt enable                                             */
            uint32            : 1;
      __IOM uint32 OVRDIS     : 1;            /*!< [12..12] Overrun Disable                                                  */
      __IOM uint32 DDRE       : 1;            /*!< [13..13] DMA Disable on Reception Error                                   */
      __IOM uint32 DEM        : 1;            /*!< [14..14] Driver enable mode                                               */
      __IOM uint32 DEP        : 1;            /*!< [15..15] Driver enable polarity selection                                 */
            uint32            : 4;
      __IOM uint32 WUS        : 2;            /*!< [21..20] Wakeup from Stop mode interrupt flag selection                   */
      __IOM uint32 WUFIE      : 1;            /*!< [22..22] Wakeup from Stop mode interrupt enable                           */
      __IOM uint32 TXFTIE     : 1;            /*!< [23..23] TXFIFO threshold interrupt enable                                */
            uint32            : 1;
      __IOM uint32 RXFTCFG    : 3;            /*!< [27..25] Receive FIFO threshold configuration                             */
      __IOM uint32 RXFTIE     : 1;            /*!< [28..28] RXFIFO threshold interrupt enable                                */
      __IOM uint32 TXFTCFG    : 3;            /*!< [31..29] TXFIFO threshold configuration                                   */
    } bit;
  } CR3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) Baud rate register                                         */
    
    struct {
      __IOM uint32 BRR        : 20;           /*!< [19..0] BRR                                                               */
            uint32            : 12;
    } bit;
  } BRR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) Guard time and prescaler register                          */
    
    struct {
      __IOM uint32 PSC        : 8;            /*!< [7..0] Prescaler value                                                    */
      __IOM uint32 GT         : 8;            /*!< [15..8] Guard time value                                                  */
            uint32            : 16;
    } bit;
  } GTPR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000014) Receiver timeout register                                  */
    
    struct {
      __IOM uint32 RTO        : 24;           /*!< [23..0] Receiver timeout value                                            */
      __IOM uint32 BLEN       : 8;            /*!< [31..24] Block Length                                                     */
    } bit;
  } RTOR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000018) Request register                                           */
    
    struct {
      __OM  uint32 ABRRQ      : 1;            /*!< [0..0] Auto baud rate request                                             */
      __OM  uint32 SBKRQ      : 1;            /*!< [1..1] Send break request                                                 */
      __OM  uint32 MMRQ       : 1;            /*!< [2..2] Mute mode request                                                  */
      __OM  uint32 RXFRQ      : 1;            /*!< [3..3] Receive data flush request                                         */
      __OM  uint32 TXFRQ      : 1;            /*!< [4..4] Transmit data flush request                                        */
            uint32            : 27;
    } bit;
  } RQR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000001C) Interrupt & status register                                */
    
    struct {
      __IM  uint32 PE         : 1;            /*!< [0..0] PE                                                                 */
      __IM  uint32 FE         : 1;            /*!< [1..1] FE                                                                 */
      __IM  uint32 NE         : 1;            /*!< [2..2] NE                                                                 */
      __IM  uint32 ORE        : 1;            /*!< [3..3] ORE                                                                */
      __IM  uint32 IDLE       : 1;            /*!< [4..4] IDLE                                                               */
      __IM  uint32 RXNE       : 1;            /*!< [5..5] RXNE                                                               */
      __IM  uint32 TC         : 1;            /*!< [6..6] TC                                                                 */
      __IM  uint32 TXE        : 1;            /*!< [7..7] TXE                                                                */
            uint32            : 1;
      __IM  uint32 CTSIF      : 1;            /*!< [9..9] CTSIF                                                              */
      __IM  uint32 CTS        : 1;            /*!< [10..10] CTS                                                              */
            uint32            : 5;
      __IM  uint32 BUSY       : 1;            /*!< [16..16] BUSY                                                             */
      __IM  uint32 CMF        : 1;            /*!< [17..17] CMF                                                              */
      __IM  uint32 SBKF       : 1;            /*!< [18..18] SBKF                                                             */
      __IM  uint32 RWU        : 1;            /*!< [19..19] RWU                                                              */
      __IM  uint32 WUF        : 1;            /*!< [20..20] WUF                                                              */
      __IM  uint32 TEACK      : 1;            /*!< [21..21] TEACK                                                            */
      __IM  uint32 REACK      : 1;            /*!< [22..22] REACK                                                            */
      __IM  uint32 TXFE       : 1;            /*!< [23..23] TXFIFO Empty                                                     */
      __IM  uint32 RXFF       : 1;            /*!< [24..24] RXFIFO Full                                                      */
            uint32            : 1;
      __IM  uint32 RXFT       : 1;            /*!< [26..26] RXFIFO threshold flag                                            */
      __IM  uint32 TXFT       : 1;            /*!< [27..27] TXFIFO threshold flag                                            */
            uint32            : 4;
    } bit;
  } ISR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000020) Interrupt flag clear register                              */
    
    struct {
      __OM  uint32 PECF       : 1;            /*!< [0..0] Parity error clear flag                                            */
      __OM  uint32 FECF       : 1;            /*!< [1..1] Framing error clear flag                                           */
      __OM  uint32 NCF        : 1;            /*!< [2..2] Noise detected clear flag                                          */
      __OM  uint32 ORECF      : 1;            /*!< [3..3] Overrun error clear flag                                           */
      __OM  uint32 IDLECF     : 1;            /*!< [4..4] Idle line detected clear flag                                      */
            uint32            : 1;
      __OM  uint32 TCCF       : 1;            /*!< [6..6] Transmission complete clear flag                                   */
            uint32            : 2;
      __OM  uint32 CTSCF      : 1;            /*!< [9..9] CTS clear flag                                                     */
            uint32            : 7;
      __OM  uint32 CMCF       : 1;            /*!< [17..17] Character match clear flag                                       */
            uint32            : 2;
      __OM  uint32 WUCF       : 1;            /*!< [20..20] Wakeup from Stop mode clear flag                                 */
            uint32            : 11;
    } bit;
  } ICR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000024) Receive data register                                      */
    
    struct {
      __IM  uint32 RDR        : 9;            /*!< [8..0] Receive data value                                                 */
            uint32            : 23;
    } bit;
  } RDR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000028) Transmit data register                                     */
    
    struct {
      __IOM uint32 TDR        : 9;            /*!< [8..0] Transmit data value                                                */
            uint32            : 23;
    } bit;
  } TDR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000002C) Prescaler register                                         */
    
    struct {
      __IOM uint32 PRESCALER  : 4;            /*!< [3..0] Clock prescaler                                                    */
            uint32            : 28;
    } bit;
  } PRESC;
} LPUART1_Type;                                 /*!< Size = 48 (0x30)                                                          */



/* =========================================================================================================================== */
/* ================                                          SYSCFG                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief System configuration controller (SYSCFG)
  */

typedef struct {                                /*!< (@ 0x58000400) SYSCFG Structure                                           */
  __IM  uint32  RESERVED;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) peripheral mode configuration register                     */
    
    struct {
      __IOM uint32 I2C1FMP    : 1;            /*!< [0..0] I2C1 Fm+                                                           */
      __IOM uint32 I2C2FMP    : 1;            /*!< [1..1] I2C2 Fm+                                                           */
      __IOM uint32 I2C3FMP    : 1;            /*!< [2..2] I2C3 Fm+                                                           */
      __IOM uint32 I2C4FMP    : 1;            /*!< [3..3] I2C4 Fm+                                                           */
      __IOM uint32 PB6FMP     : 1;            /*!< [4..4] PB(6) Fm+                                                          */
      __IOM uint32 PB7FMP     : 1;            /*!< [5..5] PB(7) Fast Mode Plus                                               */
      __IOM uint32 PB8FMP     : 1;            /*!< [6..6] PB(8) Fast Mode Plus                                               */
      __IOM uint32 PB9FMP     : 1;            /*!< [7..7] PB(9) Fm+                                                          */
      __IOM uint32 BOOSTE     : 1;            /*!< [8..8] Booster Enable                                                     */
            uint32            : 12;
      __IOM uint32 EPIS       : 3;            /*!< [23..21] Ethernet PHY Interface Selection                                 */
      __IOM uint32 PA0SO      : 1;            /*!< [24..24] PA0 Switch Open                                                  */
      __IOM uint32 PA1SO      : 1;            /*!< [25..25] PA1 Switch Open                                                  */
      __IOM uint32 PC2SO      : 1;            /*!< [26..26] PC2 Switch Open                                                  */
      __IOM uint32 PC3SO      : 1;            /*!< [27..27] PC3 Switch Open                                                  */
            uint32            : 4;
    } bit;
  } PMCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) external interrupt configuration register 1                */
    
    struct {
      __IOM uint32 EXTI0      : 4;            /*!< [3..0] EXTI x configuration (x = 0 to 3)                                  */
      __IOM uint32 EXTI1      : 4;            /*!< [7..4] EXTI x configuration (x = 0 to 3)                                  */
      __IOM uint32 EXTI2      : 4;            /*!< [11..8] EXTI x configuration (x = 0 to 3)                                 */
      __IOM uint32 EXTI3      : 4;            /*!< [15..12] EXTI x configuration (x = 0 to 3)                                */
            uint32            : 16;
    } bit;
  } EXTICR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) external interrupt configuration register 2                */
    
    struct {
      __IOM uint32 EXTI4      : 4;            /*!< [3..0] EXTI x configuration (x = 4 to 7)                                  */
      __IOM uint32 EXTI5      : 4;            /*!< [7..4] EXTI x configuration (x = 4 to 7)                                  */
      __IOM uint32 EXTI6      : 4;            /*!< [11..8] EXTI x configuration (x = 4 to 7)                                 */
      __IOM uint32 EXTI7      : 4;            /*!< [15..12] EXTI x configuration (x = 4 to 7)                                */
            uint32            : 16;
    } bit;
  } EXTICR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) external interrupt configuration register 3                */
    
    struct {
      __IOM uint32 EXTI8      : 4;            /*!< [3..0] EXTI x configuration (x = 8 to 11)                                 */
      __IOM uint32 EXTI9      : 4;            /*!< [7..4] EXTI x configuration (x = 8 to 11)                                 */
      __IOM uint32 EXTI10     : 4;            /*!< [11..8] EXTI10                                                            */
      __IOM uint32 EXTI11     : 4;            /*!< [15..12] EXTI x configuration (x = 8 to 11)                               */
            uint32            : 16;
    } bit;
  } EXTICR3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000014) external interrupt configuration register 4                */
    
    struct {
      __IOM uint32 EXTI12     : 4;            /*!< [3..0] EXTI x configuration (x = 12 to 15)                                */
      __IOM uint32 EXTI13     : 4;            /*!< [7..4] EXTI x configuration (x = 12 to 15)                                */
      __IOM uint32 EXTI14     : 4;            /*!< [11..8] EXTI x configuration (x = 12 to 15)                               */
      __IOM uint32 EXTI15     : 4;            /*!< [15..12] EXTI x configuration (x = 12 to 15)                              */
            uint32            : 16;
    } bit;
  } EXTICR4;
  __IM  uint32  RESERVED1[2];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000020) compensation cell control/status register                  */
    
    struct {
      __IOM uint32 EN         : 1;            /*!< [0..0] enable                                                             */
      __IOM uint32 CS         : 1;            /*!< [1..1] Code selection                                                     */
            uint32            : 6;
      __IOM uint32 READY      : 1;            /*!< [8..8] Compensation cell ready flag                                       */
            uint32            : 7;
      __IOM uint32 HSLV       : 1;            /*!< [16..16] High-speed at low-voltage                                        */
            uint32            : 15;
    } bit;
  } CCCSR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000024) SYSCFG compensation cell value register                    */
    
    struct {
      __IM  uint32 NCV        : 4;            /*!< [3..0] NMOS compensation value                                            */
      __IM  uint32 PCV        : 4;            /*!< [7..4] PMOS compensation value                                            */
            uint32            : 24;
    } bit;
  } CCVR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000028) SYSCFG compensation cell code register                     */
    
    struct {
      __IOM uint32 NCC        : 4;            /*!< [3..0] NMOS compensation code                                             */
      __IOM uint32 PCC        : 4;            /*!< [7..4] PMOS compensation code                                             */
            uint32            : 24;
    } bit;
  } CCCR;
  __IM  uint32  RESERVED2[62];
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000124) SYSCFG package register                                    */
    
    struct {
      __IM  uint32 PKG        : 4;            /*!< [3..0] Package                                                            */
            uint32            : 28;
    } bit;
  } PKGR;
  __IM  uint32  RESERVED3[118];
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000300) SYSCFG user register 0                                     */
    
    struct {
      __IM  uint32 BKS        : 1;            /*!< [0..0] Bank Swap                                                          */
            uint32            : 15;
      __IM  uint32 RDP        : 8;            /*!< [23..16] Readout protection                                               */
            uint32            : 8;
    } bit;
  } UR0;
  __IM  uint32  RESERVED4;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000308) SYSCFG user register 2                                     */
    
    struct {
      __IOM uint32 BORH       : 2;            /*!< [1..0] BOR_LVL Brownout Reset Threshold Level                             */
            uint32            : 14;
      __IOM uint32 BOOT_ADD0  : 16;           /*!< [31..16] Boot Address 0                                                   */
    } bit;
  } UR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000030C) SYSCFG user register 3                                     */
    
    struct {
            uint32            : 16;
      __IOM uint32 BOOT_ADD1  : 16;           /*!< [31..16] Boot Address 1                                                   */
    } bit;
  } UR3;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000310) SYSCFG user register 4                                     */
    
    struct {
            uint32            : 16;
      __IM  uint32 MEPAD_1    : 1;            /*!< [16..16] Mass Erase Protected Area Disabled for bank 1                    */
            uint32            : 15;
    } bit;
  } UR4;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000314) SYSCFG user register 5                                     */
    
    struct {
      __IM  uint32 MESAD_1    : 1;            /*!< [0..0] Mass erase secured area disabled for bank 1                        */
            uint32            : 15;
      __IM  uint32 WRPN_1     : 8;            /*!< [23..16] Write protection for flash bank 1                                */
            uint32            : 8;
    } bit;
  } UR5;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000318) SYSCFG user register 6                                     */
    
    struct {
      __IM  uint32 PA_BEG_1   : 12;           /*!< [11..0] Protected area start address for bank 1                           */
            uint32            : 4;
      __IM  uint32 PA_END_1   : 12;           /*!< [27..16] Protected area end address for bank 1                            */
            uint32            : 4;
    } bit;
  } UR6;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000031C) SYSCFG user register 7                                     */
    
    struct {
      __IM  uint32 SA_BEG_1   : 12;           /*!< [11..0] Secured area start address for bank 1                             */
            uint32            : 4;
      __IM  uint32 SA_END_1   : 12;           /*!< [27..16] Secured area end address for bank 1                              */
            uint32            : 4;
    } bit;
  } UR7;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000320) SYSCFG user register 8                                     */
    
    struct {
      __IM  uint32 MEPAD_2    : 1;            /*!< [0..0] Mass erase protected area disabled for bank 2                      */
            uint32            : 15;
      __IM  uint32 MESAD_2    : 1;            /*!< [16..16] Mass erase secured area disabled for bank 2                      */
            uint32            : 15;
    } bit;
  } UR8;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000324) SYSCFG user register 9                                     */
    
    struct {
      __IM  uint32 WRPN_2     : 8;            /*!< [7..0] Write protection for flash bank 2                                  */
            uint32            : 8;
      __IM  uint32 PA_BEG_2   : 12;           /*!< [27..16] Protected area start address for bank 2                          */
            uint32            : 4;
    } bit;
  } UR9;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000328) SYSCFG user register 10                                    */
    
    struct {
      __IM  uint32 PA_END_2   : 12;           /*!< [11..0] Protected area end address for bank 2                             */
            uint32            : 4;
      __IM  uint32 SA_BEG_2   : 12;           /*!< [27..16] Secured area start address for bank 2                            */
            uint32            : 4;
    } bit;
  } UR10;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000032C) SYSCFG user register 11                                    */
    
    struct {
      __IM  uint32 SA_END_2   : 12;           /*!< [11..0] Secured area end address for bank 2                               */
            uint32            : 4;
      __IM  uint32 IWDG1M     : 1;            /*!< [16..16] Independent Watchdog 1 mode                                      */
            uint32            : 15;
    } bit;
  } UR11;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000330) SYSCFG user register 12                                    */
    
    struct {
            uint32            : 16;
      __IM  uint32 SECURE     : 1;            /*!< [16..16] Secure mode                                                      */
            uint32            : 15;
    } bit;
  } UR12;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000334) SYSCFG user register 13                                    */
    
    struct {
      __IM  uint32 SDRS       : 2;            /*!< [1..0] Secured DTCM RAM Size                                              */
            uint32            : 14;
      __IM  uint32 D1SBRST    : 1;            /*!< [16..16] D1 Standby reset                                                 */
            uint32            : 15;
    } bit;
  } UR13;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000338) SYSCFG user register 14                                    */
    
    struct {
      __IOM uint32 D1STPRST   : 1;            /*!< [0..0] D1 Stop Reset                                                      */
            uint32            : 31;
    } bit;
  } UR14;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000033C) SYSCFG user register 15                                    */
    
    struct {
            uint32            : 16;
      __IM  uint32 FZIWDGSTB  : 1;            /*!< [16..16] Freeze independent watchdog in Standby mode                      */
            uint32            : 15;
    } bit;
  } UR15;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000340) SYSCFG user register 16                                    */
    
    struct {
      __IM  uint32 FZIWDGSTP  : 1;            /*!< [0..0] Freeze independent watchdog in Stop mode                           */
            uint32            : 15;
      __IM  uint32 PKP        : 1;            /*!< [16..16] Private key programmed                                           */
            uint32            : 15;
    } bit;
  } UR16;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000344) SYSCFG user register 17                                    */
    
    struct {
      __IM  uint32 IO_HSLV    : 1;            /*!< [0..0] I/O high speed / low voltage                                       */
            uint32            : 31;
    } bit;
  } UR17;
} SYSCFG_Type;                                  /*!< Size = 840 (0x348)                                                        */



/* =========================================================================================================================== */
/* ================                                           EXTI                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief External interrupt/event
      controller (EXTI)
  */

typedef struct {                                /*!< (@ 0x58000000) EXTI Structure                                             */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) EXTI rising trigger selection register                     */
    
    struct {
      __IOM uint32 TR0        : 1;            /*!< [0..0] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR1        : 1;            /*!< [1..1] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR2        : 1;            /*!< [2..2] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR3        : 1;            /*!< [3..3] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR4        : 1;            /*!< [4..4] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR5        : 1;            /*!< [5..5] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR6        : 1;            /*!< [6..6] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR7        : 1;            /*!< [7..7] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR8        : 1;            /*!< [8..8] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR9        : 1;            /*!< [9..9] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR10       : 1;            /*!< [10..10] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR11       : 1;            /*!< [11..11] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR12       : 1;            /*!< [12..12] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR13       : 1;            /*!< [13..13] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR14       : 1;            /*!< [14..14] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR15       : 1;            /*!< [15..15] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR16       : 1;            /*!< [16..16] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR17       : 1;            /*!< [17..17] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR18       : 1;            /*!< [18..18] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR19       : 1;            /*!< [19..19] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR20       : 1;            /*!< [20..20] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR21       : 1;            /*!< [21..21] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
            uint32            : 10;
    } bit;
  } RTSR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) EXTI falling trigger selection register                    */
    
    struct {
      __IOM uint32 TR0        : 1;            /*!< [0..0] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR1        : 1;            /*!< [1..1] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR2        : 1;            /*!< [2..2] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR3        : 1;            /*!< [3..3] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR4        : 1;            /*!< [4..4] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR5        : 1;            /*!< [5..5] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR6        : 1;            /*!< [6..6] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR7        : 1;            /*!< [7..7] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR8        : 1;            /*!< [8..8] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR9        : 1;            /*!< [9..9] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR10       : 1;            /*!< [10..10] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR11       : 1;            /*!< [11..11] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR12       : 1;            /*!< [12..12] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR13       : 1;            /*!< [13..13] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR14       : 1;            /*!< [14..14] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR15       : 1;            /*!< [15..15] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR16       : 1;            /*!< [16..16] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR17       : 1;            /*!< [17..17] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR18       : 1;            /*!< [18..18] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR19       : 1;            /*!< [19..19] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR20       : 1;            /*!< [20..20] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 TR21       : 1;            /*!< [21..21] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
            uint32            : 10;
    } bit;
  } FTSR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) EXTI software interrupt event register                     */
    
    struct {
      __IOM uint32 SWIER0     : 1;            /*!< [0..0] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 SWIER1     : 1;            /*!< [1..1] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 SWIER2     : 1;            /*!< [2..2] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 SWIER3     : 1;            /*!< [3..3] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 SWIER4     : 1;            /*!< [4..4] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 SWIER5     : 1;            /*!< [5..5] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 SWIER6     : 1;            /*!< [6..6] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 SWIER7     : 1;            /*!< [7..7] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 SWIER8     : 1;            /*!< [8..8] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 SWIER9     : 1;            /*!< [9..9] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 SWIER10    : 1;            /*!< [10..10] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 SWIER11    : 1;            /*!< [11..11] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 SWIER12    : 1;            /*!< [12..12] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 SWIER13    : 1;            /*!< [13..13] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 SWIER14    : 1;            /*!< [14..14] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 SWIER15    : 1;            /*!< [15..15] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 SWIER16    : 1;            /*!< [16..16] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 SWIER17    : 1;            /*!< [17..17] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 SWIER18    : 1;            /*!< [18..18] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 SWIER19    : 1;            /*!< [19..19] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 SWIER20    : 1;            /*!< [20..20] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 SWIER21    : 1;            /*!< [21..21] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
            uint32            : 10;
    } bit;
  } SWIER1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) EXTI D3 pending mask register                              */
    
    struct {
      __IOM uint32 MR0        : 1;            /*!< [0..0] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR1        : 1;            /*!< [1..1] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR2        : 1;            /*!< [2..2] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR3        : 1;            /*!< [3..3] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR4        : 1;            /*!< [4..4] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR5        : 1;            /*!< [5..5] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR6        : 1;            /*!< [6..6] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR7        : 1;            /*!< [7..7] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR8        : 1;            /*!< [8..8] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR9        : 1;            /*!< [9..9] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR10       : 1;            /*!< [10..10] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR11       : 1;            /*!< [11..11] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR12       : 1;            /*!< [12..12] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR13       : 1;            /*!< [13..13] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR14       : 1;            /*!< [14..14] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR15       : 1;            /*!< [15..15] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
            uint32            : 3;
      __IOM uint32 MR19       : 1;            /*!< [19..19] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR20       : 1;            /*!< [20..20] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR21       : 1;            /*!< [21..21] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
            uint32            : 3;
      __IOM uint32 MR25       : 1;            /*!< [25..25] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
            uint32            : 6;
    } bit;
  } D3PMR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) EXTI D3 pending clear selection register low               */
    
    struct {
      __IOM uint32 PCS0       : 2;            /*!< [1..0] D3 Pending request clear input signal selection on Event
                                                     input x = truncate (n/2)                                                  */
      __IOM uint32 PCS1       : 2;            /*!< [3..2] D3 Pending request clear input signal selection on Event
                                                     input x = truncate (n/2)                                                  */
      __IOM uint32 PCS2       : 2;            /*!< [5..4] D3 Pending request clear input signal selection on Event
                                                     input x = truncate (n/2)                                                  */
      __IOM uint32 PCS3       : 2;            /*!< [7..6] D3 Pending request clear input signal selection on Event
                                                     input x = truncate (n/2)                                                  */
      __IOM uint32 PCS4       : 2;            /*!< [9..8] D3 Pending request clear input signal selection on Event
                                                     input x = truncate (n/2)                                                  */
      __IOM uint32 PCS5       : 2;            /*!< [11..10] D3 Pending request clear input signal selection on
                                                     Event input x = truncate (n/2)                                            */
      __IOM uint32 PCS6       : 2;            /*!< [13..12] D3 Pending request clear input signal selection on
                                                     Event input x = truncate (n/2)                                            */
      __IOM uint32 PCS7       : 2;            /*!< [15..14] D3 Pending request clear input signal selection on
                                                     Event input x = truncate (n/2)                                            */
      __IOM uint32 PCS8       : 2;            /*!< [17..16] D3 Pending request clear input signal selection on
                                                     Event input x = truncate (n/2)                                            */
      __IOM uint32 PCS9       : 2;            /*!< [19..18] D3 Pending request clear input signal selection on
                                                     Event input x = truncate (n/2)                                            */
      __IOM uint32 PCS10      : 2;            /*!< [21..20] D3 Pending request clear input signal selection on
                                                     Event input x = truncate (n/2)                                            */
      __IOM uint32 PCS11      : 2;            /*!< [23..22] D3 Pending request clear input signal selection on
                                                     Event input x = truncate (n/2)                                            */
      __IOM uint32 PCS12      : 2;            /*!< [25..24] D3 Pending request clear input signal selection on
                                                     Event input x = truncate (n/2)                                            */
      __IOM uint32 PCS13      : 2;            /*!< [27..26] D3 Pending request clear input signal selection on
                                                     Event input x = truncate (n/2)                                            */
      __IOM uint32 PCS14      : 2;            /*!< [29..28] D3 Pending request clear input signal selection on
                                                     Event input x = truncate (n/2)                                            */
      __IOM uint32 PCS15      : 2;            /*!< [31..30] D3 Pending request clear input signal selection on
                                                     Event input x = truncate (n/2)                                            */
    } bit;
  } D3PCR1L;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000014) EXTI D3 pending clear selection register high              */
    
    struct {
            uint32            : 6;
      __IOM uint32 PCS19      : 2;            /*!< [7..6] D3 Pending request clear input signal selection on Event
                                                     input x = truncate ((n+32)/2)                                             */
      __IOM uint32 PCS20      : 2;            /*!< [9..8] D3 Pending request clear input signal selection on Event
                                                     input x = truncate ((n+32)/2)                                             */
      __IOM uint32 PCS21      : 2;            /*!< [11..10] D3 Pending request clear input signal selection on
                                                     Event input x = truncate ((n+32)/2)                                       */
            uint32            : 6;
      __IOM uint32 PCS25      : 2;            /*!< [19..18] D3 Pending request clear input signal selection on
                                                     Event input x = truncate ((n+32)/2)                                       */
            uint32            : 12;
    } bit;
  } D3PCR1H;
  __IM  uint32  RESERVED[2];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000020) EXTI rising trigger selection register                     */
    
    struct {
            uint32            : 17;
      __IOM uint32 TR49       : 1;            /*!< [17..17] Rising trigger event configuration bit of Configurable
                                                     Event input x+32                                                          */
            uint32            : 1;
      __IOM uint32 TR51       : 1;            /*!< [19..19] Rising trigger event configuration bit of Configurable
                                                     Event input x+32                                                          */
            uint32            : 12;
    } bit;
  } RTSR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000024) EXTI falling trigger selection register                    */
    
    struct {
            uint32            : 17;
      __IOM uint32 TR49       : 1;            /*!< [17..17] Falling trigger event configuration bit of Configurable
                                                     Event input x+32                                                          */
            uint32            : 1;
      __IOM uint32 TR51       : 1;            /*!< [19..19] Falling trigger event configuration bit of Configurable
                                                     Event input x+32                                                          */
            uint32            : 12;
    } bit;
  } FTSR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000028) EXTI software interrupt event register                     */
    
    struct {
            uint32            : 17;
      __IOM uint32 SWIER49    : 1;            /*!< [17..17] Software interrupt on line x+32                                  */
            uint32            : 1;
      __IOM uint32 SWIER51    : 1;            /*!< [19..19] Software interrupt on line x+32                                  */
            uint32            : 12;
    } bit;
  } SWIER2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000002C) EXTI D3 pending mask register                              */
    
    struct {
            uint32            : 2;
      __IOM uint32 MR34       : 1;            /*!< [2..2] D3 Pending Mask on Event input x+32                                */
      __IOM uint32 MR35       : 1;            /*!< [3..3] D3 Pending Mask on Event input x+32                                */
            uint32            : 5;
      __IOM uint32 MR41       : 1;            /*!< [9..9] D3 Pending Mask on Event input x+32                                */
            uint32            : 6;
      __IOM uint32 MR48       : 1;            /*!< [16..16] D3 Pending Mask on Event input x+32                              */
      __IOM uint32 MR49       : 1;            /*!< [17..17] D3 Pending Mask on Event input x+32                              */
      __IOM uint32 MR50       : 1;            /*!< [18..18] D3 Pending Mask on Event input x+32                              */
      __IOM uint32 MR51       : 1;            /*!< [19..19] D3 Pending Mask on Event input x+32                              */
      __IOM uint32 MR52       : 1;            /*!< [20..20] D3 Pending Mask on Event input x+32                              */
      __IOM uint32 MR53       : 1;            /*!< [21..21] D3 Pending Mask on Event input x+32                              */
            uint32            : 10;
    } bit;
  } D3PMR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000030) EXTI D3 pending clear selection register low               */
    
    struct {
            uint32            : 4;
      __IOM uint32 PCS34      : 2;            /*!< [5..4] D3 Pending request clear input signal selection on Event
                                                     input x = truncate ((n+64)/2)                                             */
      __IOM uint32 PCS35      : 2;            /*!< [7..6] D3 Pending request clear input signal selection on Event
                                                     input x = truncate ((n+64)/2)                                             */
            uint32            : 10;
      __IOM uint32 PCS41      : 2;            /*!< [19..18] D3 Pending request clear input signal selection on
                                                     Event input x = truncate ((n+64)/2)                                       */
            uint32            : 12;
    } bit;
  } D3PCR2L;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000034) EXTI D3 pending clear selection register high              */
    
    struct {
      __IOM uint32 PCS48      : 2;            /*!< [1..0] Pending request clear input signal selection on Event
                                                     input x= truncate ((n+96)/2)                                              */
      __IOM uint32 PCS49      : 2;            /*!< [3..2] Pending request clear input signal selection on Event
                                                     input x= truncate ((n+96)/2)                                              */
      __IOM uint32 PCS50      : 2;            /*!< [5..4] Pending request clear input signal selection on Event
                                                     input x= truncate ((n+96)/2)                                              */
      __IOM uint32 PCS51      : 2;            /*!< [7..6] Pending request clear input signal selection on Event
                                                     input x= truncate ((n+96)/2)                                              */
      __IOM uint32 PCS52      : 2;            /*!< [9..8] Pending request clear input signal selection on Event
                                                     input x= truncate ((n+96)/2)                                              */
      __IOM uint32 PCS53      : 2;            /*!< [11..10] Pending request clear input signal selection on Event
                                                     input x= truncate ((n+96)/2)                                              */
            uint32            : 20;
    } bit;
  } D3PCR2H;
  __IM  uint32  RESERVED1[2];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000040) EXTI rising trigger selection register                     */
    
    struct {
            uint32            : 18;
      __IOM uint32 TR82       : 1;            /*!< [18..18] Rising trigger event configuration bit of Configurable
                                                     Event input x+64                                                          */
            uint32            : 1;
      __IOM uint32 TR84       : 1;            /*!< [20..20] Rising trigger event configuration bit of Configurable
                                                     Event input x+64                                                          */
      __IOM uint32 TR85       : 1;            /*!< [21..21] Rising trigger event configuration bit of Configurable
                                                     Event input x+64                                                          */
      __IOM uint32 TR86       : 1;            /*!< [22..22] Rising trigger event configuration bit of Configurable
                                                     Event input x+64                                                          */
            uint32            : 9;
    } bit;
  } RTSR3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000044) EXTI falling trigger selection register                    */
    
    struct {
            uint32            : 18;
      __IOM uint32 TR82       : 1;            /*!< [18..18] Falling trigger event configuration bit of Configurable
                                                     Event input x+64                                                          */
            uint32            : 1;
      __IOM uint32 TR84       : 1;            /*!< [20..20] Falling trigger event configuration bit of Configurable
                                                     Event input x+64                                                          */
      __IOM uint32 TR85       : 1;            /*!< [21..21] Falling trigger event configuration bit of Configurable
                                                     Event input x+64                                                          */
      __IOM uint32 TR86       : 1;            /*!< [22..22] Falling trigger event configuration bit of Configurable
                                                     Event input x+64                                                          */
            uint32            : 9;
    } bit;
  } FTSR3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000048) EXTI software interrupt event register                     */
    
    struct {
            uint32            : 18;
      __IOM uint32 SWIER82    : 1;            /*!< [18..18] Software interrupt on line x+64                                  */
            uint32            : 1;
      __IOM uint32 SWIER84    : 1;            /*!< [20..20] Software interrupt on line x+64                                  */
      __IOM uint32 SWIER85    : 1;            /*!< [21..21] Software interrupt on line x+64                                  */
      __IOM uint32 SWIER86    : 1;            /*!< [22..22] Software interrupt on line x+64                                  */
            uint32            : 9;
    } bit;
  } SWIER3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000004C) EXTI D3 pending mask register                              */
    
    struct {
            uint32            : 24;
      __IOM uint32 MR88       : 1;            /*!< [24..24] D3 Pending Mask on Event input x+64                              */
            uint32            : 7;
    } bit;
  } D3PMR3;
  __IM  uint32  RESERVED2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000054) EXTI D3 pending clear selection register high              */
    
    struct {
            uint32            : 18;
      __IOM uint32 PCS88      : 2;            /*!< [19..18] D3 Pending request clear input signal selection on
                                                     Event input x= truncate N+160/2                                           */
            uint32            : 12;
    } bit;
  } D3PCR3H;
  __IM  uint32  RESERVED3[10];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000080) EXTI interrupt mask register                               */
    
    struct {
      __IOM uint32 MR0        : 1;            /*!< [0..0] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR1        : 1;            /*!< [1..1] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR2        : 1;            /*!< [2..2] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR3        : 1;            /*!< [3..3] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR4        : 1;            /*!< [4..4] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR5        : 1;            /*!< [5..5] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR6        : 1;            /*!< [6..6] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR7        : 1;            /*!< [7..7] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR8        : 1;            /*!< [8..8] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR9        : 1;            /*!< [9..9] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR10       : 1;            /*!< [10..10] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR11       : 1;            /*!< [11..11] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR12       : 1;            /*!< [12..12] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR13       : 1;            /*!< [13..13] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR14       : 1;            /*!< [14..14] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR15       : 1;            /*!< [15..15] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR16       : 1;            /*!< [16..16] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR17       : 1;            /*!< [17..17] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR18       : 1;            /*!< [18..18] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR19       : 1;            /*!< [19..19] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR20       : 1;            /*!< [20..20] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR21       : 1;            /*!< [21..21] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR22       : 1;            /*!< [22..22] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR23       : 1;            /*!< [23..23] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR24       : 1;            /*!< [24..24] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR25       : 1;            /*!< [25..25] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR26       : 1;            /*!< [26..26] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR27       : 1;            /*!< [27..27] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR28       : 1;            /*!< [28..28] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR29       : 1;            /*!< [29..29] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR30       : 1;            /*!< [30..30] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32 MR31       : 1;            /*!< [31..31] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
    } bit;
  } CPUIMR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000084) EXTI event mask register                                   */
    
    struct {
      __IOM uint32 MR0        : 1;            /*!< [0..0] CPU Event mask on Event input x                                    */
      __IOM uint32 MR1        : 1;            /*!< [1..1] CPU Event mask on Event input x                                    */
      __IOM uint32 MR2        : 1;            /*!< [2..2] CPU Event mask on Event input x                                    */
      __IOM uint32 MR3        : 1;            /*!< [3..3] CPU Event mask on Event input x                                    */
      __IOM uint32 MR4        : 1;            /*!< [4..4] CPU Event mask on Event input x                                    */
      __IOM uint32 MR5        : 1;            /*!< [5..5] CPU Event mask on Event input x                                    */
      __IOM uint32 MR6        : 1;            /*!< [6..6] CPU Event mask on Event input x                                    */
      __IOM uint32 MR7        : 1;            /*!< [7..7] CPU Event mask on Event input x                                    */
      __IOM uint32 MR8        : 1;            /*!< [8..8] CPU Event mask on Event input x                                    */
      __IOM uint32 MR9        : 1;            /*!< [9..9] CPU Event mask on Event input x                                    */
      __IOM uint32 MR10       : 1;            /*!< [10..10] CPU Event mask on Event input x                                  */
      __IOM uint32 MR11       : 1;            /*!< [11..11] CPU Event mask on Event input x                                  */
      __IOM uint32 MR12       : 1;            /*!< [12..12] CPU Event mask on Event input x                                  */
      __IOM uint32 MR13       : 1;            /*!< [13..13] CPU Event mask on Event input x                                  */
      __IOM uint32 MR14       : 1;            /*!< [14..14] CPU Event mask on Event input x                                  */
      __IOM uint32 MR15       : 1;            /*!< [15..15] CPU Event mask on Event input x                                  */
      __IOM uint32 MR16       : 1;            /*!< [16..16] CPU Event mask on Event input x                                  */
      __IOM uint32 MR17       : 1;            /*!< [17..17] CPU Event mask on Event input x                                  */
      __IOM uint32 MR18       : 1;            /*!< [18..18] CPU Event mask on Event input x                                  */
      __IOM uint32 MR19       : 1;            /*!< [19..19] CPU Event mask on Event input x                                  */
      __IOM uint32 MR20       : 1;            /*!< [20..20] CPU Event mask on Event input x                                  */
      __IOM uint32 MR21       : 1;            /*!< [21..21] CPU Event mask on Event input x                                  */
      __IOM uint32 MR22       : 1;            /*!< [22..22] CPU Event mask on Event input x                                  */
      __IOM uint32 MR23       : 1;            /*!< [23..23] CPU Event mask on Event input x                                  */
      __IOM uint32 MR24       : 1;            /*!< [24..24] CPU Event mask on Event input x                                  */
      __IOM uint32 MR25       : 1;            /*!< [25..25] CPU Event mask on Event input x                                  */
      __IOM uint32 MR26       : 1;            /*!< [26..26] CPU Event mask on Event input x                                  */
      __IOM uint32 MR27       : 1;            /*!< [27..27] CPU Event mask on Event input x                                  */
      __IOM uint32 MR28       : 1;            /*!< [28..28] CPU Event mask on Event input x                                  */
      __IOM uint32 MR29       : 1;            /*!< [29..29] CPU Event mask on Event input x                                  */
      __IOM uint32 MR30       : 1;            /*!< [30..30] CPU Event mask on Event input x                                  */
      __IOM uint32 MR31       : 1;            /*!< [31..31] CPU Event mask on Event input x                                  */
    } bit;
  } CPUEMR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000088) EXTI pending register                                      */
    
    struct {
      __IOM uint32 PR0        : 1;            /*!< [0..0] CPU Event mask on Event input x                                    */
      __IOM uint32 PR1        : 1;            /*!< [1..1] CPU Event mask on Event input x                                    */
      __IOM uint32 PR2        : 1;            /*!< [2..2] CPU Event mask on Event input x                                    */
      __IOM uint32 PR3        : 1;            /*!< [3..3] CPU Event mask on Event input x                                    */
      __IOM uint32 PR4        : 1;            /*!< [4..4] CPU Event mask on Event input x                                    */
      __IOM uint32 PR5        : 1;            /*!< [5..5] CPU Event mask on Event input x                                    */
      __IOM uint32 PR6        : 1;            /*!< [6..6] CPU Event mask on Event input x                                    */
      __IOM uint32 PR7        : 1;            /*!< [7..7] CPU Event mask on Event input x                                    */
      __IOM uint32 PR8        : 1;            /*!< [8..8] CPU Event mask on Event input x                                    */
      __IOM uint32 PR9        : 1;            /*!< [9..9] CPU Event mask on Event input x                                    */
      __IOM uint32 PR10       : 1;            /*!< [10..10] CPU Event mask on Event input x                                  */
      __IOM uint32 PR11       : 1;            /*!< [11..11] CPU Event mask on Event input x                                  */
      __IOM uint32 PR12       : 1;            /*!< [12..12] CPU Event mask on Event input x                                  */
      __IOM uint32 PR13       : 1;            /*!< [13..13] CPU Event mask on Event input x                                  */
      __IOM uint32 PR14       : 1;            /*!< [14..14] CPU Event mask on Event input x                                  */
      __IOM uint32 PR15       : 1;            /*!< [15..15] CPU Event mask on Event input x                                  */
      __IOM uint32 PR16       : 1;            /*!< [16..16] CPU Event mask on Event input x                                  */
      __IOM uint32 PR17       : 1;            /*!< [17..17] CPU Event mask on Event input x                                  */
      __IOM uint32 PR18       : 1;            /*!< [18..18] CPU Event mask on Event input x                                  */
      __IOM uint32 PR19       : 1;            /*!< [19..19] CPU Event mask on Event input x                                  */
      __IOM uint32 PR20       : 1;            /*!< [20..20] CPU Event mask on Event input x                                  */
      __IOM uint32 PR21       : 1;            /*!< [21..21] CPU Event mask on Event input x                                  */
            uint32            : 10;
    } bit;
  } CPUPR1;
  __IM  uint32  RESERVED4;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000090) EXTI interrupt mask register                               */
    
    struct {
      __IOM uint32 MR0        : 1;            /*!< [0..0] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32 MR1        : 1;            /*!< [1..1] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32 MR2        : 1;            /*!< [2..2] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32 MR3        : 1;            /*!< [3..3] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32 MR4        : 1;            /*!< [4..4] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32 MR5        : 1;            /*!< [5..5] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32 MR6        : 1;            /*!< [6..6] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32 MR7        : 1;            /*!< [7..7] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32 MR8        : 1;            /*!< [8..8] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32 MR9        : 1;            /*!< [9..9] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32 MR10       : 1;            /*!< [10..10] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32 MR11       : 1;            /*!< [11..11] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32 MR12       : 1;            /*!< [12..12] CPU Interrupt Mask on Direct Event input x+32                    */
            uint32            : 1;
      __IOM uint32 MR14       : 1;            /*!< [14..14] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32 MR15       : 1;            /*!< [15..15] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32 MR16       : 1;            /*!< [16..16] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32 MR17       : 1;            /*!< [17..17] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32 MR18       : 1;            /*!< [18..18] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32 MR19       : 1;            /*!< [19..19] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32 MR20       : 1;            /*!< [20..20] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32 MR21       : 1;            /*!< [21..21] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32 MR22       : 1;            /*!< [22..22] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32 MR23       : 1;            /*!< [23..23] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32 MR24       : 1;            /*!< [24..24] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32 MR25       : 1;            /*!< [25..25] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32 MR26       : 1;            /*!< [26..26] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32 MR27       : 1;            /*!< [27..27] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32 MR28       : 1;            /*!< [28..28] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32 MR29       : 1;            /*!< [29..29] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32 MR30       : 1;            /*!< [30..30] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32 MR31       : 1;            /*!< [31..31] CPU Interrupt Mask on Direct Event input x+32                    */
    } bit;
  } CPUIMR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000094) EXTI event mask register                                   */
    
    struct {
      __IOM uint32 MR32       : 1;            /*!< [0..0] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32 MR33       : 1;            /*!< [1..1] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32 MR34       : 1;            /*!< [2..2] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32 MR35       : 1;            /*!< [3..3] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32 MR36       : 1;            /*!< [4..4] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32 MR37       : 1;            /*!< [5..5] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32 MR38       : 1;            /*!< [6..6] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32 MR39       : 1;            /*!< [7..7] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32 MR40       : 1;            /*!< [8..8] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32 MR41       : 1;            /*!< [9..9] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32 MR42       : 1;            /*!< [10..10] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32 MR43       : 1;            /*!< [11..11] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32 MR44       : 1;            /*!< [12..12] CPU Interrupt Mask on Direct Event input x+32                    */
            uint32            : 1;
      __IOM uint32 MR46       : 1;            /*!< [14..14] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32 MR47       : 1;            /*!< [15..15] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32 MR48       : 1;            /*!< [16..16] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32 MR49       : 1;            /*!< [17..17] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32 MR50       : 1;            /*!< [18..18] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32 MR51       : 1;            /*!< [19..19] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32 MR52       : 1;            /*!< [20..20] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32 MR53       : 1;            /*!< [21..21] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32 MR54       : 1;            /*!< [22..22] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32 MR55       : 1;            /*!< [23..23] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32 MR56       : 1;            /*!< [24..24] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32 MR57       : 1;            /*!< [25..25] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32 MR58       : 1;            /*!< [26..26] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32 MR59       : 1;            /*!< [27..27] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32 MR60       : 1;            /*!< [28..28] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32 MR61       : 1;            /*!< [29..29] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32 MR62       : 1;            /*!< [30..30] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32 MR63       : 1;            /*!< [31..31] CPU Interrupt Mask on Direct Event input x+32                    */
    } bit;
  } CPUEMR2;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000098) EXTI pending register                                      */
    
    struct {
            uint32            : 17;
      __IM  uint32 PR49       : 1;            /*!< [17..17] Configurable event inputs x+32 Pending bit                       */
            uint32            : 1;
      __IM  uint32 PR51       : 1;            /*!< [19..19] Configurable event inputs x+32 Pending bit                       */
            uint32            : 12;
    } bit;
  } CPUPR2;
  __IM  uint32  RESERVED5;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000000A0) EXTI interrupt mask register                               */
    
    struct {
      __IM  uint32 MR64       : 1;            /*!< [0..0] CPU Interrupt Mask on Direct Event input x+64                      */
      __IM  uint32 MR65       : 1;            /*!< [1..1] CPU Interrupt Mask on Direct Event input x+64                      */
      __IM  uint32 MR66       : 1;            /*!< [2..2] CPU Interrupt Mask on Direct Event input x+64                      */
      __IM  uint32 MR67       : 1;            /*!< [3..3] CPU Interrupt Mask on Direct Event input x+64                      */
      __IM  uint32 MR68       : 1;            /*!< [4..4] CPU Interrupt Mask on Direct Event input x+64                      */
      __IM  uint32 MR69       : 1;            /*!< [5..5] CPU Interrupt Mask on Direct Event input x+64                      */
      __IM  uint32 MR70       : 1;            /*!< [6..6] CPU Interrupt Mask on Direct Event input x+64                      */
      __IM  uint32 MR71       : 1;            /*!< [7..7] CPU Interrupt Mask on Direct Event input x+64                      */
      __IM  uint32 MR72       : 1;            /*!< [8..8] CPU Interrupt Mask on Direct Event input x+64                      */
      __IM  uint32 MR73       : 1;            /*!< [9..9] CPU Interrupt Mask on Direct Event input x+64                      */
      __IM  uint32 MR74       : 1;            /*!< [10..10] CPU Interrupt Mask on Direct Event input x+64                    */
      __IM  uint32 MR75       : 1;            /*!< [11..11] CPU Interrupt Mask on Direct Event input x+64                    */
      __IM  uint32 MR76       : 1;            /*!< [12..12] CPU Interrupt Mask on Direct Event input x+64                    */
      __IM  uint32 MR77       : 1;            /*!< [13..13] CPU Interrupt Mask on Direct Event input x+64                    */
      __IM  uint32 MR78       : 1;            /*!< [14..14] CPU Interrupt Mask on Direct Event input x+64                    */
      __IM  uint32 MR79       : 1;            /*!< [15..15] CPU Interrupt Mask on Direct Event input x+64                    */
      __IM  uint32 MR80       : 1;            /*!< [16..16] CPU Interrupt Mask on Direct Event input x+64                    */
            uint32            : 1;
      __IM  uint32 MR82       : 1;            /*!< [18..18] CPU Interrupt Mask on Direct Event input x+64                    */
            uint32            : 1;
      __IM  uint32 MR84       : 1;            /*!< [20..20] CPU Interrupt Mask on Direct Event input x+64                    */
      __IM  uint32 MR85       : 1;            /*!< [21..21] CPU Interrupt Mask on Direct Event input x+64                    */
      __IM  uint32 MR86       : 1;            /*!< [22..22] CPU Interrupt Mask on Direct Event input x+64                    */
      __IM  uint32 MR87       : 1;            /*!< [23..23] CPU Interrupt Mask on Direct Event input x+64                    */
      __IM  uint32 MR88       : 1;            /*!< [24..24] CPU Interrupt Mask on Direct Event input x+64                    */
            uint32            : 7;
    } bit;
  } CPUIMR3;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000000A4) EXTI event mask register                                   */
    
    struct {
      __IM  uint32 MR64       : 1;            /*!< [0..0] CPU Event mask on Event input x+64                                 */
      __IM  uint32 MR65       : 1;            /*!< [1..1] CPU Event mask on Event input x+64                                 */
      __IM  uint32 MR66       : 1;            /*!< [2..2] CPU Event mask on Event input x+64                                 */
      __IM  uint32 MR67       : 1;            /*!< [3..3] CPU Event mask on Event input x+64                                 */
      __IM  uint32 MR68       : 1;            /*!< [4..4] CPU Event mask on Event input x+64                                 */
      __IM  uint32 MR69       : 1;            /*!< [5..5] CPU Event mask on Event input x+64                                 */
      __IM  uint32 MR70       : 1;            /*!< [6..6] CPU Event mask on Event input x+64                                 */
      __IM  uint32 MR71       : 1;            /*!< [7..7] CPU Event mask on Event input x+64                                 */
      __IM  uint32 MR72       : 1;            /*!< [8..8] CPU Event mask on Event input x+64                                 */
      __IM  uint32 MR73       : 1;            /*!< [9..9] CPU Event mask on Event input x+64                                 */
      __IM  uint32 MR74       : 1;            /*!< [10..10] CPU Event mask on Event input x+64                               */
      __IM  uint32 MR75       : 1;            /*!< [11..11] CPU Event mask on Event input x+64                               */
      __IM  uint32 MR76       : 1;            /*!< [12..12] CPU Event mask on Event input x+64                               */
      __IM  uint32 MR77       : 1;            /*!< [13..13] CPU Event mask on Event input x+64                               */
      __IM  uint32 MR78       : 1;            /*!< [14..14] CPU Event mask on Event input x+64                               */
      __IM  uint32 MR79       : 1;            /*!< [15..15] CPU Event mask on Event input x+64                               */
      __IM  uint32 MR80       : 1;            /*!< [16..16] CPU Event mask on Event input x+64                               */
            uint32            : 1;
      __IM  uint32 MR82       : 1;            /*!< [18..18] CPU Event mask on Event input x+64                               */
            uint32            : 1;
      __IM  uint32 MR84       : 1;            /*!< [20..20] CPU Event mask on Event input x+64                               */
      __IM  uint32 MR85       : 1;            /*!< [21..21] CPU Event mask on Event input x+64                               */
      __IM  uint32 MR86       : 1;            /*!< [22..22] CPU Event mask on Event input x+64                               */
      __IM  uint32 MR87       : 1;            /*!< [23..23] CPU Event mask on Event input x+64                               */
      __IM  uint32 MR88       : 1;            /*!< [24..24] CPU Event mask on Event input x+64                               */
            uint32            : 7;
    } bit;
  } CPUEMR3;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000000A8) EXTI pending register                                      */
    
    struct {
            uint32            : 18;
      __IM  uint32 PR82       : 1;            /*!< [18..18] Configurable event inputs x+64 Pending bit                       */
            uint32            : 1;
      __IM  uint32 PR84       : 1;            /*!< [20..20] Configurable event inputs x+64 Pending bit                       */
      __IM  uint32 PR85       : 1;            /*!< [21..21] Configurable event inputs x+64 Pending bit                       */
      __IM  uint32 PR86       : 1;            /*!< [22..22] Configurable event inputs x+64 Pending bit                       */
            uint32            : 9;
    } bit;
  } CPUPR3;
} EXTI_Type;                                    /*!< Size = 172 (0xac)                                                         */



/* =========================================================================================================================== */
/* ================                                    DELAY_Block_SDMMC1                                     ================ */
/* =========================================================================================================================== */


/**
  * @brief DELAY_Block_SDMMC1 (DELAY_Block_SDMMC1)
  */

typedef struct {                                /*!< (@ 0x52008000) DELAY_Block_SDMMC1 Structure                               */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) DLYB control register                                      */
    
    struct {
      __IOM uint32 DEN        : 1;            /*!< [0..0] Delay block enable bit                                             */
      __IOM uint32 SEN        : 1;            /*!< [1..1] Sampler length enable bit                                          */
            uint32            : 30;
    } bit;
  } CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) DLYB configuration register                                */
    
    struct {
      __IOM uint32 SEL        : 4;            /*!< [3..0] Select the phase for the Output clock                              */
            uint32            : 4;
      __IOM uint32 UNIT       : 7;            /*!< [14..8] Delay Defines the delay of a Unit delay cell                      */
            uint32            : 1;
      __IOM uint32 LNG        : 12;           /*!< [27..16] Delay line length value                                          */
            uint32            : 3;
      __IOM uint32 LNGF       : 1;            /*!< [31..31] Length valid flag                                                */
    } bit;
  } CFGR;
} DELAY_Block_SDMMC1_Type;                      /*!< Size = 8 (0x8)                                                            */



/* =========================================================================================================================== */
/* ================                                           Flash                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Flash (Flash)
  */

typedef struct {                                /*!< (@ 0x52002000) Flash Structure                                            */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) Access control register                                    */
    
    struct {
      __IOM uint32 LATENCY    : 3;            /*!< [2..0] Read latency                                                       */
            uint32            : 1;
      __IOM uint32 WRHIGHFREQ : 2;            /*!< [5..4] Flash signal delay                                                 */
            uint32            : 26;
    } bit;
  } ACR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) FLASH key register for bank 1                              */
    
    struct {
      __IOM uint32 KEYR1      : 32;           /*!< [31..0] Bank 1 access configuration unlock key                            */
    } bit;
  } KEYR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) FLASH option key register                                  */
    
    struct {
      __IOM uint32 OPTKEYR    : 32;           /*!< [31..0] Unlock key option bytes                                           */
    } bit;
  } OPTKEYR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) FLASH control register for bank 1                          */
    
    struct {
      __IOM uint32 LOCK1      : 1;            /*!< [0..0] Bank 1 configuration lock bit                                      */
      __IOM uint32 PG1        : 1;            /*!< [1..1] Bank 1 program enable bit                                          */
      __IOM uint32 SER1       : 1;            /*!< [2..2] Bank 1 sector erase request                                        */
      __IOM uint32 BER1       : 1;            /*!< [3..3] Bank 1 erase request                                               */
      __IOM uint32 PSIZE1     : 2;            /*!< [5..4] Bank 1 program size                                                */
      __IOM uint32 FW1        : 1;            /*!< [6..6] Bank 1 write forcing control bit                                   */
      __IOM uint32 START1     : 1;            /*!< [7..7] Bank 1 bank or sector erase start control bit                      */
      __IOM uint32 SNB1       : 3;            /*!< [10..8] Bank 1 sector erase selection number                              */
            uint32            : 4;
      __IOM uint32 CRC_EN     : 1;            /*!< [15..15] Bank 1 CRC control bit                                           */
      __IOM uint32 EOPIE1     : 1;            /*!< [16..16] Bank 1 end-of-program interrupt control bit                      */
      __IOM uint32 WRPERRIE1  : 1;            /*!< [17..17] Bank 1 write protection error interrupt enable bit               */
      __IOM uint32 PGSERRIE1  : 1;            /*!< [18..18] Bank 1 programming sequence error interrupt enable
                                                     bit                                                                       */
      __IOM uint32 STRBERRIE1 : 1;            /*!< [19..19] Bank 1 strobe error interrupt enable bit                         */
            uint32            : 1;
      __IOM uint32 INCERRIE1  : 1;            /*!< [21..21] Bank 1 inconsistency error interrupt enable bit                  */
      __IOM uint32 OPERRIE1   : 1;            /*!< [22..22] Bank 1 write/erase error interrupt enable bit                    */
      __IOM uint32 RDPERRIE1  : 1;            /*!< [23..23] Bank 1 read protection error interrupt enable bit                */
      __IOM uint32 RDSERRIE1  : 1;            /*!< [24..24] Bank 1 secure error interrupt enable bit                         */
      __IOM uint32 SNECCERRIE1 : 1;           /*!< [25..25] Bank 1 ECC single correction error interrupt enable
                                                     bit                                                                       */
      __IOM uint32 DBECCERRIE1 : 1;           /*!< [26..26] Bank 1 ECC double detection error interrupt enable
                                                     bit                                                                       */
      __IOM uint32 CRCENDIE1  : 1;            /*!< [27..27] Bank 1 end of CRC calculation interrupt enable bit               */
            uint32            : 4;
    } bit;
  } CR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) FLASH status register for bank 1                           */
    
    struct {
      __IOM uint32 BSY1       : 1;            /*!< [0..0] Bank 1 ongoing program flag                                        */
      __IOM uint32 WBNE1      : 1;            /*!< [1..1] Bank 1 write buffer not empty flag                                 */
      __IOM uint32 QW1        : 1;            /*!< [2..2] Bank 1 wait queue flag                                             */
      __IOM uint32 CRC_BUSY1  : 1;            /*!< [3..3] Bank 1 CRC busy flag                                               */
            uint32            : 12;
      __IOM uint32 EOP1       : 1;            /*!< [16..16] Bank 1 end-of-program flag                                       */
      __IOM uint32 WRPERR1    : 1;            /*!< [17..17] Bank 1 write protection error flag                               */
      __IOM uint32 PGSERR1    : 1;            /*!< [18..18] Bank 1 programming sequence error flag                           */
      __IOM uint32 STRBERR1   : 1;            /*!< [19..19] Bank 1 strobe error flag                                         */
            uint32            : 1;
      __IOM uint32 INCERR1    : 1;            /*!< [21..21] Bank 1 inconsistency error flag                                  */
      __IOM uint32 OPERR1     : 1;            /*!< [22..22] Bank 1 write/erase error flag                                    */
      __IOM uint32 RDPERR1    : 1;            /*!< [23..23] Bank 1 read protection error flag                                */
      __IOM uint32 RDSERR1    : 1;            /*!< [24..24] Bank 1 secure error flag                                         */
      __IOM uint32 SNECCERR11 : 1;            /*!< [25..25] Bank 1 single correction error flag                              */
      __IOM uint32 DBECCERR1  : 1;            /*!< [26..26] Bank 1 ECC double detection error flag                           */
      __IOM uint32 CRCEND1    : 1;            /*!< [27..27] Bank 1 CRC-complete flag                                         */
            uint32            : 4;
    } bit;
  } SR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000014) FLASH clear control register for bank 1                    */
    
    struct {
            uint32            : 16;
      __IOM uint32 CLR_EOP1   : 1;            /*!< [16..16] Bank 1 EOP1 flag clear bit                                       */
      __IOM uint32 CLR_WRPERR1 : 1;           /*!< [17..17] Bank 1 WRPERR1 flag clear bit                                    */
      __IOM uint32 CLR_PGSERR1 : 1;           /*!< [18..18] Bank 1 PGSERR1 flag clear bi                                     */
      __IOM uint32 CLR_STRBERR1 : 1;          /*!< [19..19] Bank 1 STRBERR1 flag clear bit                                   */
            uint32            : 1;
      __IOM uint32 CLR_INCERR1 : 1;           /*!< [21..21] Bank 1 INCERR1 flag clear bit                                    */
      __IOM uint32 CLR_OPERR1 : 1;            /*!< [22..22] Bank 1 OPERR1 flag clear bit                                     */
      __IOM uint32 CLR_RDPERR1 : 1;           /*!< [23..23] Bank 1 RDPERR1 flag clear bit                                    */
      __IOM uint32 CLR_RDSERR1 : 1;           /*!< [24..24] Bank 1 RDSERR1 flag clear bit                                    */
      __IOM uint32 CLR_SNECCERR1 : 1;         /*!< [25..25] Bank 1 SNECCERR1 flag clear bit                                  */
      __IOM uint32 CLR_DBECCERR1 : 1;         /*!< [26..26] Bank 1 DBECCERR1 flag clear bit                                  */
      __IOM uint32 CLR_CRCEND1 : 1;           /*!< [27..27] Bank 1 CRCEND1 flag clear bit                                    */
            uint32            : 4;
    } bit;
  } CCR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000018) FLASH option control register                              */
    
    struct {
      __IOM uint32 OPTLOCK    : 1;            /*!< [0..0] FLASH_OPTCR lock option configuration bit                          */
      __IOM uint32 OPTSTART   : 1;            /*!< [1..1] Option byte start change option configuration bit                  */
            uint32            : 2;
      __IOM uint32 MER        : 1;            /*!< [4..4] Flash mass erase enable bit                                        */
            uint32            : 25;
      __IOM uint32 OPTCHANGEERRIE : 1;        /*!< [30..30] Option byte change error interrupt enable bit                    */
      __IOM uint32 SWAP_BANK  : 1;            /*!< [31..31] Bank swapping configuration bit                                  */
    } bit;
  } OPTCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000001C) FLASH option status register                               */
    
    struct {
      __IOM uint32 OPT_BUSY   : 1;            /*!< [0..0] Option byte change ongoing flag                                    */
            uint32            : 1;
      __IOM uint32 BOR_LEV    : 2;            /*!< [3..2] Brownout level option status bit                                   */
      __IOM uint32 IWDG1_HW   : 1;            /*!< [4..4] IWDG1 control option status bit                                    */
            uint32            : 1;
      __IOM uint32 nRST_STOP_D1 : 1;          /*!< [6..6] D1 DStop entry reset option status bit                             */
      __IOM uint32 nRST_STBY_D1 : 1;          /*!< [7..7] D1 DStandby entry reset option status bit                          */
      __IOM uint32 RDP        : 8;            /*!< [15..8] Readout protection level option status byte                       */
            uint32            : 1;
      __IOM uint32 FZ_IWDG_STOP : 1;          /*!< [17..17] IWDG Stop mode freeze option status bit                          */
      __IOM uint32 FZ_IWDG_SDBY : 1;          /*!< [18..18] IWDG Standby mode freeze option status bit                       */
      __IOM uint32 ST_RAM_SIZE : 2;           /*!< [20..19] DTCM RAM size option status                                      */
      __IOM uint32 SECURITY   : 1;            /*!< [21..21] Security enable option status bit                                */
            uint32            : 4;
      __IOM uint32 RSS1       : 1;            /*!< [26..26] User option bit 1                                                */
            uint32            : 1;
      __IOM uint32 PERSO_OK   : 1;            /*!< [28..28] Device personalization status bit                                */
      __IOM uint32 IO_HSLV    : 1;            /*!< [29..29] I/O high-speed at low-voltage status bit (PRODUCT_BELOW_25V)     */
      __IOM uint32 OPTCHANGEERR : 1;          /*!< [30..30] Option byte change error flag                                    */
      __IOM uint32 SWAP_BANK_OPT : 1;         /*!< [31..31] Bank swapping option status bit                                  */
    } bit;
  } OPTSR_CUR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000020) FLASH option status register                               */
    
    struct {
            uint32            : 2;
      __IOM uint32 BOR_LEV    : 2;            /*!< [3..2] BOR reset level option configuration bits                          */
      __IOM uint32 IWDG1_HW   : 1;            /*!< [4..4] IWDG1 option configuration bit                                     */
            uint32            : 1;
      __IOM uint32 nRST_STOP_D1 : 1;          /*!< [6..6] Option byte erase after D1 DStop option configuration
                                                     bit                                                                       */
      __IOM uint32 nRST_STBY_D1 : 1;          /*!< [7..7] Option byte erase after D1 DStandby option configuration
                                                     bit                                                                       */
      __IOM uint32 RDP        : 8;            /*!< [15..8] Readout protection level option configuration byte                */
            uint32            : 1;
      __IOM uint32 FZ_IWDG_STOP : 1;          /*!< [17..17] IWDG Stop mode freeze option configuration bit                   */
      __IOM uint32 FZ_IWDG_SDBY : 1;          /*!< [18..18] IWDG Standby mode freeze option configuration bit                */
      __IOM uint32 ST_RAM_SIZE : 2;           /*!< [20..19] DTCM size select option configuration bits                       */
      __IOM uint32 SECURITY   : 1;            /*!< [21..21] Security option configuration bit                                */
            uint32            : 4;
      __IOM uint32 RSS1       : 1;            /*!< [26..26] User option configuration bit 1                                  */
      __IOM uint32 RSS2       : 1;            /*!< [27..27] User option configuration bit 2                                  */
            uint32            : 1;
      __IOM uint32 IO_HSLV    : 1;            /*!< [29..29] I/O high-speed at low-voltage (PRODUCT_BELOW_25V)                */
            uint32            : 1;
      __IOM uint32 SWAP_BANK_OPT : 1;         /*!< [31..31] Bank swapping option configuration bit                           */
    } bit;
  } OPTSR_PRG;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000024) FLASH option clear control register                        */
    
    struct {
            uint32            : 30;
      __OM  uint32 CLR_OPTCHANGEERR : 1;      /*!< [30..30] OPTCHANGEERR reset bit                                           */
            uint32            : 1;
    } bit;
  } OPTCCR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000028) FLASH protection address for bank 1                        */
    
    struct {
      __IM  uint32 PROT_AREA_START1 : 12;     /*!< [11..0] Bank 1 lowest PCROP protected address                             */
            uint32            : 4;
      __IM  uint32 PROT_AREA_END1 : 12;       /*!< [27..16] Bank 1 highest PCROP protected address                           */
            uint32            : 3;
      __IM  uint32 DMEP1      : 1;            /*!< [31..31] Bank 1 PCROP protected erase enable option status bit            */
    } bit;
  } PRAR_CUR1;
  
  union {
    union {
      __IOM uint32 reg;                       /*!< (@ 0x0000002C) FLASH protection address for bank 1                        */
      
      struct {
        __IOM uint32 PROT_AREA_START1 : 12;   /*!< [11..0] Bank 1 lowest PCROP protected address configuration               */
              uint32          : 4;
        __IOM uint32 PROT_AREA_END1 : 12;     /*!< [27..16] Bank 1 highest PCROP protected address configuration             */
              uint32          : 3;
        __IOM uint32 DMEP1    : 1;            /*!< [31..31] Bank 1 PCROP protected erase enable option configuration
                                                     bit                                                                       */
      } bit;
    } PRAR_PRG1;
    
    union {
      __IOM uint32 reg;                       /*!< (@ 0x0000002C) FLASH protection address for bank 2                        */
      
      struct {
        __IOM uint32 PROT_AREA_START2 : 12;   /*!< [11..0] Bank 2 lowest PCROP protected address configuration               */
              uint32          : 4;
        __IOM uint32 PROT_AREA_END2 : 12;     /*!< [27..16] Bank 2 highest PCROP protected address configuration             */
              uint32          : 3;
        __IOM uint32 DMEP2    : 1;            /*!< [31..31] Bank 2 PCROP protected erase enable option configuration
                                                     bit                                                                       */
      } bit;
    } PRAR_PRG2;
  };
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000030) FLASH secure address for bank 1                            */
    
    struct {
      __IOM uint32 SEC_AREA_START1 : 12;      /*!< [11..0] Bank 1 lowest secure protected address                            */
            uint32            : 4;
      __IOM uint32 SEC_AREA_END1 : 12;        /*!< [27..16] Bank 1 highest secure protected address                          */
            uint32            : 3;
      __IOM uint32 DMES1      : 1;            /*!< [31..31] Bank 1 secure protected erase enable option status
                                                     bit                                                                       */
    } bit;
  } SCAR_CUR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000034) FLASH secure address for bank 1                            */
    
    struct {
      __IOM uint32 SEC_AREA_START1 : 12;      /*!< [11..0] Bank 1 lowest secure protected address configuration              */
            uint32            : 4;
      __IOM uint32 SEC_AREA_END1 : 12;        /*!< [27..16] Bank 1 highest secure protected address configuration            */
            uint32            : 3;
      __IOM uint32 DMES1      : 1;            /*!< [31..31] Bank 1 secure protected erase enable option configuration
                                                     bit                                                                       */
    } bit;
  } SCAR_PRG1;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000038) FLASH write sector protection for bank 1                   */
    
    struct {
      __IM  uint32 WRPSn1     : 8;            /*!< [7..0] Bank 1 sector write protection option status byte                  */
            uint32            : 24;
    } bit;
  } WPSN_CUR1R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000003C) FLASH write sector protection for bank 1                   */
    
    struct {
      __IOM uint32 WRPSn1     : 8;            /*!< [7..0] Bank 1 sector write protection configuration byte                  */
            uint32            : 24;
    } bit;
  } WPSN_PRG1R;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000040) FLASH register with boot address                           */
    
    struct {
      __IM  uint32 BOOT_ADD0  : 16;           /*!< [15..0] Boot address 0                                                    */
      __IM  uint32 BOOT_ADD1  : 16;           /*!< [31..16] Boot address 1                                                   */
    } bit;
  } BOOT_CURR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000044) FLASH register with boot address                           */
    
    struct {
      __IM  uint32 BOOT_ADD0  : 16;           /*!< [15..0] Boot address 0                                                    */
      __IM  uint32 BOOT_ADD1  : 16;           /*!< [31..16] Boot address 1                                                   */
    } bit;
  } BOOT_PRGR;
  __IM  uint32  RESERVED[2];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000050) FLASH CRC control register for bank 1                      */
    
    struct {
      __IOM uint32 CRC_SECT   : 3;            /*!< [2..0] Bank 1 CRC sector number                                           */
            uint32            : 4;
      __IOM uint32 ALL_BANK   : 1;            /*!< [7..7] Bank 1 CRC select bit                                              */
      __IOM uint32 CRC_BY_SECT : 1;           /*!< [8..8] Bank 1 CRC sector mode select bit                                  */
      __IOM uint32 ADD_SECT   : 1;            /*!< [9..9] Bank 1 CRC sector select bit                                       */
      __IOM uint32 CLEAN_SECT : 1;            /*!< [10..10] Bank 1 CRC sector list clear bit                                 */
            uint32            : 5;
      __IOM uint32 START_CRC  : 1;            /*!< [16..16] Bank 1 CRC start bit                                             */
      __IOM uint32 CLEAN_CRC  : 1;            /*!< [17..17] Bank 1 CRC clear bit                                             */
            uint32            : 2;
      __IOM uint32 CRC_BURST  : 2;            /*!< [21..20] Bank 1 CRC burst size                                            */
            uint32            : 10;
    } bit;
  } CRCCR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000054) FLASH CRC start address register for bank 1                */
    
    struct {
      __IOM uint32 CRC_START_ADDR : 32;       /*!< [31..0] CRC start address on bank 1                                       */
    } bit;
  } CRCSADD1R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000058) FLASH CRC end address register for bank 1                  */
    
    struct {
      __IOM uint32 CRC_END_ADDR : 32;         /*!< [31..0] CRC end address on bank 1                                         */
    } bit;
  } CRCEADD1R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000005C) FLASH CRC data register                                    */
    
    struct {
      __IOM uint32 CRC_DATA   : 32;           /*!< [31..0] CRC result                                                        */
    } bit;
  } CRCDATAR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000060) FLASH ECC fail address for bank 1                          */
    
    struct {
      __IM  uint32 FAIL_ECC_ADDR1 : 15;       /*!< [14..0] Bank 1 ECC error address                                          */
            uint32            : 17;
    } bit;
  } ECC_FA1R;
  __IM  uint32  RESERVED1[39];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000100) Access control register                                    */
    
    struct {
      __IOM uint32 LATENCY    : 3;            /*!< [2..0] Read latency                                                       */
            uint32            : 1;
      __IOM uint32 WRHIGHFREQ : 2;            /*!< [5..4] Flash signal delay                                                 */
            uint32            : 26;
    } bit;
  } ACR_;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000104) FLASH key register for bank 2                              */
    
    struct {
      __IM  uint32 KEYR2      : 32;           /*!< [31..0] Bank 2 access configuration unlock key                            */
    } bit;
  } KEYR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000108) FLASH option key register                                  */
    
    struct {
      __IOM uint32 OPTKEYR    : 32;           /*!< [31..0] Unlock key option bytes                                           */
    } bit;
  } OPTKEYR_;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000010C) FLASH control register for bank 2                          */
    
    struct {
      __IOM uint32 LOCK2      : 1;            /*!< [0..0] Bank 2 configuration lock bit                                      */
      __IOM uint32 PG2        : 1;            /*!< [1..1] Bank 2 program enable bit                                          */
      __IOM uint32 SER2       : 1;            /*!< [2..2] Bank 2 sector erase request                                        */
      __IOM uint32 BER2       : 1;            /*!< [3..3] Bank 2 erase request                                               */
      __IOM uint32 PSIZE2     : 2;            /*!< [5..4] Bank 2 program size                                                */
      __IOM uint32 FW2        : 1;            /*!< [6..6] Bank 2 write forcing control bit                                   */
      __IOM uint32 START2     : 1;            /*!< [7..7] Bank 2 bank or sector erase start control bit                      */
      __IOM uint32 SNB2       : 3;            /*!< [10..8] Bank 2 sector erase selection number                              */
            uint32            : 4;
      __IOM uint32 CRC_EN     : 1;            /*!< [15..15] Bank 2 CRC control bit                                           */
      __IOM uint32 EOPIE2     : 1;            /*!< [16..16] Bank 2 end-of-program interrupt control bit                      */
      __IOM uint32 WRPERRIE2  : 1;            /*!< [17..17] Bank 2 write protection error interrupt enable bit               */
      __IOM uint32 PGSERRIE2  : 1;            /*!< [18..18] Bank 2 programming sequence error interrupt enable
                                                     bit                                                                       */
      __IOM uint32 STRBERRIE2 : 1;            /*!< [19..19] Bank 2 strobe error interrupt enable bit                         */
            uint32            : 1;
      __IOM uint32 INCERRIE2  : 1;            /*!< [21..21] Bank 2 inconsistency error interrupt enable bit                  */
      __IOM uint32 OPERRIE2   : 1;            /*!< [22..22] Bank 2 write/erase error interrupt enable bit                    */
      __IOM uint32 RDPERRIE2  : 1;            /*!< [23..23] Bank 2 read protection error interrupt enable bit                */
      __IOM uint32 RDSERRIE2  : 1;            /*!< [24..24] Bank 2 secure error interrupt enable bit                         */
      __IOM uint32 SNECCERRIE2 : 1;           /*!< [25..25] Bank 2 ECC single correction error interrupt enable
                                                     bit                                                                       */
      __IOM uint32 DBECCERRIE2 : 1;           /*!< [26..26] Bank 2 ECC double detection error interrupt enable
                                                     bit                                                                       */
      __IOM uint32 CRCENDIE2  : 1;            /*!< [27..27] Bank 2 end of CRC calculation interrupt enable bit               */
            uint32            : 4;
    } bit;
  } CR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000110) FLASH status register for bank 2                           */
    
    struct {
      __IOM uint32 BSY2       : 1;            /*!< [0..0] Bank 2 ongoing program flag                                        */
      __IOM uint32 WBNE2      : 1;            /*!< [1..1] Bank 2 write buffer not empty flag                                 */
      __IOM uint32 QW2        : 1;            /*!< [2..2] Bank 2 wait queue flag                                             */
      __IOM uint32 CRC_BUSY2  : 1;            /*!< [3..3] Bank 2 CRC busy flag                                               */
            uint32            : 12;
      __IOM uint32 EOP2       : 1;            /*!< [16..16] Bank 2 end-of-program flag                                       */
      __IOM uint32 WRPERR2    : 1;            /*!< [17..17] Bank 2 write protection error flag                               */
      __IOM uint32 PGSERR2    : 1;            /*!< [18..18] Bank 2 programming sequence error flag                           */
      __IOM uint32 STRBERR2   : 1;            /*!< [19..19] Bank 2 strobe error flag                                         */
            uint32            : 1;
      __IOM uint32 INCERR2    : 1;            /*!< [21..21] Bank 2 inconsistency error flag                                  */
      __IOM uint32 OPERR2     : 1;            /*!< [22..22] Bank 2 write/erase error flag                                    */
      __IOM uint32 RDPERR2    : 1;            /*!< [23..23] Bank 2 read protection error flag                                */
      __IOM uint32 RDSERR2    : 1;            /*!< [24..24] Bank 2 secure error flag                                         */
      __IOM uint32 SNECCERR2  : 1;            /*!< [25..25] Bank 2 single correction error flag                              */
      __IOM uint32 DBECCERR2  : 1;            /*!< [26..26] Bank 2 ECC double detection error flag                           */
      __IOM uint32 CRCEND2    : 1;            /*!< [27..27] Bank 2 CRC-complete flag                                         */
            uint32            : 4;
    } bit;
  } SR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000114) FLASH clear control register for bank 2                    */
    
    struct {
            uint32            : 16;
      __IOM uint32 CLR_EOP2   : 1;            /*!< [16..16] Bank 1 EOP1 flag clear bit                                       */
      __IOM uint32 CLR_WRPERR2 : 1;           /*!< [17..17] Bank 2 WRPERR1 flag clear bit                                    */
      __IOM uint32 CLR_PGSERR2 : 1;           /*!< [18..18] Bank 2 PGSERR1 flag clear bi                                     */
      __IOM uint32 CLR_STRBERR2 : 1;          /*!< [19..19] Bank 2 STRBERR1 flag clear bit                                   */
            uint32            : 1;
      __IOM uint32 CLR_INCERR2 : 1;           /*!< [21..21] Bank 2 INCERR1 flag clear bit                                    */
      __IOM uint32 CLR_OPERR2 : 1;            /*!< [22..22] Bank 2 OPERR1 flag clear bit                                     */
      __IOM uint32 CLR_RDPERR2 : 1;           /*!< [23..23] Bank 2 RDPERR1 flag clear bit                                    */
      __IOM uint32 CLR_RDSERR1 : 1;           /*!< [24..24] Bank 1 RDSERR1 flag clear bit                                    */
      __IOM uint32 CLR_SNECCERR2 : 1;         /*!< [25..25] Bank 2 SNECCERR1 flag clear bit                                  */
      __IOM uint32 CLR_DBECCERR1 : 1;         /*!< [26..26] Bank 1 DBECCERR1 flag clear bit                                  */
      __IOM uint32 CLR_CRCEND2 : 1;           /*!< [27..27] Bank 2 CRCEND1 flag clear bit                                    */
            uint32            : 4;
    } bit;
  } CCR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000118) FLASH option control register                              */
    
    struct {
      __IOM uint32 OPTLOCK    : 1;            /*!< [0..0] FLASH_OPTCR lock option configuration bit                          */
      __IOM uint32 OPTSTART   : 1;            /*!< [1..1] Option byte start change option configuration bit                  */
            uint32            : 2;
      __IOM uint32 MER        : 1;            /*!< [4..4] Flash mass erase enable bit                                        */
            uint32            : 25;
      __IOM uint32 OPTCHANGEERRIE : 1;        /*!< [30..30] Option byte change error interrupt enable bit                    */
      __IOM uint32 SWAP_BANK  : 1;            /*!< [31..31] Bank swapping configuration bit                                  */
    } bit;
  } OPTCR_;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000011C) FLASH option status register                               */
    
    struct {
      __IOM uint32 OPT_BUSY   : 1;            /*!< [0..0] Option byte change ongoing flag                                    */
            uint32            : 1;
      __IOM uint32 BOR_LEV    : 2;            /*!< [3..2] Brownout level option status bit                                   */
      __IOM uint32 IWDG1_HW   : 1;            /*!< [4..4] IWDG1 control option status bit                                    */
            uint32            : 1;
      __IOM uint32 nRST_STOP_D1 : 1;          /*!< [6..6] D1 DStop entry reset option status bit                             */
      __IOM uint32 nRST_STBY_D1 : 1;          /*!< [7..7] D1 DStandby entry reset option status bit                          */
      __IOM uint32 RDP        : 8;            /*!< [15..8] Readout protection level option status byte                       */
            uint32            : 1;
      __IOM uint32 FZ_IWDG_STOP : 1;          /*!< [17..17] IWDG Stop mode freeze option status bit                          */
      __IOM uint32 FZ_IWDG_SDBY : 1;          /*!< [18..18] IWDG Standby mode freeze option status bit                       */
      __IOM uint32 ST_RAM_SIZE : 2;           /*!< [20..19] DTCM RAM size option status                                      */
      __IOM uint32 SECURITY   : 1;            /*!< [21..21] Security enable option status bit                                */
            uint32            : 4;
      __IOM uint32 RSS1       : 1;            /*!< [26..26] User option bit 1                                                */
            uint32            : 1;
      __IOM uint32 PERSO_OK   : 1;            /*!< [28..28] Device personalization status bit                                */
      __IOM uint32 IO_HSLV    : 1;            /*!< [29..29] I/O high-speed at low-voltage status bit (PRODUCT_BELOW_25V)     */
      __IOM uint32 OPTCHANGEERR : 1;          /*!< [30..30] Option byte change error flag                                    */
      __IOM uint32 SWAP_BANK_OPT : 1;         /*!< [31..31] Bank swapping option status bit                                  */
    } bit;
  } OPTSR_CUR_;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000120) FLASH option status register                               */
    
    struct {
            uint32            : 2;
      __IOM uint32 BOR_LEV    : 2;            /*!< [3..2] BOR reset level option configuration bits                          */
      __IOM uint32 IWDG1_HW   : 1;            /*!< [4..4] IWDG1 option configuration bit                                     */
            uint32            : 1;
      __IOM uint32 nRST_STOP_D1 : 1;          /*!< [6..6] Option byte erase after D1 DStop option configuration
                                                     bit                                                                       */
      __IOM uint32 nRST_STBY_D1 : 1;          /*!< [7..7] Option byte erase after D1 DStandby option configuration
                                                     bit                                                                       */
      __IOM uint32 RDP        : 8;            /*!< [15..8] Readout protection level option configuration byte                */
            uint32            : 1;
      __IOM uint32 FZ_IWDG_STOP : 1;          /*!< [17..17] IWDG Stop mode freeze option configuration bit                   */
      __IOM uint32 FZ_IWDG_SDBY : 1;          /*!< [18..18] IWDG Standby mode freeze option configuration bit                */
      __IOM uint32 ST_RAM_SIZE : 2;           /*!< [20..19] DTCM size select option configuration bits                       */
      __IOM uint32 SECURITY   : 1;            /*!< [21..21] Security option configuration bit                                */
            uint32            : 4;
      __IOM uint32 RSS1       : 1;            /*!< [26..26] User option configuration bit 1                                  */
      __IOM uint32 RSS2       : 1;            /*!< [27..27] User option configuration bit 2                                  */
            uint32            : 1;
      __IOM uint32 IO_HSLV    : 1;            /*!< [29..29] I/O high-speed at low-voltage (PRODUCT_BELOW_25V)                */
            uint32            : 1;
      __IOM uint32 SWAP_BANK_OPT : 1;         /*!< [31..31] Bank swapping option configuration bit                           */
    } bit;
  } OPTSR_PRG_;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000124) FLASH option clear control register                        */
    
    struct {
            uint32            : 30;
      __OM  uint32 CLR_OPTCHANGEERR : 1;      /*!< [30..30] OPTCHANGEERR reset bit                                           */
            uint32            : 1;
    } bit;
  } OPTCCR_;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000128) FLASH protection address for bank 1                        */
    
    struct {
      __IM  uint32 PROT_AREA_START2 : 12;     /*!< [11..0] Bank 2 lowest PCROP protected address                             */
            uint32            : 4;
      __IM  uint32 PROT_AREA_END2 : 12;       /*!< [27..16] Bank 2 highest PCROP protected address                           */
            uint32            : 3;
      __IM  uint32 DMEP2      : 1;            /*!< [31..31] Bank 2 PCROP protected erase enable option status bit            */
    } bit;
  } PRAR_CUR2;
  __IM  uint32  RESERVED2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000130) FLASH secure address for bank 2                            */
    
    struct {
      __IOM uint32 SEC_AREA_START2 : 12;      /*!< [11..0] Bank 2 lowest secure protected address                            */
            uint32            : 4;
      __IOM uint32 SEC_AREA_END2 : 12;        /*!< [27..16] Bank 2 highest secure protected address                          */
            uint32            : 3;
      __IOM uint32 DMES2      : 1;            /*!< [31..31] Bank 2 secure protected erase enable option status
                                                     bit                                                                       */
    } bit;
  } SCAR_CUR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000134) FLASH secure address for bank 2                            */
    
    struct {
      __IOM uint32 SEC_AREA_START2 : 12;      /*!< [11..0] Bank 2 lowest secure protected address configuration              */
            uint32            : 4;
      __IOM uint32 SEC_AREA_END2 : 12;        /*!< [27..16] Bank 2 highest secure protected address configuration            */
            uint32            : 3;
      __IOM uint32 DMES2      : 1;            /*!< [31..31] Bank 2 secure protected erase enable option configuration
                                                     bit                                                                       */
    } bit;
  } SCAR_PRG2;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000138) FLASH write sector protection for bank 2                   */
    
    struct {
      __IM  uint32 WRPSn2     : 8;            /*!< [7..0] Bank 2 sector write protection option status byte                  */
            uint32            : 24;
    } bit;
  } WPSN_CUR2R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000013C) FLASH write sector protection for bank 2                   */
    
    struct {
      __IOM uint32 WRPSn2     : 8;            /*!< [7..0] Bank 2 sector write protection configuration byte                  */
            uint32            : 24;
    } bit;
  } WPSN_PRG2R;
  __IM  uint32  RESERVED3[4];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000150) FLASH CRC control register for bank 1                      */
    
    struct {
      __IOM uint32 CRC_SECT   : 3;            /*!< [2..0] Bank 2 CRC sector number                                           */
            uint32            : 4;
      __IOM uint32 ALL_BANK   : 1;            /*!< [7..7] Bank 2 CRC select bit                                              */
      __IOM uint32 CRC_BY_SECT : 1;           /*!< [8..8] Bank 2 CRC sector mode select bit                                  */
      __IOM uint32 ADD_SECT   : 1;            /*!< [9..9] Bank 2 CRC sector select bit                                       */
      __IOM uint32 CLEAN_SECT : 1;            /*!< [10..10] Bank 2 CRC sector list clear bit                                 */
            uint32            : 5;
      __IOM uint32 START_CRC  : 1;            /*!< [16..16] Bank 2 CRC start bit                                             */
      __IOM uint32 CLEAN_CRC  : 1;            /*!< [17..17] Bank 2 CRC clear bit                                             */
            uint32            : 2;
      __IOM uint32 CRC_BURST  : 2;            /*!< [21..20] Bank 2 CRC burst size                                            */
            uint32            : 10;
    } bit;
  } CRCCR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000154) FLASH CRC start address register for bank 2                */
    
    struct {
      __IOM uint32 CRC_START_ADDR : 32;       /*!< [31..0] CRC start address on bank 2                                       */
    } bit;
  } CRCSADD2R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000158) FLASH CRC end address register for bank 2                  */
    
    struct {
      __IOM uint32 CRC_END_ADDR : 32;         /*!< [31..0] CRC end address on bank 2                                         */
    } bit;
  } CRCEADD2R;
  __IM  uint32  RESERVED4;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000160) FLASH ECC fail address for bank 2                          */
    
    struct {
      __IM  uint32 FAIL_ECC_ADDR2 : 15;       /*!< [14..0] Bank 2 ECC error address                                          */
            uint32            : 17;
    } bit;
  } ECC_FA2R;
} Flash_Type;                                   /*!< Size = 356 (0x164)                                                        */



/* =========================================================================================================================== */
/* ================                                            AXI                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief AXI interconnect registers (AXI)
  */

typedef struct {                                /*!< (@ 0x51000000) AXI Structure                                              */
  __IM  uint32  RESERVED[2036];
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00001FD0) AXI interconnect - peripheral ID4 register                 */
    
    struct {
      __IM  uint32 JEP106CON  : 4;            /*!< [3..0] JEP106 continuation code                                           */
      __IM  uint32 _4KCOUNT    : 4;            /*!< [7..4] Register file size                                                 */
            uint32            : 24;
    } bit;
  } AXI_PERIPH_ID_4;
  __IM  uint32  RESERVED1[3];
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00001FE0) AXI interconnect - peripheral ID0 register                 */
    
    struct {
      __IM  uint32 PARTNUM    : 8;            /*!< [7..0] Peripheral part number bits 0 to 7                                 */
            uint32            : 24;
    } bit;
  } AXI_PERIPH_ID_0;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00001FE4) AXI interconnect - peripheral ID1 register                 */
    
    struct {
      __IM  uint32 PARTNUM    : 4;            /*!< [3..0] Peripheral part number bits 8 to 11                                */
      __IM  uint32 JEP106I    : 4;            /*!< [7..4] JEP106 identity bits 0 to 3                                        */
            uint32            : 24;
    } bit;
  } AXI_PERIPH_ID_1;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00001FE8) AXI interconnect - peripheral ID2 register                 */
    
    struct {
      __IM  uint32 JEP106ID   : 3;            /*!< [2..0] JEP106 Identity bits 4 to 6                                        */
      __IM  uint32 JEDEC      : 1;            /*!< [3..3] JEP106 code flag                                                   */
      __IM  uint32 REVISION   : 4;            /*!< [7..4] Peripheral revision number                                         */
            uint32            : 24;
    } bit;
  } AXI_PERIPH_ID_2;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00001FEC) AXI interconnect - peripheral ID3 register                 */
    
    struct {
      __IM  uint32 CUST_MOD_NUM : 4;          /*!< [3..0] Customer modification                                              */
      __IM  uint32 REV_AND    : 4;            /*!< [7..4] Customer version                                                   */
            uint32            : 24;
    } bit;
  } AXI_PERIPH_ID_3;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00001FF0) AXI interconnect - component ID0 register                  */
    
    struct {
      __IM  uint32 PREAMBLE   : 8;            /*!< [7..0] Preamble bits 0 to 7                                               */
            uint32            : 24;
    } bit;
  } AXI_COMP_ID_0;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00001FF4) AXI interconnect - component ID1 register                  */
    
    struct {
      __IM  uint32 PREAMBLE   : 4;            /*!< [3..0] Preamble bits 8 to 11                                              */
      __IM  uint32 CLASS      : 4;            /*!< [7..4] Component class                                                    */
            uint32            : 24;
    } bit;
  } AXI_COMP_ID_1;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00001FF8) AXI interconnect - component ID2 register                  */
    
    struct {
      __IM  uint32 PREAMBLE   : 8;            /*!< [7..0] Preamble bits 12 to 19                                             */
            uint32            : 24;
    } bit;
  } AXI_COMP_ID_2;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00001FFC) AXI interconnect - component ID3 register                  */
    
    struct {
      __IM  uint32 PREAMBLE   : 8;            /*!< [7..0] Preamble bits 20 to 27                                             */
            uint32            : 24;
    } bit;
  } AXI_COMP_ID_3;
  __IM  uint32  RESERVED2[2];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00002008) AXI interconnect - TARG x bus matrix issuing
                                                                    functionality register                                     */
    
    struct {
      __IOM uint32 READ_ISS_OVERRIDE : 1;     /*!< [0..0] READ_ISS_OVERRIDE                                                  */
      __IOM uint32 WRITE_ISS_OVERRIDE : 1;    /*!< [1..1] Switch matrix write issuing override for target                    */
            uint32            : 30;
    } bit;
  } AXI_TARG1_FN_MOD_ISS_BM;
  __IM  uint32  RESERVED3[6];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00002024) AXI interconnect - TARG x bus matrix functionality
                                                                    2 register                                                 */
    
    struct {
      __IOM uint32 BYPASS_MERGE : 1;          /*!< [0..0] Disable packing of beats to match the output data width            */
            uint32            : 31;
    } bit;
  } AXI_TARG1_FN_MOD2;
  __IM  uint32  RESERVED4;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000202C) AXI interconnect - TARG x long burst functionality
                                                                    modification                                               */
    
    struct {
      __IOM uint32 FN_MOD_LB  : 1;            /*!< [0..0] Controls burst breaking of long bursts                             */
            uint32            : 31;
    } bit;
  } AXI_TARG1_FN_MOD_LB;
  __IM  uint32  RESERVED5[54];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00002108) AXI interconnect - TARG x long burst functionality
                                                                    modification                                               */
    
    struct {
      __IOM uint32 READ_ISS_OVERRIDE : 1;     /*!< [0..0] Override AMIB read issuing capability                              */
      __IOM uint32 WRITE_ISS_OVERRIDE : 1;    /*!< [1..1] Override AMIB write issuing capability                             */
            uint32            : 30;
    } bit;
  } AXI_TARG1_FN_MOD;
  __IM  uint32  RESERVED6[959];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00003008) AXI interconnect - TARG x bus matrix issuing
                                                                    functionality register                                     */
    
    struct {
      __IOM uint32 READ_ISS_OVERRIDE : 1;     /*!< [0..0] READ_ISS_OVERRIDE                                                  */
      __IOM uint32 WRITE_ISS_OVERRIDE : 1;    /*!< [1..1] Switch matrix write issuing override for target                    */
            uint32            : 30;
    } bit;
  } AXI_TARG2_FN_MOD_ISS_BM;
  __IM  uint32  RESERVED7[6];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00003024) AXI interconnect - TARG x bus matrix functionality
                                                                    2 register                                                 */
    
    struct {
      __IOM uint32 BYPASS_MERGE : 1;          /*!< [0..0] Disable packing of beats to match the output data width            */
            uint32            : 31;
    } bit;
  } AXI_TARG2_FN_MOD2;
  __IM  uint32  RESERVED8;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000302C) AXI interconnect - TARG x long burst functionality
                                                                    modification                                               */
    
    struct {
      __IOM uint32 FN_MOD_LB  : 1;            /*!< [0..0] Controls burst breaking of long bursts                             */
            uint32            : 31;
    } bit;
  } AXI_TARG2_FN_MOD_LB;
  __IM  uint32  RESERVED9[54];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00003108) AXI interconnect - TARG x long burst functionality
                                                                    modification                                               */
    
    struct {
      __IOM uint32 READ_ISS_OVERRIDE : 1;     /*!< [0..0] Override AMIB read issuing capability                              */
      __IOM uint32 WRITE_ISS_OVERRIDE : 1;    /*!< [1..1] Override AMIB write issuing capability                             */
            uint32            : 30;
    } bit;
  } AXI_TARG2_FN_MOD;
  __IM  uint32  RESERVED10[959];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00004008) AXI interconnect - TARG x bus matrix issuing
                                                                    functionality register                                     */
    
    struct {
      __IOM uint32 READ_ISS_OVERRIDE : 1;     /*!< [0..0] READ_ISS_OVERRIDE                                                  */
      __IOM uint32 WRITE_ISS_OVERRIDE : 1;    /*!< [1..1] Switch matrix write issuing override for target                    */
            uint32            : 30;
    } bit;
  } AXI_TARG3_FN_MOD_ISS_BM;
  __IM  uint32  RESERVED11[1023];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00005008) AXI interconnect - TARG x bus matrix issuing
                                                                    functionality register                                     */
    
    struct {
      __IOM uint32 READ_ISS_OVERRIDE : 1;     /*!< [0..0] READ_ISS_OVERRIDE                                                  */
      __IOM uint32 WRITE_ISS_OVERRIDE : 1;    /*!< [1..1] Switch matrix write issuing override for target                    */
            uint32            : 30;
    } bit;
  } AXI_TARG4_FN_MOD_ISS_BM;
  __IM  uint32  RESERVED12[1023];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00006008) AXI interconnect - TARG x bus matrix issuing
                                                                    functionality register                                     */
    
    struct {
      __IOM uint32 READ_ISS_OVERRIDE : 1;     /*!< [0..0] READ_ISS_OVERRIDE                                                  */
      __IOM uint32 WRITE_ISS_OVERRIDE : 1;    /*!< [1..1] Switch matrix write issuing override for target                    */
            uint32            : 30;
    } bit;
  } AXI_TARG5_FN_MOD_ISS_BM;
  __IM  uint32  RESERVED13[1023];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00007008) AXI interconnect - TARG x bus matrix issuing
                                                                    functionality register                                     */
    
    struct {
      __IOM uint32 READ_ISS_OVERRIDE : 1;     /*!< [0..0] READ_ISS_OVERRIDE                                                  */
      __IOM uint32 WRITE_ISS_OVERRIDE : 1;    /*!< [1..1] Switch matrix write issuing override for target                    */
            uint32            : 30;
    } bit;
  } AXI_TARG6_FN_MOD_ISS_BM;
  __IM  uint32  RESERVED14[1024];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000800C) AXI interconnect - TARG x bus matrix issuing
                                                                    functionality register                                     */
    
    struct {
      __IOM uint32 READ_ISS_OVERRIDE : 1;     /*!< [0..0] READ_ISS_OVERRIDE                                                  */
      __IOM uint32 WRITE_ISS_OVERRIDE : 1;    /*!< [1..1] Switch matrix write issuing override for target                    */
            uint32            : 30;
    } bit;
  } AXI_TARG7_FN_MOD_ISS_BM;
  __IM  uint32  RESERVED15[5];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00008024) AXI interconnect - TARG x bus matrix functionality
                                                                    2 register                                                 */
    
    struct {
      __IOM uint32 BYPASS_MERGE : 1;          /*!< [0..0] Disable packing of beats to match the output data width            */
            uint32            : 31;
    } bit;
  } AXI_TARG7_FN_MOD2;
  __IM  uint32  RESERVED16[56];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00008108) AXI interconnect - TARG x long burst functionality
                                                                    modification                                               */
    
    struct {
      __IOM uint32 READ_ISS_OVERRIDE : 1;     /*!< [0..0] Override AMIB read issuing capability                              */
      __IOM uint32 WRITE_ISS_OVERRIDE : 1;    /*!< [1..1] Override AMIB write issuing capability                             */
            uint32            : 30;
    } bit;
  } AXI_TARG7_FN_MOD;
  __IM  uint32  RESERVED17[59334];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00042024) AXI interconnect - INI x functionality modification
                                                                    2 register                                                 */
    
    struct {
      __IOM uint32 BYPASS_MERGE : 1;          /*!< [0..0] Disables alteration of transactions by the up-sizer unless
                                                     required by the protocol                                                  */
            uint32            : 31;
    } bit;
  } AXI_INI1_FN_MOD2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00042028) AXI interconnect - INI x AHB functionality modification
                                                                    register                                                   */
    
    struct {
      __IOM uint32 RD_INC_OVERRIDE : 1;       /*!< [0..0] Converts all AHB-Lite write transactions to a series
                                                     of single beat AXI                                                        */
      __IOM uint32 WR_INC_OVERRIDE : 1;       /*!< [1..1] Converts all AHB-Lite read transactions to a series of
                                                     single beat AXI                                                           */
            uint32            : 30;
    } bit;
  } AXI_INI1_FN_MOD_AHB;
  __IM  uint32  RESERVED18[53];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00042100) AXI interconnect - INI x read QoS register                 */
    
    struct {
      __IOM uint32 AR_QOS     : 4;            /*!< [3..0] Read channel QoS setting                                           */
            uint32            : 28;
    } bit;
  } AXI_INI1_READ_QOS;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00042104) AXI interconnect - INI x write QoS register                */
    
    struct {
      __IOM uint32 AW_QOS     : 4;            /*!< [3..0] Write channel QoS setting                                          */
            uint32            : 28;
    } bit;
  } AXI_INI1_WRITE_QOS;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00042108) AXI interconnect - INI x issuing functionality
                                                                    modification register                                      */
    
    struct {
      __IOM uint32 READ_ISS_OVERRIDE : 1;     /*!< [0..0] Override ASIB read issuing capability                              */
      __IOM uint32 WRITE_ISS_OVERRIDE : 1;    /*!< [1..1] Override ASIB write issuing capability                             */
            uint32            : 30;
    } bit;
  } AXI_INI1_FN_MOD;
  __IM  uint32  RESERVED19[1021];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00043100) AXI interconnect - INI x read QoS register                 */
    
    struct {
      __IOM uint32 AR_QOS     : 4;            /*!< [3..0] Read channel QoS setting                                           */
            uint32            : 28;
    } bit;
  } AXI_INI2_READ_QOS;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00043104) AXI interconnect - INI x write QoS register                */
    
    struct {
      __IOM uint32 AW_QOS     : 4;            /*!< [3..0] Write channel QoS setting                                          */
            uint32            : 28;
    } bit;
  } AXI_INI2_WRITE_QOS;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00043108) AXI interconnect - INI x issuing functionality
                                                                    modification register                                      */
    
    struct {
      __IOM uint32 READ_ISS_OVERRIDE : 1;     /*!< [0..0] Override ASIB read issuing capability                              */
      __IOM uint32 WRITE_ISS_OVERRIDE : 1;    /*!< [1..1] Override ASIB write issuing capability                             */
            uint32            : 30;
    } bit;
  } AXI_INI2_FN_MOD;
  __IM  uint32  RESERVED20[966];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00044024) AXI interconnect - INI x functionality modification
                                                                    2 register                                                 */
    
    struct {
      __IOM uint32 BYPASS_MERGE : 1;          /*!< [0..0] Disables alteration of transactions by the up-sizer unless
                                                     required by the protocol                                                  */
            uint32            : 31;
    } bit;
  } AXI_INI3_FN_MOD2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00044028) AXI interconnect - INI x AHB functionality modification
                                                                    register                                                   */
    
    struct {
      __IOM uint32 RD_INC_OVERRIDE : 1;       /*!< [0..0] Converts all AHB-Lite write transactions to a series
                                                     of single beat AXI                                                        */
      __IOM uint32 WR_INC_OVERRIDE : 1;       /*!< [1..1] Converts all AHB-Lite read transactions to a series of
                                                     single beat AXI                                                           */
            uint32            : 30;
    } bit;
  } AXI_INI3_FN_MOD_AHB;
  __IM  uint32  RESERVED21[53];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00044100) AXI interconnect - INI x read QoS register                 */
    
    struct {
      __IOM uint32 AR_QOS     : 4;            /*!< [3..0] Read channel QoS setting                                           */
            uint32            : 28;
    } bit;
  } AXI_INI3_READ_QOS;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00044104) AXI interconnect - INI x write QoS register                */
    
    struct {
      __IOM uint32 AW_QOS     : 4;            /*!< [3..0] Write channel QoS setting                                          */
            uint32            : 28;
    } bit;
  } AXI_INI3_WRITE_QOS;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00044108) AXI interconnect - INI x issuing functionality
                                                                    modification register                                      */
    
    struct {
      __IOM uint32 READ_ISS_OVERRIDE : 1;     /*!< [0..0] Override ASIB read issuing capability                              */
      __IOM uint32 WRITE_ISS_OVERRIDE : 1;    /*!< [1..1] Override ASIB write issuing capability                             */
            uint32            : 30;
    } bit;
  } AXI_INI3_FN_MOD;
  __IM  uint32  RESERVED22[1021];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00045100) AXI interconnect - INI x read QoS register                 */
    
    struct {
      __IOM uint32 AR_QOS     : 4;            /*!< [3..0] Read channel QoS setting                                           */
            uint32            : 28;
    } bit;
  } AXI_INI4_READ_QOS;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00045104) AXI interconnect - INI x write QoS register                */
    
    struct {
      __IOM uint32 AW_QOS     : 4;            /*!< [3..0] Write channel QoS setting                                          */
            uint32            : 28;
    } bit;
  } AXI_INI4_WRITE_QOS;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00045108) AXI interconnect - INI x issuing functionality
                                                                    modification register                                      */
    
    struct {
      __IOM uint32 READ_ISS_OVERRIDE : 1;     /*!< [0..0] Override ASIB read issuing capability                              */
      __IOM uint32 WRITE_ISS_OVERRIDE : 1;    /*!< [1..1] Override ASIB write issuing capability                             */
            uint32            : 30;
    } bit;
  } AXI_INI4_FN_MOD;
  __IM  uint32  RESERVED23[1021];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00046100) AXI interconnect - INI x read QoS register                 */
    
    struct {
      __IOM uint32 AR_QOS     : 4;            /*!< [3..0] Read channel QoS setting                                           */
            uint32            : 28;
    } bit;
  } AXI_INI5_READ_QOS;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00046104) AXI interconnect - INI x write QoS register                */
    
    struct {
      __IOM uint32 AW_QOS     : 4;            /*!< [3..0] Write channel QoS setting                                          */
            uint32            : 28;
    } bit;
  } AXI_INI5_WRITE_QOS;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00046108) AXI interconnect - INI x issuing functionality
                                                                    modification register                                      */
    
    struct {
      __IOM uint32 READ_ISS_OVERRIDE : 1;     /*!< [0..0] Override ASIB read issuing capability                              */
      __IOM uint32 WRITE_ISS_OVERRIDE : 1;    /*!< [1..1] Override ASIB write issuing capability                             */
            uint32            : 30;
    } bit;
  } AXI_INI5_FN_MOD;
  __IM  uint32  RESERVED24[1021];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00047100) AXI interconnect - INI x read QoS register                 */
    
    struct {
      __IOM uint32 AR_QOS     : 4;            /*!< [3..0] Read channel QoS setting                                           */
            uint32            : 28;
    } bit;
  } AXI_INI6_READ_QOS;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00047104) AXI interconnect - INI x write QoS register                */
    
    struct {
      __IOM uint32 AW_QOS     : 4;            /*!< [3..0] Write channel QoS setting                                          */
            uint32            : 28;
    } bit;
  } AXI_INI6_WRITE_QOS;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00047108) AXI interconnect - INI x issuing functionality
                                                                    modification register                                      */
    
    struct {
      __IOM uint32 READ_ISS_OVERRIDE : 1;     /*!< [0..0] Override ASIB read issuing capability                              */
      __IOM uint32 WRITE_ISS_OVERRIDE : 1;    /*!< [1..1] Override ASIB write issuing capability                             */
            uint32            : 30;
    } bit;
  } AXI_INI6_FN_MOD;
} AXI_Type;                                     /*!< Size = 291084 (0x4710c)                                                   */



/* =========================================================================================================================== */
/* ================                                           HASH                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Hash processor (HASH)
  */

typedef struct {                                /*!< (@ 0x48021400) HASH Structure                                             */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) control register                                           */
    
    struct {
            uint32            : 2;
      __OM  uint32 INIT       : 1;            /*!< [2..2] Initialize message digest calculation                              */
      __IOM uint32 DMAE       : 1;            /*!< [3..3] DMA enable                                                         */
      __IOM uint32 DATATYPE   : 2;            /*!< [5..4] Data type selection                                                */
      __IOM uint32 MODE       : 1;            /*!< [6..6] Mode selection                                                     */
      __IOM uint32 ALGO0      : 1;            /*!< [7..7] Algorithm selection                                                */
      __IM  uint32 NBW        : 4;            /*!< [11..8] Number of words already pushed                                    */
      __IM  uint32 DINNE      : 1;            /*!< [12..12] DIN not empty                                                    */
      __IOM uint32 MDMAT      : 1;            /*!< [13..13] Multiple DMA Transfers                                           */
            uint32            : 2;
      __IOM uint32 LKEY       : 1;            /*!< [16..16] Long key selection                                               */
            uint32            : 1;
      __IOM uint32 ALGO1      : 1;            /*!< [18..18] ALGO                                                             */
            uint32            : 13;
    } bit;
  } CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) data input register                                        */
    
    struct {
      __IOM uint32 DATAIN     : 32;           /*!< [31..0] Data input                                                        */
    } bit;
  } DIN;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) start register                                             */
    
    struct {
      __IOM uint32 NBLW       : 5;            /*!< [4..0] Number of valid bits in the last word of the message               */
            uint32            : 3;
      __OM  uint32 DCAL       : 1;            /*!< [8..8] Digest calculation                                                 */
            uint32            : 23;
    } bit;
  } STR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000000C) digest registers                                           */
    
    struct {
      __IM  uint32 H0         : 32;           /*!< [31..0] H0                                                                */
    } bit;
  } HR0;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000010) digest registers                                           */
    
    struct {
      __IM  uint32 H1         : 32;           /*!< [31..0] H1                                                                */
    } bit;
  } HR1;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000014) digest registers                                           */
    
    struct {
      __IM  uint32 H2         : 32;           /*!< [31..0] H2                                                                */
    } bit;
  } HR2;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000018) digest registers                                           */
    
    struct {
      __IM  uint32 H3         : 32;           /*!< [31..0] H3                                                                */
    } bit;
  } HR3;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000001C) digest registers                                           */
    
    struct {
      __IM  uint32 H4         : 32;           /*!< [31..0] H4                                                                */
    } bit;
  } HR4;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000020) interrupt enable register                                  */
    
    struct {
      __IOM uint32 DINIE      : 1;            /*!< [0..0] Data input interrupt enable                                        */
      __IOM uint32 DCIE       : 1;            /*!< [1..1] Digest calculation completion interrupt enable                     */
            uint32            : 30;
    } bit;
  } IMR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000024) status register                                            */
    
    struct {
      __IOM uint32 DINIS      : 1;            /*!< [0..0] Data input interrupt status                                        */
      __IOM uint32 DCIS       : 1;            /*!< [1..1] Digest calculation completion interrupt status                     */
      __IM  uint32 DMAS       : 1;            /*!< [2..2] DMA Status                                                         */
      __IM  uint32 BUSY       : 1;            /*!< [3..3] Busy bit                                                           */
            uint32            : 28;
    } bit;
  } SR;
  __IM  uint32  RESERVED[52];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000F8) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR0       : 32;           /*!< [31..0] CSR0                                                              */
    } bit;
  } CSR0;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000FC) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR1       : 32;           /*!< [31..0] CSR1                                                              */
    } bit;
  } CSR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000100) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR2       : 32;           /*!< [31..0] CSR2                                                              */
    } bit;
  } CSR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000104) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR3       : 32;           /*!< [31..0] CSR3                                                              */
    } bit;
  } CSR3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000108) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR4       : 32;           /*!< [31..0] CSR4                                                              */
    } bit;
  } CSR4;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000010C) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR5       : 32;           /*!< [31..0] CSR5                                                              */
    } bit;
  } CSR5;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000110) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR6       : 32;           /*!< [31..0] CSR6                                                              */
    } bit;
  } CSR6;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000114) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR7       : 32;           /*!< [31..0] CSR7                                                              */
    } bit;
  } CSR7;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000118) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR8       : 32;           /*!< [31..0] CSR8                                                              */
    } bit;
  } CSR8;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000011C) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR9       : 32;           /*!< [31..0] CSR9                                                              */
    } bit;
  } CSR9;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000120) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR10      : 32;           /*!< [31..0] CSR10                                                             */
    } bit;
  } CSR10;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000124) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR11      : 32;           /*!< [31..0] CSR11                                                             */
    } bit;
  } CSR11;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000128) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR12      : 32;           /*!< [31..0] CSR12                                                             */
    } bit;
  } CSR12;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000012C) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR13      : 32;           /*!< [31..0] CSR13                                                             */
    } bit;
  } CSR13;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000130) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR14      : 32;           /*!< [31..0] CSR14                                                             */
    } bit;
  } CSR14;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000134) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR15      : 32;           /*!< [31..0] CSR15                                                             */
    } bit;
  } CSR15;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000138) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR16      : 32;           /*!< [31..0] CSR16                                                             */
    } bit;
  } CSR16;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000013C) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR17      : 32;           /*!< [31..0] CSR17                                                             */
    } bit;
  } CSR17;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000140) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR18      : 32;           /*!< [31..0] CSR18                                                             */
    } bit;
  } CSR18;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000144) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR19      : 32;           /*!< [31..0] CSR19                                                             */
    } bit;
  } CSR19;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000148) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR20      : 32;           /*!< [31..0] CSR20                                                             */
    } bit;
  } CSR20;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000014C) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR21      : 32;           /*!< [31..0] CSR21                                                             */
    } bit;
  } CSR21;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000150) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR22      : 32;           /*!< [31..0] CSR22                                                             */
    } bit;
  } CSR22;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000154) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR23      : 32;           /*!< [31..0] CSR23                                                             */
    } bit;
  } CSR23;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000158) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR24      : 32;           /*!< [31..0] CSR24                                                             */
    } bit;
  } CSR24;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000015C) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR25      : 32;           /*!< [31..0] CSR25                                                             */
    } bit;
  } CSR25;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000160) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR26      : 32;           /*!< [31..0] CSR26                                                             */
    } bit;
  } CSR26;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000164) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR27      : 32;           /*!< [31..0] CSR27                                                             */
    } bit;
  } CSR27;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000168) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR28      : 32;           /*!< [31..0] CSR28                                                             */
    } bit;
  } CSR28;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000016C) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR29      : 32;           /*!< [31..0] CSR29                                                             */
    } bit;
  } CSR29;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000170) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR30      : 32;           /*!< [31..0] CSR30                                                             */
    } bit;
  } CSR30;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000174) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR31      : 32;           /*!< [31..0] CSR31                                                             */
    } bit;
  } CSR31;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000178) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR32      : 32;           /*!< [31..0] CSR32                                                             */
    } bit;
  } CSR32;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000017C) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR33      : 32;           /*!< [31..0] CSR33                                                             */
    } bit;
  } CSR33;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000180) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR34      : 32;           /*!< [31..0] CSR34                                                             */
    } bit;
  } CSR34;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000184) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR35      : 32;           /*!< [31..0] CSR35                                                             */
    } bit;
  } CSR35;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000188) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR36      : 32;           /*!< [31..0] CSR36                                                             */
    } bit;
  } CSR36;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000018C) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR37      : 32;           /*!< [31..0] CSR37                                                             */
    } bit;
  } CSR37;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000190) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR38      : 32;           /*!< [31..0] CSR38                                                             */
    } bit;
  } CSR38;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000194) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR39      : 32;           /*!< [31..0] CSR39                                                             */
    } bit;
  } CSR39;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000198) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR40      : 32;           /*!< [31..0] CSR40                                                             */
    } bit;
  } CSR40;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000019C) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR41      : 32;           /*!< [31..0] CSR41                                                             */
    } bit;
  } CSR41;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001A0) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR42      : 32;           /*!< [31..0] CSR42                                                             */
    } bit;
  } CSR42;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001A4) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR43      : 32;           /*!< [31..0] CSR43                                                             */
    } bit;
  } CSR43;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001A8) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR44      : 32;           /*!< [31..0] CSR44                                                             */
    } bit;
  } CSR44;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001AC) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR45      : 32;           /*!< [31..0] CSR45                                                             */
    } bit;
  } CSR45;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001B0) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR46      : 32;           /*!< [31..0] CSR46                                                             */
    } bit;
  } CSR46;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001B4) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR47      : 32;           /*!< [31..0] CSR47                                                             */
    } bit;
  } CSR47;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001B8) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR48      : 32;           /*!< [31..0] CSR48                                                             */
    } bit;
  } CSR48;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001BC) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR49      : 32;           /*!< [31..0] CSR49                                                             */
    } bit;
  } CSR49;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001C0) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR50      : 32;           /*!< [31..0] CSR50                                                             */
    } bit;
  } CSR50;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001C4) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR51      : 32;           /*!< [31..0] CSR51                                                             */
    } bit;
  } CSR51;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001C8) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR52      : 32;           /*!< [31..0] CSR52                                                             */
    } bit;
  } CSR52;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001CC) context swap registers                                     */
    
    struct {
      __IOM uint32 CSR53      : 32;           /*!< [31..0] CSR53                                                             */
    } bit;
  } CSR53;
  __IM  uint32  RESERVED1[80];
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000310) HASH digest register                                       */
    
    struct {
      __IM  uint32 H0         : 32;           /*!< [31..0] H0                                                                */
    } bit;
  } HASH_HR0;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000314) read-only                                                  */
    
    struct {
      __IM  uint32 H1         : 32;           /*!< [31..0] H1                                                                */
    } bit;
  } HASH_HR1;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000318) read-only                                                  */
    
    struct {
      __IM  uint32 H2         : 32;           /*!< [31..0] H2                                                                */
    } bit;
  } HASH_HR2;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000031C) read-only                                                  */
    
    struct {
      __IM  uint32 H3         : 32;           /*!< [31..0] H3                                                                */
    } bit;
  } HASH_HR3;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000320) read-only                                                  */
    
    struct {
      __IM  uint32 H4         : 32;           /*!< [31..0] H4                                                                */
    } bit;
  } HASH_HR4;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000324) read-only                                                  */
    
    struct {
      __IM  uint32 H5         : 32;           /*!< [31..0] H5                                                                */
    } bit;
  } HASH_HR5;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000328) read-only                                                  */
    
    struct {
      __IM  uint32 H6         : 32;           /*!< [31..0] H6                                                                */
    } bit;
  } HASH_HR6;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000032C) read-only                                                  */
    
    struct {
      __IM  uint32 H7         : 32;           /*!< [31..0] H7                                                                */
    } bit;
  } HASH_HR7;
} HASH_Type;                                    /*!< Size = 816 (0x330)                                                        */



/* =========================================================================================================================== */
/* ================                                           CRYP                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Cryptographic processor (CRYP)
  */

typedef struct {                                /*!< (@ 0x48021000) CRYP Structure                                             */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) control register                                           */
    
    struct {
            uint32            : 2;
      __IOM uint32 ALGODIR    : 1;            /*!< [2..2] Algorithm direction                                                */
      __IOM uint32 ALGOMODE0  : 3;            /*!< [5..3] Algorithm mode                                                     */
      __IOM uint32 DATATYPE   : 2;            /*!< [7..6] Data type selection                                                */
      __IOM uint32 KEYSIZE    : 2;            /*!< [9..8] Key size selection (AES mode only)                                 */
            uint32            : 4;
      __OM  uint32 FFLUSH     : 1;            /*!< [14..14] FIFO flush                                                       */
      __IOM uint32 CRYPEN     : 1;            /*!< [15..15] Cryptographic processor enable                                   */
      __IOM uint32 GCM_CCMPH  : 2;            /*!< [17..16] GCM_CCMPH                                                        */
            uint32            : 1;
      __IOM uint32 ALGOMODE3  : 1;            /*!< [19..19] ALGOMODE                                                         */
            uint32            : 12;
    } bit;
  } CR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000004) status register                                            */
    
    struct {
      __IM  uint32 IFEM       : 1;            /*!< [0..0] Input FIFO empty                                                   */
      __IM  uint32 IFNF       : 1;            /*!< [1..1] Input FIFO not full                                                */
      __IM  uint32 OFNE       : 1;            /*!< [2..2] Output FIFO not empty                                              */
      __IM  uint32 OFFU       : 1;            /*!< [3..3] Output FIFO full                                                   */
      __IM  uint32 BUSY       : 1;            /*!< [4..4] Busy bit                                                           */
            uint32            : 27;
    } bit;
  } SR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) data input register                                        */
    
    struct {
      __IOM uint32 DATAIN     : 32;           /*!< [31..0] Data input                                                        */
    } bit;
  } DIN;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000000C) data output register                                       */
    
    struct {
      __IM  uint32 DATAOUT    : 32;           /*!< [31..0] Data output                                                       */
    } bit;
  } DOUT;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) DMA control register                                       */
    
    struct {
      __IOM uint32 DIEN       : 1;            /*!< [0..0] DMA input enable                                                   */
      __IOM uint32 DOEN       : 1;            /*!< [1..1] DMA output enable                                                  */
            uint32            : 30;
    } bit;
  } DMACR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000014) interrupt mask set/clear register                          */
    
    struct {
      __IOM uint32 INIM       : 1;            /*!< [0..0] Input FIFO service interrupt mask                                  */
      __IOM uint32 OUTIM      : 1;            /*!< [1..1] Output FIFO service interrupt mask                                 */
            uint32            : 30;
    } bit;
  } IMSCR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000018) raw interrupt status register                              */
    
    struct {
      __IM  uint32 INRIS      : 1;            /*!< [0..0] Input FIFO service raw interrupt status                            */
      __IM  uint32 OUTRIS     : 1;            /*!< [1..1] Output FIFO service raw interrupt status                           */
            uint32            : 30;
    } bit;
  } RISR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000001C) masked interrupt status register                           */
    
    struct {
      __IM  uint32 INMIS      : 1;            /*!< [0..0] Input FIFO service masked interrupt status                         */
      __IM  uint32 OUTMIS     : 1;            /*!< [1..1] Output FIFO service masked interrupt status                        */
            uint32            : 30;
    } bit;
  } MISR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000020) key registers                                              */
    
    struct {
      __OM  uint32 b224       : 1;            /*!< [0..0] b224                                                               */
      __OM  uint32 b225       : 1;            /*!< [1..1] b225                                                               */
      __OM  uint32 b226       : 1;            /*!< [2..2] b226                                                               */
      __OM  uint32 b227       : 1;            /*!< [3..3] b227                                                               */
      __OM  uint32 b228       : 1;            /*!< [4..4] b228                                                               */
      __OM  uint32 b229       : 1;            /*!< [5..5] b229                                                               */
      __OM  uint32 b230       : 1;            /*!< [6..6] b230                                                               */
      __OM  uint32 b231       : 1;            /*!< [7..7] b231                                                               */
      __OM  uint32 b232       : 1;            /*!< [8..8] b232                                                               */
      __OM  uint32 b233       : 1;            /*!< [9..9] b233                                                               */
      __OM  uint32 b234       : 1;            /*!< [10..10] b234                                                             */
      __OM  uint32 b235       : 1;            /*!< [11..11] b235                                                             */
      __OM  uint32 b236       : 1;            /*!< [12..12] b236                                                             */
      __OM  uint32 b237       : 1;            /*!< [13..13] b237                                                             */
      __OM  uint32 b238       : 1;            /*!< [14..14] b238                                                             */
      __OM  uint32 b239       : 1;            /*!< [15..15] b239                                                             */
      __OM  uint32 b240       : 1;            /*!< [16..16] b240                                                             */
      __OM  uint32 b241       : 1;            /*!< [17..17] b241                                                             */
      __OM  uint32 b242       : 1;            /*!< [18..18] b242                                                             */
      __OM  uint32 b243       : 1;            /*!< [19..19] b243                                                             */
      __OM  uint32 b244       : 1;            /*!< [20..20] b244                                                             */
      __OM  uint32 b245       : 1;            /*!< [21..21] b245                                                             */
      __OM  uint32 b246       : 1;            /*!< [22..22] b246                                                             */
      __OM  uint32 b247       : 1;            /*!< [23..23] b247                                                             */
      __OM  uint32 b248       : 1;            /*!< [24..24] b248                                                             */
      __OM  uint32 b249       : 1;            /*!< [25..25] b249                                                             */
      __OM  uint32 b250       : 1;            /*!< [26..26] b250                                                             */
      __OM  uint32 b251       : 1;            /*!< [27..27] b251                                                             */
      __OM  uint32 b252       : 1;            /*!< [28..28] b252                                                             */
      __OM  uint32 b253       : 1;            /*!< [29..29] b253                                                             */
      __OM  uint32 b254       : 1;            /*!< [30..30] b254                                                             */
      __OM  uint32 b255       : 1;            /*!< [31..31] b255                                                             */
    } bit;
  } K0LR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000024) key registers                                              */
    
    struct {
      __OM  uint32 b192       : 1;            /*!< [0..0] b192                                                               */
      __OM  uint32 b193       : 1;            /*!< [1..1] b193                                                               */
      __OM  uint32 b194       : 1;            /*!< [2..2] b194                                                               */
      __OM  uint32 b195       : 1;            /*!< [3..3] b195                                                               */
      __OM  uint32 b196       : 1;            /*!< [4..4] b196                                                               */
      __OM  uint32 b197       : 1;            /*!< [5..5] b197                                                               */
      __OM  uint32 b198       : 1;            /*!< [6..6] b198                                                               */
      __OM  uint32 b199       : 1;            /*!< [7..7] b199                                                               */
      __OM  uint32 b200       : 1;            /*!< [8..8] b200                                                               */
      __OM  uint32 b201       : 1;            /*!< [9..9] b201                                                               */
      __OM  uint32 b202       : 1;            /*!< [10..10] b202                                                             */
      __OM  uint32 b203       : 1;            /*!< [11..11] b203                                                             */
      __OM  uint32 b204       : 1;            /*!< [12..12] b204                                                             */
      __OM  uint32 b205       : 1;            /*!< [13..13] b205                                                             */
      __OM  uint32 b206       : 1;            /*!< [14..14] b206                                                             */
      __OM  uint32 b207       : 1;            /*!< [15..15] b207                                                             */
      __OM  uint32 b208       : 1;            /*!< [16..16] b208                                                             */
      __OM  uint32 b209       : 1;            /*!< [17..17] b209                                                             */
      __OM  uint32 b210       : 1;            /*!< [18..18] b210                                                             */
      __OM  uint32 b211       : 1;            /*!< [19..19] b211                                                             */
      __OM  uint32 b212       : 1;            /*!< [20..20] b212                                                             */
      __OM  uint32 b213       : 1;            /*!< [21..21] b213                                                             */
      __OM  uint32 b214       : 1;            /*!< [22..22] b214                                                             */
      __OM  uint32 b215       : 1;            /*!< [23..23] b215                                                             */
      __OM  uint32 b216       : 1;            /*!< [24..24] b216                                                             */
      __OM  uint32 b217       : 1;            /*!< [25..25] b217                                                             */
      __OM  uint32 b218       : 1;            /*!< [26..26] b218                                                             */
      __OM  uint32 b219       : 1;            /*!< [27..27] b219                                                             */
      __OM  uint32 b220       : 1;            /*!< [28..28] b220                                                             */
      __OM  uint32 b221       : 1;            /*!< [29..29] b221                                                             */
      __OM  uint32 b222       : 1;            /*!< [30..30] b222                                                             */
      __OM  uint32 b223       : 1;            /*!< [31..31] b223                                                             */
    } bit;
  } K0RR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000028) key registers                                              */
    
    struct {
      __OM  uint32 b160       : 1;            /*!< [0..0] b160                                                               */
      __OM  uint32 b161       : 1;            /*!< [1..1] b161                                                               */
      __OM  uint32 b162       : 1;            /*!< [2..2] b162                                                               */
      __OM  uint32 b163       : 1;            /*!< [3..3] b163                                                               */
      __OM  uint32 b164       : 1;            /*!< [4..4] b164                                                               */
      __OM  uint32 b165       : 1;            /*!< [5..5] b165                                                               */
      __OM  uint32 b166       : 1;            /*!< [6..6] b166                                                               */
      __OM  uint32 b167       : 1;            /*!< [7..7] b167                                                               */
      __OM  uint32 b168       : 1;            /*!< [8..8] b168                                                               */
      __OM  uint32 b169       : 1;            /*!< [9..9] b169                                                               */
      __OM  uint32 b170       : 1;            /*!< [10..10] b170                                                             */
      __OM  uint32 b171       : 1;            /*!< [11..11] b171                                                             */
      __OM  uint32 b172       : 1;            /*!< [12..12] b172                                                             */
      __OM  uint32 b173       : 1;            /*!< [13..13] b173                                                             */
      __OM  uint32 b174       : 1;            /*!< [14..14] b174                                                             */
      __OM  uint32 b175       : 1;            /*!< [15..15] b175                                                             */
      __OM  uint32 b176       : 1;            /*!< [16..16] b176                                                             */
      __OM  uint32 b177       : 1;            /*!< [17..17] b177                                                             */
      __OM  uint32 b178       : 1;            /*!< [18..18] b178                                                             */
      __OM  uint32 b179       : 1;            /*!< [19..19] b179                                                             */
      __OM  uint32 b180       : 1;            /*!< [20..20] b180                                                             */
      __OM  uint32 b181       : 1;            /*!< [21..21] b181                                                             */
      __OM  uint32 b182       : 1;            /*!< [22..22] b182                                                             */
      __OM  uint32 b183       : 1;            /*!< [23..23] b183                                                             */
      __OM  uint32 b184       : 1;            /*!< [24..24] b184                                                             */
      __OM  uint32 b185       : 1;            /*!< [25..25] b185                                                             */
      __OM  uint32 b186       : 1;            /*!< [26..26] b186                                                             */
      __OM  uint32 b187       : 1;            /*!< [27..27] b187                                                             */
      __OM  uint32 b188       : 1;            /*!< [28..28] b188                                                             */
      __OM  uint32 b189       : 1;            /*!< [29..29] b189                                                             */
      __OM  uint32 b190       : 1;            /*!< [30..30] b190                                                             */
      __OM  uint32 b191       : 1;            /*!< [31..31] b191                                                             */
    } bit;
  } K1LR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x0000002C) key registers                                              */
    
    struct {
      __OM  uint32 b128       : 1;            /*!< [0..0] b128                                                               */
      __OM  uint32 b129       : 1;            /*!< [1..1] b129                                                               */
      __OM  uint32 b130       : 1;            /*!< [2..2] b130                                                               */
      __OM  uint32 b131       : 1;            /*!< [3..3] b131                                                               */
      __OM  uint32 b132       : 1;            /*!< [4..4] b132                                                               */
      __OM  uint32 b133       : 1;            /*!< [5..5] b133                                                               */
      __OM  uint32 b134       : 1;            /*!< [6..6] b134                                                               */
      __OM  uint32 b135       : 1;            /*!< [7..7] b135                                                               */
      __OM  uint32 b136       : 1;            /*!< [8..8] b136                                                               */
      __OM  uint32 b137       : 1;            /*!< [9..9] b137                                                               */
      __OM  uint32 b138       : 1;            /*!< [10..10] b138                                                             */
      __OM  uint32 b139       : 1;            /*!< [11..11] b139                                                             */
      __OM  uint32 b140       : 1;            /*!< [12..12] b140                                                             */
      __OM  uint32 b141       : 1;            /*!< [13..13] b141                                                             */
      __OM  uint32 b142       : 1;            /*!< [14..14] b142                                                             */
      __OM  uint32 b143       : 1;            /*!< [15..15] b143                                                             */
      __OM  uint32 b144       : 1;            /*!< [16..16] b144                                                             */
      __OM  uint32 b145       : 1;            /*!< [17..17] b145                                                             */
      __OM  uint32 b146       : 1;            /*!< [18..18] b146                                                             */
      __OM  uint32 b147       : 1;            /*!< [19..19] b147                                                             */
      __OM  uint32 b148       : 1;            /*!< [20..20] b148                                                             */
      __OM  uint32 b149       : 1;            /*!< [21..21] b149                                                             */
      __OM  uint32 b150       : 1;            /*!< [22..22] b150                                                             */
      __OM  uint32 b151       : 1;            /*!< [23..23] b151                                                             */
      __OM  uint32 b152       : 1;            /*!< [24..24] b152                                                             */
      __OM  uint32 b153       : 1;            /*!< [25..25] b153                                                             */
      __OM  uint32 b154       : 1;            /*!< [26..26] b154                                                             */
      __OM  uint32 b155       : 1;            /*!< [27..27] b155                                                             */
      __OM  uint32 b156       : 1;            /*!< [28..28] b156                                                             */
      __OM  uint32 b157       : 1;            /*!< [29..29] b157                                                             */
      __OM  uint32 b158       : 1;            /*!< [30..30] b158                                                             */
      __OM  uint32 b159       : 1;            /*!< [31..31] b159                                                             */
    } bit;
  } K1RR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000030) key registers                                              */
    
    struct {
      __OM  uint32 b96        : 1;            /*!< [0..0] b96                                                                */
      __OM  uint32 b97        : 1;            /*!< [1..1] b97                                                                */
      __OM  uint32 b98        : 1;            /*!< [2..2] b98                                                                */
      __OM  uint32 b99        : 1;            /*!< [3..3] b99                                                                */
      __OM  uint32 b100       : 1;            /*!< [4..4] b100                                                               */
      __OM  uint32 b101       : 1;            /*!< [5..5] b101                                                               */
      __OM  uint32 b102       : 1;            /*!< [6..6] b102                                                               */
      __OM  uint32 b103       : 1;            /*!< [7..7] b103                                                               */
      __OM  uint32 b104       : 1;            /*!< [8..8] b104                                                               */
      __OM  uint32 b105       : 1;            /*!< [9..9] b105                                                               */
      __OM  uint32 b106       : 1;            /*!< [10..10] b106                                                             */
      __OM  uint32 b107       : 1;            /*!< [11..11] b107                                                             */
      __OM  uint32 b108       : 1;            /*!< [12..12] b108                                                             */
      __OM  uint32 b109       : 1;            /*!< [13..13] b109                                                             */
      __OM  uint32 b110       : 1;            /*!< [14..14] b110                                                             */
      __OM  uint32 b111       : 1;            /*!< [15..15] b111                                                             */
      __OM  uint32 b112       : 1;            /*!< [16..16] b112                                                             */
      __OM  uint32 b113       : 1;            /*!< [17..17] b113                                                             */
      __OM  uint32 b114       : 1;            /*!< [18..18] b114                                                             */
      __OM  uint32 b115       : 1;            /*!< [19..19] b115                                                             */
      __OM  uint32 b116       : 1;            /*!< [20..20] b116                                                             */
      __OM  uint32 b117       : 1;            /*!< [21..21] b117                                                             */
      __OM  uint32 b118       : 1;            /*!< [22..22] b118                                                             */
      __OM  uint32 b119       : 1;            /*!< [23..23] b119                                                             */
      __OM  uint32 b120       : 1;            /*!< [24..24] b120                                                             */
      __OM  uint32 b121       : 1;            /*!< [25..25] b121                                                             */
      __OM  uint32 b122       : 1;            /*!< [26..26] b122                                                             */
      __OM  uint32 b123       : 1;            /*!< [27..27] b123                                                             */
      __OM  uint32 b124       : 1;            /*!< [28..28] b124                                                             */
      __OM  uint32 b125       : 1;            /*!< [29..29] b125                                                             */
      __OM  uint32 b126       : 1;            /*!< [30..30] b126                                                             */
      __OM  uint32 b127       : 1;            /*!< [31..31] b127                                                             */
    } bit;
  } K2LR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000034) key registers                                              */
    
    struct {
      __OM  uint32 b64        : 1;            /*!< [0..0] b64                                                                */
      __OM  uint32 b65        : 1;            /*!< [1..1] b65                                                                */
      __OM  uint32 b66        : 1;            /*!< [2..2] b66                                                                */
      __OM  uint32 b67        : 1;            /*!< [3..3] b67                                                                */
      __OM  uint32 b68        : 1;            /*!< [4..4] b68                                                                */
      __OM  uint32 b69        : 1;            /*!< [5..5] b69                                                                */
      __OM  uint32 b70        : 1;            /*!< [6..6] b70                                                                */
      __OM  uint32 b71        : 1;            /*!< [7..7] b71                                                                */
      __OM  uint32 b72        : 1;            /*!< [8..8] b72                                                                */
      __OM  uint32 b73        : 1;            /*!< [9..9] b73                                                                */
      __OM  uint32 b74        : 1;            /*!< [10..10] b74                                                              */
      __OM  uint32 b75        : 1;            /*!< [11..11] b75                                                              */
      __OM  uint32 b76        : 1;            /*!< [12..12] b76                                                              */
      __OM  uint32 b77        : 1;            /*!< [13..13] b77                                                              */
      __OM  uint32 b78        : 1;            /*!< [14..14] b78                                                              */
      __OM  uint32 b79        : 1;            /*!< [15..15] b79                                                              */
      __OM  uint32 b80        : 1;            /*!< [16..16] b80                                                              */
      __OM  uint32 b81        : 1;            /*!< [17..17] b81                                                              */
      __OM  uint32 b82        : 1;            /*!< [18..18] b82                                                              */
      __OM  uint32 b83        : 1;            /*!< [19..19] b83                                                              */
      __OM  uint32 b84        : 1;            /*!< [20..20] b84                                                              */
      __OM  uint32 b85        : 1;            /*!< [21..21] b85                                                              */
      __OM  uint32 b86        : 1;            /*!< [22..22] b86                                                              */
      __OM  uint32 b87        : 1;            /*!< [23..23] b87                                                              */
      __OM  uint32 b88        : 1;            /*!< [24..24] b88                                                              */
      __OM  uint32 b89        : 1;            /*!< [25..25] b89                                                              */
      __OM  uint32 b90        : 1;            /*!< [26..26] b90                                                              */
      __OM  uint32 b91        : 1;            /*!< [27..27] b91                                                              */
      __OM  uint32 b92        : 1;            /*!< [28..28] b92                                                              */
      __OM  uint32 b93        : 1;            /*!< [29..29] b93                                                              */
      __OM  uint32 b94        : 1;            /*!< [30..30] b94                                                              */
      __OM  uint32 b95        : 1;            /*!< [31..31] b95                                                              */
    } bit;
  } K2RR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000038) key registers                                              */
    
    struct {
      __OM  uint32 b32        : 1;            /*!< [0..0] b32                                                                */
      __OM  uint32 b33        : 1;            /*!< [1..1] b33                                                                */
      __OM  uint32 b34        : 1;            /*!< [2..2] b34                                                                */
      __OM  uint32 b35        : 1;            /*!< [3..3] b35                                                                */
      __OM  uint32 b36        : 1;            /*!< [4..4] b36                                                                */
      __OM  uint32 b37        : 1;            /*!< [5..5] b37                                                                */
      __OM  uint32 b38        : 1;            /*!< [6..6] b38                                                                */
      __OM  uint32 b39        : 1;            /*!< [7..7] b39                                                                */
      __OM  uint32 b40        : 1;            /*!< [8..8] b40                                                                */
      __OM  uint32 b41        : 1;            /*!< [9..9] b41                                                                */
      __OM  uint32 b42        : 1;            /*!< [10..10] b42                                                              */
      __OM  uint32 b43        : 1;            /*!< [11..11] b43                                                              */
      __OM  uint32 b44        : 1;            /*!< [12..12] b44                                                              */
      __OM  uint32 b45        : 1;            /*!< [13..13] b45                                                              */
      __OM  uint32 b46        : 1;            /*!< [14..14] b46                                                              */
      __OM  uint32 b47        : 1;            /*!< [15..15] b47                                                              */
      __OM  uint32 b48        : 1;            /*!< [16..16] b48                                                              */
      __OM  uint32 b49        : 1;            /*!< [17..17] b49                                                              */
      __OM  uint32 b50        : 1;            /*!< [18..18] b50                                                              */
      __OM  uint32 b51        : 1;            /*!< [19..19] b51                                                              */
      __OM  uint32 b52        : 1;            /*!< [20..20] b52                                                              */
      __OM  uint32 b53        : 1;            /*!< [21..21] b53                                                              */
      __OM  uint32 b54        : 1;            /*!< [22..22] b54                                                              */
      __OM  uint32 b55        : 1;            /*!< [23..23] b55                                                              */
      __OM  uint32 b56        : 1;            /*!< [24..24] b56                                                              */
      __OM  uint32 b57        : 1;            /*!< [25..25] b57                                                              */
      __OM  uint32 b58        : 1;            /*!< [26..26] b58                                                              */
      __OM  uint32 b59        : 1;            /*!< [27..27] b59                                                              */
      __OM  uint32 b60        : 1;            /*!< [28..28] b60                                                              */
      __OM  uint32 b61        : 1;            /*!< [29..29] b61                                                              */
      __OM  uint32 b62        : 1;            /*!< [30..30] b62                                                              */
      __OM  uint32 b63        : 1;            /*!< [31..31] b63                                                              */
    } bit;
  } K3LR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x0000003C) key registers                                              */
    
    struct {
      __OM  uint32 b0         : 1;            /*!< [0..0] b0                                                                 */
      __OM  uint32 b1         : 1;            /*!< [1..1] b1                                                                 */
      __OM  uint32 b2         : 1;            /*!< [2..2] b2                                                                 */
      __OM  uint32 b3         : 1;            /*!< [3..3] b3                                                                 */
      __OM  uint32 b4         : 1;            /*!< [4..4] b4                                                                 */
      __OM  uint32 b5         : 1;            /*!< [5..5] b5                                                                 */
      __OM  uint32 b6         : 1;            /*!< [6..6] b6                                                                 */
      __OM  uint32 b7         : 1;            /*!< [7..7] b7                                                                 */
      __OM  uint32 b8         : 1;            /*!< [8..8] b8                                                                 */
      __OM  uint32 b9         : 1;            /*!< [9..9] b9                                                                 */
      __OM  uint32 b10        : 1;            /*!< [10..10] b10                                                              */
      __OM  uint32 b11        : 1;            /*!< [11..11] b11                                                              */
      __OM  uint32 b12        : 1;            /*!< [12..12] b12                                                              */
      __OM  uint32 b13        : 1;            /*!< [13..13] b13                                                              */
      __OM  uint32 b14        : 1;            /*!< [14..14] b14                                                              */
      __OM  uint32 b15        : 1;            /*!< [15..15] b15                                                              */
      __OM  uint32 b16        : 1;            /*!< [16..16] b16                                                              */
      __OM  uint32 b17        : 1;            /*!< [17..17] b17                                                              */
      __OM  uint32 b18        : 1;            /*!< [18..18] b18                                                              */
      __OM  uint32 b19        : 1;            /*!< [19..19] b19                                                              */
      __OM  uint32 b20        : 1;            /*!< [20..20] b20                                                              */
      __OM  uint32 b21        : 1;            /*!< [21..21] b21                                                              */
      __OM  uint32 b22        : 1;            /*!< [22..22] b22                                                              */
      __OM  uint32 b23        : 1;            /*!< [23..23] b23                                                              */
      __OM  uint32 b24        : 1;            /*!< [24..24] b24                                                              */
      __OM  uint32 b25        : 1;            /*!< [25..25] b25                                                              */
      __OM  uint32 b26        : 1;            /*!< [26..26] b26                                                              */
      __OM  uint32 b27        : 1;            /*!< [27..27] b27                                                              */
      __OM  uint32 b28        : 1;            /*!< [28..28] b28                                                              */
      __OM  uint32 b29        : 1;            /*!< [29..29] b29                                                              */
      __OM  uint32 b30        : 1;            /*!< [30..30] b30                                                              */
      __OM  uint32 b31        : 1;            /*!< [31..31] b31                                                              */
    } bit;
  } K3RR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000040) initialization vector registers                            */
    
    struct {
      __IOM uint32 IV31       : 1;            /*!< [0..0] IV31                                                               */
      __IOM uint32 IV30       : 1;            /*!< [1..1] IV30                                                               */
      __IOM uint32 IV29       : 1;            /*!< [2..2] IV29                                                               */
      __IOM uint32 IV28       : 1;            /*!< [3..3] IV28                                                               */
      __IOM uint32 IV27       : 1;            /*!< [4..4] IV27                                                               */
      __IOM uint32 IV26       : 1;            /*!< [5..5] IV26                                                               */
      __IOM uint32 IV25       : 1;            /*!< [6..6] IV25                                                               */
      __IOM uint32 IV24       : 1;            /*!< [7..7] IV24                                                               */
      __IOM uint32 IV23       : 1;            /*!< [8..8] IV23                                                               */
      __IOM uint32 IV22       : 1;            /*!< [9..9] IV22                                                               */
      __IOM uint32 IV21       : 1;            /*!< [10..10] IV21                                                             */
      __IOM uint32 IV20       : 1;            /*!< [11..11] IV20                                                             */
      __IOM uint32 IV19       : 1;            /*!< [12..12] IV19                                                             */
      __IOM uint32 IV18       : 1;            /*!< [13..13] IV18                                                             */
      __IOM uint32 IV17       : 1;            /*!< [14..14] IV17                                                             */
      __IOM uint32 IV16       : 1;            /*!< [15..15] IV16                                                             */
      __IOM uint32 IV15       : 1;            /*!< [16..16] IV15                                                             */
      __IOM uint32 IV14       : 1;            /*!< [17..17] IV14                                                             */
      __IOM uint32 IV13       : 1;            /*!< [18..18] IV13                                                             */
      __IOM uint32 IV12       : 1;            /*!< [19..19] IV12                                                             */
      __IOM uint32 IV11       : 1;            /*!< [20..20] IV11                                                             */
      __IOM uint32 IV10       : 1;            /*!< [21..21] IV10                                                             */
      __IOM uint32 IV9        : 1;            /*!< [22..22] IV9                                                              */
      __IOM uint32 IV8        : 1;            /*!< [23..23] IV8                                                              */
      __IOM uint32 IV7        : 1;            /*!< [24..24] IV7                                                              */
      __IOM uint32 IV6        : 1;            /*!< [25..25] IV6                                                              */
      __IOM uint32 IV5        : 1;            /*!< [26..26] IV5                                                              */
      __IOM uint32 IV4        : 1;            /*!< [27..27] IV4                                                              */
      __IOM uint32 IV3        : 1;            /*!< [28..28] IV3                                                              */
      __IOM uint32 IV2        : 1;            /*!< [29..29] IV2                                                              */
      __IOM uint32 IV1        : 1;            /*!< [30..30] IV1                                                              */
      __IOM uint32 IV0        : 1;            /*!< [31..31] IV0                                                              */
    } bit;
  } IV0LR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000044) initialization vector registers                            */
    
    struct {
      __IOM uint32 IV63       : 1;            /*!< [0..0] IV63                                                               */
      __IOM uint32 IV62       : 1;            /*!< [1..1] IV62                                                               */
      __IOM uint32 IV61       : 1;            /*!< [2..2] IV61                                                               */
      __IOM uint32 IV60       : 1;            /*!< [3..3] IV60                                                               */
      __IOM uint32 IV59       : 1;            /*!< [4..4] IV59                                                               */
      __IOM uint32 IV58       : 1;            /*!< [5..5] IV58                                                               */
      __IOM uint32 IV57       : 1;            /*!< [6..6] IV57                                                               */
      __IOM uint32 IV56       : 1;            /*!< [7..7] IV56                                                               */
      __IOM uint32 IV55       : 1;            /*!< [8..8] IV55                                                               */
      __IOM uint32 IV54       : 1;            /*!< [9..9] IV54                                                               */
      __IOM uint32 IV53       : 1;            /*!< [10..10] IV53                                                             */
      __IOM uint32 IV52       : 1;            /*!< [11..11] IV52                                                             */
      __IOM uint32 IV51       : 1;            /*!< [12..12] IV51                                                             */
      __IOM uint32 IV50       : 1;            /*!< [13..13] IV50                                                             */
      __IOM uint32 IV49       : 1;            /*!< [14..14] IV49                                                             */
      __IOM uint32 IV48       : 1;            /*!< [15..15] IV48                                                             */
      __IOM uint32 IV47       : 1;            /*!< [16..16] IV47                                                             */
      __IOM uint32 IV46       : 1;            /*!< [17..17] IV46                                                             */
      __IOM uint32 IV45       : 1;            /*!< [18..18] IV45                                                             */
      __IOM uint32 IV44       : 1;            /*!< [19..19] IV44                                                             */
      __IOM uint32 IV43       : 1;            /*!< [20..20] IV43                                                             */
      __IOM uint32 IV42       : 1;            /*!< [21..21] IV42                                                             */
      __IOM uint32 IV41       : 1;            /*!< [22..22] IV41                                                             */
      __IOM uint32 IV40       : 1;            /*!< [23..23] IV40                                                             */
      __IOM uint32 IV39       : 1;            /*!< [24..24] IV39                                                             */
      __IOM uint32 IV38       : 1;            /*!< [25..25] IV38                                                             */
      __IOM uint32 IV37       : 1;            /*!< [26..26] IV37                                                             */
      __IOM uint32 IV36       : 1;            /*!< [27..27] IV36                                                             */
      __IOM uint32 IV35       : 1;            /*!< [28..28] IV35                                                             */
      __IOM uint32 IV34       : 1;            /*!< [29..29] IV34                                                             */
      __IOM uint32 IV33       : 1;            /*!< [30..30] IV33                                                             */
      __IOM uint32 IV32       : 1;            /*!< [31..31] IV32                                                             */
    } bit;
  } IV0RR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000048) initialization vector registers                            */
    
    struct {
      __IOM uint32 IV95       : 1;            /*!< [0..0] IV95                                                               */
      __IOM uint32 IV94       : 1;            /*!< [1..1] IV94                                                               */
      __IOM uint32 IV93       : 1;            /*!< [2..2] IV93                                                               */
      __IOM uint32 IV92       : 1;            /*!< [3..3] IV92                                                               */
      __IOM uint32 IV91       : 1;            /*!< [4..4] IV91                                                               */
      __IOM uint32 IV90       : 1;            /*!< [5..5] IV90                                                               */
      __IOM uint32 IV89       : 1;            /*!< [6..6] IV89                                                               */
      __IOM uint32 IV88       : 1;            /*!< [7..7] IV88                                                               */
      __IOM uint32 IV87       : 1;            /*!< [8..8] IV87                                                               */
      __IOM uint32 IV86       : 1;            /*!< [9..9] IV86                                                               */
      __IOM uint32 IV85       : 1;            /*!< [10..10] IV85                                                             */
      __IOM uint32 IV84       : 1;            /*!< [11..11] IV84                                                             */
      __IOM uint32 IV83       : 1;            /*!< [12..12] IV83                                                             */
      __IOM uint32 IV82       : 1;            /*!< [13..13] IV82                                                             */
      __IOM uint32 IV81       : 1;            /*!< [14..14] IV81                                                             */
      __IOM uint32 IV80       : 1;            /*!< [15..15] IV80                                                             */
      __IOM uint32 IV79       : 1;            /*!< [16..16] IV79                                                             */
      __IOM uint32 IV78       : 1;            /*!< [17..17] IV78                                                             */
      __IOM uint32 IV77       : 1;            /*!< [18..18] IV77                                                             */
      __IOM uint32 IV76       : 1;            /*!< [19..19] IV76                                                             */
      __IOM uint32 IV75       : 1;            /*!< [20..20] IV75                                                             */
      __IOM uint32 IV74       : 1;            /*!< [21..21] IV74                                                             */
      __IOM uint32 IV73       : 1;            /*!< [22..22] IV73                                                             */
      __IOM uint32 IV72       : 1;            /*!< [23..23] IV72                                                             */
      __IOM uint32 IV71       : 1;            /*!< [24..24] IV71                                                             */
      __IOM uint32 IV70       : 1;            /*!< [25..25] IV70                                                             */
      __IOM uint32 IV69       : 1;            /*!< [26..26] IV69                                                             */
      __IOM uint32 IV68       : 1;            /*!< [27..27] IV68                                                             */
      __IOM uint32 IV67       : 1;            /*!< [28..28] IV67                                                             */
      __IOM uint32 IV66       : 1;            /*!< [29..29] IV66                                                             */
      __IOM uint32 IV65       : 1;            /*!< [30..30] IV65                                                             */
      __IOM uint32 IV64       : 1;            /*!< [31..31] IV64                                                             */
    } bit;
  } IV1LR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000004C) initialization vector registers                            */
    
    struct {
      __IOM uint32 IV127      : 1;            /*!< [0..0] IV127                                                              */
      __IOM uint32 IV126      : 1;            /*!< [1..1] IV126                                                              */
      __IOM uint32 IV125      : 1;            /*!< [2..2] IV125                                                              */
      __IOM uint32 IV124      : 1;            /*!< [3..3] IV124                                                              */
      __IOM uint32 IV123      : 1;            /*!< [4..4] IV123                                                              */
      __IOM uint32 IV122      : 1;            /*!< [5..5] IV122                                                              */
      __IOM uint32 IV121      : 1;            /*!< [6..6] IV121                                                              */
      __IOM uint32 IV120      : 1;            /*!< [7..7] IV120                                                              */
      __IOM uint32 IV119      : 1;            /*!< [8..8] IV119                                                              */
      __IOM uint32 IV118      : 1;            /*!< [9..9] IV118                                                              */
      __IOM uint32 IV117      : 1;            /*!< [10..10] IV117                                                            */
      __IOM uint32 IV116      : 1;            /*!< [11..11] IV116                                                            */
      __IOM uint32 IV115      : 1;            /*!< [12..12] IV115                                                            */
      __IOM uint32 IV114      : 1;            /*!< [13..13] IV114                                                            */
      __IOM uint32 IV113      : 1;            /*!< [14..14] IV113                                                            */
      __IOM uint32 IV112      : 1;            /*!< [15..15] IV112                                                            */
      __IOM uint32 IV111      : 1;            /*!< [16..16] IV111                                                            */
      __IOM uint32 IV110      : 1;            /*!< [17..17] IV110                                                            */
      __IOM uint32 IV109      : 1;            /*!< [18..18] IV109                                                            */
      __IOM uint32 IV108      : 1;            /*!< [19..19] IV108                                                            */
      __IOM uint32 IV107      : 1;            /*!< [20..20] IV107                                                            */
      __IOM uint32 IV106      : 1;            /*!< [21..21] IV106                                                            */
      __IOM uint32 IV105      : 1;            /*!< [22..22] IV105                                                            */
      __IOM uint32 IV104      : 1;            /*!< [23..23] IV104                                                            */
      __IOM uint32 IV103      : 1;            /*!< [24..24] IV103                                                            */
      __IOM uint32 IV102      : 1;            /*!< [25..25] IV102                                                            */
      __IOM uint32 IV101      : 1;            /*!< [26..26] IV101                                                            */
      __IOM uint32 IV100      : 1;            /*!< [27..27] IV100                                                            */
      __IOM uint32 IV99       : 1;            /*!< [28..28] IV99                                                             */
      __IOM uint32 IV98       : 1;            /*!< [29..29] IV98                                                             */
      __IOM uint32 IV97       : 1;            /*!< [30..30] IV97                                                             */
      __IOM uint32 IV96       : 1;            /*!< [31..31] IV96                                                             */
    } bit;
  } IV1RR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000050) context swap register                                      */
    
    struct {
      __IOM uint32 CSGCMCCM0R : 32;           /*!< [31..0] CSGCMCCM0R                                                        */
    } bit;
  } CSGCMCCM0R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000054) context swap register                                      */
    
    struct {
      __IOM uint32 CSGCMCCM1R : 32;           /*!< [31..0] CSGCMCCM1R                                                        */
    } bit;
  } CSGCMCCM1R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000058) context swap register                                      */
    
    struct {
      __IOM uint32 CSGCMCCM2R : 32;           /*!< [31..0] CSGCMCCM2R                                                        */
    } bit;
  } CSGCMCCM2R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000005C) context swap register                                      */
    
    struct {
      __IOM uint32 CSGCMCCM3R : 32;           /*!< [31..0] CSGCMCCM3R                                                        */
    } bit;
  } CSGCMCCM3R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000060) context swap register                                      */
    
    struct {
      __IOM uint32 CSGCMCCM4R : 32;           /*!< [31..0] CSGCMCCM4R                                                        */
    } bit;
  } CSGCMCCM4R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000064) context swap register                                      */
    
    struct {
      __IOM uint32 CSGCMCCM5R : 32;           /*!< [31..0] CSGCMCCM5R                                                        */
    } bit;
  } CSGCMCCM5R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000068) context swap register                                      */
    
    struct {
      __IOM uint32 CSGCMCCM6R : 32;           /*!< [31..0] CSGCMCCM6R                                                        */
    } bit;
  } CSGCMCCM6R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000006C) context swap register                                      */
    
    struct {
      __IOM uint32 CSGCMCCM7R : 32;           /*!< [31..0] CSGCMCCM7R                                                        */
    } bit;
  } CSGCMCCM7R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000070) context swap register                                      */
    
    struct {
      __IOM uint32 CSGCM0R    : 32;           /*!< [31..0] CSGCM0R                                                           */
    } bit;
  } CSGCM0R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000074) context swap register                                      */
    
    struct {
      __IOM uint32 CSGCM1R    : 32;           /*!< [31..0] CSGCM1R                                                           */
    } bit;
  } CSGCM1R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000078) context swap register                                      */
    
    struct {
      __IOM uint32 CSGCM2R    : 32;           /*!< [31..0] CSGCM2R                                                           */
    } bit;
  } CSGCM2R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000007C) context swap register                                      */
    
    struct {
      __IOM uint32 CSGCM3R    : 32;           /*!< [31..0] CSGCM3R                                                           */
    } bit;
  } CSGCM3R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000080) context swap register                                      */
    
    struct {
      __IOM uint32 CSGCM4R    : 32;           /*!< [31..0] CSGCM4R                                                           */
    } bit;
  } CSGCM4R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000084) context swap register                                      */
    
    struct {
      __IOM uint32 CSGCM5R    : 32;           /*!< [31..0] CSGCM5R                                                           */
    } bit;
  } CSGCM5R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000088) context swap register                                      */
    
    struct {
      __IOM uint32 CSGCM6R    : 32;           /*!< [31..0] CSGCM6R                                                           */
    } bit;
  } CSGCM6R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000008C) context swap register                                      */
    
    struct {
      __IOM uint32 CSGCM7R    : 32;           /*!< [31..0] CSGCM7R                                                           */
    } bit;
  } CSGCM7R;
} CRYP_Type;                                    /*!< Size = 144 (0x90)                                                         */



/* =========================================================================================================================== */
/* ================                                           DCMI                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Digital camera interface (DCMI)
  */

typedef struct {                                /*!< (@ 0x48020000) DCMI Structure                                             */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) control register 1                                         */
    
    struct {
      __IOM uint32 CAPTURE    : 1;            /*!< [0..0] Capture enable                                                     */
      __IOM uint32 CM         : 1;            /*!< [1..1] Capture mode                                                       */
      __IOM uint32 CROP       : 1;            /*!< [2..2] Crop feature                                                       */
      __IOM uint32 JPEG       : 1;            /*!< [3..3] JPEG format                                                        */
      __IOM uint32 ESS        : 1;            /*!< [4..4] Embedded synchronization select                                    */
      __IOM uint32 PCKPOL     : 1;            /*!< [5..5] Pixel clock polarity                                               */
      __IOM uint32 HSPOL      : 1;            /*!< [6..6] Horizontal synchronization polarity                                */
      __IOM uint32 VSPOL      : 1;            /*!< [7..7] Vertical synchronization polarity                                  */
      __IOM uint32 FCRC       : 2;            /*!< [9..8] Frame capture rate control                                         */
      __IOM uint32 EDM        : 2;            /*!< [11..10] Extended data mode                                               */
            uint32            : 2;
      __IOM uint32 ENABLE     : 1;            /*!< [14..14] DCMI enable                                                      */
            uint32            : 1;
      __IOM uint32 BSM        : 2;            /*!< [17..16] Byte Select mode                                                 */
      __IOM uint32 OEBS       : 1;            /*!< [18..18] Odd/Even Byte Select (Byte Select Start)                         */
      __IOM uint32 LSM        : 1;            /*!< [19..19] Line Select mode                                                 */
      __IOM uint32 OELS       : 1;            /*!< [20..20] Odd/Even Line Select (Line Select Start)                         */
            uint32            : 11;
    } bit;
  } CR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000004) status register                                            */
    
    struct {
      __IM  uint32 HSYNC      : 1;            /*!< [0..0] HSYNC                                                              */
      __IM  uint32 VSYNC      : 1;            /*!< [1..1] VSYNC                                                              */
      __IM  uint32 FNE        : 1;            /*!< [2..2] FIFO not empty                                                     */
            uint32            : 29;
    } bit;
  } SR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000008) raw interrupt status register                              */
    
    struct {
      __IM  uint32 FRAME_RIS  : 1;            /*!< [0..0] Capture complete raw interrupt status                              */
      __IM  uint32 OVR_RIS    : 1;            /*!< [1..1] Overrun raw interrupt status                                       */
      __IM  uint32 ERR_RIS    : 1;            /*!< [2..2] Synchronization error raw interrupt status                         */
      __IM  uint32 VSYNC_RIS  : 1;            /*!< [3..3] VSYNC raw interrupt status                                         */
      __IM  uint32 LINE_RIS   : 1;            /*!< [4..4] Line raw interrupt status                                          */
            uint32            : 27;
    } bit;
  } RIS;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) interrupt enable register                                  */
    
    struct {
      __IOM uint32 FRAME_IE   : 1;            /*!< [0..0] Capture complete interrupt enable                                  */
      __IOM uint32 OVR_IE     : 1;            /*!< [1..1] Overrun interrupt enable                                           */
      __IOM uint32 ERR_IE     : 1;            /*!< [2..2] Synchronization error interrupt enable                             */
      __IOM uint32 VSYNC_IE   : 1;            /*!< [3..3] VSYNC interrupt enable                                             */
      __IOM uint32 LINE_IE    : 1;            /*!< [4..4] Line interrupt enable                                              */
            uint32            : 27;
    } bit;
  } IER;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000010) masked interrupt status register                           */
    
    struct {
      __IM  uint32 FRAME_MIS  : 1;            /*!< [0..0] Capture complete masked interrupt status                           */
      __IM  uint32 OVR_MIS    : 1;            /*!< [1..1] Overrun masked interrupt status                                    */
      __IM  uint32 ERR_MIS    : 1;            /*!< [2..2] Synchronization error masked interrupt status                      */
      __IM  uint32 VSYNC_MIS  : 1;            /*!< [3..3] VSYNC masked interrupt status                                      */
      __IM  uint32 LINE_MIS   : 1;            /*!< [4..4] Line masked interrupt status                                       */
            uint32            : 27;
    } bit;
  } MIS;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000014) interrupt clear register                                   */
    
    struct {
      __OM  uint32 FRAME_ISC  : 1;            /*!< [0..0] Capture complete interrupt status clear                            */
      __OM  uint32 OVR_ISC    : 1;            /*!< [1..1] Overrun interrupt status clear                                     */
      __OM  uint32 ERR_ISC    : 1;            /*!< [2..2] Synchronization error interrupt status clear                       */
      __OM  uint32 VSYNC_ISC  : 1;            /*!< [3..3] Vertical synch interrupt status clear                              */
      __OM  uint32 LINE_ISC   : 1;            /*!< [4..4] line interrupt status clear                                        */
            uint32            : 27;
    } bit;
  } ICR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000018) embedded synchronization code register                     */
    
    struct {
      __IOM uint32 FSC        : 8;            /*!< [7..0] Frame start delimiter code                                         */
      __IOM uint32 LSC        : 8;            /*!< [15..8] Line start delimiter code                                         */
      __IOM uint32 LEC        : 8;            /*!< [23..16] Line end delimiter code                                          */
      __IOM uint32 FEC        : 8;            /*!< [31..24] Frame end delimiter code                                         */
    } bit;
  } ESCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000001C) embedded synchronization unmask register                   */
    
    struct {
      __IOM uint32 FSU        : 8;            /*!< [7..0] Frame start delimiter unmask                                       */
      __IOM uint32 LSU        : 8;            /*!< [15..8] Line start delimiter unmask                                       */
      __IOM uint32 LEU        : 8;            /*!< [23..16] Line end delimiter unmask                                        */
      __IOM uint32 FEU        : 8;            /*!< [31..24] Frame end delimiter unmask                                       */
    } bit;
  } ESUR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000020) crop window start                                          */
    
    struct {
      __IOM uint32 HOFFCNT    : 14;           /*!< [13..0] Horizontal offset count                                           */
            uint32            : 2;
      __IOM uint32 VST        : 13;           /*!< [28..16] Vertical start line count                                        */
            uint32            : 3;
    } bit;
  } CWSTRT;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000024) crop window size                                           */
    
    struct {
      __IOM uint32 CAPCNT     : 14;           /*!< [13..0] Capture count                                                     */
            uint32            : 2;
      __IOM uint32 VLINE      : 14;           /*!< [29..16] Vertical line count                                              */
            uint32            : 2;
    } bit;
  } CWSIZE;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000028) data register                                              */
    
    struct {
      __IM  uint32 Byte0      : 8;            /*!< [7..0] Data byte 0                                                        */
      __IM  uint32 Byte1      : 8;            /*!< [15..8] Data byte 1                                                       */
      __IM  uint32 Byte2      : 8;            /*!< [23..16] Data byte 2                                                      */
      __IM  uint32 Byte3      : 8;            /*!< [31..24] Data byte 3                                                      */
    } bit;
  } DR;
} DCMI_Type;                                    /*!< Size = 44 (0x2c)                                                          */



/* =========================================================================================================================== */
/* ================                                      OTG1_HS_GLOBAL                                       ================ */
/* =========================================================================================================================== */


/**
  * @brief USB 1 on the go high speed (OTG1_HS_GLOBAL)
  */

typedef struct {                                /*!< (@ 0x40040000) OTG1_HS_GLOBAL Structure                                   */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) OTG_HS control and status register                         */
    
    struct {
      __IM  uint32 SRQSCS     : 1;            /*!< [0..0] Session request success                                            */
      __IOM uint32 SRQ        : 1;            /*!< [1..1] Session request                                                    */
            uint32            : 6;
      __IM  uint32 HNGSCS     : 1;            /*!< [8..8] Host negotiation success                                           */
      __IOM uint32 HNPRQ      : 1;            /*!< [9..9] HNP request                                                        */
      __IOM uint32 HSHNPEN    : 1;            /*!< [10..10] Host set HNP enable                                              */
      __IOM uint32 DHNPEN     : 1;            /*!< [11..11] Device HNP enabled                                               */
      __IOM uint32 EHEN       : 1;            /*!< [12..12] Embedded host enable                                             */
            uint32            : 3;
      __IM  uint32 CIDSTS     : 1;            /*!< [16..16] Connector ID status                                              */
      __IM  uint32 DBCT       : 1;            /*!< [17..17] Long/short debounce time                                         */
      __IM  uint32 ASVLD      : 1;            /*!< [18..18] A-session valid                                                  */
      __IM  uint32 BSVLD      : 1;            /*!< [19..19] B-session valid                                                  */
            uint32            : 12;
    } bit;
  } OTG_HS_GOTGCTL;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) OTG_HS interrupt register                                  */
    
    struct {
            uint32            : 2;
      __IOM uint32 SEDET      : 1;            /*!< [2..2] Session end detected                                               */
            uint32            : 5;
      __IOM uint32 SRSSCHG    : 1;            /*!< [8..8] Session request success status change                              */
      __IOM uint32 HNSSCHG    : 1;            /*!< [9..9] Host negotiation success status change                             */
            uint32            : 7;
      __IOM uint32 HNGDET     : 1;            /*!< [17..17] Host negotiation detected                                        */
      __IOM uint32 ADTOCHG    : 1;            /*!< [18..18] A-device timeout change                                          */
      __IOM uint32 DBCDNE     : 1;            /*!< [19..19] Debounce done                                                    */
      __IOM uint32 IDCHNG     : 1;            /*!< [20..20] ID input pin changed                                             */
            uint32            : 11;
    } bit;
  } OTG_HS_GOTGINT;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) OTG_HS AHB configuration register                          */
    
    struct {
      __IOM uint32 GINT       : 1;            /*!< [0..0] Global interrupt mask                                              */
      __IOM uint32 HBSTLEN    : 4;            /*!< [4..1] Burst length/type                                                  */
      __IOM uint32 DMAEN      : 1;            /*!< [5..5] DMA enable                                                         */
            uint32            : 1;
      __IOM uint32 TXFELVL    : 1;            /*!< [7..7] TxFIFO empty level                                                 */
      __IOM uint32 PTXFELVL   : 1;            /*!< [8..8] Periodic TxFIFO empty level                                        */
            uint32            : 23;
    } bit;
  } OTG_HS_GAHBCFG;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) OTG_HS USB configuration register                          */
    
    struct {
      __IOM uint32 TOCAL      : 3;            /*!< [2..0] FS timeout calibration                                             */
            uint32            : 3;
      __OM  uint32 PHYSEL     : 1;            /*!< [6..6] USB 2.0 high-speed ULPI PHY or USB 1.1 full-speed serial
                                                     transceiver select                                                        */
            uint32            : 1;
      __IOM uint32 SRPCAP     : 1;            /*!< [8..8] SRP-capable                                                        */
      __IOM uint32 HNPCAP     : 1;            /*!< [9..9] HNP-capable                                                        */
      __IOM uint32 TRDT       : 4;            /*!< [13..10] USB turnaround time                                              */
            uint32            : 1;
      __IOM uint32 PHYLPCS    : 1;            /*!< [15..15] PHY Low-power clock select                                       */
            uint32            : 1;
      __IOM uint32 ULPIFSLS   : 1;            /*!< [17..17] ULPI FS/LS select                                                */
      __IOM uint32 ULPIAR     : 1;            /*!< [18..18] ULPI Auto-resume                                                 */
      __IOM uint32 ULPICSM    : 1;            /*!< [19..19] ULPI Clock SuspendM                                              */
      __IOM uint32 ULPIEVBUSD : 1;            /*!< [20..20] ULPI External VBUS Drive                                         */
      __IOM uint32 ULPIEVBUSI : 1;            /*!< [21..21] ULPI external VBUS indicator                                     */
      __IOM uint32 TSDPS      : 1;            /*!< [22..22] TermSel DLine pulsing selection                                  */
      __IOM uint32 PCCI       : 1;            /*!< [23..23] Indicator complement                                             */
      __IOM uint32 PTCI       : 1;            /*!< [24..24] Indicator pass through                                           */
      __IOM uint32 ULPIIPD    : 1;            /*!< [25..25] ULPI interface protect disable                                   */
            uint32            : 3;
      __IOM uint32 FHMOD      : 1;            /*!< [29..29] Forced host mode                                                 */
      __IOM uint32 FDMOD      : 1;            /*!< [30..30] Forced peripheral mode                                           */
            uint32            : 1;
    } bit;
  } OTG_HS_GUSBCFG;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) OTG_HS reset register                                      */
    
    struct {
      __IOM uint32 CSRST      : 1;            /*!< [0..0] Core soft reset                                                    */
      __IOM uint32 HSRST      : 1;            /*!< [1..1] HCLK soft reset                                                    */
      __IOM uint32 FCRST      : 1;            /*!< [2..2] Host frame counter reset                                           */
            uint32            : 1;
      __IOM uint32 RXFFLSH    : 1;            /*!< [4..4] RxFIFO flush                                                       */
      __IOM uint32 TXFFLSH    : 1;            /*!< [5..5] TxFIFO flush                                                       */
      __IOM uint32 TXFNUM     : 5;            /*!< [10..6] TxFIFO number                                                     */
            uint32            : 19;
      __IM  uint32 DMAREQ     : 1;            /*!< [30..30] DMA request signal enabled for USB OTG HS                        */
      __IM  uint32 AHBIDL     : 1;            /*!< [31..31] AHB master idle                                                  */
    } bit;
  } OTG_HS_GRSTCTL;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000014) OTG_HS core interrupt register                             */
    
    struct {
      __IM  uint32 CMOD       : 1;            /*!< [0..0] Current mode of operation                                          */
      __IOM uint32 MMIS       : 1;            /*!< [1..1] Mode mismatch interrupt                                            */
      __IM  uint32 OTGINT     : 1;            /*!< [2..2] OTG interrupt                                                      */
      __IOM uint32 SOF        : 1;            /*!< [3..3] Start of frame                                                     */
      __IM  uint32 RXFLVL     : 1;            /*!< [4..4] RxFIFO nonempty                                                    */
      __IM  uint32 NPTXFE     : 1;            /*!< [5..5] Nonperiodic TxFIFO empty                                           */
      __IM  uint32 GINAKEFF   : 1;            /*!< [6..6] Global IN nonperiodic NAK effective                                */
      __IM  uint32 BOUTNAKEFF : 1;            /*!< [7..7] Global OUT NAK effective                                           */
            uint32            : 2;
      __IOM uint32 ESUSP      : 1;            /*!< [10..10] Early suspend                                                    */
      __IOM uint32 USBSUSP    : 1;            /*!< [11..11] USB suspend                                                      */
      __IOM uint32 USBRST     : 1;            /*!< [12..12] USB reset                                                        */
      __IOM uint32 ENUMDNE    : 1;            /*!< [13..13] Enumeration done                                                 */
      __IOM uint32 ISOODRP    : 1;            /*!< [14..14] Isochronous OUT packet dropped interrupt                         */
      __IOM uint32 EOPF       : 1;            /*!< [15..15] End of periodic frame interrupt                                  */
            uint32            : 2;
      __IM  uint32 IEPINT     : 1;            /*!< [18..18] IN endpoint interrupt                                            */
      __IM  uint32 OEPINT     : 1;            /*!< [19..19] OUT endpoint interrupt                                           */
      __IOM uint32 IISOIXFR   : 1;            /*!< [20..20] Incomplete isochronous IN transfer                               */
      __IOM uint32 PXFR_INCOMPISOOUT : 1;     /*!< [21..21] Incomplete periodic transfer                                     */
      __IOM uint32 DATAFSUSP  : 1;            /*!< [22..22] Data fetch suspended                                             */
            uint32            : 1;
      __IM  uint32 HPRTINT    : 1;            /*!< [24..24] Host port interrupt                                              */
      __IM  uint32 HCINT      : 1;            /*!< [25..25] Host channels interrupt                                          */
      __IM  uint32 PTXFE      : 1;            /*!< [26..26] Periodic TxFIFO empty                                            */
            uint32            : 1;
      __IOM uint32 CIDSCHG    : 1;            /*!< [28..28] Connector ID status change                                       */
      __IOM uint32 DISCINT    : 1;            /*!< [29..29] Disconnect detected interrupt                                    */
      __IOM uint32 SRQINT     : 1;            /*!< [30..30] Session request/new session detected interrupt                   */
      __IOM uint32 WKUINT     : 1;            /*!< [31..31] Resume/remote wakeup detected interrupt                          */
    } bit;
  } OTG_HS_GINTSTS;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000018) OTG_HS interrupt mask register                             */
    
    struct {
            uint32            : 1;
      __IOM uint32 MMISM      : 1;            /*!< [1..1] Mode mismatch interrupt mask                                       */
      __IOM uint32 OTGINT     : 1;            /*!< [2..2] OTG interrupt mask                                                 */
      __IOM uint32 SOFM       : 1;            /*!< [3..3] Start of frame mask                                                */
      __IOM uint32 RXFLVLM    : 1;            /*!< [4..4] Receive FIFO nonempty mask                                         */
      __IOM uint32 NPTXFEM    : 1;            /*!< [5..5] Nonperiodic TxFIFO empty mask                                      */
      __IOM uint32 GINAKEFFM  : 1;            /*!< [6..6] Global nonperiodic IN NAK effective mask                           */
      __IOM uint32 GONAKEFFM  : 1;            /*!< [7..7] Global OUT NAK effective mask                                      */
            uint32            : 2;
      __IOM uint32 ESUSPM     : 1;            /*!< [10..10] Early suspend mask                                               */
      __IOM uint32 USBSUSPM   : 1;            /*!< [11..11] USB suspend mask                                                 */
      __IOM uint32 USBRST     : 1;            /*!< [12..12] USB reset mask                                                   */
      __IOM uint32 ENUMDNEM   : 1;            /*!< [13..13] Enumeration done mask                                            */
      __IOM uint32 ISOODRPM   : 1;            /*!< [14..14] Isochronous OUT packet dropped interrupt mask                    */
      __IOM uint32 EOPFM      : 1;            /*!< [15..15] End of periodic frame interrupt mask                             */
            uint32            : 2;
      __IOM uint32 IEPINT     : 1;            /*!< [18..18] IN endpoints interrupt mask                                      */
      __IOM uint32 OEPINT     : 1;            /*!< [19..19] OUT endpoints interrupt mask                                     */
      __IOM uint32 IISOIXFRM  : 1;            /*!< [20..20] Incomplete isochronous IN transfer mask                          */
      __IOM uint32 PXFRM_IISOOXFRM : 1;       /*!< [21..21] Incomplete periodic transfer mask                                */
      __IOM uint32 FSUSPM     : 1;            /*!< [22..22] Data fetch suspended mask                                        */
      __IOM uint32 RSTDE      : 1;            /*!< [23..23] Reset detected interrupt mask                                    */
      __IM  uint32 PRTIM      : 1;            /*!< [24..24] Host port interrupt mask                                         */
      __IOM uint32 HCIM       : 1;            /*!< [25..25] Host channels interrupt mask                                     */
      __IOM uint32 PTXFEM     : 1;            /*!< [26..26] Periodic TxFIFO empty mask                                       */
      __IOM uint32 LPMINTM    : 1;            /*!< [27..27] LPM interrupt mask                                               */
      __IOM uint32 CIDSCHGM   : 1;            /*!< [28..28] Connector ID status change mask                                  */
      __IOM uint32 DISCINT    : 1;            /*!< [29..29] Disconnect detected interrupt mask                               */
      __IOM uint32 SRQIM      : 1;            /*!< [30..30] Session request/new session detected interrupt mask              */
      __IOM uint32 WUIM       : 1;            /*!< [31..31] Resume/remote wakeup detected interrupt mask                     */
    } bit;
  } OTG_HS_GINTMSK;
  
  union {
    union {
      __IM  uint32 reg;                       /*!< (@ 0x0000001C) OTG_HS Receive status debug read register (host
                                                                    mode)                                                      */
      
      struct {
        __IM  uint32 CHNUM    : 4;            /*!< [3..0] Channel number                                                     */
        __IM  uint32 BCNT     : 11;           /*!< [14..4] Byte count                                                        */
        __IM  uint32 DPID     : 2;            /*!< [16..15] Data PID                                                         */
        __IM  uint32 PKTSTS   : 4;            /*!< [20..17] Packet status                                                    */
              uint32          : 11;
      } bit;
    } OTG_HS_GRXSTSR_Host;
    
    union {
      __IM  uint32 reg;                       /*!< (@ 0x0000001C) OTG_HS Receive status debug read register (peripheral
                                                                    mode mode)                                                 */
      
      struct {
        __IM  uint32 EPNUM    : 4;            /*!< [3..0] Endpoint number                                                    */
        __IM  uint32 BCNT     : 11;           /*!< [14..4] Byte count                                                        */
        __IM  uint32 DPID     : 2;            /*!< [16..15] Data PID                                                         */
        __IM  uint32 PKTSTS   : 4;            /*!< [20..17] Packet status                                                    */
        __IM  uint32 FRMNUM   : 4;            /*!< [24..21] Frame number                                                     */
              uint32          : 7;
      } bit;
    } OTG_HS_GRXSTSR_Device;
  };
  
  union {
    union {
      __IM  uint32 reg;                       /*!< (@ 0x00000020) OTG_HS status read and pop register (host mode)            */
      
      struct {
        __IM  uint32 CHNUM    : 4;            /*!< [3..0] Channel number                                                     */
        __IM  uint32 BCNT     : 11;           /*!< [14..4] Byte count                                                        */
        __IM  uint32 DPID     : 2;            /*!< [16..15] Data PID                                                         */
        __IM  uint32 PKTSTS   : 4;            /*!< [20..17] Packet status                                                    */
              uint32          : 11;
      } bit;
    } OTG_HS_GRXSTSP_Host;
    
    union {
      __IM  uint32 reg;                       /*!< (@ 0x00000020) OTG_HS status read and pop register (peripheral
                                                                    mode)                                                      */
      
      struct {
        __IM  uint32 EPNUM    : 4;            /*!< [3..0] Endpoint number                                                    */
        __IM  uint32 BCNT     : 11;           /*!< [14..4] Byte count                                                        */
        __IM  uint32 DPID     : 2;            /*!< [16..15] Data PID                                                         */
        __IM  uint32 PKTSTS   : 4;            /*!< [20..17] Packet status                                                    */
        __IM  uint32 FRMNUM   : 4;            /*!< [24..21] Frame number                                                     */
              uint32          : 7;
      } bit;
    } OTG_HS_GRXSTSP_Device;
  };
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000024) OTG_HS Receive FIFO size register                          */
    
    struct {
      __IOM uint32 RXFD       : 16;           /*!< [15..0] RxFIFO depth                                                      */
            uint32            : 16;
    } bit;
  } OTG_HS_GRXFSIZ;
  
  union {
    union {
      __IOM uint32 reg;                       /*!< (@ 0x00000028) OTG_HS nonperiodic transmit FIFO size register
                                                                    (host mode)                                                */
      
      struct {
        __IOM uint32 NPTXFSA  : 16;           /*!< [15..0] Nonperiodic transmit RAM start address                            */
        __IOM uint32 NPTXFD   : 16;           /*!< [31..16] Nonperiodic TxFIFO depth                                         */
      } bit;
    } OTG_HS_HNPTXFSIZ_Host;
    
    union {
      __IOM uint32 reg;                       /*!< (@ 0x00000028) Endpoint 0 transmit FIFO size (peripheral mode)            */
      
      struct {
        __IOM uint32 TX0FSA   : 16;           /*!< [15..0] Endpoint 0 transmit RAM start address                             */
        __IOM uint32 TX0FD    : 16;           /*!< [31..16] Endpoint 0 TxFIFO depth                                          */
      } bit;
    } OTG_HS_DIEPTXF0_Device;
  };
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000002C) OTG_HS nonperiodic transmit FIFO/queue status
                                                                    register                                                   */
    
    struct {
      __IM  uint32 NPTXFSAV   : 16;           /*!< [15..0] Nonperiodic TxFIFO space available                                */
      __IM  uint32 NPTQXSAV   : 8;            /*!< [23..16] Nonperiodic transmit request queue space available               */
      __IM  uint32 NPTXQTOP   : 7;            /*!< [30..24] Top of the nonperiodic transmit request queue                    */
            uint32            : 1;
    } bit;
  } OTG_HS_GNPTXSTS;
  __IM  uint32  RESERVED[2];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000038) OTG_HS general core configuration register                 */
    
    struct {
      __IOM uint32 DCDET      : 1;            /*!< [0..0] Data contact detection (DCD) status                                */
      __IOM uint32 PDET       : 1;            /*!< [1..1] Primary detection (PD) status                                      */
      __IOM uint32 SDET       : 1;            /*!< [2..2] Secondary detection (SD) status                                    */
      __IOM uint32 PS2DET     : 1;            /*!< [3..3] DM pull-up detection status                                        */
            uint32            : 12;
      __IOM uint32 PWRDWN     : 1;            /*!< [16..16] Power down                                                       */
      __IOM uint32 BCDEN      : 1;            /*!< [17..17] Battery charging detector (BCD) enable                           */
      __IOM uint32 DCDEN      : 1;            /*!< [18..18] Data contact detection (DCD) mode enable                         */
      __IOM uint32 PDEN       : 1;            /*!< [19..19] Primary detection (PD) mode enable                               */
      __IOM uint32 SDEN       : 1;            /*!< [20..20] Secondary detection (SD) mode enable                             */
      __IOM uint32 VBDEN      : 1;            /*!< [21..21] USB VBUS detection enable                                        */
            uint32            : 10;
    } bit;
  } OTG_HS_GCCFG;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000003C) OTG_HS core ID register                                    */
    
    struct {
      __IOM uint32 PRODUCT_ID : 32;           /*!< [31..0] Product ID field                                                  */
    } bit;
  } OTG_HS_CID;
  __IM  uint32  RESERVED1[5];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000054) OTG core LPM configuration register                        */
    
    struct {
      __IOM uint32 LPMEN      : 1;            /*!< [0..0] LPM support enable                                                 */
      __IOM uint32 LPMACK     : 1;            /*!< [1..1] LPM token acknowledge enable                                       */
      __IM  uint32 BESL       : 4;            /*!< [5..2] Best effort service latency                                        */
      __IM  uint32 REMWAKE    : 1;            /*!< [6..6] bRemoteWake value                                                  */
      __IOM uint32 L1SSEN     : 1;            /*!< [7..7] L1 Shallow Sleep enable                                            */
      __IOM uint32 BESLTHRS   : 4;            /*!< [11..8] BESL threshold                                                    */
      __IOM uint32 L1DSEN     : 1;            /*!< [12..12] L1 deep sleep enable                                             */
      __IM  uint32 LPMRST     : 2;            /*!< [14..13] LPM response                                                     */
      __IM  uint32 SLPSTS     : 1;            /*!< [15..15] Port sleep status                                                */
      __IM  uint32 L1RSMOK    : 1;            /*!< [16..16] Sleep State Resume OK                                            */
      __IOM uint32 LPMCHIDX   : 4;            /*!< [20..17] LPM Channel Index                                                */
      __IOM uint32 LPMRCNT    : 3;            /*!< [23..21] LPM retry count                                                  */
      __IOM uint32 SNDLPM     : 1;            /*!< [24..24] Send LPM transaction                                             */
      __IM  uint32 LPMRCNTSTS : 3;            /*!< [27..25] LPM retry count status                                           */
      __IOM uint32 ENBESL     : 1;            /*!< [28..28] Enable best effort service latency                               */
            uint32            : 3;
    } bit;
  } OTG_HS_GLPMCFG;
  __IM  uint32  RESERVED2[42];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000100) OTG_HS Host periodic transmit FIFO size register           */
    
    struct {
      __IOM uint32 PTXSA      : 16;           /*!< [15..0] Host periodic TxFIFO start address                                */
      __IOM uint32 PTXFD      : 16;           /*!< [31..16] Host periodic TxFIFO depth                                       */
    } bit;
  } OTG_HS_HPTXFSIZ;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000104) OTG_HS device IN endpoint transmit FIFO size
                                                                    register                                                   */
    
    struct {
      __IOM uint32 INEPTXSA   : 16;           /*!< [15..0] IN endpoint FIFOx transmit RAM start address                      */
      __IOM uint32 INEPTXFD   : 16;           /*!< [31..16] IN endpoint TxFIFO depth                                         */
    } bit;
  } OTG_HS_DIEPTXF1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000108) OTG_HS device IN endpoint transmit FIFO size
                                                                    register                                                   */
    
    struct {
      __IOM uint32 INEPTXSA   : 16;           /*!< [15..0] IN endpoint FIFOx transmit RAM start address                      */
      __IOM uint32 INEPTXFD   : 16;           /*!< [31..16] IN endpoint TxFIFO depth                                         */
    } bit;
  } OTG_HS_DIEPTXF2;
  __IM  uint32  RESERVED3[4];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000011C) OTG_HS device IN endpoint transmit FIFO size
                                                                    register                                                   */
    
    struct {
      __IOM uint32 INEPTXSA   : 16;           /*!< [15..0] IN endpoint FIFOx transmit RAM start address                      */
      __IOM uint32 INEPTXFD   : 16;           /*!< [31..16] IN endpoint TxFIFO depth                                         */
    } bit;
  } OTG_HS_DIEPTXF3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000120) OTG_HS device IN endpoint transmit FIFO size
                                                                    register                                                   */
    
    struct {
      __IOM uint32 INEPTXSA   : 16;           /*!< [15..0] IN endpoint FIFOx transmit RAM start address                      */
      __IOM uint32 INEPTXFD   : 16;           /*!< [31..16] IN endpoint TxFIFO depth                                         */
    } bit;
  } OTG_HS_DIEPTXF4;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000124) OTG_HS device IN endpoint transmit FIFO size
                                                                    register                                                   */
    
    struct {
      __IOM uint32 INEPTXSA   : 16;           /*!< [15..0] IN endpoint FIFOx transmit RAM start address                      */
      __IOM uint32 INEPTXFD   : 16;           /*!< [31..16] IN endpoint TxFIFO depth                                         */
    } bit;
  } OTG_HS_DIEPTXF5;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000128) OTG_HS device IN endpoint transmit FIFO size
                                                                    register                                                   */
    
    struct {
      __IOM uint32 INEPTXSA   : 16;           /*!< [15..0] IN endpoint FIFOx transmit RAM start address                      */
      __IOM uint32 INEPTXFD   : 16;           /*!< [31..16] IN endpoint TxFIFO depth                                         */
    } bit;
  } OTG_HS_DIEPTXF6;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000012C) OTG_HS device IN endpoint transmit FIFO size
                                                                    register                                                   */
    
    struct {
      __IOM uint32 INEPTXSA   : 16;           /*!< [15..0] IN endpoint FIFOx transmit RAM start address                      */
      __IOM uint32 INEPTXFD   : 16;           /*!< [31..16] IN endpoint TxFIFO depth                                         */
    } bit;
  } OTG_HS_DIEPTXF7;
} OTG1_HS_GLOBAL_Type;                          /*!< Size = 304 (0x130)                                                        */



/* =========================================================================================================================== */
/* ================                                       OTG1_HS_HOST                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief USB 1 on the go high speed (OTG1_HS_HOST)
  */

typedef struct {                                /*!< (@ 0x40040400) OTG1_HS_HOST Structure                                     */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) OTG_HS host configuration register                         */
    
    struct {
      __IOM uint32 FSLSPCS    : 2;            /*!< [1..0] FS/LS PHY clock select                                             */
      __IM  uint32 FSLSS      : 1;            /*!< [2..2] FS- and LS-only support                                            */
            uint32            : 29;
    } bit;
  } OTG_HS_HCFG;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) OTG_HS Host frame interval register                        */
    
    struct {
      __IOM uint32 FRIVL      : 16;           /*!< [15..0] Frame interval                                                    */
            uint32            : 16;
    } bit;
  } OTG_HS_HFIR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000008) OTG_HS host frame number/frame time remaining
                                                                    register                                                   */
    
    struct {
      __IM  uint32 FRNUM      : 16;           /*!< [15..0] Frame number                                                      */
      __IM  uint32 FTREM      : 16;           /*!< [31..16] Frame time remaining                                             */
    } bit;
  } OTG_HS_HFNUM;
  __IM  uint32  RESERVED;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) OTG_HS_Host periodic transmit FIFO/queue status
                                                                    register                                                   */
    
    struct {
      __IOM uint32 PTXFSAVL   : 16;           /*!< [15..0] Periodic transmit data FIFO space available                       */
      __IM  uint32 PTXQSAV    : 8;            /*!< [23..16] Periodic transmit request queue space available                  */
      __IM  uint32 PTXQTOP    : 8;            /*!< [31..24] Top of the periodic transmit request queue                       */
    } bit;
  } OTG_HS_HPTXSTS;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000014) OTG_HS Host all channels interrupt register                */
    
    struct {
      __IM  uint32 HAINT      : 16;           /*!< [15..0] Channel interrupts                                                */
            uint32            : 16;
    } bit;
  } OTG_HS_HAINT;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000018) OTG_HS host all channels interrupt mask register           */
    
    struct {
      __IOM uint32 HAINTM     : 16;           /*!< [15..0] Channel interrupt mask                                            */
            uint32            : 16;
    } bit;
  } OTG_HS_HAINTMSK;
  __IM  uint32  RESERVED1[9];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000040) OTG_HS host port control and status register               */
    
    struct {
      __IM  uint32 PCSTS      : 1;            /*!< [0..0] Port connect status                                                */
      __IOM uint32 PCDET      : 1;            /*!< [1..1] Port connect detected                                              */
      __IOM uint32 PENA       : 1;            /*!< [2..2] Port enable                                                        */
      __IOM uint32 PENCHNG    : 1;            /*!< [3..3] Port enable/disable change                                         */
      __IM  uint32 POCA       : 1;            /*!< [4..4] Port overcurrent active                                            */
      __IOM uint32 POCCHNG    : 1;            /*!< [5..5] Port overcurrent change                                            */
      __IOM uint32 PRES       : 1;            /*!< [6..6] Port resume                                                        */
      __IOM uint32 PSUSP      : 1;            /*!< [7..7] Port suspend                                                       */
      __IOM uint32 PRST       : 1;            /*!< [8..8] Port reset                                                         */
            uint32            : 1;
      __IM  uint32 PLSTS      : 2;            /*!< [11..10] Port line status                                                 */
      __IOM uint32 PPWR       : 1;            /*!< [12..12] Port power                                                       */
      __IOM uint32 PTCTL      : 4;            /*!< [16..13] Port test control                                                */
      __IM  uint32 PSPD       : 2;            /*!< [18..17] Port speed                                                       */
            uint32            : 13;
    } bit;
  } OTG_HS_HPRT;
  __IM  uint32  RESERVED2[47];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000100) OTG_HS host channel-0 characteristics register             */
    
    struct {
      __IOM uint32 MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
      __IOM uint32 EPNUM      : 4;            /*!< [14..11] Endpoint number                                                  */
      __IOM uint32 EPDIR      : 1;            /*!< [15..15] Endpoint direction                                               */
            uint32            : 1;
      __IOM uint32 LSDEV      : 1;            /*!< [17..17] Low-speed device                                                 */
      __IOM uint32 EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32 MC         : 2;            /*!< [21..20] Multi Count (MC) / Error Count (EC)                              */
      __IOM uint32 DAD        : 7;            /*!< [28..22] Device address                                                   */
      __IOM uint32 ODDFRM     : 1;            /*!< [29..29] Odd frame                                                        */
      __IOM uint32 CHDIS      : 1;            /*!< [30..30] Channel disable                                                  */
      __IOM uint32 CHENA      : 1;            /*!< [31..31] Channel enable                                                   */
    } bit;
  } OTG_HS_HCCHAR0;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000104) OTG_HS host channel-0 split control register               */
    
    struct {
      __IOM uint32 PRTADDR    : 7;            /*!< [6..0] Port address                                                       */
      __IOM uint32 HUBADDR    : 7;            /*!< [13..7] Hub address                                                       */
      __IOM uint32 XACTPOS    : 2;            /*!< [15..14] XACTPOS                                                          */
      __IOM uint32 COMPLSPLT  : 1;            /*!< [16..16] Do complete split                                                */
            uint32            : 14;
      __IOM uint32 SPLITEN    : 1;            /*!< [31..31] Split enable                                                     */
    } bit;
  } OTG_HS_HCSPLT0;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000108) OTG_HS host channel-11 interrupt register                  */
    
    struct {
      __IOM uint32 XFRC       : 1;            /*!< [0..0] Transfer completed                                                 */
      __IOM uint32 CHH        : 1;            /*!< [1..1] Channel halted                                                     */
      __IOM uint32 AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32 STALL      : 1;            /*!< [3..3] STALL response received interrupt                                  */
      __IOM uint32 NAK        : 1;            /*!< [4..4] NAK response received interrupt                                    */
      __IOM uint32 ACK        : 1;            /*!< [5..5] ACK response received/transmitted interrupt                        */
      __IOM uint32 NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32 TXERR      : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32 BBERR      : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32 FRMOR      : 1;            /*!< [9..9] Frame overrun                                                      */
      __IOM uint32 DTERR      : 1;            /*!< [10..10] Data toggle error                                                */
            uint32            : 21;
    } bit;
  } OTG_HS_HCINT0;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000010C) OTG_HS host channel-11 interrupt mask register             */
    
    struct {
      __IOM uint32 XFRCM      : 1;            /*!< [0..0] Transfer completed mask                                            */
      __IOM uint32 CHHM       : 1;            /*!< [1..1] Channel halted mask                                                */
      __IOM uint32 AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32 STALLM     : 1;            /*!< [3..3] STALL response received interrupt mask                             */
      __IOM uint32 NAKM       : 1;            /*!< [4..4] NAK response received interrupt mask                               */
      __IOM uint32 ACKM       : 1;            /*!< [5..5] ACK response received/transmitted interrupt mask                   */
      __IOM uint32 NYET       : 1;            /*!< [6..6] response received interrupt mask                                   */
      __IOM uint32 TXERRM     : 1;            /*!< [7..7] Transaction error mask                                             */
      __IOM uint32 BBERRM     : 1;            /*!< [8..8] Babble error mask                                                  */
      __IOM uint32 FRMORM     : 1;            /*!< [9..9] Frame overrun mask                                                 */
      __IOM uint32 DTERRM     : 1;            /*!< [10..10] Data toggle error mask                                           */
            uint32            : 21;
    } bit;
  } OTG_HS_HCINTMSK0;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000110) OTG_HS host channel-11 transfer size register              */
    
    struct {
      __IOM uint32 XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32 PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32 DPID       : 2;            /*!< [30..29] Data PID                                                         */
            uint32            : 1;
    } bit;
  } OTG_HS_HCTSIZ0;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000114) OTG_HS host channel-0 DMA address register                 */
    
    struct {
      __IOM uint32 DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } bit;
  } OTG_HS_HCDMA0;
  __IM  uint32  RESERVED3[2];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000120) OTG_HS host channel-1 characteristics register             */
    
    struct {
      __IOM uint32 MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
      __IOM uint32 EPNUM      : 4;            /*!< [14..11] Endpoint number                                                  */
      __IOM uint32 EPDIR      : 1;            /*!< [15..15] Endpoint direction                                               */
            uint32            : 1;
      __IOM uint32 LSDEV      : 1;            /*!< [17..17] Low-speed device                                                 */
      __IOM uint32 EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32 MC         : 2;            /*!< [21..20] Multi Count (MC) / Error Count (EC)                              */
      __IOM uint32 DAD        : 7;            /*!< [28..22] Device address                                                   */
      __IOM uint32 ODDFRM     : 1;            /*!< [29..29] Odd frame                                                        */
      __IOM uint32 CHDIS      : 1;            /*!< [30..30] Channel disable                                                  */
      __IOM uint32 CHENA      : 1;            /*!< [31..31] Channel enable                                                   */
    } bit;
  } OTG_HS_HCCHAR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000124) OTG_HS host channel-1 split control register               */
    
    struct {
      __IOM uint32 PRTADDR    : 7;            /*!< [6..0] Port address                                                       */
      __IOM uint32 HUBADDR    : 7;            /*!< [13..7] Hub address                                                       */
      __IOM uint32 XACTPOS    : 2;            /*!< [15..14] XACTPOS                                                          */
      __IOM uint32 COMPLSPLT  : 1;            /*!< [16..16] Do complete split                                                */
            uint32            : 14;
      __IOM uint32 SPLITEN    : 1;            /*!< [31..31] Split enable                                                     */
    } bit;
  } OTG_HS_HCSPLT1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000128) OTG_HS host channel-1 interrupt register                   */
    
    struct {
      __IOM uint32 XFRC       : 1;            /*!< [0..0] Transfer completed                                                 */
      __IOM uint32 CHH        : 1;            /*!< [1..1] Channel halted                                                     */
      __IOM uint32 AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32 STALL      : 1;            /*!< [3..3] STALL response received interrupt                                  */
      __IOM uint32 NAK        : 1;            /*!< [4..4] NAK response received interrupt                                    */
      __IOM uint32 ACK        : 1;            /*!< [5..5] ACK response received/transmitted interrupt                        */
      __IOM uint32 NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32 TXERR      : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32 BBERR      : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32 FRMOR      : 1;            /*!< [9..9] Frame overrun                                                      */
      __IOM uint32 DTERR      : 1;            /*!< [10..10] Data toggle error                                                */
            uint32            : 21;
    } bit;
  } OTG_HS_HCINT1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000012C) OTG_HS host channel-1 interrupt mask register              */
    
    struct {
      __IOM uint32 XFRCM      : 1;            /*!< [0..0] Transfer completed mask                                            */
      __IOM uint32 CHHM       : 1;            /*!< [1..1] Channel halted mask                                                */
      __IOM uint32 AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32 STALLM     : 1;            /*!< [3..3] STALL response received interrupt mask                             */
      __IOM uint32 NAKM       : 1;            /*!< [4..4] NAK response received interrupt mask                               */
      __IOM uint32 ACKM       : 1;            /*!< [5..5] ACK response received/transmitted interrupt mask                   */
      __IOM uint32 NYET       : 1;            /*!< [6..6] response received interrupt mask                                   */
      __IOM uint32 TXERRM     : 1;            /*!< [7..7] Transaction error mask                                             */
      __IOM uint32 BBERRM     : 1;            /*!< [8..8] Babble error mask                                                  */
      __IOM uint32 FRMORM     : 1;            /*!< [9..9] Frame overrun mask                                                 */
      __IOM uint32 DTERRM     : 1;            /*!< [10..10] Data toggle error mask                                           */
            uint32            : 21;
    } bit;
  } OTG_HS_HCINTMSK1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000130) OTG_HS host channel-1 transfer size register               */
    
    struct {
      __IOM uint32 XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32 PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32 DPID       : 2;            /*!< [30..29] Data PID                                                         */
            uint32            : 1;
    } bit;
  } OTG_HS_HCTSIZ1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000134) OTG_HS host channel-1 DMA address register                 */
    
    struct {
      __IOM uint32 DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } bit;
  } OTG_HS_HCDMA1;
  __IM  uint32  RESERVED4[2];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000140) OTG_HS host channel-2 characteristics register             */
    
    struct {
      __IOM uint32 MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
      __IOM uint32 EPNUM      : 4;            /*!< [14..11] Endpoint number                                                  */
      __IOM uint32 EPDIR      : 1;            /*!< [15..15] Endpoint direction                                               */
            uint32            : 1;
      __IOM uint32 LSDEV      : 1;            /*!< [17..17] Low-speed device                                                 */
      __IOM uint32 EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32 MC         : 2;            /*!< [21..20] Multi Count (MC) / Error Count (EC)                              */
      __IOM uint32 DAD        : 7;            /*!< [28..22] Device address                                                   */
      __IOM uint32 ODDFRM     : 1;            /*!< [29..29] Odd frame                                                        */
      __IOM uint32 CHDIS      : 1;            /*!< [30..30] Channel disable                                                  */
      __IOM uint32 CHENA      : 1;            /*!< [31..31] Channel enable                                                   */
    } bit;
  } OTG_HS_HCCHAR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000144) OTG_HS host channel-2 split control register               */
    
    struct {
      __IOM uint32 PRTADDR    : 7;            /*!< [6..0] Port address                                                       */
      __IOM uint32 HUBADDR    : 7;            /*!< [13..7] Hub address                                                       */
      __IOM uint32 XACTPOS    : 2;            /*!< [15..14] XACTPOS                                                          */
      __IOM uint32 COMPLSPLT  : 1;            /*!< [16..16] Do complete split                                                */
            uint32            : 14;
      __IOM uint32 SPLITEN    : 1;            /*!< [31..31] Split enable                                                     */
    } bit;
  } OTG_HS_HCSPLT2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000148) OTG_HS host channel-2 interrupt register                   */
    
    struct {
      __IOM uint32 XFRC       : 1;            /*!< [0..0] Transfer completed                                                 */
      __IOM uint32 CHH        : 1;            /*!< [1..1] Channel halted                                                     */
      __IOM uint32 AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32 STALL      : 1;            /*!< [3..3] STALL response received interrupt                                  */
      __IOM uint32 NAK        : 1;            /*!< [4..4] NAK response received interrupt                                    */
      __IOM uint32 ACK        : 1;            /*!< [5..5] ACK response received/transmitted interrupt                        */
      __IOM uint32 NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32 TXERR      : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32 BBERR      : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32 FRMOR      : 1;            /*!< [9..9] Frame overrun                                                      */
      __IOM uint32 DTERR      : 1;            /*!< [10..10] Data toggle error                                                */
            uint32            : 21;
    } bit;
  } OTG_HS_HCINT2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000014C) OTG_HS host channel-2 interrupt mask register              */
    
    struct {
      __IOM uint32 XFRCM      : 1;            /*!< [0..0] Transfer completed mask                                            */
      __IOM uint32 CHHM       : 1;            /*!< [1..1] Channel halted mask                                                */
      __IOM uint32 AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32 STALLM     : 1;            /*!< [3..3] STALL response received interrupt mask                             */
      __IOM uint32 NAKM       : 1;            /*!< [4..4] NAK response received interrupt mask                               */
      __IOM uint32 ACKM       : 1;            /*!< [5..5] ACK response received/transmitted interrupt mask                   */
      __IOM uint32 NYET       : 1;            /*!< [6..6] response received interrupt mask                                   */
      __IOM uint32 TXERRM     : 1;            /*!< [7..7] Transaction error mask                                             */
      __IOM uint32 BBERRM     : 1;            /*!< [8..8] Babble error mask                                                  */
      __IOM uint32 FRMORM     : 1;            /*!< [9..9] Frame overrun mask                                                 */
      __IOM uint32 DTERRM     : 1;            /*!< [10..10] Data toggle error mask                                           */
            uint32            : 21;
    } bit;
  } OTG_HS_HCINTMSK2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000150) OTG_HS host channel-2 transfer size register               */
    
    struct {
      __IOM uint32 XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32 PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32 DPID       : 2;            /*!< [30..29] Data PID                                                         */
            uint32            : 1;
    } bit;
  } OTG_HS_HCTSIZ2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000154) OTG_HS host channel-2 DMA address register                 */
    
    struct {
      __IOM uint32 DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } bit;
  } OTG_HS_HCDMA2;
  __IM  uint32  RESERVED5[2];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000160) OTG_HS host channel-3 characteristics register             */
    
    struct {
      __IOM uint32 MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
      __IOM uint32 EPNUM      : 4;            /*!< [14..11] Endpoint number                                                  */
      __IOM uint32 EPDIR      : 1;            /*!< [15..15] Endpoint direction                                               */
            uint32            : 1;
      __IOM uint32 LSDEV      : 1;            /*!< [17..17] Low-speed device                                                 */
      __IOM uint32 EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32 MC         : 2;            /*!< [21..20] Multi Count (MC) / Error Count (EC)                              */
      __IOM uint32 DAD        : 7;            /*!< [28..22] Device address                                                   */
      __IOM uint32 ODDFRM     : 1;            /*!< [29..29] Odd frame                                                        */
      __IOM uint32 CHDIS      : 1;            /*!< [30..30] Channel disable                                                  */
      __IOM uint32 CHENA      : 1;            /*!< [31..31] Channel enable                                                   */
    } bit;
  } OTG_HS_HCCHAR3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000164) OTG_HS host channel-3 split control register               */
    
    struct {
      __IOM uint32 PRTADDR    : 7;            /*!< [6..0] Port address                                                       */
      __IOM uint32 HUBADDR    : 7;            /*!< [13..7] Hub address                                                       */
      __IOM uint32 XACTPOS    : 2;            /*!< [15..14] XACTPOS                                                          */
      __IOM uint32 COMPLSPLT  : 1;            /*!< [16..16] Do complete split                                                */
            uint32            : 14;
      __IOM uint32 SPLITEN    : 1;            /*!< [31..31] Split enable                                                     */
    } bit;
  } OTG_HS_HCSPLT3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000168) OTG_HS host channel-3 interrupt register                   */
    
    struct {
      __IOM uint32 XFRC       : 1;            /*!< [0..0] Transfer completed                                                 */
      __IOM uint32 CHH        : 1;            /*!< [1..1] Channel halted                                                     */
      __IOM uint32 AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32 STALL      : 1;            /*!< [3..3] STALL response received interrupt                                  */
      __IOM uint32 NAK        : 1;            /*!< [4..4] NAK response received interrupt                                    */
      __IOM uint32 ACK        : 1;            /*!< [5..5] ACK response received/transmitted interrupt                        */
      __IOM uint32 NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32 TXERR      : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32 BBERR      : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32 FRMOR      : 1;            /*!< [9..9] Frame overrun                                                      */
      __IOM uint32 DTERR      : 1;            /*!< [10..10] Data toggle error                                                */
            uint32            : 21;
    } bit;
  } OTG_HS_HCINT3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000016C) OTG_HS host channel-3 interrupt mask register              */
    
    struct {
      __IOM uint32 XFRCM      : 1;            /*!< [0..0] Transfer completed mask                                            */
      __IOM uint32 CHHM       : 1;            /*!< [1..1] Channel halted mask                                                */
      __IOM uint32 AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32 STALLM     : 1;            /*!< [3..3] STALL response received interrupt mask                             */
      __IOM uint32 NAKM       : 1;            /*!< [4..4] NAK response received interrupt mask                               */
      __IOM uint32 ACKM       : 1;            /*!< [5..5] ACK response received/transmitted interrupt mask                   */
      __IOM uint32 NYET       : 1;            /*!< [6..6] response received interrupt mask                                   */
      __IOM uint32 TXERRM     : 1;            /*!< [7..7] Transaction error mask                                             */
      __IOM uint32 BBERRM     : 1;            /*!< [8..8] Babble error mask                                                  */
      __IOM uint32 FRMORM     : 1;            /*!< [9..9] Frame overrun mask                                                 */
      __IOM uint32 DTERRM     : 1;            /*!< [10..10] Data toggle error mask                                           */
            uint32            : 21;
    } bit;
  } OTG_HS_HCINTMSK3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000170) OTG_HS host channel-3 transfer size register               */
    
    struct {
      __IOM uint32 XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32 PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32 DPID       : 2;            /*!< [30..29] Data PID                                                         */
            uint32            : 1;
    } bit;
  } OTG_HS_HCTSIZ3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000174) OTG_HS host channel-3 DMA address register                 */
    
    struct {
      __IOM uint32 DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } bit;
  } OTG_HS_HCDMA3;
  __IM  uint32  RESERVED6[2];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000180) OTG_HS host channel-4 characteristics register             */
    
    struct {
      __IOM uint32 MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
      __IOM uint32 EPNUM      : 4;            /*!< [14..11] Endpoint number                                                  */
      __IOM uint32 EPDIR      : 1;            /*!< [15..15] Endpoint direction                                               */
            uint32            : 1;
      __IOM uint32 LSDEV      : 1;            /*!< [17..17] Low-speed device                                                 */
      __IOM uint32 EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32 MC         : 2;            /*!< [21..20] Multi Count (MC) / Error Count (EC)                              */
      __IOM uint32 DAD        : 7;            /*!< [28..22] Device address                                                   */
      __IOM uint32 ODDFRM     : 1;            /*!< [29..29] Odd frame                                                        */
      __IOM uint32 CHDIS      : 1;            /*!< [30..30] Channel disable                                                  */
      __IOM uint32 CHENA      : 1;            /*!< [31..31] Channel enable                                                   */
    } bit;
  } OTG_HS_HCCHAR4;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000184) OTG_HS host channel-4 split control register               */
    
    struct {
      __IOM uint32 PRTADDR    : 7;            /*!< [6..0] Port address                                                       */
      __IOM uint32 HUBADDR    : 7;            /*!< [13..7] Hub address                                                       */
      __IOM uint32 XACTPOS    : 2;            /*!< [15..14] XACTPOS                                                          */
      __IOM uint32 COMPLSPLT  : 1;            /*!< [16..16] Do complete split                                                */
            uint32            : 14;
      __IOM uint32 SPLITEN    : 1;            /*!< [31..31] Split enable                                                     */
    } bit;
  } OTG_HS_HCSPLT4;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000188) OTG_HS host channel-4 interrupt register                   */
    
    struct {
      __IOM uint32 XFRC       : 1;            /*!< [0..0] Transfer completed                                                 */
      __IOM uint32 CHH        : 1;            /*!< [1..1] Channel halted                                                     */
      __IOM uint32 AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32 STALL      : 1;            /*!< [3..3] STALL response received interrupt                                  */
      __IOM uint32 NAK        : 1;            /*!< [4..4] NAK response received interrupt                                    */
      __IOM uint32 ACK        : 1;            /*!< [5..5] ACK response received/transmitted interrupt                        */
      __IOM uint32 NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32 TXERR      : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32 BBERR      : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32 FRMOR      : 1;            /*!< [9..9] Frame overrun                                                      */
      __IOM uint32 DTERR      : 1;            /*!< [10..10] Data toggle error                                                */
            uint32            : 21;
    } bit;
  } OTG_HS_HCINT4;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000018C) OTG_HS host channel-4 interrupt mask register              */
    
    struct {
      __IOM uint32 XFRCM      : 1;            /*!< [0..0] Transfer completed mask                                            */
      __IOM uint32 CHHM       : 1;            /*!< [1..1] Channel halted mask                                                */
      __IOM uint32 AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32 STALLM     : 1;            /*!< [3..3] STALL response received interrupt mask                             */
      __IOM uint32 NAKM       : 1;            /*!< [4..4] NAK response received interrupt mask                               */
      __IOM uint32 ACKM       : 1;            /*!< [5..5] ACK response received/transmitted interrupt mask                   */
      __IOM uint32 NYET       : 1;            /*!< [6..6] response received interrupt mask                                   */
      __IOM uint32 TXERRM     : 1;            /*!< [7..7] Transaction error mask                                             */
      __IOM uint32 BBERRM     : 1;            /*!< [8..8] Babble error mask                                                  */
      __IOM uint32 FRMORM     : 1;            /*!< [9..9] Frame overrun mask                                                 */
      __IOM uint32 DTERRM     : 1;            /*!< [10..10] Data toggle error mask                                           */
            uint32            : 21;
    } bit;
  } OTG_HS_HCINTMSK4;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000190) OTG_HS host channel-4 transfer size register               */
    
    struct {
      __IOM uint32 XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32 PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32 DPID       : 2;            /*!< [30..29] Data PID                                                         */
            uint32            : 1;
    } bit;
  } OTG_HS_HCTSIZ4;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000194) OTG_HS host channel-4 DMA address register                 */
    
    struct {
      __IOM uint32 DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } bit;
  } OTG_HS_HCDMA4;
  __IM  uint32  RESERVED7[2];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001A0) OTG_HS host channel-5 characteristics register             */
    
    struct {
      __IOM uint32 MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
      __IOM uint32 EPNUM      : 4;            /*!< [14..11] Endpoint number                                                  */
      __IOM uint32 EPDIR      : 1;            /*!< [15..15] Endpoint direction                                               */
            uint32            : 1;
      __IOM uint32 LSDEV      : 1;            /*!< [17..17] Low-speed device                                                 */
      __IOM uint32 EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32 MC         : 2;            /*!< [21..20] Multi Count (MC) / Error Count (EC)                              */
      __IOM uint32 DAD        : 7;            /*!< [28..22] Device address                                                   */
      __IOM uint32 ODDFRM     : 1;            /*!< [29..29] Odd frame                                                        */
      __IOM uint32 CHDIS      : 1;            /*!< [30..30] Channel disable                                                  */
      __IOM uint32 CHENA      : 1;            /*!< [31..31] Channel enable                                                   */
    } bit;
  } OTG_HS_HCCHAR5;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001A4) OTG_HS host channel-5 split control register               */
    
    struct {
      __IOM uint32 PRTADDR    : 7;            /*!< [6..0] Port address                                                       */
      __IOM uint32 HUBADDR    : 7;            /*!< [13..7] Hub address                                                       */
      __IOM uint32 XACTPOS    : 2;            /*!< [15..14] XACTPOS                                                          */
      __IOM uint32 COMPLSPLT  : 1;            /*!< [16..16] Do complete split                                                */
            uint32            : 14;
      __IOM uint32 SPLITEN    : 1;            /*!< [31..31] Split enable                                                     */
    } bit;
  } OTG_HS_HCSPLT5;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001A8) OTG_HS host channel-5 interrupt register                   */
    
    struct {
      __IOM uint32 XFRC       : 1;            /*!< [0..0] Transfer completed                                                 */
      __IOM uint32 CHH        : 1;            /*!< [1..1] Channel halted                                                     */
      __IOM uint32 AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32 STALL      : 1;            /*!< [3..3] STALL response received interrupt                                  */
      __IOM uint32 NAK        : 1;            /*!< [4..4] NAK response received interrupt                                    */
      __IOM uint32 ACK        : 1;            /*!< [5..5] ACK response received/transmitted interrupt                        */
      __IOM uint32 NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32 TXERR      : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32 BBERR      : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32 FRMOR      : 1;            /*!< [9..9] Frame overrun                                                      */
      __IOM uint32 DTERR      : 1;            /*!< [10..10] Data toggle error                                                */
            uint32            : 21;
    } bit;
  } OTG_HS_HCINT5;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001AC) OTG_HS host channel-5 interrupt mask register              */
    
    struct {
      __IOM uint32 XFRCM      : 1;            /*!< [0..0] Transfer completed mask                                            */
      __IOM uint32 CHHM       : 1;            /*!< [1..1] Channel halted mask                                                */
      __IOM uint32 AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32 STALLM     : 1;            /*!< [3..3] STALL response received interrupt mask                             */
      __IOM uint32 NAKM       : 1;            /*!< [4..4] NAK response received interrupt mask                               */
      __IOM uint32 ACKM       : 1;            /*!< [5..5] ACK response received/transmitted interrupt mask                   */
      __IOM uint32 NYET       : 1;            /*!< [6..6] response received interrupt mask                                   */
      __IOM uint32 TXERRM     : 1;            /*!< [7..7] Transaction error mask                                             */
      __IOM uint32 BBERRM     : 1;            /*!< [8..8] Babble error mask                                                  */
      __IOM uint32 FRMORM     : 1;            /*!< [9..9] Frame overrun mask                                                 */
      __IOM uint32 DTERRM     : 1;            /*!< [10..10] Data toggle error mask                                           */
            uint32            : 21;
    } bit;
  } OTG_HS_HCINTMSK5;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001B0) OTG_HS host channel-5 transfer size register               */
    
    struct {
      __IOM uint32 XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32 PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32 DPID       : 2;            /*!< [30..29] Data PID                                                         */
            uint32            : 1;
    } bit;
  } OTG_HS_HCTSIZ5;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001B4) OTG_HS host channel-5 DMA address register                 */
    
    struct {
      __IOM uint32 DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } bit;
  } OTG_HS_HCDMA5;
  __IM  uint32  RESERVED8[2];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001C0) OTG_HS host channel-6 characteristics register             */
    
    struct {
      __IOM uint32 MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
      __IOM uint32 EPNUM      : 4;            /*!< [14..11] Endpoint number                                                  */
      __IOM uint32 EPDIR      : 1;            /*!< [15..15] Endpoint direction                                               */
            uint32            : 1;
      __IOM uint32 LSDEV      : 1;            /*!< [17..17] Low-speed device                                                 */
      __IOM uint32 EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32 MC         : 2;            /*!< [21..20] Multi Count (MC) / Error Count (EC)                              */
      __IOM uint32 DAD        : 7;            /*!< [28..22] Device address                                                   */
      __IOM uint32 ODDFRM     : 1;            /*!< [29..29] Odd frame                                                        */
      __IOM uint32 CHDIS      : 1;            /*!< [30..30] Channel disable                                                  */
      __IOM uint32 CHENA      : 1;            /*!< [31..31] Channel enable                                                   */
    } bit;
  } OTG_HS_HCCHAR6;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001C4) OTG_HS host channel-6 split control register               */
    
    struct {
      __IOM uint32 PRTADDR    : 7;            /*!< [6..0] Port address                                                       */
      __IOM uint32 HUBADDR    : 7;            /*!< [13..7] Hub address                                                       */
      __IOM uint32 XACTPOS    : 2;            /*!< [15..14] XACTPOS                                                          */
      __IOM uint32 COMPLSPLT  : 1;            /*!< [16..16] Do complete split                                                */
            uint32            : 14;
      __IOM uint32 SPLITEN    : 1;            /*!< [31..31] Split enable                                                     */
    } bit;
  } OTG_HS_HCSPLT6;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001C8) OTG_HS host channel-6 interrupt register                   */
    
    struct {
      __IOM uint32 XFRC       : 1;            /*!< [0..0] Transfer completed                                                 */
      __IOM uint32 CHH        : 1;            /*!< [1..1] Channel halted                                                     */
      __IOM uint32 AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32 STALL      : 1;            /*!< [3..3] STALL response received interrupt                                  */
      __IOM uint32 NAK        : 1;            /*!< [4..4] NAK response received interrupt                                    */
      __IOM uint32 ACK        : 1;            /*!< [5..5] ACK response received/transmitted interrupt                        */
      __IOM uint32 NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32 TXERR      : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32 BBERR      : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32 FRMOR      : 1;            /*!< [9..9] Frame overrun                                                      */
      __IOM uint32 DTERR      : 1;            /*!< [10..10] Data toggle error                                                */
            uint32            : 21;
    } bit;
  } OTG_HS_HCINT6;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001CC) OTG_HS host channel-6 interrupt mask register              */
    
    struct {
      __IOM uint32 XFRCM      : 1;            /*!< [0..0] Transfer completed mask                                            */
      __IOM uint32 CHHM       : 1;            /*!< [1..1] Channel halted mask                                                */
      __IOM uint32 AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32 STALLM     : 1;            /*!< [3..3] STALL response received interrupt mask                             */
      __IOM uint32 NAKM       : 1;            /*!< [4..4] NAK response received interrupt mask                               */
      __IOM uint32 ACKM       : 1;            /*!< [5..5] ACK response received/transmitted interrupt mask                   */
      __IOM uint32 NYET       : 1;            /*!< [6..6] response received interrupt mask                                   */
      __IOM uint32 TXERRM     : 1;            /*!< [7..7] Transaction error mask                                             */
      __IOM uint32 BBERRM     : 1;            /*!< [8..8] Babble error mask                                                  */
      __IOM uint32 FRMORM     : 1;            /*!< [9..9] Frame overrun mask                                                 */
      __IOM uint32 DTERRM     : 1;            /*!< [10..10] Data toggle error mask                                           */
            uint32            : 21;
    } bit;
  } OTG_HS_HCINTMSK6;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001D0) OTG_HS host channel-6 transfer size register               */
    
    struct {
      __IOM uint32 XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32 PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32 DPID       : 2;            /*!< [30..29] Data PID                                                         */
            uint32            : 1;
    } bit;
  } OTG_HS_HCTSIZ6;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001D4) OTG_HS host channel-6 DMA address register                 */
    
    struct {
      __IOM uint32 DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } bit;
  } OTG_HS_HCDMA6;
  __IM  uint32  RESERVED9[2];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001E0) OTG_HS host channel-7 characteristics register             */
    
    struct {
      __IOM uint32 MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
      __IOM uint32 EPNUM      : 4;            /*!< [14..11] Endpoint number                                                  */
      __IOM uint32 EPDIR      : 1;            /*!< [15..15] Endpoint direction                                               */
            uint32            : 1;
      __IOM uint32 LSDEV      : 1;            /*!< [17..17] Low-speed device                                                 */
      __IOM uint32 EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32 MC         : 2;            /*!< [21..20] Multi Count (MC) / Error Count (EC)                              */
      __IOM uint32 DAD        : 7;            /*!< [28..22] Device address                                                   */
      __IOM uint32 ODDFRM     : 1;            /*!< [29..29] Odd frame                                                        */
      __IOM uint32 CHDIS      : 1;            /*!< [30..30] Channel disable                                                  */
      __IOM uint32 CHENA      : 1;            /*!< [31..31] Channel enable                                                   */
    } bit;
  } OTG_HS_HCCHAR7;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001E4) OTG_HS host channel-7 split control register               */
    
    struct {
      __IOM uint32 PRTADDR    : 7;            /*!< [6..0] Port address                                                       */
      __IOM uint32 HUBADDR    : 7;            /*!< [13..7] Hub address                                                       */
      __IOM uint32 XACTPOS    : 2;            /*!< [15..14] XACTPOS                                                          */
      __IOM uint32 COMPLSPLT  : 1;            /*!< [16..16] Do complete split                                                */
            uint32            : 14;
      __IOM uint32 SPLITEN    : 1;            /*!< [31..31] Split enable                                                     */
    } bit;
  } OTG_HS_HCSPLT7;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001E8) OTG_HS host channel-7 interrupt register                   */
    
    struct {
      __IOM uint32 XFRC       : 1;            /*!< [0..0] Transfer completed                                                 */
      __IOM uint32 CHH        : 1;            /*!< [1..1] Channel halted                                                     */
      __IOM uint32 AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32 STALL      : 1;            /*!< [3..3] STALL response received interrupt                                  */
      __IOM uint32 NAK        : 1;            /*!< [4..4] NAK response received interrupt                                    */
      __IOM uint32 ACK        : 1;            /*!< [5..5] ACK response received/transmitted interrupt                        */
      __IOM uint32 NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32 TXERR      : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32 BBERR      : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32 FRMOR      : 1;            /*!< [9..9] Frame overrun                                                      */
      __IOM uint32 DTERR      : 1;            /*!< [10..10] Data toggle error                                                */
            uint32            : 21;
    } bit;
  } OTG_HS_HCINT7;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001EC) OTG_HS host channel-7 interrupt mask register              */
    
    struct {
      __IOM uint32 XFRCM      : 1;            /*!< [0..0] Transfer completed mask                                            */
      __IOM uint32 CHHM       : 1;            /*!< [1..1] Channel halted mask                                                */
      __IOM uint32 AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32 STALLM     : 1;            /*!< [3..3] STALL response received interrupt mask                             */
      __IOM uint32 NAKM       : 1;            /*!< [4..4] NAK response received interrupt mask                               */
      __IOM uint32 ACKM       : 1;            /*!< [5..5] ACK response received/transmitted interrupt mask                   */
      __IOM uint32 NYET       : 1;            /*!< [6..6] response received interrupt mask                                   */
      __IOM uint32 TXERRM     : 1;            /*!< [7..7] Transaction error mask                                             */
      __IOM uint32 BBERRM     : 1;            /*!< [8..8] Babble error mask                                                  */
      __IOM uint32 FRMORM     : 1;            /*!< [9..9] Frame overrun mask                                                 */
      __IOM uint32 DTERRM     : 1;            /*!< [10..10] Data toggle error mask                                           */
            uint32            : 21;
    } bit;
  } OTG_HS_HCINTMSK7;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001F0) OTG_HS host channel-7 transfer size register               */
    
    struct {
      __IOM uint32 XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32 PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32 DPID       : 2;            /*!< [30..29] Data PID                                                         */
            uint32            : 1;
    } bit;
  } OTG_HS_HCTSIZ7;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001F4) OTG_HS host channel-7 DMA address register                 */
    
    struct {
      __IOM uint32 DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } bit;
  } OTG_HS_HCDMA7;
  __IM  uint32  RESERVED10[2];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000200) OTG_HS host channel-8 characteristics register             */
    
    struct {
      __IOM uint32 MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
      __IOM uint32 EPNUM      : 4;            /*!< [14..11] Endpoint number                                                  */
      __IOM uint32 EPDIR      : 1;            /*!< [15..15] Endpoint direction                                               */
            uint32            : 1;
      __IOM uint32 LSDEV      : 1;            /*!< [17..17] Low-speed device                                                 */
      __IOM uint32 EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32 MC         : 2;            /*!< [21..20] Multi Count (MC) / Error Count (EC)                              */
      __IOM uint32 DAD        : 7;            /*!< [28..22] Device address                                                   */
      __IOM uint32 ODDFRM     : 1;            /*!< [29..29] Odd frame                                                        */
      __IOM uint32 CHDIS      : 1;            /*!< [30..30] Channel disable                                                  */
      __IOM uint32 CHENA      : 1;            /*!< [31..31] Channel enable                                                   */
    } bit;
  } OTG_HS_HCCHAR8;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000204) OTG_HS host channel-8 split control register               */
    
    struct {
      __IOM uint32 PRTADDR    : 7;            /*!< [6..0] Port address                                                       */
      __IOM uint32 HUBADDR    : 7;            /*!< [13..7] Hub address                                                       */
      __IOM uint32 XACTPOS    : 2;            /*!< [15..14] XACTPOS                                                          */
      __IOM uint32 COMPLSPLT  : 1;            /*!< [16..16] Do complete split                                                */
            uint32            : 14;
      __IOM uint32 SPLITEN    : 1;            /*!< [31..31] Split enable                                                     */
    } bit;
  } OTG_HS_HCSPLT8;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000208) OTG_HS host channel-8 interrupt register                   */
    
    struct {
      __IOM uint32 XFRC       : 1;            /*!< [0..0] Transfer completed                                                 */
      __IOM uint32 CHH        : 1;            /*!< [1..1] Channel halted                                                     */
      __IOM uint32 AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32 STALL      : 1;            /*!< [3..3] STALL response received interrupt                                  */
      __IOM uint32 NAK        : 1;            /*!< [4..4] NAK response received interrupt                                    */
      __IOM uint32 ACK        : 1;            /*!< [5..5] ACK response received/transmitted interrupt                        */
      __IOM uint32 NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32 TXERR      : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32 BBERR      : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32 FRMOR      : 1;            /*!< [9..9] Frame overrun                                                      */
      __IOM uint32 DTERR      : 1;            /*!< [10..10] Data toggle error                                                */
            uint32            : 21;
    } bit;
  } OTG_HS_HCINT8;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000020C) OTG_HS host channel-8 interrupt mask register              */
    
    struct {
      __IOM uint32 XFRCM      : 1;            /*!< [0..0] Transfer completed mask                                            */
      __IOM uint32 CHHM       : 1;            /*!< [1..1] Channel halted mask                                                */
      __IOM uint32 AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32 STALLM     : 1;            /*!< [3..3] STALL response received interrupt mask                             */
      __IOM uint32 NAKM       : 1;            /*!< [4..4] NAK response received interrupt mask                               */
      __IOM uint32 ACKM       : 1;            /*!< [5..5] ACK response received/transmitted interrupt mask                   */
      __IOM uint32 NYET       : 1;            /*!< [6..6] response received interrupt mask                                   */
      __IOM uint32 TXERRM     : 1;            /*!< [7..7] Transaction error mask                                             */
      __IOM uint32 BBERRM     : 1;            /*!< [8..8] Babble error mask                                                  */
      __IOM uint32 FRMORM     : 1;            /*!< [9..9] Frame overrun mask                                                 */
      __IOM uint32 DTERRM     : 1;            /*!< [10..10] Data toggle error mask                                           */
            uint32            : 21;
    } bit;
  } OTG_HS_HCINTMSK8;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000210) OTG_HS host channel-8 transfer size register               */
    
    struct {
      __IOM uint32 XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32 PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32 DPID       : 2;            /*!< [30..29] Data PID                                                         */
            uint32            : 1;
    } bit;
  } OTG_HS_HCTSIZ8;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000214) OTG_HS host channel-8 DMA address register                 */
    
    struct {
      __IOM uint32 DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } bit;
  } OTG_HS_HCDMA8;
  __IM  uint32  RESERVED11[2];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000220) OTG_HS host channel-9 characteristics register             */
    
    struct {
      __IOM uint32 MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
      __IOM uint32 EPNUM      : 4;            /*!< [14..11] Endpoint number                                                  */
      __IOM uint32 EPDIR      : 1;            /*!< [15..15] Endpoint direction                                               */
            uint32            : 1;
      __IOM uint32 LSDEV      : 1;            /*!< [17..17] Low-speed device                                                 */
      __IOM uint32 EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32 MC         : 2;            /*!< [21..20] Multi Count (MC) / Error Count (EC)                              */
      __IOM uint32 DAD        : 7;            /*!< [28..22] Device address                                                   */
      __IOM uint32 ODDFRM     : 1;            /*!< [29..29] Odd frame                                                        */
      __IOM uint32 CHDIS      : 1;            /*!< [30..30] Channel disable                                                  */
      __IOM uint32 CHENA      : 1;            /*!< [31..31] Channel enable                                                   */
    } bit;
  } OTG_HS_HCCHAR9;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000224) OTG_HS host channel-9 split control register               */
    
    struct {
      __IOM uint32 PRTADDR    : 7;            /*!< [6..0] Port address                                                       */
      __IOM uint32 HUBADDR    : 7;            /*!< [13..7] Hub address                                                       */
      __IOM uint32 XACTPOS    : 2;            /*!< [15..14] XACTPOS                                                          */
      __IOM uint32 COMPLSPLT  : 1;            /*!< [16..16] Do complete split                                                */
            uint32            : 14;
      __IOM uint32 SPLITEN    : 1;            /*!< [31..31] Split enable                                                     */
    } bit;
  } OTG_HS_HCSPLT9;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000228) OTG_HS host channel-9 interrupt register                   */
    
    struct {
      __IOM uint32 XFRC       : 1;            /*!< [0..0] Transfer completed                                                 */
      __IOM uint32 CHH        : 1;            /*!< [1..1] Channel halted                                                     */
      __IOM uint32 AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32 STALL      : 1;            /*!< [3..3] STALL response received interrupt                                  */
      __IOM uint32 NAK        : 1;            /*!< [4..4] NAK response received interrupt                                    */
      __IOM uint32 ACK        : 1;            /*!< [5..5] ACK response received/transmitted interrupt                        */
      __IOM uint32 NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32 TXERR      : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32 BBERR      : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32 FRMOR      : 1;            /*!< [9..9] Frame overrun                                                      */
      __IOM uint32 DTERR      : 1;            /*!< [10..10] Data toggle error                                                */
            uint32            : 21;
    } bit;
  } OTG_HS_HCINT9;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000022C) OTG_HS host channel-9 interrupt mask register              */
    
    struct {
      __IOM uint32 XFRCM      : 1;            /*!< [0..0] Transfer completed mask                                            */
      __IOM uint32 CHHM       : 1;            /*!< [1..1] Channel halted mask                                                */
      __IOM uint32 AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32 STALLM     : 1;            /*!< [3..3] STALL response received interrupt mask                             */
      __IOM uint32 NAKM       : 1;            /*!< [4..4] NAK response received interrupt mask                               */
      __IOM uint32 ACKM       : 1;            /*!< [5..5] ACK response received/transmitted interrupt mask                   */
      __IOM uint32 NYET       : 1;            /*!< [6..6] response received interrupt mask                                   */
      __IOM uint32 TXERRM     : 1;            /*!< [7..7] Transaction error mask                                             */
      __IOM uint32 BBERRM     : 1;            /*!< [8..8] Babble error mask                                                  */
      __IOM uint32 FRMORM     : 1;            /*!< [9..9] Frame overrun mask                                                 */
      __IOM uint32 DTERRM     : 1;            /*!< [10..10] Data toggle error mask                                           */
            uint32            : 21;
    } bit;
  } OTG_HS_HCINTMSK9;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000230) OTG_HS host channel-9 transfer size register               */
    
    struct {
      __IOM uint32 XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32 PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32 DPID       : 2;            /*!< [30..29] Data PID                                                         */
            uint32            : 1;
    } bit;
  } OTG_HS_HCTSIZ9;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000234) OTG_HS host channel-9 DMA address register                 */
    
    struct {
      __IOM uint32 DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } bit;
  } OTG_HS_HCDMA9;
  __IM  uint32  RESERVED12[2];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000240) OTG_HS host channel-10 characteristics register            */
    
    struct {
      __IOM uint32 MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
      __IOM uint32 EPNUM      : 4;            /*!< [14..11] Endpoint number                                                  */
      __IOM uint32 EPDIR      : 1;            /*!< [15..15] Endpoint direction                                               */
            uint32            : 1;
      __IOM uint32 LSDEV      : 1;            /*!< [17..17] Low-speed device                                                 */
      __IOM uint32 EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32 MC         : 2;            /*!< [21..20] Multi Count (MC) / Error Count (EC)                              */
      __IOM uint32 DAD        : 7;            /*!< [28..22] Device address                                                   */
      __IOM uint32 ODDFRM     : 1;            /*!< [29..29] Odd frame                                                        */
      __IOM uint32 CHDIS      : 1;            /*!< [30..30] Channel disable                                                  */
      __IOM uint32 CHENA      : 1;            /*!< [31..31] Channel enable                                                   */
    } bit;
  } OTG_HS_HCCHAR10;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000244) OTG_HS host channel-10 split control register              */
    
    struct {
      __IOM uint32 PRTADDR    : 7;            /*!< [6..0] Port address                                                       */
      __IOM uint32 HUBADDR    : 7;            /*!< [13..7] Hub address                                                       */
      __IOM uint32 XACTPOS    : 2;            /*!< [15..14] XACTPOS                                                          */
      __IOM uint32 COMPLSPLT  : 1;            /*!< [16..16] Do complete split                                                */
            uint32            : 14;
      __IOM uint32 SPLITEN    : 1;            /*!< [31..31] Split enable                                                     */
    } bit;
  } OTG_HS_HCSPLT10;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000248) OTG_HS host channel-10 interrupt register                  */
    
    struct {
      __IOM uint32 XFRC       : 1;            /*!< [0..0] Transfer completed                                                 */
      __IOM uint32 CHH        : 1;            /*!< [1..1] Channel halted                                                     */
      __IOM uint32 AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32 STALL      : 1;            /*!< [3..3] STALL response received interrupt                                  */
      __IOM uint32 NAK        : 1;            /*!< [4..4] NAK response received interrupt                                    */
      __IOM uint32 ACK        : 1;            /*!< [5..5] ACK response received/transmitted interrupt                        */
      __IOM uint32 NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32 TXERR      : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32 BBERR      : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32 FRMOR      : 1;            /*!< [9..9] Frame overrun                                                      */
      __IOM uint32 DTERR      : 1;            /*!< [10..10] Data toggle error                                                */
            uint32            : 21;
    } bit;
  } OTG_HS_HCINT10;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000024C) OTG_HS host channel-10 interrupt mask register             */
    
    struct {
      __IOM uint32 XFRCM      : 1;            /*!< [0..0] Transfer completed mask                                            */
      __IOM uint32 CHHM       : 1;            /*!< [1..1] Channel halted mask                                                */
      __IOM uint32 AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32 STALLM     : 1;            /*!< [3..3] STALL response received interrupt mask                             */
      __IOM uint32 NAKM       : 1;            /*!< [4..4] NAK response received interrupt mask                               */
      __IOM uint32 ACKM       : 1;            /*!< [5..5] ACK response received/transmitted interrupt mask                   */
      __IOM uint32 NYET       : 1;            /*!< [6..6] response received interrupt mask                                   */
      __IOM uint32 TXERRM     : 1;            /*!< [7..7] Transaction error mask                                             */
      __IOM uint32 BBERRM     : 1;            /*!< [8..8] Babble error mask                                                  */
      __IOM uint32 FRMORM     : 1;            /*!< [9..9] Frame overrun mask                                                 */
      __IOM uint32 DTERRM     : 1;            /*!< [10..10] Data toggle error mask                                           */
            uint32            : 21;
    } bit;
  } OTG_HS_HCINTMSK10;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000250) OTG_HS host channel-10 transfer size register              */
    
    struct {
      __IOM uint32 XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32 PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32 DPID       : 2;            /*!< [30..29] Data PID                                                         */
            uint32            : 1;
    } bit;
  } OTG_HS_HCTSIZ10;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000254) OTG_HS host channel-10 DMA address register                */
    
    struct {
      __IOM uint32 DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } bit;
  } OTG_HS_HCDMA10;
  __IM  uint32  RESERVED13[2];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000260) OTG_HS host channel-11 characteristics register            */
    
    struct {
      __IOM uint32 MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
      __IOM uint32 EPNUM      : 4;            /*!< [14..11] Endpoint number                                                  */
      __IOM uint32 EPDIR      : 1;            /*!< [15..15] Endpoint direction                                               */
            uint32            : 1;
      __IOM uint32 LSDEV      : 1;            /*!< [17..17] Low-speed device                                                 */
      __IOM uint32 EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32 MC         : 2;            /*!< [21..20] Multi Count (MC) / Error Count (EC)                              */
      __IOM uint32 DAD        : 7;            /*!< [28..22] Device address                                                   */
      __IOM uint32 ODDFRM     : 1;            /*!< [29..29] Odd frame                                                        */
      __IOM uint32 CHDIS      : 1;            /*!< [30..30] Channel disable                                                  */
      __IOM uint32 CHENA      : 1;            /*!< [31..31] Channel enable                                                   */
    } bit;
  } OTG_HS_HCCHAR11;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000264) OTG_HS host channel-11 split control register              */
    
    struct {
      __IOM uint32 PRTADDR    : 7;            /*!< [6..0] Port address                                                       */
      __IOM uint32 HUBADDR    : 7;            /*!< [13..7] Hub address                                                       */
      __IOM uint32 XACTPOS    : 2;            /*!< [15..14] XACTPOS                                                          */
      __IOM uint32 COMPLSPLT  : 1;            /*!< [16..16] Do complete split                                                */
            uint32            : 14;
      __IOM uint32 SPLITEN    : 1;            /*!< [31..31] Split enable                                                     */
    } bit;
  } OTG_HS_HCSPLT11;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000268) OTG_HS host channel-11 interrupt register                  */
    
    struct {
      __IOM uint32 XFRC       : 1;            /*!< [0..0] Transfer completed                                                 */
      __IOM uint32 CHH        : 1;            /*!< [1..1] Channel halted                                                     */
      __IOM uint32 AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32 STALL      : 1;            /*!< [3..3] STALL response received interrupt                                  */
      __IOM uint32 NAK        : 1;            /*!< [4..4] NAK response received interrupt                                    */
      __IOM uint32 ACK        : 1;            /*!< [5..5] ACK response received/transmitted interrupt                        */
      __IOM uint32 NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32 TXERR      : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32 BBERR      : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32 FRMOR      : 1;            /*!< [9..9] Frame overrun                                                      */
      __IOM uint32 DTERR      : 1;            /*!< [10..10] Data toggle error                                                */
            uint32            : 21;
    } bit;
  } OTG_HS_HCINT11;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000026C) OTG_HS host channel-11 interrupt mask register             */
    
    struct {
      __IOM uint32 XFRCM      : 1;            /*!< [0..0] Transfer completed mask                                            */
      __IOM uint32 CHHM       : 1;            /*!< [1..1] Channel halted mask                                                */
      __IOM uint32 AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32 STALLM     : 1;            /*!< [3..3] STALL response received interrupt mask                             */
      __IOM uint32 NAKM       : 1;            /*!< [4..4] NAK response received interrupt mask                               */
      __IOM uint32 ACKM       : 1;            /*!< [5..5] ACK response received/transmitted interrupt mask                   */
      __IOM uint32 NYET       : 1;            /*!< [6..6] response received interrupt mask                                   */
      __IOM uint32 TXERRM     : 1;            /*!< [7..7] Transaction error mask                                             */
      __IOM uint32 BBERRM     : 1;            /*!< [8..8] Babble error mask                                                  */
      __IOM uint32 FRMORM     : 1;            /*!< [9..9] Frame overrun mask                                                 */
      __IOM uint32 DTERRM     : 1;            /*!< [10..10] Data toggle error mask                                           */
            uint32            : 21;
    } bit;
  } OTG_HS_HCINTMSK11;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000270) OTG_HS host channel-11 transfer size register              */
    
    struct {
      __IOM uint32 XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32 PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32 DPID       : 2;            /*!< [30..29] Data PID                                                         */
            uint32            : 1;
    } bit;
  } OTG_HS_HCTSIZ11;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000274) OTG_HS host channel-11 DMA address register                */
    
    struct {
      __IOM uint32 DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } bit;
  } OTG_HS_HCDMA11;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000278) OTG_HS host channel-12 characteristics register            */
    
    struct {
      __IOM uint32 MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
      __IOM uint32 EPNUM      : 4;            /*!< [14..11] Endpoint number                                                  */
      __IOM uint32 EPDIR      : 1;            /*!< [15..15] Endpoint direction                                               */
            uint32            : 1;
      __IOM uint32 LSDEV      : 1;            /*!< [17..17] Low-speed device                                                 */
      __IOM uint32 EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32 MC         : 2;            /*!< [21..20] Multi Count (MC) / Error Count (EC)                              */
      __IOM uint32 DAD        : 7;            /*!< [28..22] Device address                                                   */
      __IOM uint32 ODDFRM     : 1;            /*!< [29..29] Odd frame                                                        */
      __IOM uint32 CHDIS      : 1;            /*!< [30..30] Channel disable                                                  */
      __IOM uint32 CHENA      : 1;            /*!< [31..31] Channel enable                                                   */
    } bit;
  } OTG_HS_HCCHAR12;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000027C) OTG_HS host channel-12 split control register              */
    
    struct {
      __IOM uint32 PRTADDR    : 7;            /*!< [6..0] Port address                                                       */
      __IOM uint32 HUBADDR    : 7;            /*!< [13..7] Hub address                                                       */
      __IOM uint32 XACTPOS    : 2;            /*!< [15..14] XACTPOS                                                          */
      __IOM uint32 COMPLSPLT  : 1;            /*!< [16..16] Do complete split                                                */
            uint32            : 14;
      __IOM uint32 SPLITEN    : 1;            /*!< [31..31] Split enable                                                     */
    } bit;
  } OTG_HS_HCSPLT12;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000280) OTG_HS host channel-12 interrupt register                  */
    
    struct {
      __IOM uint32 XFRC       : 1;            /*!< [0..0] Transfer completed                                                 */
      __IOM uint32 CHH        : 1;            /*!< [1..1] Channel halted                                                     */
      __IOM uint32 AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32 STALL      : 1;            /*!< [3..3] STALL response received interrupt                                  */
      __IOM uint32 NAK        : 1;            /*!< [4..4] NAK response received interrupt                                    */
      __IOM uint32 ACK        : 1;            /*!< [5..5] ACK response received/transmitted interrupt                        */
      __IOM uint32 NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32 TXERR      : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32 BBERR      : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32 FRMOR      : 1;            /*!< [9..9] Frame overrun                                                      */
      __IOM uint32 DTERR      : 1;            /*!< [10..10] Data toggle error                                                */
            uint32            : 21;
    } bit;
  } OTG_HS_HCINT12;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000284) OTG_HS host channel-12 interrupt mask register             */
    
    struct {
      __IOM uint32 XFRCM      : 1;            /*!< [0..0] Transfer completed mask                                            */
      __IOM uint32 CHHM       : 1;            /*!< [1..1] Channel halted mask                                                */
      __IOM uint32 AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32 STALLM     : 1;            /*!< [3..3] STALL response received interrupt mask                             */
      __IOM uint32 NAKM       : 1;            /*!< [4..4] NAK response received interrupt mask                               */
      __IOM uint32 ACKM       : 1;            /*!< [5..5] ACK response received/transmitted interrupt mask                   */
      __IOM uint32 NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32 TXERRM     : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32 BBERRM     : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32 FRMORM     : 1;            /*!< [9..9] Frame overrun mask                                                 */
      __IOM uint32 DTERRM     : 1;            /*!< [10..10] Data toggle error mask                                           */
            uint32            : 21;
    } bit;
  } OTG_HS_HCINTMSK12;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000288) OTG_HS host channel-12 transfer size register              */
    
    struct {
      __IOM uint32 XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32 PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32 DPID       : 2;            /*!< [30..29] Data PID                                                         */
            uint32            : 1;
    } bit;
  } OTG_HS_HCTSIZ12;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000028C) OTG_HS host channel-12 DMA address register                */
    
    struct {
      __IOM uint32 DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } bit;
  } OTG_HS_HCDMA12;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000290) OTG_HS host channel-13 characteristics register            */
    
    struct {
      __IOM uint32 MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
      __IOM uint32 EPNUM      : 4;            /*!< [14..11] Endpoint number                                                  */
      __IOM uint32 EPDIR      : 1;            /*!< [15..15] Endpoint direction                                               */
            uint32            : 1;
      __IOM uint32 LSDEV      : 1;            /*!< [17..17] Low-speed device                                                 */
      __IOM uint32 EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32 MC         : 2;            /*!< [21..20] Multi Count (MC) / Error Count (EC)                              */
      __IOM uint32 DAD        : 7;            /*!< [28..22] Device address                                                   */
      __IOM uint32 ODDFRM     : 1;            /*!< [29..29] Odd frame                                                        */
      __IOM uint32 CHDIS      : 1;            /*!< [30..30] Channel disable                                                  */
      __IOM uint32 CHENA      : 1;            /*!< [31..31] Channel enable                                                   */
    } bit;
  } OTG_HS_HCCHAR13;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000294) OTG_HS host channel-13 split control register              */
    
    struct {
      __IOM uint32 PRTADDR    : 7;            /*!< [6..0] Port address                                                       */
      __IOM uint32 HUBADDR    : 7;            /*!< [13..7] Hub address                                                       */
      __IOM uint32 XACTPOS    : 2;            /*!< [15..14] XACTPOS                                                          */
      __IOM uint32 COMPLSPLT  : 1;            /*!< [16..16] Do complete split                                                */
            uint32            : 14;
      __IOM uint32 SPLITEN    : 1;            /*!< [31..31] Split enable                                                     */
    } bit;
  } OTG_HS_HCSPLT13;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000298) OTG_HS host channel-13 interrupt register                  */
    
    struct {
      __IOM uint32 XFRC       : 1;            /*!< [0..0] Transfer completed                                                 */
      __IOM uint32 CHH        : 1;            /*!< [1..1] Channel halted                                                     */
      __IOM uint32 AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32 STALL      : 1;            /*!< [3..3] STALL response received interrupt                                  */
      __IOM uint32 NAK        : 1;            /*!< [4..4] NAK response received interrupt                                    */
      __IOM uint32 ACK        : 1;            /*!< [5..5] ACK response received/transmitted interrupt                        */
      __IOM uint32 NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32 TXERR      : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32 BBERR      : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32 FRMOR      : 1;            /*!< [9..9] Frame overrun                                                      */
      __IOM uint32 DTERR      : 1;            /*!< [10..10] Data toggle error                                                */
            uint32            : 21;
    } bit;
  } OTG_HS_HCINT13;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000029C) OTG_HS host channel-13 interrupt mask register             */
    
    struct {
      __IOM uint32 XFRCM      : 1;            /*!< [0..0] Transfer completed mask                                            */
      __IOM uint32 CHHM       : 1;            /*!< [1..1] Channel halted mask                                                */
      __IOM uint32 AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32 STALLM     : 1;            /*!< [3..3] STALLM response received interrupt mask                            */
      __IOM uint32 NAKM       : 1;            /*!< [4..4] NAK response received interrupt mask                               */
      __IOM uint32 ACKM       : 1;            /*!< [5..5] ACK response received/transmitted interrupt mask                   */
      __IOM uint32 NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32 TXERRM     : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32 BBERRM     : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32 FRMORM     : 1;            /*!< [9..9] Frame overrun mask                                                 */
      __IOM uint32 DTERRM     : 1;            /*!< [10..10] Data toggle error mask                                           */
            uint32            : 21;
    } bit;
  } OTG_HS_HCINTMSK13;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000002A0) OTG_HS host channel-13 transfer size register              */
    
    struct {
      __IOM uint32 XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32 PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32 DPID       : 2;            /*!< [30..29] Data PID                                                         */
            uint32            : 1;
    } bit;
  } OTG_HS_HCTSIZ13;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000002A4) OTG_HS host channel-13 DMA address register                */
    
    struct {
      __IOM uint32 DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } bit;
  } OTG_HS_HCDMA13;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000002A8) OTG_HS host channel-14 characteristics register            */
    
    struct {
      __IOM uint32 MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
      __IOM uint32 EPNUM      : 4;            /*!< [14..11] Endpoint number                                                  */
      __IOM uint32 EPDIR      : 1;            /*!< [15..15] Endpoint direction                                               */
            uint32            : 1;
      __IOM uint32 LSDEV      : 1;            /*!< [17..17] Low-speed device                                                 */
      __IOM uint32 EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32 MC         : 2;            /*!< [21..20] Multi Count (MC) / Error Count (EC)                              */
      __IOM uint32 DAD        : 7;            /*!< [28..22] Device address                                                   */
      __IOM uint32 ODDFRM     : 1;            /*!< [29..29] Odd frame                                                        */
      __IOM uint32 CHDIS      : 1;            /*!< [30..30] Channel disable                                                  */
      __IOM uint32 CHENA      : 1;            /*!< [31..31] Channel enable                                                   */
    } bit;
  } OTG_HS_HCCHAR14;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000002AC) OTG_HS host channel-14 split control register              */
    
    struct {
      __IOM uint32 PRTADDR    : 7;            /*!< [6..0] Port address                                                       */
      __IOM uint32 HUBADDR    : 7;            /*!< [13..7] Hub address                                                       */
      __IOM uint32 XACTPOS    : 2;            /*!< [15..14] XACTPOS                                                          */
      __IOM uint32 COMPLSPLT  : 1;            /*!< [16..16] Do complete split                                                */
            uint32            : 14;
      __IOM uint32 SPLITEN    : 1;            /*!< [31..31] Split enable                                                     */
    } bit;
  } OTG_HS_HCSPLT14;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000002B0) OTG_HS host channel-14 interrupt register                  */
    
    struct {
      __IOM uint32 XFRC       : 1;            /*!< [0..0] Transfer completed                                                 */
      __IOM uint32 CHH        : 1;            /*!< [1..1] Channel halted                                                     */
      __IOM uint32 AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32 STALL      : 1;            /*!< [3..3] STALL response received interrupt                                  */
      __IOM uint32 NAK        : 1;            /*!< [4..4] NAK response received interrupt                                    */
      __IOM uint32 ACK        : 1;            /*!< [5..5] ACK response received/transmitted interrupt                        */
      __IOM uint32 NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32 TXERR      : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32 BBERR      : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32 FRMOR      : 1;            /*!< [9..9] Frame overrun                                                      */
      __IOM uint32 DTERR      : 1;            /*!< [10..10] Data toggle error                                                */
            uint32            : 21;
    } bit;
  } OTG_HS_HCINT14;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000002B4) OTG_HS host channel-14 interrupt mask register             */
    
    struct {
      __IOM uint32 XFRCM      : 1;            /*!< [0..0] Transfer completed mask                                            */
      __IOM uint32 CHHM       : 1;            /*!< [1..1] Channel halted mask                                                */
      __IOM uint32 AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32 STALLM     : 1;            /*!< [3..3] STALL response received interrupt mask                             */
      __IOM uint32 NAKM       : 1;            /*!< [4..4] NAKM response received interrupt mask                              */
      __IOM uint32 ACKM       : 1;            /*!< [5..5] ACKM response received/transmitted interrupt mask                  */
      __IOM uint32 NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32 TXERRM     : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32 BBERRM     : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32 FRMORM     : 1;            /*!< [9..9] Frame overrun mask                                                 */
      __IOM uint32 DTERRM     : 1;            /*!< [10..10] Data toggle error mask                                           */
            uint32            : 21;
    } bit;
  } OTG_HS_HCINTMSK14;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000002B8) OTG_HS host channel-14 transfer size register              */
    
    struct {
      __IOM uint32 XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32 PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32 DPID       : 2;            /*!< [30..29] Data PID                                                         */
            uint32            : 1;
    } bit;
  } OTG_HS_HCTSIZ14;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000002BC) OTG_HS host channel-14 DMA address register                */
    
    struct {
      __IOM uint32 DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } bit;
  } OTG_HS_HCDMA14;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000002C0) OTG_HS host channel-15 characteristics register            */
    
    struct {
      __IOM uint32 MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
      __IOM uint32 EPNUM      : 4;            /*!< [14..11] Endpoint number                                                  */
      __IOM uint32 EPDIR      : 1;            /*!< [15..15] Endpoint direction                                               */
            uint32            : 1;
      __IOM uint32 LSDEV      : 1;            /*!< [17..17] Low-speed device                                                 */
      __IOM uint32 EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32 MC         : 2;            /*!< [21..20] Multi Count (MC) / Error Count (EC)                              */
      __IOM uint32 DAD        : 7;            /*!< [28..22] Device address                                                   */
      __IOM uint32 ODDFRM     : 1;            /*!< [29..29] Odd frame                                                        */
      __IOM uint32 CHDIS      : 1;            /*!< [30..30] Channel disable                                                  */
      __IOM uint32 CHENA      : 1;            /*!< [31..31] Channel enable                                                   */
    } bit;
  } OTG_HS_HCCHAR15;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000002C4) OTG_HS host channel-15 split control register              */
    
    struct {
      __IOM uint32 PRTADDR    : 7;            /*!< [6..0] Port address                                                       */
      __IOM uint32 HUBADDR    : 7;            /*!< [13..7] Hub address                                                       */
      __IOM uint32 XACTPOS    : 2;            /*!< [15..14] XACTPOS                                                          */
      __IOM uint32 COMPLSPLT  : 1;            /*!< [16..16] Do complete split                                                */
            uint32            : 14;
      __IOM uint32 SPLITEN    : 1;            /*!< [31..31] Split enable                                                     */
    } bit;
  } OTG_HS_HCSPLT15;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000002C8) OTG_HS host channel-15 interrupt register                  */
    
    struct {
      __IOM uint32 XFRC       : 1;            /*!< [0..0] Transfer completed                                                 */
      __IOM uint32 CHH        : 1;            /*!< [1..1] Channel halted                                                     */
      __IOM uint32 AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32 STALL      : 1;            /*!< [3..3] STALL response received interrupt                                  */
      __IOM uint32 NAK        : 1;            /*!< [4..4] NAK response received interrupt                                    */
      __IOM uint32 ACK        : 1;            /*!< [5..5] ACK response received/transmitted interrupt                        */
      __IOM uint32 NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32 TXERR      : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32 BBERR      : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32 FRMOR      : 1;            /*!< [9..9] Frame overrun                                                      */
      __IOM uint32 DTERR      : 1;            /*!< [10..10] Data toggle error                                                */
            uint32            : 21;
    } bit;
  } OTG_HS_HCINT15;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000002CC) OTG_HS host channel-15 interrupt mask register             */
    
    struct {
      __IOM uint32 XFRCM      : 1;            /*!< [0..0] Transfer completed mask                                            */
      __IOM uint32 CHHM       : 1;            /*!< [1..1] Channel halted mask                                                */
      __IOM uint32 AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32 STALL      : 1;            /*!< [3..3] STALL response received interrupt mask                             */
      __IOM uint32 NAKM       : 1;            /*!< [4..4] NAK response received interrupt mask                               */
      __IOM uint32 ACKM       : 1;            /*!< [5..5] ACK response received/transmitted interrupt mask                   */
      __IOM uint32 NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32 TXERRM     : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32 BBERRM     : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32 FRMORM     : 1;            /*!< [9..9] Frame overrun mask                                                 */
      __IOM uint32 DTERRM     : 1;            /*!< [10..10] Data toggle error mask                                           */
            uint32            : 21;
    } bit;
  } OTG_HS_HCINTMSK15;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000002D0) OTG_HS host channel-15 transfer size register              */
    
    struct {
      __IOM uint32 XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32 PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32 DPID       : 2;            /*!< [30..29] Data PID                                                         */
            uint32            : 1;
    } bit;
  } OTG_HS_HCTSIZ15;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000002D4) OTG_HS host channel-15 DMA address register                */
    
    struct {
      __IOM uint32 DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } bit;
  } OTG_HS_HCDMA15;
} OTG1_HS_HOST_Type;                            /*!< Size = 728 (0x2d8)                                                        */



/* =========================================================================================================================== */
/* ================                                      OTG1_HS_DEVICE                                       ================ */
/* =========================================================================================================================== */


/**
  * @brief USB 1 on the go high speed (OTG1_HS_DEVICE)
  */

typedef struct {                                /*!< (@ 0x40040800) OTG1_HS_DEVICE Structure                                   */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) OTG_HS device configuration register                       */
    
    struct {
      __IOM uint32 DSPD       : 2;            /*!< [1..0] Device speed                                                       */
      __IOM uint32 NZLSOHSK   : 1;            /*!< [2..2] Nonzero-length status OUT handshake                                */
            uint32            : 1;
      __IOM uint32 DAD        : 7;            /*!< [10..4] Device address                                                    */
      __IOM uint32 PFIVL      : 2;            /*!< [12..11] Periodic (micro)frame interval                                   */
            uint32            : 11;
      __IOM uint32 PERSCHIVL  : 2;            /*!< [25..24] Periodic scheduling interval                                     */
            uint32            : 6;
    } bit;
  } OTG_HS_DCFG;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) OTG_HS device control register                             */
    
    struct {
      __IOM uint32 RWUSIG     : 1;            /*!< [0..0] Remote wakeup signaling                                            */
      __IOM uint32 SDIS       : 1;            /*!< [1..1] Soft disconnect                                                    */
      __IM  uint32 GINSTS     : 1;            /*!< [2..2] Global IN NAK status                                               */
      __IM  uint32 GONSTS     : 1;            /*!< [3..3] Global OUT NAK status                                              */
      __IOM uint32 TCTL       : 3;            /*!< [6..4] Test control                                                       */
      __OM  uint32 SGINAK     : 1;            /*!< [7..7] Set global IN NAK                                                  */
      __OM  uint32 CGINAK     : 1;            /*!< [8..8] Clear global IN NAK                                                */
      __OM  uint32 SGONAK     : 1;            /*!< [9..9] Set global OUT NAK                                                 */
      __OM  uint32 CGONAK     : 1;            /*!< [10..10] Clear global OUT NAK                                             */
      __IOM uint32 POPRGDNE   : 1;            /*!< [11..11] Power-on programming done                                        */
            uint32            : 20;
    } bit;
  } OTG_HS_DCTL;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000008) OTG_HS device status register                              */
    
    struct {
      __IM  uint32 SUSPSTS    : 1;            /*!< [0..0] Suspend status                                                     */
      __IM  uint32 ENUMSPD    : 2;            /*!< [2..1] Enumerated speed                                                   */
      __IM  uint32 EERR       : 1;            /*!< [3..3] Erratic error                                                      */
            uint32            : 4;
      __IM  uint32 FNSOF      : 14;           /*!< [21..8] Frame number of the received SOF                                  */
            uint32            : 10;
    } bit;
  } OTG_HS_DSTS;
  __IM  uint32  RESERVED;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) OTG_HS device IN endpoint common interrupt mask
                                                                    register                                                   */
    
    struct {
      __IOM uint32 XFRCM      : 1;            /*!< [0..0] Transfer completed interrupt mask                                  */
      __IOM uint32 EPDM       : 1;            /*!< [1..1] Endpoint disabled interrupt mask                                   */
            uint32            : 1;
      __IOM uint32 TOM        : 1;            /*!< [3..3] Timeout condition mask (nonisochronous endpoints)                  */
      __IOM uint32 ITTXFEMSK  : 1;            /*!< [4..4] IN token received when TxFIFO empty mask                           */
      __IOM uint32 INEPNMM    : 1;            /*!< [5..5] IN token received with EP mismatch mask                            */
      __IOM uint32 INEPNEM    : 1;            /*!< [6..6] IN endpoint NAK effective mask                                     */
            uint32            : 1;
      __IOM uint32 TXFURM     : 1;            /*!< [8..8] FIFO underrun mask                                                 */
      __IOM uint32 BIM        : 1;            /*!< [9..9] BNA interrupt mask                                                 */
            uint32            : 22;
    } bit;
  } OTG_HS_DIEPMSK;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000014) OTG_HS device OUT endpoint common interrupt mask
                                                                    register                                                   */
    
    struct {
      __IOM uint32 XFRCM      : 1;            /*!< [0..0] Transfer completed interrupt mask                                  */
      __IOM uint32 EPDM       : 1;            /*!< [1..1] Endpoint disabled interrupt mask                                   */
            uint32            : 1;
      __IOM uint32 STUPM      : 1;            /*!< [3..3] SETUP phase done mask                                              */
      __IOM uint32 OTEPDM     : 1;            /*!< [4..4] OUT token received when endpoint disabled mask                     */
            uint32            : 1;
      __IOM uint32 B2BSTUP    : 1;            /*!< [6..6] Back-to-back SETUP packets received mask                           */
            uint32            : 1;
      __IOM uint32 OPEM       : 1;            /*!< [8..8] OUT packet error mask                                              */
      __IOM uint32 BOIM       : 1;            /*!< [9..9] BNA interrupt mask                                                 */
            uint32            : 22;
    } bit;
  } OTG_HS_DOEPMSK;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000018) OTG_HS device all endpoints interrupt register             */
    
    struct {
      __IM  uint32 IEPINT     : 16;           /*!< [15..0] IN endpoint interrupt bits                                        */
      __IM  uint32 OEPINT     : 16;           /*!< [31..16] OUT endpoint interrupt bits                                      */
    } bit;
  } OTG_HS_DAINT;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000001C) OTG_HS all endpoints interrupt mask register               */
    
    struct {
      __IOM uint32 IEPM       : 16;           /*!< [15..0] IN EP interrupt mask bits                                         */
      __IOM uint32 OEPM       : 16;           /*!< [31..16] OUT EP interrupt mask bits                                       */
    } bit;
  } OTG_HS_DAINTMSK;
  __IM  uint32  RESERVED1[2];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000028) OTG_HS device VBUS discharge time register                 */
    
    struct {
      __IOM uint32 VBUSDT     : 16;           /*!< [15..0] Device VBUS discharge time                                        */
            uint32            : 16;
    } bit;
  } OTG_HS_DVBUSDIS;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000002C) OTG_HS device VBUS pulsing time register                   */
    
    struct {
      __IOM uint32 DVBUSP     : 12;           /*!< [11..0] Device VBUS pulsing time                                          */
            uint32            : 20;
    } bit;
  } OTG_HS_DVBUSPULSE;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000030) OTG_HS Device threshold control register                   */
    
    struct {
      __IOM uint32 NONISOTHREN : 1;           /*!< [0..0] Nonisochronous IN endpoints threshold enable                       */
      __IOM uint32 ISOTHREN   : 1;            /*!< [1..1] ISO IN endpoint threshold enable                                   */
      __IOM uint32 TXTHRLEN   : 9;            /*!< [10..2] Transmit threshold length                                         */
            uint32            : 5;
      __IOM uint32 RXTHREN    : 1;            /*!< [16..16] Receive threshold enable                                         */
      __IOM uint32 RXTHRLEN   : 9;            /*!< [25..17] Receive threshold length                                         */
            uint32            : 1;
      __IOM uint32 ARPEN      : 1;            /*!< [27..27] Arbiter parking enable                                           */
            uint32            : 4;
    } bit;
  } OTG_HS_DTHRCTL;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000034) OTG_HS device IN endpoint FIFO empty interrupt
                                                                    mask register                                              */
    
    struct {
      __IOM uint32 INEPTXFEM  : 16;           /*!< [15..0] IN EP Tx FIFO empty interrupt mask bits                           */
            uint32            : 16;
    } bit;
  } OTG_HS_DIEPEMPMSK;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000038) OTG_HS device each endpoint interrupt register             */
    
    struct {
            uint32            : 1;
      __IOM uint32 IEP1INT    : 1;            /*!< [1..1] IN endpoint 1interrupt bit                                         */
            uint32            : 15;
      __IOM uint32 OEP1INT    : 1;            /*!< [17..17] OUT endpoint 1 interrupt bit                                     */
            uint32            : 14;
    } bit;
  } OTG_HS_DEACHINT;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000003C) OTG_HS device each endpoint interrupt register
                                                                    mask                                                       */
    
    struct {
            uint32            : 1;
      __IOM uint32 IEP1INTM   : 1;            /*!< [1..1] IN Endpoint 1 interrupt mask bit                                   */
            uint32            : 15;
      __IOM uint32 OEP1INTM   : 1;            /*!< [17..17] OUT Endpoint 1 interrupt mask bit                                */
            uint32            : 14;
    } bit;
  } OTG_HS_DEACHINTMSK;
  __IM  uint32  RESERVED2[48];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000100) OTG device endpoint-0 control register                     */
    
    struct {
      __IOM uint32 MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
            uint32            : 4;
      __IOM uint32 USBAEP     : 1;            /*!< [15..15] USB active endpoint                                              */
      __IM  uint32 EONUM_DPID : 1;            /*!< [16..16] Even/odd frame                                                   */
      __IM  uint32 NAKSTS     : 1;            /*!< [17..17] NAK status                                                       */
      __IOM uint32 EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
            uint32            : 1;
      __IOM uint32 Stall      : 1;            /*!< [21..21] STALL handshake                                                  */
      __IOM uint32 TXFNUM     : 4;            /*!< [25..22] TxFIFO number                                                    */
      __OM  uint32 CNAK       : 1;            /*!< [26..26] Clear NAK                                                        */
      __OM  uint32 SNAK       : 1;            /*!< [27..27] Set NAK                                                          */
      __OM  uint32 SD0PID_SEVNFRM : 1;        /*!< [28..28] Set DATA0 PID                                                    */
      __OM  uint32 SODDFRM    : 1;            /*!< [29..29] Set odd frame                                                    */
      __IOM uint32 EPDIS      : 1;            /*!< [30..30] Endpoint disable                                                 */
      __IOM uint32 EPENA      : 1;            /*!< [31..31] Endpoint enable                                                  */
    } bit;
  } OTG_HS_DIEPCTL0;
  __IM  uint32  RESERVED3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000108) OTG device endpoint-0 interrupt register                   */
    
    struct {
      __IOM uint32 XFRC       : 1;            /*!< [0..0] Transfer completed interrupt                                       */
      __IOM uint32 EPDISD     : 1;            /*!< [1..1] Endpoint disabled interrupt                                        */
            uint32            : 1;
      __IOM uint32 TOC        : 1;            /*!< [3..3] Timeout condition                                                  */
      __IOM uint32 ITTXFE     : 1;            /*!< [4..4] IN token received when TxFIFO is empty                             */
            uint32            : 1;
      __IOM uint32 INEPNE     : 1;            /*!< [6..6] IN endpoint NAK effective                                          */
      __IM  uint32 TXFE       : 1;            /*!< [7..7] Transmit FIFO empty                                                */
      __IOM uint32 TXFIFOUDRN : 1;            /*!< [8..8] Transmit Fifo Underrun                                             */
      __IOM uint32 BNA        : 1;            /*!< [9..9] Buffer not available interrupt                                     */
            uint32            : 1;
      __IOM uint32 PKTDRPSTS  : 1;            /*!< [11..11] Packet dropped status                                            */
      __IOM uint32 BERR       : 1;            /*!< [12..12] Babble error interrupt                                           */
      __IOM uint32 NAK        : 1;            /*!< [13..13] NAK interrupt                                                    */
            uint32            : 18;
    } bit;
  } OTG_HS_DIEPINT0;
  __IM  uint32  RESERVED4;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000110) OTG_HS device IN endpoint 0 transfer size register         */
    
    struct {
      __IOM uint32 XFRSIZ     : 7;            /*!< [6..0] Transfer size                                                      */
            uint32            : 12;
      __IOM uint32 PKTCNT     : 2;            /*!< [20..19] Packet count                                                     */
            uint32            : 11;
    } bit;
  } OTG_HS_DIEPTSIZ0;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000114) OTG_HS device endpoint-1 DMA address register              */
    
    struct {
      __IOM uint32 DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } bit;
  } OTG_HS_DIEPDMA1;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000118) OTG_HS device IN endpoint transmit FIFO status
                                                                    register                                                   */
    
    struct {
      __IM  uint32 INEPTFSAV  : 16;           /*!< [15..0] IN endpoint TxFIFO space avail                                    */
            uint32            : 16;
    } bit;
  } OTG_HS_DTXFSTS0;
  __IM  uint32  RESERVED5;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000120) OTG device endpoint-1 control register                     */
    
    struct {
      __IOM uint32 MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
            uint32            : 4;
      __IOM uint32 USBAEP     : 1;            /*!< [15..15] USB active endpoint                                              */
      __IM  uint32 EONUM_DPID : 1;            /*!< [16..16] Even/odd frame                                                   */
      __IM  uint32 NAKSTS     : 1;            /*!< [17..17] NAK status                                                       */
      __IOM uint32 EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
            uint32            : 1;
      __IOM uint32 Stall      : 1;            /*!< [21..21] STALL handshake                                                  */
      __IOM uint32 TXFNUM     : 4;            /*!< [25..22] TxFIFO number                                                    */
      __OM  uint32 CNAK       : 1;            /*!< [26..26] Clear NAK                                                        */
      __OM  uint32 SNAK       : 1;            /*!< [27..27] Set NAK                                                          */
      __OM  uint32 SD0PID_SEVNFRM : 1;        /*!< [28..28] Set DATA0 PID                                                    */
      __OM  uint32 SODDFRM    : 1;            /*!< [29..29] Set odd frame                                                    */
      __IOM uint32 EPDIS      : 1;            /*!< [30..30] Endpoint disable                                                 */
      __IOM uint32 EPENA      : 1;            /*!< [31..31] Endpoint enable                                                  */
    } bit;
  } OTG_HS_DIEPCTL1;
  __IM  uint32  RESERVED6;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000128) OTG device endpoint-1 interrupt register                   */
    
    struct {
      __IOM uint32 XFRC       : 1;            /*!< [0..0] Transfer completed interrupt                                       */
      __IOM uint32 EPDISD     : 1;            /*!< [1..1] Endpoint disabled interrupt                                        */
            uint32            : 1;
      __IOM uint32 TOC        : 1;            /*!< [3..3] Timeout condition                                                  */
      __IOM uint32 ITTXFE     : 1;            /*!< [4..4] IN token received when TxFIFO is empty                             */
            uint32            : 1;
      __IOM uint32 INEPNE     : 1;            /*!< [6..6] IN endpoint NAK effective                                          */
      __IM  uint32 TXFE       : 1;            /*!< [7..7] Transmit FIFO empty                                                */
      __IOM uint32 TXFIFOUDRN : 1;            /*!< [8..8] Transmit Fifo Underrun                                             */
      __IOM uint32 BNA        : 1;            /*!< [9..9] Buffer not available interrupt                                     */
            uint32            : 1;
      __IOM uint32 PKTDRPSTS  : 1;            /*!< [11..11] Packet dropped status                                            */
      __IOM uint32 BERR       : 1;            /*!< [12..12] Babble error interrupt                                           */
      __IOM uint32 NAK        : 1;            /*!< [13..13] NAK interrupt                                                    */
            uint32            : 18;
    } bit;
  } OTG_HS_DIEPINT1;
  __IM  uint32  RESERVED7;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000130) OTG_HS device endpoint transfer size register              */
    
    struct {
      __IOM uint32 XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32 PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32 MCNT       : 2;            /*!< [30..29] Multi count                                                      */
            uint32            : 1;
    } bit;
  } OTG_HS_DIEPTSIZ1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000134) OTG_HS device endpoint-2 DMA address register              */
    
    struct {
      __IOM uint32 DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } bit;
  } OTG_HS_DIEPDMA2;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000138) OTG_HS device IN endpoint transmit FIFO status
                                                                    register                                                   */
    
    struct {
      __IM  uint32 INEPTFSAV  : 16;           /*!< [15..0] IN endpoint TxFIFO space avail                                    */
            uint32            : 16;
    } bit;
  } OTG_HS_DTXFSTS1;
  __IM  uint32  RESERVED8;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000140) OTG device endpoint-2 control register                     */
    
    struct {
      __IOM uint32 MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
            uint32            : 4;
      __IOM uint32 USBAEP     : 1;            /*!< [15..15] USB active endpoint                                              */
      __IM  uint32 EONUM_DPID : 1;            /*!< [16..16] Even/odd frame                                                   */
      __IM  uint32 NAKSTS     : 1;            /*!< [17..17] NAK status                                                       */
      __IOM uint32 EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
            uint32            : 1;
      __IOM uint32 Stall      : 1;            /*!< [21..21] STALL handshake                                                  */
      __IOM uint32 TXFNUM     : 4;            /*!< [25..22] TxFIFO number                                                    */
      __OM  uint32 CNAK       : 1;            /*!< [26..26] Clear NAK                                                        */
      __OM  uint32 SNAK       : 1;            /*!< [27..27] Set NAK                                                          */
      __OM  uint32 SD0PID_SEVNFRM : 1;        /*!< [28..28] Set DATA0 PID                                                    */
      __OM  uint32 SODDFRM    : 1;            /*!< [29..29] Set odd frame                                                    */
      __IOM uint32 EPDIS      : 1;            /*!< [30..30] Endpoint disable                                                 */
      __IOM uint32 EPENA      : 1;            /*!< [31..31] Endpoint enable                                                  */
    } bit;
  } OTG_HS_DIEPCTL2;
  __IM  uint32  RESERVED9;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000148) OTG device endpoint-2 interrupt register                   */
    
    struct {
      __IOM uint32 XFRC       : 1;            /*!< [0..0] Transfer completed interrupt                                       */
      __IOM uint32 EPDISD     : 1;            /*!< [1..1] Endpoint disabled interrupt                                        */
            uint32            : 1;
      __IOM uint32 TOC        : 1;            /*!< [3..3] Timeout condition                                                  */
      __IOM uint32 ITTXFE     : 1;            /*!< [4..4] IN token received when TxFIFO is empty                             */
            uint32            : 1;
      __IOM uint32 INEPNE     : 1;            /*!< [6..6] IN endpoint NAK effective                                          */
      __IM  uint32 TXFE       : 1;            /*!< [7..7] Transmit FIFO empty                                                */
      __IOM uint32 TXFIFOUDRN : 1;            /*!< [8..8] Transmit Fifo Underrun                                             */
      __IOM uint32 BNA        : 1;            /*!< [9..9] Buffer not available interrupt                                     */
            uint32            : 1;
      __IOM uint32 PKTDRPSTS  : 1;            /*!< [11..11] Packet dropped status                                            */
      __IOM uint32 BERR       : 1;            /*!< [12..12] Babble error interrupt                                           */
      __IOM uint32 NAK        : 1;            /*!< [13..13] NAK interrupt                                                    */
            uint32            : 18;
    } bit;
  } OTG_HS_DIEPINT2;
  __IM  uint32  RESERVED10;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000150) OTG_HS device endpoint transfer size register              */
    
    struct {
      __IOM uint32 XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32 PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32 MCNT       : 2;            /*!< [30..29] Multi count                                                      */
            uint32            : 1;
    } bit;
  } OTG_HS_DIEPTSIZ2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000154) OTG_HS device endpoint-3 DMA address register              */
    
    struct {
      __IOM uint32 DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } bit;
  } OTG_HS_DIEPDMA3;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000158) OTG_HS device IN endpoint transmit FIFO status
                                                                    register                                                   */
    
    struct {
      __IM  uint32 INEPTFSAV  : 16;           /*!< [15..0] IN endpoint TxFIFO space avail                                    */
            uint32            : 16;
    } bit;
  } OTG_HS_DTXFSTS2;
  __IM  uint32  RESERVED11;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000160) OTG device endpoint-3 control register                     */
    
    struct {
      __IOM uint32 MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
            uint32            : 4;
      __IOM uint32 USBAEP     : 1;            /*!< [15..15] USB active endpoint                                              */
      __IM  uint32 EONUM_DPID : 1;            /*!< [16..16] Even/odd frame                                                   */
      __IM  uint32 NAKSTS     : 1;            /*!< [17..17] NAK status                                                       */
      __IOM uint32 EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
            uint32            : 1;
      __IOM uint32 Stall      : 1;            /*!< [21..21] STALL handshake                                                  */
      __IOM uint32 TXFNUM     : 4;            /*!< [25..22] TxFIFO number                                                    */
      __OM  uint32 CNAK       : 1;            /*!< [26..26] Clear NAK                                                        */
      __OM  uint32 SNAK       : 1;            /*!< [27..27] Set NAK                                                          */
      __OM  uint32 SD0PID_SEVNFRM : 1;        /*!< [28..28] Set DATA0 PID                                                    */
      __OM  uint32 SODDFRM    : 1;            /*!< [29..29] Set odd frame                                                    */
      __IOM uint32 EPDIS      : 1;            /*!< [30..30] Endpoint disable                                                 */
      __IOM uint32 EPENA      : 1;            /*!< [31..31] Endpoint enable                                                  */
    } bit;
  } OTG_HS_DIEPCTL3;
  __IM  uint32  RESERVED12;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000168) OTG device endpoint-3 interrupt register                   */
    
    struct {
      __IOM uint32 XFRC       : 1;            /*!< [0..0] Transfer completed interrupt                                       */
      __IOM uint32 EPDISD     : 1;            /*!< [1..1] Endpoint disabled interrupt                                        */
            uint32            : 1;
      __IOM uint32 TOC        : 1;            /*!< [3..3] Timeout condition                                                  */
      __IOM uint32 ITTXFE     : 1;            /*!< [4..4] IN token received when TxFIFO is empty                             */
            uint32            : 1;
      __IOM uint32 INEPNE     : 1;            /*!< [6..6] IN endpoint NAK effective                                          */
      __IM  uint32 TXFE       : 1;            /*!< [7..7] Transmit FIFO empty                                                */
      __IOM uint32 TXFIFOUDRN : 1;            /*!< [8..8] Transmit Fifo Underrun                                             */
      __IOM uint32 BNA        : 1;            /*!< [9..9] Buffer not available interrupt                                     */
            uint32            : 1;
      __IOM uint32 PKTDRPSTS  : 1;            /*!< [11..11] Packet dropped status                                            */
      __IOM uint32 BERR       : 1;            /*!< [12..12] Babble error interrupt                                           */
      __IOM uint32 NAK        : 1;            /*!< [13..13] NAK interrupt                                                    */
            uint32            : 18;
    } bit;
  } OTG_HS_DIEPINT3;
  __IM  uint32  RESERVED13;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000170) OTG_HS device endpoint transfer size register              */
    
    struct {
      __IOM uint32 XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32 PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32 MCNT       : 2;            /*!< [30..29] Multi count                                                      */
            uint32            : 1;
    } bit;
  } OTG_HS_DIEPTSIZ3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000174) OTG_HS device endpoint-4 DMA address register              */
    
    struct {
      __IOM uint32 DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } bit;
  } OTG_HS_DIEPDMA4;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000178) OTG_HS device IN endpoint transmit FIFO status
                                                                    register                                                   */
    
    struct {
      __IM  uint32 INEPTFSAV  : 16;           /*!< [15..0] IN endpoint TxFIFO space avail                                    */
            uint32            : 16;
    } bit;
  } OTG_HS_DTXFSTS3;
  __IM  uint32  RESERVED14;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000180) OTG device endpoint-4 control register                     */
    
    struct {
      __IOM uint32 MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
            uint32            : 4;
      __IOM uint32 USBAEP     : 1;            /*!< [15..15] USB active endpoint                                              */
      __IM  uint32 EONUM_DPID : 1;            /*!< [16..16] Even/odd frame                                                   */
      __IM  uint32 NAKSTS     : 1;            /*!< [17..17] NAK status                                                       */
      __IOM uint32 EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
            uint32            : 1;
      __IOM uint32 Stall      : 1;            /*!< [21..21] STALL handshake                                                  */
      __IOM uint32 TXFNUM     : 4;            /*!< [25..22] TxFIFO number                                                    */
      __OM  uint32 CNAK       : 1;            /*!< [26..26] Clear NAK                                                        */
      __OM  uint32 SNAK       : 1;            /*!< [27..27] Set NAK                                                          */
      __OM  uint32 SD0PID_SEVNFRM : 1;        /*!< [28..28] Set DATA0 PID                                                    */
      __OM  uint32 SODDFRM    : 1;            /*!< [29..29] Set odd frame                                                    */
      __IOM uint32 EPDIS      : 1;            /*!< [30..30] Endpoint disable                                                 */
      __IOM uint32 EPENA      : 1;            /*!< [31..31] Endpoint enable                                                  */
    } bit;
  } OTG_HS_DIEPCTL4;
  __IM  uint32  RESERVED15;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000188) OTG device endpoint-4 interrupt register                   */
    
    struct {
      __IOM uint32 XFRC       : 1;            /*!< [0..0] Transfer completed interrupt                                       */
      __IOM uint32 EPDISD     : 1;            /*!< [1..1] Endpoint disabled interrupt                                        */
            uint32            : 1;
      __IOM uint32 TOC        : 1;            /*!< [3..3] Timeout condition                                                  */
      __IOM uint32 ITTXFE     : 1;            /*!< [4..4] IN token received when TxFIFO is empty                             */
            uint32            : 1;
      __IOM uint32 INEPNE     : 1;            /*!< [6..6] IN endpoint NAK effective                                          */
      __IM  uint32 TXFE       : 1;            /*!< [7..7] Transmit FIFO empty                                                */
      __IOM uint32 TXFIFOUDRN : 1;            /*!< [8..8] Transmit Fifo Underrun                                             */
      __IOM uint32 BNA        : 1;            /*!< [9..9] Buffer not available interrupt                                     */
            uint32            : 1;
      __IOM uint32 PKTDRPSTS  : 1;            /*!< [11..11] Packet dropped status                                            */
      __IOM uint32 BERR       : 1;            /*!< [12..12] Babble error interrupt                                           */
      __IOM uint32 NAK        : 1;            /*!< [13..13] NAK interrupt                                                    */
            uint32            : 18;
    } bit;
  } OTG_HS_DIEPINT4;
  __IM  uint32  RESERVED16;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000190) OTG_HS device endpoint transfer size register              */
    
    struct {
      __IOM uint32 XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32 PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32 MCNT       : 2;            /*!< [30..29] Multi count                                                      */
            uint32            : 1;
    } bit;
  } OTG_HS_DIEPTSIZ4;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000194) OTG_HS device endpoint-5 DMA address register              */
    
    struct {
      __IOM uint32 DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } bit;
  } OTG_HS_DIEPDMA5;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000198) OTG_HS device IN endpoint transmit FIFO status
                                                                    register                                                   */
    
    struct {
      __IM  uint32 INEPTFSAV  : 16;           /*!< [15..0] IN endpoint TxFIFO space avail                                    */
            uint32            : 16;
    } bit;
  } OTG_HS_DTXFSTS4;
  __IM  uint32  RESERVED17;
  
  union {
    union {
      __IOM uint32 reg;                       /*!< (@ 0x000001A0) OTG device endpoint-5 control register                     */
      
      struct {
        __IOM uint32 MPSIZ    : 11;           /*!< [10..0] Maximum packet size                                               */
              uint32          : 4;
        __IOM uint32 USBAEP   : 1;            /*!< [15..15] USB active endpoint                                              */
        __IM  uint32 EONUM_DPID : 1;          /*!< [16..16] Even/odd frame                                                   */
        __IM  uint32 NAKSTS   : 1;            /*!< [17..17] NAK status                                                       */
        __IOM uint32 EPTYP    : 2;            /*!< [19..18] Endpoint type                                                    */
              uint32          : 1;
        __IOM uint32 Stall    : 1;            /*!< [21..21] STALL handshake                                                  */
        __IOM uint32 TXFNUM   : 4;            /*!< [25..22] TxFIFO number                                                    */
        __OM  uint32 CNAK     : 1;            /*!< [26..26] Clear NAK                                                        */
        __OM  uint32 SNAK     : 1;            /*!< [27..27] Set NAK                                                          */
        __OM  uint32 SD0PID_SEVNFRM : 1;      /*!< [28..28] Set DATA0 PID                                                    */
        __OM  uint32 SODDFRM  : 1;            /*!< [29..29] Set odd frame                                                    */
        __IOM uint32 EPDIS    : 1;            /*!< [30..30] Endpoint disable                                                 */
        __IOM uint32 EPENA    : 1;            /*!< [31..31] Endpoint enable                                                  */
      } bit;
    } OTG_HS_DIEPCTL5;
    
    union {
      __IOM uint32 reg;                       /*!< (@ 0x000001A0) OTG_HS device endpoint transfer size register              */
      
      struct {
        __IOM uint32 XFRSIZ   : 19;           /*!< [18..0] Transfer size                                                     */
        __IOM uint32 PKTCNT   : 10;           /*!< [28..19] Packet count                                                     */
        __IOM uint32 MCNT     : 2;            /*!< [30..29] Multi count                                                      */
              uint32          : 1;
      } bit;
    } OTG_HS_DIEPTSIZ6;
  };
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001A4) OTG_HS device IN endpoint transmit FIFO status
                                                                    register                                                   */
    
    struct {
      __IOM uint32 INEPTFSAV  : 16;           /*!< [15..0] IN endpoint TxFIFO space avail                                    */
            uint32            : 16;
    } bit;
  } OTG_HS_DTXFSTS6;
  
  union {
    union {
      __IOM uint32 reg;                       /*!< (@ 0x000001A8) OTG device endpoint-5 interrupt register                   */
      
      struct {
        __IOM uint32 XFRC     : 1;            /*!< [0..0] Transfer completed interrupt                                       */
        __IOM uint32 EPDISD   : 1;            /*!< [1..1] Endpoint disabled interrupt                                        */
              uint32          : 1;
        __IOM uint32 TOC      : 1;            /*!< [3..3] Timeout condition                                                  */
        __IOM uint32 ITTXFE   : 1;            /*!< [4..4] IN token received when TxFIFO is empty                             */
              uint32          : 1;
        __IOM uint32 INEPNE   : 1;            /*!< [6..6] IN endpoint NAK effective                                          */
        __IM  uint32 TXFE     : 1;            /*!< [7..7] Transmit FIFO empty                                                */
        __IOM uint32 TXFIFOUDRN : 1;          /*!< [8..8] Transmit Fifo Underrun                                             */
        __IOM uint32 BNA      : 1;            /*!< [9..9] Buffer not available interrupt                                     */
              uint32          : 1;
        __IOM uint32 PKTDRPSTS : 1;           /*!< [11..11] Packet dropped status                                            */
        __IOM uint32 BERR     : 1;            /*!< [12..12] Babble error interrupt                                           */
        __IOM uint32 NAK      : 1;            /*!< [13..13] NAK interrupt                                                    */
              uint32          : 18;
      } bit;
    } OTG_HS_DIEPINT5;
    
    union {
      __IOM uint32 reg;                       /*!< (@ 0x000001A8) OTG_HS device endpoint transfer size register              */
      
      struct {
        __IOM uint32 XFRSIZ   : 19;           /*!< [18..0] Transfer size                                                     */
        __IOM uint32 PKTCNT   : 10;           /*!< [28..19] Packet count                                                     */
        __IOM uint32 MCNT     : 2;            /*!< [30..29] Multi count                                                      */
              uint32          : 1;
      } bit;
    } OTG_HS_DIEPTSIZ7;
  };
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001AC) OTG_HS device IN endpoint transmit FIFO status
                                                                    register                                                   */
    
    struct {
      __IOM uint32 INEPTFSAV  : 16;           /*!< [15..0] IN endpoint TxFIFO space avail                                    */
            uint32            : 16;
    } bit;
  } OTG_HS_DTXFSTS7;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001B0) OTG_HS device endpoint transfer size register              */
    
    struct {
      __IOM uint32 XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32 PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32 MCNT       : 2;            /*!< [30..29] Multi count                                                      */
            uint32            : 1;
    } bit;
  } OTG_HS_DIEPTSIZ5;
  __IM  uint32  RESERVED18;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000001B8) OTG_HS device IN endpoint transmit FIFO status
                                                                    register                                                   */
    
    struct {
      __IM  uint32 INEPTFSAV  : 16;           /*!< [15..0] IN endpoint TxFIFO space avail                                    */
            uint32            : 16;
    } bit;
  } OTG_HS_DTXFSTS5;
  __IM  uint32  RESERVED19;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001C0) OTG device endpoint-6 control register                     */
    
    struct {
      __IOM uint32 MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
            uint32            : 4;
      __IOM uint32 USBAEP     : 1;            /*!< [15..15] USB active endpoint                                              */
      __IM  uint32 EONUM_DPID : 1;            /*!< [16..16] Even/odd frame                                                   */
      __IM  uint32 NAKSTS     : 1;            /*!< [17..17] NAK status                                                       */
      __IOM uint32 EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
            uint32            : 1;
      __IOM uint32 Stall      : 1;            /*!< [21..21] STALL handshake                                                  */
      __IOM uint32 TXFNUM     : 4;            /*!< [25..22] TxFIFO number                                                    */
      __OM  uint32 CNAK       : 1;            /*!< [26..26] Clear NAK                                                        */
      __OM  uint32 SNAK       : 1;            /*!< [27..27] Set NAK                                                          */
      __OM  uint32 SD0PID_SEVNFRM : 1;        /*!< [28..28] Set DATA0 PID                                                    */
      __OM  uint32 SODDFRM    : 1;            /*!< [29..29] Set odd frame                                                    */
      __IOM uint32 EPDIS      : 1;            /*!< [30..30] Endpoint disable                                                 */
      __IOM uint32 EPENA      : 1;            /*!< [31..31] Endpoint enable                                                  */
    } bit;
  } OTG_HS_DIEPCTL6;
  __IM  uint32  RESERVED20;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001C8) OTG device endpoint-6 interrupt register                   */
    
    struct {
      __IOM uint32 XFRC       : 1;            /*!< [0..0] Transfer completed interrupt                                       */
      __IOM uint32 EPDISD     : 1;            /*!< [1..1] Endpoint disabled interrupt                                        */
            uint32            : 1;
      __IOM uint32 TOC        : 1;            /*!< [3..3] Timeout condition                                                  */
      __IOM uint32 ITTXFE     : 1;            /*!< [4..4] IN token received when TxFIFO is empty                             */
            uint32            : 1;
      __IOM uint32 INEPNE     : 1;            /*!< [6..6] IN endpoint NAK effective                                          */
      __IM  uint32 TXFE       : 1;            /*!< [7..7] Transmit FIFO empty                                                */
      __IOM uint32 TXFIFOUDRN : 1;            /*!< [8..8] Transmit Fifo Underrun                                             */
      __IOM uint32 BNA        : 1;            /*!< [9..9] Buffer not available interrupt                                     */
            uint32            : 1;
      __IOM uint32 PKTDRPSTS  : 1;            /*!< [11..11] Packet dropped status                                            */
      __IOM uint32 BERR       : 1;            /*!< [12..12] Babble error interrupt                                           */
      __IOM uint32 NAK        : 1;            /*!< [13..13] NAK interrupt                                                    */
            uint32            : 18;
    } bit;
  } OTG_HS_DIEPINT6;
  __IM  uint32  RESERVED21[5];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001E0) OTG device endpoint-7 control register                     */
    
    struct {
      __IOM uint32 MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
            uint32            : 4;
      __IOM uint32 USBAEP     : 1;            /*!< [15..15] USB active endpoint                                              */
      __IM  uint32 EONUM_DPID : 1;            /*!< [16..16] Even/odd frame                                                   */
      __IM  uint32 NAKSTS     : 1;            /*!< [17..17] NAK status                                                       */
      __IOM uint32 EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
            uint32            : 1;
      __IOM uint32 Stall      : 1;            /*!< [21..21] STALL handshake                                                  */
      __IOM uint32 TXFNUM     : 4;            /*!< [25..22] TxFIFO number                                                    */
      __OM  uint32 CNAK       : 1;            /*!< [26..26] Clear NAK                                                        */
      __OM  uint32 SNAK       : 1;            /*!< [27..27] Set NAK                                                          */
      __OM  uint32 SD0PID_SEVNFRM : 1;        /*!< [28..28] Set DATA0 PID                                                    */
      __OM  uint32 SODDFRM    : 1;            /*!< [29..29] Set odd frame                                                    */
      __IOM uint32 EPDIS      : 1;            /*!< [30..30] Endpoint disable                                                 */
      __IOM uint32 EPENA      : 1;            /*!< [31..31] Endpoint enable                                                  */
    } bit;
  } OTG_HS_DIEPCTL7;
  __IM  uint32  RESERVED22;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000001E8) OTG device endpoint-7 interrupt register                   */
    
    struct {
      __IOM uint32 XFRC       : 1;            /*!< [0..0] Transfer completed interrupt                                       */
      __IOM uint32 EPDISD     : 1;            /*!< [1..1] Endpoint disabled interrupt                                        */
            uint32            : 1;
      __IOM uint32 TOC        : 1;            /*!< [3..3] Timeout condition                                                  */
      __IOM uint32 ITTXFE     : 1;            /*!< [4..4] IN token received when TxFIFO is empty                             */
            uint32            : 1;
      __IOM uint32 INEPNE     : 1;            /*!< [6..6] IN endpoint NAK effective                                          */
      __IM  uint32 TXFE       : 1;            /*!< [7..7] Transmit FIFO empty                                                */
      __IOM uint32 TXFIFOUDRN : 1;            /*!< [8..8] Transmit Fifo Underrun                                             */
      __IOM uint32 BNA        : 1;            /*!< [9..9] Buffer not available interrupt                                     */
            uint32            : 1;
      __IOM uint32 PKTDRPSTS  : 1;            /*!< [11..11] Packet dropped status                                            */
      __IOM uint32 BERR       : 1;            /*!< [12..12] Babble error interrupt                                           */
      __IOM uint32 NAK        : 1;            /*!< [13..13] NAK interrupt                                                    */
            uint32            : 18;
    } bit;
  } OTG_HS_DIEPINT7;
  __IM  uint32  RESERVED23[69];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000300) OTG_HS device control OUT endpoint 0 control
                                                                    register                                                   */
    
    struct {
      __IM  uint32 MPSIZ      : 2;            /*!< [1..0] Maximum packet size                                                */
            uint32            : 13;
      __IM  uint32 USBAEP     : 1;            /*!< [15..15] USB active endpoint                                              */
            uint32            : 1;
      __IM  uint32 NAKSTS     : 1;            /*!< [17..17] NAK status                                                       */
      __IM  uint32 EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32 SNPM       : 1;            /*!< [20..20] Snoop mode                                                       */
      __IOM uint32 Stall      : 1;            /*!< [21..21] STALL handshake                                                  */
            uint32            : 4;
      __OM  uint32 CNAK       : 1;            /*!< [26..26] Clear NAK                                                        */
      __OM  uint32 SNAK       : 1;            /*!< [27..27] Set NAK                                                          */
            uint32            : 2;
      __IM  uint32 EPDIS      : 1;            /*!< [30..30] Endpoint disable                                                 */
      __OM  uint32 EPENA      : 1;            /*!< [31..31] Endpoint enable                                                  */
    } bit;
  } OTG_HS_DOEPCTL0;
  __IM  uint32  RESERVED24;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000308) OTG_HS device endpoint-0 interrupt register                */
    
    struct {
      __IOM uint32 XFRC       : 1;            /*!< [0..0] Transfer completed interrupt                                       */
      __IOM uint32 EPDISD     : 1;            /*!< [1..1] Endpoint disabled interrupt                                        */
            uint32            : 1;
      __IOM uint32 STUP       : 1;            /*!< [3..3] SETUP phase done                                                   */
      __IOM uint32 OTEPDIS    : 1;            /*!< [4..4] OUT token received when endpoint disabled                          */
            uint32            : 1;
      __IOM uint32 B2BSTUP    : 1;            /*!< [6..6] Back-to-back SETUP packets received                                */
            uint32            : 7;
      __IOM uint32 NYET       : 1;            /*!< [14..14] NYET interrupt                                                   */
            uint32            : 17;
    } bit;
  } OTG_HS_DOEPINT0;
  __IM  uint32  RESERVED25;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000310) OTG_HS device endpoint-0 transfer size register            */
    
    struct {
      __IOM uint32 XFRSIZ     : 7;            /*!< [6..0] Transfer size                                                      */
            uint32            : 12;
      __IOM uint32 PKTCNT     : 1;            /*!< [19..19] Packet count                                                     */
            uint32            : 9;
      __IOM uint32 STUPCNT    : 2;            /*!< [30..29] SETUP packet count                                               */
            uint32            : 1;
    } bit;
  } OTG_HS_DOEPTSIZ0;
  __IM  uint32  RESERVED26[3];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000320) OTG device endpoint-1 control register                     */
    
    struct {
      __IOM uint32 MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
            uint32            : 4;
      __IOM uint32 USBAEP     : 1;            /*!< [15..15] USB active endpoint                                              */
      __IM  uint32 EONUM_DPID : 1;            /*!< [16..16] Even odd frame/Endpoint data PID                                 */
      __IM  uint32 NAKSTS     : 1;            /*!< [17..17] NAK status                                                       */
      __IOM uint32 EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32 SNPM       : 1;            /*!< [20..20] Snoop mode                                                       */
      __IOM uint32 Stall      : 1;            /*!< [21..21] STALL handshake                                                  */
            uint32            : 4;
      __OM  uint32 CNAK       : 1;            /*!< [26..26] Clear NAK                                                        */
      __OM  uint32 SNAK       : 1;            /*!< [27..27] Set NAK                                                          */
      __OM  uint32 SD0PID_SEVNFRM : 1;        /*!< [28..28] Set DATA0 PID/Set even frame                                     */
      __OM  uint32 SODDFRM    : 1;            /*!< [29..29] Set odd frame                                                    */
      __IOM uint32 EPDIS      : 1;            /*!< [30..30] Endpoint disable                                                 */
      __IOM uint32 EPENA      : 1;            /*!< [31..31] Endpoint enable                                                  */
    } bit;
  } OTG_HS_DOEPCTL1;
  __IM  uint32  RESERVED27;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000328) OTG_HS device endpoint-1 interrupt register                */
    
    struct {
      __IOM uint32 XFRC       : 1;            /*!< [0..0] Transfer completed interrupt                                       */
      __IOM uint32 EPDISD     : 1;            /*!< [1..1] Endpoint disabled interrupt                                        */
            uint32            : 1;
      __IOM uint32 STUP       : 1;            /*!< [3..3] SETUP phase done                                                   */
      __IOM uint32 OTEPDIS    : 1;            /*!< [4..4] OUT token received when endpoint disabled                          */
            uint32            : 1;
      __IOM uint32 B2BSTUP    : 1;            /*!< [6..6] Back-to-back SETUP packets received                                */
            uint32            : 7;
      __IOM uint32 NYET       : 1;            /*!< [14..14] NYET interrupt                                                   */
            uint32            : 17;
    } bit;
  } OTG_HS_DOEPINT1;
  __IM  uint32  RESERVED28;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000330) OTG_HS device endpoint-1 transfer size register            */
    
    struct {
      __IOM uint32 XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32 PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32 RXDPID_STUPCNT : 2;        /*!< [30..29] Received data PID/SETUP packet count                             */
            uint32            : 1;
    } bit;
  } OTG_HS_DOEPTSIZ1;
  __IM  uint32  RESERVED29[3];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000340) OTG device endpoint-2 control register                     */
    
    struct {
      __IOM uint32 MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
            uint32            : 4;
      __IOM uint32 USBAEP     : 1;            /*!< [15..15] USB active endpoint                                              */
      __IM  uint32 EONUM_DPID : 1;            /*!< [16..16] Even odd frame/Endpoint data PID                                 */
      __IM  uint32 NAKSTS     : 1;            /*!< [17..17] NAK status                                                       */
      __IOM uint32 EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32 SNPM       : 1;            /*!< [20..20] Snoop mode                                                       */
      __IOM uint32 Stall      : 1;            /*!< [21..21] STALL handshake                                                  */
            uint32            : 4;
      __OM  uint32 CNAK       : 1;            /*!< [26..26] Clear NAK                                                        */
      __OM  uint32 SNAK       : 1;            /*!< [27..27] Set NAK                                                          */
      __OM  uint32 SD0PID_SEVNFRM : 1;        /*!< [28..28] Set DATA0 PID/Set even frame                                     */
      __OM  uint32 SODDFRM    : 1;            /*!< [29..29] Set odd frame                                                    */
      __IOM uint32 EPDIS      : 1;            /*!< [30..30] Endpoint disable                                                 */
      __IOM uint32 EPENA      : 1;            /*!< [31..31] Endpoint enable                                                  */
    } bit;
  } OTG_HS_DOEPCTL2;
  __IM  uint32  RESERVED30;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000348) OTG_HS device endpoint-2 interrupt register                */
    
    struct {
      __IOM uint32 XFRC       : 1;            /*!< [0..0] Transfer completed interrupt                                       */
      __IOM uint32 EPDISD     : 1;            /*!< [1..1] Endpoint disabled interrupt                                        */
            uint32            : 1;
      __IOM uint32 STUP       : 1;            /*!< [3..3] SETUP phase done                                                   */
      __IOM uint32 OTEPDIS    : 1;            /*!< [4..4] OUT token received when endpoint disabled                          */
            uint32            : 1;
      __IOM uint32 B2BSTUP    : 1;            /*!< [6..6] Back-to-back SETUP packets received                                */
            uint32            : 7;
      __IOM uint32 NYET       : 1;            /*!< [14..14] NYET interrupt                                                   */
            uint32            : 17;
    } bit;
  } OTG_HS_DOEPINT2;
  __IM  uint32  RESERVED31;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000350) OTG_HS device endpoint-2 transfer size register            */
    
    struct {
      __IOM uint32 XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32 PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32 RXDPID_STUPCNT : 2;        /*!< [30..29] Received data PID/SETUP packet count                             */
            uint32            : 1;
    } bit;
  } OTG_HS_DOEPTSIZ2;
  __IM  uint32  RESERVED32[3];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000360) OTG device endpoint-3 control register                     */
    
    struct {
      __IOM uint32 MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
            uint32            : 4;
      __IOM uint32 USBAEP     : 1;            /*!< [15..15] USB active endpoint                                              */
      __IM  uint32 EONUM_DPID : 1;            /*!< [16..16] Even odd frame/Endpoint data PID                                 */
      __IM  uint32 NAKSTS     : 1;            /*!< [17..17] NAK status                                                       */
      __IOM uint32 EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32 SNPM       : 1;            /*!< [20..20] Snoop mode                                                       */
      __IOM uint32 Stall      : 1;            /*!< [21..21] STALL handshake                                                  */
            uint32            : 4;
      __OM  uint32 CNAK       : 1;            /*!< [26..26] Clear NAK                                                        */
      __OM  uint32 SNAK       : 1;            /*!< [27..27] Set NAK                                                          */
      __OM  uint32 SD0PID_SEVNFRM : 1;        /*!< [28..28] Set DATA0 PID/Set even frame                                     */
      __OM  uint32 SODDFRM    : 1;            /*!< [29..29] Set odd frame                                                    */
      __IOM uint32 EPDIS      : 1;            /*!< [30..30] Endpoint disable                                                 */
      __IOM uint32 EPENA      : 1;            /*!< [31..31] Endpoint enable                                                  */
    } bit;
  } OTG_HS_DOEPCTL3;
  __IM  uint32  RESERVED33;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000368) OTG_HS device endpoint-3 interrupt register                */
    
    struct {
      __IOM uint32 XFRC       : 1;            /*!< [0..0] Transfer completed interrupt                                       */
      __IOM uint32 EPDISD     : 1;            /*!< [1..1] Endpoint disabled interrupt                                        */
            uint32            : 1;
      __IOM uint32 STUP       : 1;            /*!< [3..3] SETUP phase done                                                   */
      __IOM uint32 OTEPDIS    : 1;            /*!< [4..4] OUT token received when endpoint disabled                          */
            uint32            : 1;
      __IOM uint32 B2BSTUP    : 1;            /*!< [6..6] Back-to-back SETUP packets received                                */
            uint32            : 7;
      __IOM uint32 NYET       : 1;            /*!< [14..14] NYET interrupt                                                   */
            uint32            : 17;
    } bit;
  } OTG_HS_DOEPINT3;
  __IM  uint32  RESERVED34;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000370) OTG_HS device endpoint-3 transfer size register            */
    
    struct {
      __IOM uint32 XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32 PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32 RXDPID_STUPCNT : 2;        /*!< [30..29] Received data PID/SETUP packet count                             */
            uint32            : 1;
    } bit;
  } OTG_HS_DOEPTSIZ3;
  __IM  uint32  RESERVED35[3];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000380) OTG device endpoint-4 control register                     */
    
    struct {
      __IOM uint32 MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
            uint32            : 4;
      __IOM uint32 USBAEP     : 1;            /*!< [15..15] USB active endpoint                                              */
      __IM  uint32 EONUM_DPID : 1;            /*!< [16..16] Even odd frame/Endpoint data PID                                 */
      __IM  uint32 NAKSTS     : 1;            /*!< [17..17] NAK status                                                       */
      __IOM uint32 EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32 SNPM       : 1;            /*!< [20..20] Snoop mode                                                       */
      __IOM uint32 Stall      : 1;            /*!< [21..21] STALL handshake                                                  */
            uint32            : 4;
      __OM  uint32 CNAK       : 1;            /*!< [26..26] Clear NAK                                                        */
      __OM  uint32 SNAK       : 1;            /*!< [27..27] Set NAK                                                          */
      __OM  uint32 SD0PID_SEVNFRM : 1;        /*!< [28..28] Set DATA0 PID/Set even frame                                     */
      __OM  uint32 SODDFRM    : 1;            /*!< [29..29] Set odd frame                                                    */
      __IOM uint32 EPDIS      : 1;            /*!< [30..30] Endpoint disable                                                 */
      __IOM uint32 EPENA      : 1;            /*!< [31..31] Endpoint enable                                                  */
    } bit;
  } OTG_HS_DOEPCTL4;
  __IM  uint32  RESERVED36;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000388) OTG_HS device endpoint-4 interrupt register                */
    
    struct {
      __IOM uint32 XFRC       : 1;            /*!< [0..0] Transfer completed interrupt                                       */
      __IOM uint32 EPDISD     : 1;            /*!< [1..1] Endpoint disabled interrupt                                        */
            uint32            : 1;
      __IOM uint32 STUP       : 1;            /*!< [3..3] SETUP phase done                                                   */
      __IOM uint32 OTEPDIS    : 1;            /*!< [4..4] OUT token received when endpoint disabled                          */
            uint32            : 1;
      __IOM uint32 B2BSTUP    : 1;            /*!< [6..6] Back-to-back SETUP packets received                                */
            uint32            : 7;
      __IOM uint32 NYET       : 1;            /*!< [14..14] NYET interrupt                                                   */
            uint32            : 17;
    } bit;
  } OTG_HS_DOEPINT4;
  __IM  uint32  RESERVED37;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000390) OTG_HS device endpoint-4 transfer size register            */
    
    struct {
      __IOM uint32 XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32 PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32 RXDPID_STUPCNT : 2;        /*!< [30..29] Received data PID/SETUP packet count                             */
            uint32            : 1;
    } bit;
  } OTG_HS_DOEPTSIZ4;
  __IM  uint32  RESERVED38[3];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000003A0) OTG device endpoint-5 control register                     */
    
    struct {
      __IOM uint32 MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
            uint32            : 4;
      __IOM uint32 USBAEP     : 1;            /*!< [15..15] USB active endpoint                                              */
      __IM  uint32 EONUM_DPID : 1;            /*!< [16..16] Even odd frame/Endpoint data PID                                 */
      __IM  uint32 NAKSTS     : 1;            /*!< [17..17] NAK status                                                       */
      __IOM uint32 EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32 SNPM       : 1;            /*!< [20..20] Snoop mode                                                       */
      __IOM uint32 Stall      : 1;            /*!< [21..21] STALL handshake                                                  */
            uint32            : 4;
      __OM  uint32 CNAK       : 1;            /*!< [26..26] Clear NAK                                                        */
      __OM  uint32 SNAK       : 1;            /*!< [27..27] Set NAK                                                          */
      __OM  uint32 SD0PID_SEVNFRM : 1;        /*!< [28..28] Set DATA0 PID/Set even frame                                     */
      __OM  uint32 SODDFRM    : 1;            /*!< [29..29] Set odd frame                                                    */
      __IOM uint32 EPDIS      : 1;            /*!< [30..30] Endpoint disable                                                 */
      __IOM uint32 EPENA      : 1;            /*!< [31..31] Endpoint enable                                                  */
    } bit;
  } OTG_HS_DOEPCTL5;
  __IM  uint32  RESERVED39;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000003A8) OTG_HS device endpoint-5 interrupt register                */
    
    struct {
      __IOM uint32 XFRC       : 1;            /*!< [0..0] Transfer completed interrupt                                       */
      __IOM uint32 EPDISD     : 1;            /*!< [1..1] Endpoint disabled interrupt                                        */
            uint32            : 1;
      __IOM uint32 STUP       : 1;            /*!< [3..3] SETUP phase done                                                   */
      __IOM uint32 OTEPDIS    : 1;            /*!< [4..4] OUT token received when endpoint disabled                          */
            uint32            : 1;
      __IOM uint32 B2BSTUP    : 1;            /*!< [6..6] Back-to-back SETUP packets received                                */
            uint32            : 7;
      __IOM uint32 NYET       : 1;            /*!< [14..14] NYET interrupt                                                   */
            uint32            : 17;
    } bit;
  } OTG_HS_DOEPINT5;
  __IM  uint32  RESERVED40;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000003B0) OTG_HS device endpoint-5 transfer size register            */
    
    struct {
      __IOM uint32 XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32 PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32 RXDPID_STUPCNT : 2;        /*!< [30..29] Received data PID/SETUP packet count                             */
            uint32            : 1;
    } bit;
  } OTG_HS_DOEPTSIZ5;
  __IM  uint32  RESERVED41[3];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000003C0) OTG device endpoint-6 control register                     */
    
    struct {
      __IOM uint32 MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
            uint32            : 4;
      __IOM uint32 USBAEP     : 1;            /*!< [15..15] USB active endpoint                                              */
      __IM  uint32 EONUM_DPID : 1;            /*!< [16..16] Even odd frame/Endpoint data PID                                 */
      __IM  uint32 NAKSTS     : 1;            /*!< [17..17] NAK status                                                       */
      __IOM uint32 EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32 SNPM       : 1;            /*!< [20..20] Snoop mode                                                       */
      __IOM uint32 Stall      : 1;            /*!< [21..21] STALL handshake                                                  */
            uint32            : 4;
      __OM  uint32 CNAK       : 1;            /*!< [26..26] Clear NAK                                                        */
      __OM  uint32 SNAK       : 1;            /*!< [27..27] Set NAK                                                          */
      __OM  uint32 SD0PID_SEVNFRM : 1;        /*!< [28..28] Set DATA0 PID/Set even frame                                     */
      __OM  uint32 SODDFRM    : 1;            /*!< [29..29] Set odd frame                                                    */
      __IOM uint32 EPDIS      : 1;            /*!< [30..30] Endpoint disable                                                 */
      __IOM uint32 EPENA      : 1;            /*!< [31..31] Endpoint enable                                                  */
    } bit;
  } OTG_HS_DOEPCTL6;
  __IM  uint32  RESERVED42;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000003C8) OTG_HS device endpoint-6 interrupt register                */
    
    struct {
      __IOM uint32 XFRC       : 1;            /*!< [0..0] Transfer completed interrupt                                       */
      __IOM uint32 EPDISD     : 1;            /*!< [1..1] Endpoint disabled interrupt                                        */
            uint32            : 1;
      __IOM uint32 STUP       : 1;            /*!< [3..3] SETUP phase done                                                   */
      __IOM uint32 OTEPDIS    : 1;            /*!< [4..4] OUT token received when endpoint disabled                          */
            uint32            : 1;
      __IOM uint32 B2BSTUP    : 1;            /*!< [6..6] Back-to-back SETUP packets received                                */
            uint32            : 7;
      __IOM uint32 NYET       : 1;            /*!< [14..14] NYET interrupt                                                   */
            uint32            : 17;
    } bit;
  } OTG_HS_DOEPINT6;
  __IM  uint32  RESERVED43;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000003D0) OTG_HS device endpoint-6 transfer size register            */
    
    struct {
      __IOM uint32 XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32 PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32 RXDPID_STUPCNT : 2;        /*!< [30..29] Received data PID/SETUP packet count                             */
            uint32            : 1;
    } bit;
  } OTG_HS_DOEPTSIZ6;
  __IM  uint32  RESERVED44[3];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000003E0) OTG device endpoint-7 control register                     */
    
    struct {
      __IOM uint32 MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
            uint32            : 4;
      __IOM uint32 USBAEP     : 1;            /*!< [15..15] USB active endpoint                                              */
      __IM  uint32 EONUM_DPID : 1;            /*!< [16..16] Even odd frame/Endpoint data PID                                 */
      __IM  uint32 NAKSTS     : 1;            /*!< [17..17] NAK status                                                       */
      __IOM uint32 EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32 SNPM       : 1;            /*!< [20..20] Snoop mode                                                       */
      __IOM uint32 Stall      : 1;            /*!< [21..21] STALL handshake                                                  */
            uint32            : 4;
      __OM  uint32 CNAK       : 1;            /*!< [26..26] Clear NAK                                                        */
      __OM  uint32 SNAK       : 1;            /*!< [27..27] Set NAK                                                          */
      __OM  uint32 SD0PID_SEVNFRM : 1;        /*!< [28..28] Set DATA0 PID/Set even frame                                     */
      __OM  uint32 SODDFRM    : 1;            /*!< [29..29] Set odd frame                                                    */
      __IOM uint32 EPDIS      : 1;            /*!< [30..30] Endpoint disable                                                 */
      __IOM uint32 EPENA      : 1;            /*!< [31..31] Endpoint enable                                                  */
    } bit;
  } OTG_HS_DOEPCTL7;
  __IM  uint32  RESERVED45;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000003E8) OTG_HS device endpoint-7 interrupt register                */
    
    struct {
      __IOM uint32 XFRC       : 1;            /*!< [0..0] Transfer completed interrupt                                       */
      __IOM uint32 EPDISD     : 1;            /*!< [1..1] Endpoint disabled interrupt                                        */
            uint32            : 1;
      __IOM uint32 STUP       : 1;            /*!< [3..3] SETUP phase done                                                   */
      __IOM uint32 OTEPDIS    : 1;            /*!< [4..4] OUT token received when endpoint disabled                          */
            uint32            : 1;
      __IOM uint32 B2BSTUP    : 1;            /*!< [6..6] Back-to-back SETUP packets received                                */
            uint32            : 7;
      __IOM uint32 NYET       : 1;            /*!< [14..14] NYET interrupt                                                   */
            uint32            : 17;
    } bit;
  } OTG_HS_DOEPINT7;
  __IM  uint32  RESERVED46;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000003F0) OTG_HS device endpoint-7 transfer size register            */
    
    struct {
      __IOM uint32 XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32 PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32 RXDPID_STUPCNT : 2;        /*!< [30..29] Received data PID/SETUP packet count                             */
            uint32            : 1;
    } bit;
  } OTG_HS_DOEPTSIZ7;
} OTG1_HS_DEVICE_Type;                          /*!< Size = 1012 (0x3f4)                                                       */



/* =========================================================================================================================== */
/* ================                                      OTG1_HS_PWRCLK                                       ================ */
/* =========================================================================================================================== */


/**
  * @brief USB 1 on the go high speed (OTG1_HS_PWRCLK)
  */

typedef struct {                                /*!< (@ 0x40040E00) OTG1_HS_PWRCLK Structure                                   */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) Power and clock gating control register                    */
    
    struct {
      __IOM uint32 STPPCLK    : 1;            /*!< [0..0] Stop PHY clock                                                     */
      __IOM uint32 GATEHCLK   : 1;            /*!< [1..1] Gate HCLK                                                          */
            uint32            : 2;
      __IOM uint32 PHYSUSP    : 1;            /*!< [4..4] PHY suspended                                                      */
            uint32            : 27;
    } bit;
  } OTG_HS_PCGCR;
} OTG1_HS_PWRCLK_Type;                          /*!< Size = 4 (0x4)                                                            */



/* =========================================================================================================================== */
/* ================                                       Ethernet_MAC                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief Ethernet: media access control
      (MAC) (Ethernet_MAC)
  */

typedef struct {                                /*!< (@ 0x40028000) Ethernet_MAC Structure                                     */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) DMA mode register                                          */
    
    struct {
      __IOM uint32 SWR        : 1;            /*!< [0..0] Software Reset                                                     */
      __IOM uint32 DA         : 1;            /*!< [1..1] DMA Tx or Rx Arbitration Scheme                                    */
            uint32            : 9;
      __IOM uint32 TXPR       : 1;            /*!< [11..11] Transmit priority                                                */
      __IOM uint32 PR         : 3;            /*!< [14..12] Priority ratio                                                   */
            uint32            : 1;
      __IOM uint32 INTM       : 1;            /*!< [16..16] Interrupt Mode                                                   */
            uint32            : 15;
    } bit;
  } DMAMR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) System bus mode register                                   */
    
    struct {
      __IOM uint32 FB         : 1;            /*!< [0..0] Fixed Burst Length                                                 */
            uint32            : 11;
      __IOM uint32 AAL        : 1;            /*!< [12..12] Address-Aligned Beats                                            */
            uint32            : 1;
      __IOM uint32 MB         : 1;            /*!< [14..14] Mixed Burst                                                      */
      __IOM uint32 RB         : 1;            /*!< [15..15] Rebuild INCRx Burst                                              */
            uint32            : 16;
    } bit;
  } DMASBMR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) Interrupt status register                                  */
    
    struct {
      __IOM uint32 DC0IS      : 1;            /*!< [0..0] DMA Channel Interrupt Status                                       */
            uint32            : 15;
      __IOM uint32 MTLIS      : 1;            /*!< [16..16] MTL Interrupt Status                                             */
      __IOM uint32 MACIS      : 1;            /*!< [17..17] MAC Interrupt Status                                             */
            uint32            : 14;
    } bit;
  } DMAISR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) Debug status register                                      */
    
    struct {
      __IOM uint32 AXWHSTS    : 1;            /*!< [0..0] AHB Master Write Channel                                           */
            uint32            : 7;
      __IOM uint32 RPS0       : 4;            /*!< [11..8] DMA Channel Receive Process State                                 */
      __IOM uint32 TPS0       : 4;            /*!< [15..12] DMA Channel Transmit Process State                               */
            uint32            : 16;
    } bit;
  } DMADSR;
  __IM  uint32  RESERVED[60];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000100) Channel control register                                   */
    
    struct {
      __IOM uint32 MSS        : 14;           /*!< [13..0] Maximum Segment Size                                              */
            uint32            : 2;
      __IOM uint32 PBLX8      : 1;            /*!< [16..16] 8xPBL mode                                                       */
            uint32            : 1;
      __IOM uint32 DSL        : 3;            /*!< [20..18] Descriptor Skip Length                                           */
            uint32            : 11;
    } bit;
  } DMACCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000104) Channel transmit control register                          */
    
    struct {
      __IOM uint32 ST         : 1;            /*!< [0..0] Start or Stop Transmission Command                                 */
            uint32            : 3;
      __IOM uint32 OSF        : 1;            /*!< [4..4] Operate on Second Packet                                           */
            uint32            : 7;
      __IOM uint32 TSE        : 1;            /*!< [12..12] TCP Segmentation Enabled                                         */
            uint32            : 3;
      __IOM uint32 TXPBL      : 6;            /*!< [21..16] Transmit Programmable Burst Length                               */
            uint32            : 10;
    } bit;
  } DMACTxCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000108) Channel receive control register                           */
    
    struct {
      __IOM uint32 SR         : 1;            /*!< [0..0] Start or Stop Receive Command                                      */
      __IOM uint32 RBSZ       : 14;           /*!< [14..1] Receive Buffer size                                               */
            uint32            : 1;
      __IOM uint32 RXPBL      : 6;            /*!< [21..16] RXPBL                                                            */
            uint32            : 9;
      __IOM uint32 RPF        : 1;            /*!< [31..31] DMA Rx Channel Packet Flush                                      */
    } bit;
  } DMACRxCR;
  __IM  uint32  RESERVED1[2];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000114) Channel Tx descriptor list address register                */
    
    struct {
            uint32            : 2;
      __IOM uint32 TDESLA     : 30;           /*!< [31..2] Start of Transmit List                                            */
    } bit;
  } DMACTxDLAR;
  __IM  uint32  RESERVED2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000011C) Channel Rx descriptor list address register                */
    
    struct {
            uint32            : 2;
      __IOM uint32 RDESLA     : 30;           /*!< [31..2] Start of Receive List                                             */
    } bit;
  } DMACRxDLAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000120) Channel Tx descriptor tail pointer register                */
    
    struct {
            uint32            : 2;
      __IOM uint32 TDT        : 30;           /*!< [31..2] Transmit Descriptor Tail Pointer                                  */
    } bit;
  } DMACTxDTPR;
  __IM  uint32  RESERVED3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000128) Channel Rx descriptor tail pointer register                */
    
    struct {
            uint32            : 2;
      __IOM uint32 RDT        : 30;           /*!< [31..2] Receive Descriptor Tail Pointer                                   */
    } bit;
  } DMACRxDTPR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000012C) Channel Tx descriptor ring length register                 */
    
    struct {
      __IOM uint32 TDRL       : 10;           /*!< [9..0] Transmit Descriptor Ring Length                                    */
            uint32            : 22;
    } bit;
  } DMACTxRLR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000130) Channel Rx descriptor ring length register                 */
    
    struct {
      __IOM uint32 RDRL       : 10;           /*!< [9..0] Receive Descriptor Ring Length                                     */
            uint32            : 22;
    } bit;
  } DMACRxRLR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000134) Channel interrupt enable register                          */
    
    struct {
      __IOM uint32 TIE        : 1;            /*!< [0..0] Transmit Interrupt Enable                                          */
      __IOM uint32 TXSE       : 1;            /*!< [1..1] Transmit Stopped Enable                                            */
      __IOM uint32 TBUE       : 1;            /*!< [2..2] Transmit Buffer Unavailable Enable                                 */
            uint32            : 3;
      __IOM uint32 RIE        : 1;            /*!< [6..6] Receive Interrupt Enable                                           */
      __IOM uint32 RBUE       : 1;            /*!< [7..7] Receive Buffer Unavailable Enable                                  */
      __IOM uint32 RSE        : 1;            /*!< [8..8] Receive Stopped Enable                                             */
      __IOM uint32 RWTE       : 1;            /*!< [9..9] Receive Watchdog Timeout Enable                                    */
      __IOM uint32 ETIE       : 1;            /*!< [10..10] Early Transmit Interrupt Enable                                  */
      __IOM uint32 ERIE       : 1;            /*!< [11..11] Early Receive Interrupt Enable                                   */
      __IOM uint32 FBEE       : 1;            /*!< [12..12] Fatal Bus Error Enable                                           */
      __IOM uint32 CDEE       : 1;            /*!< [13..13] Context Descriptor Error Enable                                  */
      __IOM uint32 AIE        : 1;            /*!< [14..14] Abnormal Interrupt Summary Enable                                */
      __IOM uint32 NIE        : 1;            /*!< [15..15] Normal Interrupt Summary Enable                                  */
            uint32            : 16;
    } bit;
  } DMACIER;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000138) Channel Rx interrupt watchdog timer register               */
    
    struct {
      __IOM uint32 RWT        : 8;            /*!< [7..0] Receive Interrupt Watchdog Timer Count                             */
            uint32            : 24;
    } bit;
  } DMACRxIWTR;
  __IM  uint32  RESERVED4[2];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000144) Channel current application transmit descriptor
                                                                    register                                                   */
    
    struct {
      __IOM uint32 CURTDESAPTR : 32;          /*!< [31..0] Application Transmit Descriptor Address Pointer                   */
    } bit;
  } DMACCATxDR;
  __IM  uint32  RESERVED5;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000014C) Channel current application receive descriptor
                                                                    register                                                   */
    
    struct {
      __IOM uint32 CURRDESAPTR : 32;          /*!< [31..0] Application Receive Descriptor Address Pointer                    */
    } bit;
  } DMACCARxDR;
  __IM  uint32  RESERVED6;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000154) Channel current application transmit buffer register       */
    
    struct {
      __IOM uint32 CURTBUFAPTR : 32;          /*!< [31..0] Application Transmit Buffer Address Pointer                       */
    } bit;
  } DMACCATxBR;
  __IM  uint32  RESERVED7;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000015C) Channel current application receive buffer register        */
    
    struct {
      __IOM uint32 CURRBUFAPTR : 32;          /*!< [31..0] Application Receive Buffer Address Pointer                        */
    } bit;
  } DMACCARxBR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000160) Channel status register                                    */
    
    struct {
      __IOM uint32 TI         : 1;            /*!< [0..0] Transmit Interrupt                                                 */
      __IOM uint32 TPS        : 1;            /*!< [1..1] Transmit Process Stopped                                           */
      __IOM uint32 TBU        : 1;            /*!< [2..2] Transmit Buffer Unavailable                                        */
            uint32            : 3;
      __IOM uint32 RI         : 1;            /*!< [6..6] Receive Interrupt                                                  */
      __IOM uint32 RBU        : 1;            /*!< [7..7] Receive Buffer Unavailable                                         */
      __IOM uint32 RPS        : 1;            /*!< [8..8] Receive Process Stopped                                            */
      __IOM uint32 RWT        : 1;            /*!< [9..9] Receive Watchdog Timeout                                           */
      __IOM uint32 ET         : 1;            /*!< [10..10] Early Transmit Interrupt                                         */
      __IOM uint32 ER         : 1;            /*!< [11..11] Early Receive Interrupt                                          */
      __IOM uint32 FBE        : 1;            /*!< [12..12] Fatal Bus Error                                                  */
      __IOM uint32 CDE        : 1;            /*!< [13..13] Context Descriptor Error                                         */
      __IOM uint32 AIS        : 1;            /*!< [14..14] Abnormal Interrupt Summary                                       */
      __IOM uint32 NIS        : 1;            /*!< [15..15] Normal Interrupt Summary                                         */
      __IOM uint32 TEB        : 3;            /*!< [18..16] Tx DMA Error Bits                                                */
      __IOM uint32 REB        : 3;            /*!< [21..19] Rx DMA Error Bits                                                */
            uint32            : 10;
    } bit;
  } DMACSR;
  __IM  uint32  RESERVED8[2];
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000016C) Channel missed frame count register                        */
    
    struct {
      __IM  uint32 MFC        : 11;           /*!< [10..0] Dropped Packet Counters                                           */
            uint32            : 4;
      __IM  uint32 MFCO       : 1;            /*!< [15..15] Overflow status of the MFC Counter                               */
            uint32            : 16;
    } bit;
  } DMACMFCR;
} Ethernet_MAC_Type;                            /*!< Size = 368 (0x170)                                                        */



/* =========================================================================================================================== */
/* ================                                           DMA1                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief DMA controller (DMA1)
  */

typedef struct {                                /*!< (@ 0x40020000) DMA1 Structure                                             */
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000000) low interrupt status register                              */
    
    struct {
      __IM  uint32 FEIF0      : 1;            /*!< [0..0] Stream x FIFO error interrupt flag (x=3..0)                        */
            uint32            : 1;
      __IM  uint32 DMEIF0     : 1;            /*!< [2..2] Stream x direct mode error interrupt flag (x=3..0)                 */
      __IM  uint32 TEIF0      : 1;            /*!< [3..3] Stream x transfer error interrupt flag (x=3..0)                    */
      __IM  uint32 HTIF0      : 1;            /*!< [4..4] Stream x half transfer interrupt flag (x=3..0)                     */
      __IM  uint32 TCIF0      : 1;            /*!< [5..5] Stream x transfer complete interrupt flag (x = 3..0)               */
      __IM  uint32 FEIF1      : 1;            /*!< [6..6] Stream x FIFO error interrupt flag (x=3..0)                        */
            uint32            : 1;
      __IM  uint32 DMEIF1     : 1;            /*!< [8..8] Stream x direct mode error interrupt flag (x=3..0)                 */
      __IM  uint32 TEIF1      : 1;            /*!< [9..9] Stream x transfer error interrupt flag (x=3..0)                    */
      __IM  uint32 HTIF1      : 1;            /*!< [10..10] Stream x half transfer interrupt flag (x=3..0)                   */
      __IM  uint32 TCIF1      : 1;            /*!< [11..11] Stream x transfer complete interrupt flag (x = 3..0)             */
            uint32            : 4;
      __IM  uint32 FEIF2      : 1;            /*!< [16..16] Stream x FIFO error interrupt flag (x=3..0)                      */
            uint32            : 1;
      __IM  uint32 DMEIF2     : 1;            /*!< [18..18] Stream x direct mode error interrupt flag (x=3..0)               */
      __IM  uint32 TEIF2      : 1;            /*!< [19..19] Stream x transfer error interrupt flag (x=3..0)                  */
      __IM  uint32 HTIF2      : 1;            /*!< [20..20] Stream x half transfer interrupt flag (x=3..0)                   */
      __IM  uint32 TCIF2      : 1;            /*!< [21..21] Stream x transfer complete interrupt flag (x = 3..0)             */
      __IM  uint32 FEIF3      : 1;            /*!< [22..22] Stream x FIFO error interrupt flag (x=3..0)                      */
            uint32            : 1;
      __IM  uint32 DMEIF3     : 1;            /*!< [24..24] Stream x direct mode error interrupt flag (x=3..0)               */
      __IM  uint32 TEIF3      : 1;            /*!< [25..25] Stream x transfer error interrupt flag (x=3..0)                  */
      __IM  uint32 HTIF3      : 1;            /*!< [26..26] Stream x half transfer interrupt flag (x=3..0)                   */
      __IM  uint32 TCIF3      : 1;            /*!< [27..27] Stream x transfer complete interrupt flag (x = 3..0)             */
            uint32            : 4;
    } bit;
  } LISR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000004) high interrupt status register                             */
    
    struct {
      __IM  uint32 FEIF4      : 1;            /*!< [0..0] Stream x FIFO error interrupt flag (x=7..4)                        */
            uint32            : 1;
      __IM  uint32 DMEIF4     : 1;            /*!< [2..2] Stream x direct mode error interrupt flag (x=7..4)                 */
      __IM  uint32 TEIF4      : 1;            /*!< [3..3] Stream x transfer error interrupt flag (x=7..4)                    */
      __IM  uint32 HTIF4      : 1;            /*!< [4..4] Stream x half transfer interrupt flag (x=7..4)                     */
      __IM  uint32 TCIF4      : 1;            /*!< [5..5] Stream x transfer complete interrupt flag (x=7..4)                 */
      __IM  uint32 FEIF5      : 1;            /*!< [6..6] Stream x FIFO error interrupt flag (x=7..4)                        */
            uint32            : 1;
      __IM  uint32 DMEIF5     : 1;            /*!< [8..8] Stream x direct mode error interrupt flag (x=7..4)                 */
      __IM  uint32 TEIF5      : 1;            /*!< [9..9] Stream x transfer error interrupt flag (x=7..4)                    */
      __IM  uint32 HTIF5      : 1;            /*!< [10..10] Stream x half transfer interrupt flag (x=7..4)                   */
      __IM  uint32 TCIF5      : 1;            /*!< [11..11] Stream x transfer complete interrupt flag (x=7..4)               */
            uint32            : 4;
      __IM  uint32 FEIF6      : 1;            /*!< [16..16] Stream x FIFO error interrupt flag (x=7..4)                      */
            uint32            : 1;
      __IM  uint32 DMEIF6     : 1;            /*!< [18..18] Stream x direct mode error interrupt flag (x=7..4)               */
      __IM  uint32 TEIF6      : 1;            /*!< [19..19] Stream x transfer error interrupt flag (x=7..4)                  */
      __IM  uint32 HTIF6      : 1;            /*!< [20..20] Stream x half transfer interrupt flag (x=7..4)                   */
      __IM  uint32 TCIF6      : 1;            /*!< [21..21] Stream x transfer complete interrupt flag (x=7..4)               */
      __IM  uint32 FEIF7      : 1;            /*!< [22..22] Stream x FIFO error interrupt flag (x=7..4)                      */
            uint32            : 1;
      __IM  uint32 DMEIF7     : 1;            /*!< [24..24] Stream x direct mode error interrupt flag (x=7..4)               */
      __IM  uint32 TEIF7      : 1;            /*!< [25..25] Stream x transfer error interrupt flag (x=7..4)                  */
      __IM  uint32 HTIF7      : 1;            /*!< [26..26] Stream x half transfer interrupt flag (x=7..4)                   */
      __IM  uint32 TCIF7      : 1;            /*!< [27..27] Stream x transfer complete interrupt flag (x=7..4)               */
            uint32            : 4;
    } bit;
  } HISR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) low interrupt flag clear register                          */
    
    struct {
      __IOM uint32 CFEIF0     : 1;            /*!< [0..0] Stream x clear FIFO error interrupt flag (x = 3..0)                */
            uint32            : 1;
      __IOM uint32 CDMEIF0    : 1;            /*!< [2..2] Stream x clear direct mode error interrupt flag (x =
                                                     3..0)                                                                     */
      __IOM uint32 CTEIF0     : 1;            /*!< [3..3] Stream x clear transfer error interrupt flag (x = 3..0)            */
      __IOM uint32 CHTIF0     : 1;            /*!< [4..4] Stream x clear half transfer interrupt flag (x = 3..0)             */
      __IOM uint32 CTCIF0     : 1;            /*!< [5..5] Stream x clear transfer complete interrupt flag (x =
                                                     3..0)                                                                     */
      __IOM uint32 CFEIF1     : 1;            /*!< [6..6] Stream x clear FIFO error interrupt flag (x = 3..0)                */
            uint32            : 1;
      __IOM uint32 CDMEIF1    : 1;            /*!< [8..8] Stream x clear direct mode error interrupt flag (x =
                                                     3..0)                                                                     */
      __IOM uint32 CTEIF1     : 1;            /*!< [9..9] Stream x clear transfer error interrupt flag (x = 3..0)            */
      __IOM uint32 CHTIF1     : 1;            /*!< [10..10] Stream x clear half transfer interrupt flag (x = 3..0)           */
      __IOM uint32 CTCIF1     : 1;            /*!< [11..11] Stream x clear transfer complete interrupt flag (x
                                                     = 3..0)                                                                   */
            uint32            : 4;
      __IOM uint32 CFEIF2     : 1;            /*!< [16..16] Stream x clear FIFO error interrupt flag (x = 3..0)              */
            uint32            : 1;
      __IOM uint32 CDMEIF2    : 1;            /*!< [18..18] Stream x clear direct mode error interrupt flag (x
                                                     = 3..0)                                                                   */
      __IOM uint32 CTEIF2     : 1;            /*!< [19..19] Stream x clear transfer error interrupt flag (x = 3..0)          */
      __IOM uint32 CHTIF2     : 1;            /*!< [20..20] Stream x clear half transfer interrupt flag (x = 3..0)           */
      __IOM uint32 CTCIF2     : 1;            /*!< [21..21] Stream x clear transfer complete interrupt flag (x
                                                     = 3..0)                                                                   */
      __IOM uint32 CFEIF3     : 1;            /*!< [22..22] Stream x clear FIFO error interrupt flag (x = 3..0)              */
            uint32            : 1;
      __IOM uint32 CDMEIF3    : 1;            /*!< [24..24] Stream x clear direct mode error interrupt flag (x
                                                     = 3..0)                                                                   */
      __IOM uint32 CTEIF3     : 1;            /*!< [25..25] Stream x clear transfer error interrupt flag (x = 3..0)          */
      __IOM uint32 CHTIF3     : 1;            /*!< [26..26] Stream x clear half transfer interrupt flag (x = 3..0)           */
      __IOM uint32 CTCIF3     : 1;            /*!< [27..27] Stream x clear transfer complete interrupt flag (x
                                                     = 3..0)                                                                   */
            uint32            : 4;
    } bit;
  } LIFCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) high interrupt flag clear register                         */
    
    struct {
      __IOM uint32 CFEIF4     : 1;            /*!< [0..0] Stream x clear FIFO error interrupt flag (x = 7..4)                */
            uint32            : 1;
      __IOM uint32 CDMEIF4    : 1;            /*!< [2..2] Stream x clear direct mode error interrupt flag (x =
                                                     7..4)                                                                     */
      __IOM uint32 CTEIF4     : 1;            /*!< [3..3] Stream x clear transfer error interrupt flag (x = 7..4)            */
      __IOM uint32 CHTIF4     : 1;            /*!< [4..4] Stream x clear half transfer interrupt flag (x = 7..4)             */
      __IOM uint32 CTCIF4     : 1;            /*!< [5..5] Stream x clear transfer complete interrupt flag (x =
                                                     7..4)                                                                     */
      __IOM uint32 CFEIF5     : 1;            /*!< [6..6] Stream x clear FIFO error interrupt flag (x = 7..4)                */
            uint32            : 1;
      __IOM uint32 CDMEIF5    : 1;            /*!< [8..8] Stream x clear direct mode error interrupt flag (x =
                                                     7..4)                                                                     */
      __IOM uint32 CTEIF5     : 1;            /*!< [9..9] Stream x clear transfer error interrupt flag (x = 7..4)            */
      __IOM uint32 CHTIF5     : 1;            /*!< [10..10] Stream x clear half transfer interrupt flag (x = 7..4)           */
      __IOM uint32 CTCIF5     : 1;            /*!< [11..11] Stream x clear transfer complete interrupt flag (x
                                                     = 7..4)                                                                   */
            uint32            : 4;
      __IOM uint32 CFEIF6     : 1;            /*!< [16..16] Stream x clear FIFO error interrupt flag (x = 7..4)              */
            uint32            : 1;
      __IOM uint32 CDMEIF6    : 1;            /*!< [18..18] Stream x clear direct mode error interrupt flag (x
                                                     = 7..4)                                                                   */
      __IOM uint32 CTEIF6     : 1;            /*!< [19..19] Stream x clear transfer error interrupt flag (x = 7..4)          */
      __IOM uint32 CHTIF6     : 1;            /*!< [20..20] Stream x clear half transfer interrupt flag (x = 7..4)           */
      __IOM uint32 CTCIF6     : 1;            /*!< [21..21] Stream x clear transfer complete interrupt flag (x
                                                     = 7..4)                                                                   */
      __IOM uint32 CFEIF7     : 1;            /*!< [22..22] Stream x clear FIFO error interrupt flag (x = 7..4)              */
            uint32            : 1;
      __IOM uint32 CDMEIF7    : 1;            /*!< [24..24] Stream x clear direct mode error interrupt flag (x
                                                     = 7..4)                                                                   */
      __IOM uint32 CTEIF7     : 1;            /*!< [25..25] Stream x clear transfer error interrupt flag (x = 7..4)          */
      __IOM uint32 CHTIF7     : 1;            /*!< [26..26] Stream x clear half transfer interrupt flag (x = 7..4)           */
      __IOM uint32 CTCIF7     : 1;            /*!< [27..27] Stream x clear transfer complete interrupt flag (x
                                                     = 7..4)                                                                   */
            uint32            : 4;
    } bit;
  } HIFCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) stream x configuration register                            */
    
    struct {
      __IOM uint32 EN         : 1;            /*!< [0..0] Stream enable / flag stream ready when read low                    */
      __IOM uint32 DMEIE      : 1;            /*!< [1..1] Direct mode error interrupt enable                                 */
      __IOM uint32 TEIE       : 1;            /*!< [2..2] Transfer error interrupt enable                                    */
      __IOM uint32 HTIE       : 1;            /*!< [3..3] Half transfer interrupt enable                                     */
      __IOM uint32 TCIE       : 1;            /*!< [4..4] Transfer complete interrupt enable                                 */
      __IOM uint32 PFCTRL     : 1;            /*!< [5..5] Peripheral flow controller                                         */
      __IOM uint32 DIR        : 2;            /*!< [7..6] Data transfer direction                                            */
      __IOM uint32 CIRC       : 1;            /*!< [8..8] Circular mode                                                      */
      __IOM uint32 PINC       : 1;            /*!< [9..9] Peripheral increment mode                                          */
      __IOM uint32 MINC       : 1;            /*!< [10..10] Memory increment mode                                            */
      __IOM uint32 PSIZE      : 2;            /*!< [12..11] Peripheral data size                                             */
      __IOM uint32 MSIZE      : 2;            /*!< [14..13] Memory data size                                                 */
      __IOM uint32 PINCOS     : 1;            /*!< [15..15] Peripheral increment offset size                                 */
      __IOM uint32 PL         : 2;            /*!< [17..16] Priority level                                                   */
      __IOM uint32 DBM        : 1;            /*!< [18..18] Double buffer mode                                               */
      __IOM uint32 CT         : 1;            /*!< [19..19] Current target (only in double buffer mode)                      */
            uint32            : 1;
      __IOM uint32 PBURST     : 2;            /*!< [22..21] Peripheral burst transfer configuration                          */
      __IOM uint32 MBURST     : 2;            /*!< [24..23] Memory burst transfer configuration                              */
            uint32            : 7;
    } bit;
  } S0CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000014) stream x number of data register                           */
    
    struct {
      __IOM uint32 NDT        : 16;           /*!< [15..0] Number of data items to transfer                                  */
            uint32            : 16;
    } bit;
  } S0NDTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000018) stream x peripheral address register                       */
    
    struct {
      __IOM uint32 PA         : 32;           /*!< [31..0] Peripheral address                                                */
    } bit;
  } S0PAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000001C) stream x memory 0 address register                         */
    
    struct {
      __IOM uint32 M0A        : 32;           /*!< [31..0] Memory 0 address                                                  */
    } bit;
  } S0M0AR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000020) stream x memory 1 address register                         */
    
    struct {
      __IOM uint32 M1A        : 32;           /*!< [31..0] Memory 1 address (used in case of Double buffer mode)             */
    } bit;
  } S0M1AR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000024) stream x FIFO control register                             */
    
    struct {
      __IOM uint32 FTH        : 2;            /*!< [1..0] FIFO threshold selection                                           */
      __IOM uint32 DMDIS      : 1;            /*!< [2..2] Direct mode disable                                                */
      __IM  uint32 FS         : 3;            /*!< [5..3] FIFO status                                                        */
            uint32            : 1;
      __IOM uint32 FEIE       : 1;            /*!< [7..7] FIFO error interrupt enable                                        */
            uint32            : 24;
    } bit;
  } S0FCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000028) stream x configuration register                            */
    
    struct {
      __IOM uint32 EN         : 1;            /*!< [0..0] Stream enable / flag stream ready when read low                    */
      __IOM uint32 DMEIE      : 1;            /*!< [1..1] Direct mode error interrupt enable                                 */
      __IOM uint32 TEIE       : 1;            /*!< [2..2] Transfer error interrupt enable                                    */
      __IOM uint32 HTIE       : 1;            /*!< [3..3] Half transfer interrupt enable                                     */
      __IOM uint32 TCIE       : 1;            /*!< [4..4] Transfer complete interrupt enable                                 */
      __IOM uint32 PFCTRL     : 1;            /*!< [5..5] Peripheral flow controller                                         */
      __IOM uint32 DIR        : 2;            /*!< [7..6] Data transfer direction                                            */
      __IOM uint32 CIRC       : 1;            /*!< [8..8] Circular mode                                                      */
      __IOM uint32 PINC       : 1;            /*!< [9..9] Peripheral increment mode                                          */
      __IOM uint32 MINC       : 1;            /*!< [10..10] Memory increment mode                                            */
      __IOM uint32 PSIZE      : 2;            /*!< [12..11] Peripheral data size                                             */
      __IOM uint32 MSIZE      : 2;            /*!< [14..13] Memory data size                                                 */
      __IOM uint32 PINCOS     : 1;            /*!< [15..15] Peripheral increment offset size                                 */
      __IOM uint32 PL         : 2;            /*!< [17..16] Priority level                                                   */
      __IOM uint32 DBM        : 1;            /*!< [18..18] Double buffer mode                                               */
      __IOM uint32 CT         : 1;            /*!< [19..19] Current target (only in double buffer mode)                      */
      __IOM uint32 ACK        : 1;            /*!< [20..20] ACK                                                              */
      __IOM uint32 PBURST     : 2;            /*!< [22..21] Peripheral burst transfer configuration                          */
      __IOM uint32 MBURST     : 2;            /*!< [24..23] Memory burst transfer configuration                              */
            uint32            : 7;
    } bit;
  } S1CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000002C) stream x number of data register                           */
    
    struct {
      __IOM uint32 NDT        : 16;           /*!< [15..0] Number of data items to transfer                                  */
            uint32            : 16;
    } bit;
  } S1NDTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000030) stream x peripheral address register                       */
    
    struct {
      __IOM uint32 PA         : 32;           /*!< [31..0] Peripheral address                                                */
    } bit;
  } S1PAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000034) stream x memory 0 address register                         */
    
    struct {
      __IOM uint32 M0A        : 32;           /*!< [31..0] Memory 0 address                                                  */
    } bit;
  } S1M0AR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000038) stream x memory 1 address register                         */
    
    struct {
      __IOM uint32 M1A        : 32;           /*!< [31..0] Memory 1 address (used in case of Double buffer mode)             */
    } bit;
  } S1M1AR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000003C) stream x FIFO control register                             */
    
    struct {
      __IOM uint32 FTH        : 2;            /*!< [1..0] FIFO threshold selection                                           */
      __IOM uint32 DMDIS      : 1;            /*!< [2..2] Direct mode disable                                                */
      __IM  uint32 FS         : 3;            /*!< [5..3] FIFO status                                                        */
            uint32            : 1;
      __IOM uint32 FEIE       : 1;            /*!< [7..7] FIFO error interrupt enable                                        */
            uint32            : 24;
    } bit;
  } S1FCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000040) stream x configuration register                            */
    
    struct {
      __IOM uint32 EN         : 1;            /*!< [0..0] Stream enable / flag stream ready when read low                    */
      __IOM uint32 DMEIE      : 1;            /*!< [1..1] Direct mode error interrupt enable                                 */
      __IOM uint32 TEIE       : 1;            /*!< [2..2] Transfer error interrupt enable                                    */
      __IOM uint32 HTIE       : 1;            /*!< [3..3] Half transfer interrupt enable                                     */
      __IOM uint32 TCIE       : 1;            /*!< [4..4] Transfer complete interrupt enable                                 */
      __IOM uint32 PFCTRL     : 1;            /*!< [5..5] Peripheral flow controller                                         */
      __IOM uint32 DIR        : 2;            /*!< [7..6] Data transfer direction                                            */
      __IOM uint32 CIRC       : 1;            /*!< [8..8] Circular mode                                                      */
      __IOM uint32 PINC       : 1;            /*!< [9..9] Peripheral increment mode                                          */
      __IOM uint32 MINC       : 1;            /*!< [10..10] Memory increment mode                                            */
      __IOM uint32 PSIZE      : 2;            /*!< [12..11] Peripheral data size                                             */
      __IOM uint32 MSIZE      : 2;            /*!< [14..13] Memory data size                                                 */
      __IOM uint32 PINCOS     : 1;            /*!< [15..15] Peripheral increment offset size                                 */
      __IOM uint32 PL         : 2;            /*!< [17..16] Priority level                                                   */
      __IOM uint32 DBM        : 1;            /*!< [18..18] Double buffer mode                                               */
      __IOM uint32 CT         : 1;            /*!< [19..19] Current target (only in double buffer mode)                      */
      __IOM uint32 ACK        : 1;            /*!< [20..20] ACK                                                              */
      __IOM uint32 PBURST     : 2;            /*!< [22..21] Peripheral burst transfer configuration                          */
      __IOM uint32 MBURST     : 2;            /*!< [24..23] Memory burst transfer configuration                              */
            uint32            : 7;
    } bit;
  } S2CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000044) stream x number of data register                           */
    
    struct {
      __IOM uint32 NDT        : 16;           /*!< [15..0] Number of data items to transfer                                  */
            uint32            : 16;
    } bit;
  } S2NDTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000048) stream x peripheral address register                       */
    
    struct {
      __IOM uint32 PA         : 32;           /*!< [31..0] Peripheral address                                                */
    } bit;
  } S2PAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000004C) stream x memory 0 address register                         */
    
    struct {
      __IOM uint32 M0A        : 32;           /*!< [31..0] Memory 0 address                                                  */
    } bit;
  } S2M0AR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000050) stream x memory 1 address register                         */
    
    struct {
      __IOM uint32 M1A        : 32;           /*!< [31..0] Memory 1 address (used in case of Double buffer mode)             */
    } bit;
  } S2M1AR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000054) stream x FIFO control register                             */
    
    struct {
      __IOM uint32 FTH        : 2;            /*!< [1..0] FIFO threshold selection                                           */
      __IOM uint32 DMDIS      : 1;            /*!< [2..2] Direct mode disable                                                */
      __IM  uint32 FS         : 3;            /*!< [5..3] FIFO status                                                        */
            uint32            : 1;
      __IOM uint32 FEIE       : 1;            /*!< [7..7] FIFO error interrupt enable                                        */
            uint32            : 24;
    } bit;
  } S2FCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000058) stream x configuration register                            */
    
    struct {
      __IOM uint32 EN         : 1;            /*!< [0..0] Stream enable / flag stream ready when read low                    */
      __IOM uint32 DMEIE      : 1;            /*!< [1..1] Direct mode error interrupt enable                                 */
      __IOM uint32 TEIE       : 1;            /*!< [2..2] Transfer error interrupt enable                                    */
      __IOM uint32 HTIE       : 1;            /*!< [3..3] Half transfer interrupt enable                                     */
      __IOM uint32 TCIE       : 1;            /*!< [4..4] Transfer complete interrupt enable                                 */
      __IOM uint32 PFCTRL     : 1;            /*!< [5..5] Peripheral flow controller                                         */
      __IOM uint32 DIR        : 2;            /*!< [7..6] Data transfer direction                                            */
      __IOM uint32 CIRC       : 1;            /*!< [8..8] Circular mode                                                      */
      __IOM uint32 PINC       : 1;            /*!< [9..9] Peripheral increment mode                                          */
      __IOM uint32 MINC       : 1;            /*!< [10..10] Memory increment mode                                            */
      __IOM uint32 PSIZE      : 2;            /*!< [12..11] Peripheral data size                                             */
      __IOM uint32 MSIZE      : 2;            /*!< [14..13] Memory data size                                                 */
      __IOM uint32 PINCOS     : 1;            /*!< [15..15] Peripheral increment offset size                                 */
      __IOM uint32 PL         : 2;            /*!< [17..16] Priority level                                                   */
      __IOM uint32 DBM        : 1;            /*!< [18..18] Double buffer mode                                               */
      __IOM uint32 CT         : 1;            /*!< [19..19] Current target (only in double buffer mode)                      */
      __IOM uint32 ACK        : 1;            /*!< [20..20] ACK                                                              */
      __IOM uint32 PBURST     : 2;            /*!< [22..21] Peripheral burst transfer configuration                          */
      __IOM uint32 MBURST     : 2;            /*!< [24..23] Memory burst transfer configuration                              */
            uint32            : 7;
    } bit;
  } S3CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000005C) stream x number of data register                           */
    
    struct {
      __IOM uint32 NDT        : 16;           /*!< [15..0] Number of data items to transfer                                  */
            uint32            : 16;
    } bit;
  } S3NDTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000060) stream x peripheral address register                       */
    
    struct {
      __IOM uint32 PA         : 32;           /*!< [31..0] Peripheral address                                                */
    } bit;
  } S3PAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000064) stream x memory 0 address register                         */
    
    struct {
      __IOM uint32 M0A        : 32;           /*!< [31..0] Memory 0 address                                                  */
    } bit;
  } S3M0AR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000068) stream x memory 1 address register                         */
    
    struct {
      __IOM uint32 M1A        : 32;           /*!< [31..0] Memory 1 address (used in case of Double buffer mode)             */
    } bit;
  } S3M1AR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000006C) stream x FIFO control register                             */
    
    struct {
      __IOM uint32 FTH        : 2;            /*!< [1..0] FIFO threshold selection                                           */
      __IOM uint32 DMDIS      : 1;            /*!< [2..2] Direct mode disable                                                */
      __IM  uint32 FS         : 3;            /*!< [5..3] FIFO status                                                        */
            uint32            : 1;
      __IOM uint32 FEIE       : 1;            /*!< [7..7] FIFO error interrupt enable                                        */
            uint32            : 24;
    } bit;
  } S3FCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000070) stream x configuration register                            */
    
    struct {
      __IOM uint32 EN         : 1;            /*!< [0..0] Stream enable / flag stream ready when read low                    */
      __IOM uint32 DMEIE      : 1;            /*!< [1..1] Direct mode error interrupt enable                                 */
      __IOM uint32 TEIE       : 1;            /*!< [2..2] Transfer error interrupt enable                                    */
      __IOM uint32 HTIE       : 1;            /*!< [3..3] Half transfer interrupt enable                                     */
      __IOM uint32 TCIE       : 1;            /*!< [4..4] Transfer complete interrupt enable                                 */
      __IOM uint32 PFCTRL     : 1;            /*!< [5..5] Peripheral flow controller                                         */
      __IOM uint32 DIR        : 2;            /*!< [7..6] Data transfer direction                                            */
      __IOM uint32 CIRC       : 1;            /*!< [8..8] Circular mode                                                      */
      __IOM uint32 PINC       : 1;            /*!< [9..9] Peripheral increment mode                                          */
      __IOM uint32 MINC       : 1;            /*!< [10..10] Memory increment mode                                            */
      __IOM uint32 PSIZE      : 2;            /*!< [12..11] Peripheral data size                                             */
      __IOM uint32 MSIZE      : 2;            /*!< [14..13] Memory data size                                                 */
      __IOM uint32 PINCOS     : 1;            /*!< [15..15] Peripheral increment offset size                                 */
      __IOM uint32 PL         : 2;            /*!< [17..16] Priority level                                                   */
      __IOM uint32 DBM        : 1;            /*!< [18..18] Double buffer mode                                               */
      __IOM uint32 CT         : 1;            /*!< [19..19] Current target (only in double buffer mode)                      */
      __IOM uint32 ACK        : 1;            /*!< [20..20] ACK                                                              */
      __IOM uint32 PBURST     : 2;            /*!< [22..21] Peripheral burst transfer configuration                          */
      __IOM uint32 MBURST     : 2;            /*!< [24..23] Memory burst transfer configuration                              */
            uint32            : 7;
    } bit;
  } S4CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000074) stream x number of data register                           */
    
    struct {
      __IOM uint32 NDT        : 16;           /*!< [15..0] Number of data items to transfer                                  */
            uint32            : 16;
    } bit;
  } S4NDTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000078) stream x peripheral address register                       */
    
    struct {
      __IOM uint32 PA         : 32;           /*!< [31..0] Peripheral address                                                */
    } bit;
  } S4PAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000007C) stream x memory 0 address register                         */
    
    struct {
      __IOM uint32 M0A        : 32;           /*!< [31..0] Memory 0 address                                                  */
    } bit;
  } S4M0AR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000080) stream x memory 1 address register                         */
    
    struct {
      __IOM uint32 M1A        : 32;           /*!< [31..0] Memory 1 address (used in case of Double buffer mode)             */
    } bit;
  } S4M1AR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000084) stream x FIFO control register                             */
    
    struct {
      __IOM uint32 FTH        : 2;            /*!< [1..0] FIFO threshold selection                                           */
      __IOM uint32 DMDIS      : 1;            /*!< [2..2] Direct mode disable                                                */
      __IM  uint32 FS         : 3;            /*!< [5..3] FIFO status                                                        */
            uint32            : 1;
      __IOM uint32 FEIE       : 1;            /*!< [7..7] FIFO error interrupt enable                                        */
            uint32            : 24;
    } bit;
  } S4FCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000088) stream x configuration register                            */
    
    struct {
      __IOM uint32 EN         : 1;            /*!< [0..0] Stream enable / flag stream ready when read low                    */
      __IOM uint32 DMEIE      : 1;            /*!< [1..1] Direct mode error interrupt enable                                 */
      __IOM uint32 TEIE       : 1;            /*!< [2..2] Transfer error interrupt enable                                    */
      __IOM uint32 HTIE       : 1;            /*!< [3..3] Half transfer interrupt enable                                     */
      __IOM uint32 TCIE       : 1;            /*!< [4..4] Transfer complete interrupt enable                                 */
      __IOM uint32 PFCTRL     : 1;            /*!< [5..5] Peripheral flow controller                                         */
      __IOM uint32 DIR        : 2;            /*!< [7..6] Data transfer direction                                            */
      __IOM uint32 CIRC       : 1;            /*!< [8..8] Circular mode                                                      */
      __IOM uint32 PINC       : 1;            /*!< [9..9] Peripheral increment mode                                          */
      __IOM uint32 MINC       : 1;            /*!< [10..10] Memory increment mode                                            */
      __IOM uint32 PSIZE      : 2;            /*!< [12..11] Peripheral data size                                             */
      __IOM uint32 MSIZE      : 2;            /*!< [14..13] Memory data size                                                 */
      __IOM uint32 PINCOS     : 1;            /*!< [15..15] Peripheral increment offset size                                 */
      __IOM uint32 PL         : 2;            /*!< [17..16] Priority level                                                   */
      __IOM uint32 DBM        : 1;            /*!< [18..18] Double buffer mode                                               */
      __IOM uint32 CT         : 1;            /*!< [19..19] Current target (only in double buffer mode)                      */
      __IOM uint32 ACK        : 1;            /*!< [20..20] ACK                                                              */
      __IOM uint32 PBURST     : 2;            /*!< [22..21] Peripheral burst transfer configuration                          */
      __IOM uint32 MBURST     : 2;            /*!< [24..23] Memory burst transfer configuration                              */
            uint32            : 7;
    } bit;
  } S5CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000008C) stream x number of data register                           */
    
    struct {
      __IOM uint32 NDT        : 16;           /*!< [15..0] Number of data items to transfer                                  */
            uint32            : 16;
    } bit;
  } S5NDTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000090) stream x peripheral address register                       */
    
    struct {
      __IOM uint32 PA         : 32;           /*!< [31..0] Peripheral address                                                */
    } bit;
  } S5PAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000094) stream x memory 0 address register                         */
    
    struct {
      __IOM uint32 M0A        : 32;           /*!< [31..0] Memory 0 address                                                  */
    } bit;
  } S5M0AR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000098) stream x memory 1 address register                         */
    
    struct {
      __IOM uint32 M1A        : 32;           /*!< [31..0] Memory 1 address (used in case of Double buffer mode)             */
    } bit;
  } S5M1AR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000009C) stream x FIFO control register                             */
    
    struct {
      __IOM uint32 FTH        : 2;            /*!< [1..0] FIFO threshold selection                                           */
      __IOM uint32 DMDIS      : 1;            /*!< [2..2] Direct mode disable                                                */
      __IM  uint32 FS         : 3;            /*!< [5..3] FIFO status                                                        */
            uint32            : 1;
      __IOM uint32 FEIE       : 1;            /*!< [7..7] FIFO error interrupt enable                                        */
            uint32            : 24;
    } bit;
  } S5FCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000A0) stream x configuration register                            */
    
    struct {
      __IOM uint32 EN         : 1;            /*!< [0..0] Stream enable / flag stream ready when read low                    */
      __IOM uint32 DMEIE      : 1;            /*!< [1..1] Direct mode error interrupt enable                                 */
      __IOM uint32 TEIE       : 1;            /*!< [2..2] Transfer error interrupt enable                                    */
      __IOM uint32 HTIE       : 1;            /*!< [3..3] Half transfer interrupt enable                                     */
      __IOM uint32 TCIE       : 1;            /*!< [4..4] Transfer complete interrupt enable                                 */
      __IOM uint32 PFCTRL     : 1;            /*!< [5..5] Peripheral flow controller                                         */
      __IOM uint32 DIR        : 2;            /*!< [7..6] Data transfer direction                                            */
      __IOM uint32 CIRC       : 1;            /*!< [8..8] Circular mode                                                      */
      __IOM uint32 PINC       : 1;            /*!< [9..9] Peripheral increment mode                                          */
      __IOM uint32 MINC       : 1;            /*!< [10..10] Memory increment mode                                            */
      __IOM uint32 PSIZE      : 2;            /*!< [12..11] Peripheral data size                                             */
      __IOM uint32 MSIZE      : 2;            /*!< [14..13] Memory data size                                                 */
      __IOM uint32 PINCOS     : 1;            /*!< [15..15] Peripheral increment offset size                                 */
      __IOM uint32 PL         : 2;            /*!< [17..16] Priority level                                                   */
      __IOM uint32 DBM        : 1;            /*!< [18..18] Double buffer mode                                               */
      __IOM uint32 CT         : 1;            /*!< [19..19] Current target (only in double buffer mode)                      */
      __IOM uint32 ACK        : 1;            /*!< [20..20] ACK                                                              */
      __IOM uint32 PBURST     : 2;            /*!< [22..21] Peripheral burst transfer configuration                          */
      __IOM uint32 MBURST     : 2;            /*!< [24..23] Memory burst transfer configuration                              */
            uint32            : 7;
    } bit;
  } S6CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000A4) stream x number of data register                           */
    
    struct {
      __IOM uint32 NDT        : 16;           /*!< [15..0] Number of data items to transfer                                  */
            uint32            : 16;
    } bit;
  } S6NDTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000A8) stream x peripheral address register                       */
    
    struct {
      __IOM uint32 PA         : 32;           /*!< [31..0] Peripheral address                                                */
    } bit;
  } S6PAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000AC) stream x memory 0 address register                         */
    
    struct {
      __IOM uint32 M0A        : 32;           /*!< [31..0] Memory 0 address                                                  */
    } bit;
  } S6M0AR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000B0) stream x memory 1 address register                         */
    
    struct {
      __IOM uint32 M1A        : 32;           /*!< [31..0] Memory 1 address (used in case of Double buffer mode)             */
    } bit;
  } S6M1AR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000B4) stream x FIFO control register                             */
    
    struct {
      __IOM uint32 FTH        : 2;            /*!< [1..0] FIFO threshold selection                                           */
      __IOM uint32 DMDIS      : 1;            /*!< [2..2] Direct mode disable                                                */
      __IM  uint32 FS         : 3;            /*!< [5..3] FIFO status                                                        */
            uint32            : 1;
      __IOM uint32 FEIE       : 1;            /*!< [7..7] FIFO error interrupt enable                                        */
            uint32            : 24;
    } bit;
  } S6FCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000B8) stream x configuration register                            */
    
    struct {
      __IOM uint32 EN         : 1;            /*!< [0..0] Stream enable / flag stream ready when read low                    */
      __IOM uint32 DMEIE      : 1;            /*!< [1..1] Direct mode error interrupt enable                                 */
      __IOM uint32 TEIE       : 1;            /*!< [2..2] Transfer error interrupt enable                                    */
      __IOM uint32 HTIE       : 1;            /*!< [3..3] Half transfer interrupt enable                                     */
      __IOM uint32 TCIE       : 1;            /*!< [4..4] Transfer complete interrupt enable                                 */
      __IOM uint32 PFCTRL     : 1;            /*!< [5..5] Peripheral flow controller                                         */
      __IOM uint32 DIR        : 2;            /*!< [7..6] Data transfer direction                                            */
      __IOM uint32 CIRC       : 1;            /*!< [8..8] Circular mode                                                      */
      __IOM uint32 PINC       : 1;            /*!< [9..9] Peripheral increment mode                                          */
      __IOM uint32 MINC       : 1;            /*!< [10..10] Memory increment mode                                            */
      __IOM uint32 PSIZE      : 2;            /*!< [12..11] Peripheral data size                                             */
      __IOM uint32 MSIZE      : 2;            /*!< [14..13] Memory data size                                                 */
      __IOM uint32 PINCOS     : 1;            /*!< [15..15] Peripheral increment offset size                                 */
      __IOM uint32 PL         : 2;            /*!< [17..16] Priority level                                                   */
      __IOM uint32 DBM        : 1;            /*!< [18..18] Double buffer mode                                               */
      __IOM uint32 CT         : 1;            /*!< [19..19] Current target (only in double buffer mode)                      */
      __IOM uint32 ACK        : 1;            /*!< [20..20] ACK                                                              */
      __IOM uint32 PBURST     : 2;            /*!< [22..21] Peripheral burst transfer configuration                          */
      __IOM uint32 MBURST     : 2;            /*!< [24..23] Memory burst transfer configuration                              */
            uint32            : 7;
    } bit;
  } S7CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000BC) stream x number of data register                           */
    
    struct {
      __IOM uint32 NDT        : 16;           /*!< [15..0] Number of data items to transfer                                  */
            uint32            : 16;
    } bit;
  } S7NDTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000C0) stream x peripheral address register                       */
    
    struct {
      __IOM uint32 PA         : 32;           /*!< [31..0] Peripheral address                                                */
    } bit;
  } S7PAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000C4) stream x memory 0 address register                         */
    
    struct {
      __IOM uint32 M0A        : 32;           /*!< [31..0] Memory 0 address                                                  */
    } bit;
  } S7M0AR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000C8) stream x memory 1 address register                         */
    
    struct {
      __IOM uint32 M1A        : 32;           /*!< [31..0] Memory 1 address (used in case of Double buffer mode)             */
    } bit;
  } S7M1AR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000CC) stream x FIFO control register                             */
    
    struct {
      __IOM uint32 FTH        : 2;            /*!< [1..0] FIFO threshold selection                                           */
      __IOM uint32 DMDIS      : 1;            /*!< [2..2] Direct mode disable                                                */
      __IM  uint32 FS         : 3;            /*!< [5..3] FIFO status                                                        */
            uint32            : 1;
      __IOM uint32 FEIE       : 1;            /*!< [7..7] FIFO error interrupt enable                                        */
            uint32            : 24;
    } bit;
  } S7FCR;
} DMA1_Type;                                    /*!< Size = 208 (0xd0)                                                         */



/* =========================================================================================================================== */
/* ================                                       HRTIM_Master                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief High Resolution Timer: Master
      Timers (HRTIM_Master)
  */

typedef struct {                                /*!< (@ 0x40017400) HRTIM_Master Structure                                     */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) Master Timer Control Register                              */
    
    struct {
      __IOM uint32 CK_PSC     : 3;            /*!< [2..0] HRTIM Master Clock prescaler                                       */
      __IOM uint32 CONT       : 1;            /*!< [3..3] Master Continuous mode                                             */
      __IOM uint32 RETRIG     : 1;            /*!< [4..4] Master Re-triggerable mode                                         */
      __IOM uint32 HALF       : 1;            /*!< [5..5] Half mode enable                                                   */
            uint32            : 2;
      __IOM uint32 SYNC_IN    : 2;            /*!< [9..8] ynchronization input                                               */
      __IOM uint32 SYNCRSTM   : 1;            /*!< [10..10] Synchronization Resets Master                                    */
      __IOM uint32 SYNCSTRTM  : 1;            /*!< [11..11] Synchronization Starts Master                                    */
      __IOM uint32 SYNC_OUT   : 2;            /*!< [13..12] Synchronization output                                           */
      __IOM uint32 SYNC_SRC   : 2;            /*!< [15..14] Synchronization source                                           */
      __IOM uint32 MCEN       : 1;            /*!< [16..16] Master Counter enable                                            */
      __IOM uint32 TACEN      : 1;            /*!< [17..17] Timer A counter enable                                           */
      __IOM uint32 TBCEN      : 1;            /*!< [18..18] Timer B counter enable                                           */
      __IOM uint32 TCCEN      : 1;            /*!< [19..19] Timer C counter enable                                           */
      __IOM uint32 TDCEN      : 1;            /*!< [20..20] Timer D counter enable                                           */
      __IOM uint32 TECEN      : 1;            /*!< [21..21] Timer E counter enable                                           */
            uint32            : 3;
      __IOM uint32 DACSYNC    : 2;            /*!< [26..25] AC Synchronization                                               */
      __IOM uint32 PREEN      : 1;            /*!< [27..27] Preload enable                                                   */
            uint32            : 1;
      __IOM uint32 MREPU      : 1;            /*!< [29..29] Master Timer Repetition update                                   */
      __IOM uint32 BRSTDMA    : 2;            /*!< [31..30] Burst DMA Update                                                 */
    } bit;
  } MCR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000004) Master Timer Interrupt Status Register                     */
    
    struct {
      __IM  uint32 MCMP1      : 1;            /*!< [0..0] Master Compare 1 Interrupt Flag                                    */
      __IM  uint32 MCMP2      : 1;            /*!< [1..1] Master Compare 2 Interrupt Flag                                    */
      __IM  uint32 MCMP3      : 1;            /*!< [2..2] Master Compare 3 Interrupt Flag                                    */
      __IM  uint32 MCMP4      : 1;            /*!< [3..3] Master Compare 4 Interrupt Flag                                    */
      __IM  uint32 MREP       : 1;            /*!< [4..4] Master Repetition Interrupt Flag                                   */
      __IM  uint32 SYNC       : 1;            /*!< [5..5] Sync Input Interrupt Flag                                          */
      __IM  uint32 MUPD       : 1;            /*!< [6..6] Master Update Interrupt Flag                                       */
            uint32            : 25;
    } bit;
  } MISR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000008) Master Timer Interrupt Clear Register                      */
    
    struct {
      __OM  uint32 MCMP1C     : 1;            /*!< [0..0] Master Compare 1 Interrupt flag clear                              */
      __OM  uint32 MCMP2C     : 1;            /*!< [1..1] Master Compare 2 Interrupt flag clear                              */
      __OM  uint32 MCMP3C     : 1;            /*!< [2..2] Master Compare 3 Interrupt flag clear                              */
      __OM  uint32 MCMP4C     : 1;            /*!< [3..3] Master Compare 4 Interrupt flag clear                              */
      __OM  uint32 MREPC      : 1;            /*!< [4..4] Repetition Interrupt flag clear                                    */
      __OM  uint32 SYNCC      : 1;            /*!< [5..5] Sync Input Interrupt flag clear                                    */
      __OM  uint32 MUPDC      : 1;            /*!< [6..6] Master update Interrupt flag clear                                 */
            uint32            : 25;
    } bit;
  } MICR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) MDIER4                                                     */
    
    struct {
      __IOM uint32 MCMP1IE    : 1;            /*!< [0..0] MCMP1IE                                                            */
      __IOM uint32 MCMP2IE    : 1;            /*!< [1..1] MCMP2IE                                                            */
      __IOM uint32 MCMP3IE    : 1;            /*!< [2..2] MCMP3IE                                                            */
      __IOM uint32 MCMP4IE    : 1;            /*!< [3..3] MCMP4IE                                                            */
      __IOM uint32 MREPIE     : 1;            /*!< [4..4] MREPIE                                                             */
      __IOM uint32 SYNCIE     : 1;            /*!< [5..5] SYNCIE                                                             */
      __IOM uint32 MUPDIE     : 1;            /*!< [6..6] MUPDIE                                                             */
            uint32            : 9;
      __IOM uint32 MCMP1DE    : 1;            /*!< [16..16] MCMP1DE                                                          */
      __IOM uint32 MCMP2DE    : 1;            /*!< [17..17] MCMP2DE                                                          */
      __IOM uint32 MCMP3DE    : 1;            /*!< [18..18] MCMP3DE                                                          */
      __IOM uint32 MCMP4DE    : 1;            /*!< [19..19] MCMP4DE                                                          */
      __IOM uint32 MREPDE     : 1;            /*!< [20..20] MREPDE                                                           */
      __IOM uint32 SYNCDE     : 1;            /*!< [21..21] SYNCDE                                                           */
      __IOM uint32 MUPDDE     : 1;            /*!< [22..22] MUPDDE                                                           */
            uint32            : 9;
    } bit;
  } MDIER4;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) Master Timer Counter Register                              */
    
    struct {
      __IOM uint32 MCNT       : 16;           /*!< [15..0] Counter value                                                     */
            uint32            : 16;
    } bit;
  } MCNTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000014) Master Timer Period Register                               */
    
    struct {
      __IOM uint32 MPER       : 16;           /*!< [15..0] Master Timer Period value                                         */
            uint32            : 16;
    } bit;
  } MPER;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000018) Master Timer Repetition Register                           */
    
    struct {
      __IOM uint32 MREP       : 8;            /*!< [7..0] Master Timer Repetition counter value                              */
            uint32            : 24;
    } bit;
  } MREP;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000001C) Master Timer Compare 1 Register                            */
    
    struct {
      __IOM uint32 MCMP1      : 16;           /*!< [15..0] Master Timer Compare 1 value                                      */
            uint32            : 16;
    } bit;
  } MCMP1R;
  __IM  uint32  RESERVED;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000024) Master Timer Compare 2 Register                            */
    
    struct {
      __IOM uint32 MCMP2      : 16;           /*!< [15..0] Master Timer Compare 2 value                                      */
            uint32            : 16;
    } bit;
  } MCMP2R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000028) Master Timer Compare 3 Register                            */
    
    struct {
      __IOM uint32 MCMP3      : 16;           /*!< [15..0] Master Timer Compare 3 value                                      */
            uint32            : 16;
    } bit;
  } MCMP3R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000002C) Master Timer Compare 4 Register                            */
    
    struct {
      __IOM uint32 MCMP4      : 16;           /*!< [15..0] Master Timer Compare 4 value                                      */
            uint32            : 16;
    } bit;
  } MCMP4R;
} HRTIM_Master_Type;                            /*!< Size = 48 (0x30)                                                          */



/* =========================================================================================================================== */
/* ================                                        HRTIM_TIMA                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief High Resolution Timer: TIMA (HRTIM_TIMA)
  */

typedef struct {                                /*!< (@ 0x40017480) HRTIM_TIMA Structure                                       */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) Timerx Control Register                                    */
    
    struct {
      __IOM uint32 CK_PSCx    : 3;            /*!< [2..0] HRTIM Timer x Clock prescaler                                      */
      __IOM uint32 CONT       : 1;            /*!< [3..3] Continuous mode                                                    */
      __IOM uint32 RETRIG     : 1;            /*!< [4..4] Re-triggerable mode                                                */
      __IOM uint32 HALF       : 1;            /*!< [5..5] Half mode enable                                                   */
      __IOM uint32 PSHPLL     : 1;            /*!< [6..6] Push-Pull mode enable                                              */
            uint32            : 3;
      __IOM uint32 SYNCRSTx   : 1;            /*!< [10..10] Synchronization Resets Timer x                                   */
      __IOM uint32 SYNCSTRTx  : 1;            /*!< [11..11] Synchronization Starts Timer x                                   */
      __IOM uint32 DELCMP2    : 2;            /*!< [13..12] Delayed CMP2 mode                                                */
      __IOM uint32 DELCMP4    : 2;            /*!< [15..14] Delayed CMP4 mode                                                */
            uint32            : 1;
      __IOM uint32 TxREPU     : 1;            /*!< [17..17] Timer x Repetition update                                        */
      __IOM uint32 TxRSTU     : 1;            /*!< [18..18] Timerx reset update                                              */
            uint32            : 1;
      __IOM uint32 TBU        : 1;            /*!< [20..20] TBU                                                              */
      __IOM uint32 TCU        : 1;            /*!< [21..21] TCU                                                              */
      __IOM uint32 TDU        : 1;            /*!< [22..22] TDU                                                              */
      __IOM uint32 TEU        : 1;            /*!< [23..23] TEU                                                              */
      __IOM uint32 MSTU       : 1;            /*!< [24..24] Master Timer update                                              */
      __IOM uint32 DACSYNC    : 2;            /*!< [26..25] AC Synchronization                                               */
      __IOM uint32 PREEN      : 1;            /*!< [27..27] Preload enable                                                   */
      __IOM uint32 UPDGAT     : 4;            /*!< [31..28] Update Gating                                                    */
    } bit;
  } TIMACR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000004) Timerx Interrupt Status Register                           */
    
    struct {
      __IM  uint32 CMP1       : 1;            /*!< [0..0] Compare 1 Interrupt Flag                                           */
      __IM  uint32 CMP2       : 1;            /*!< [1..1] Compare 2 Interrupt Flag                                           */
      __IM  uint32 CMP3       : 1;            /*!< [2..2] Compare 3 Interrupt Flag                                           */
      __IM  uint32 CMP4       : 1;            /*!< [3..3] Compare 4 Interrupt Flag                                           */
      __IM  uint32 REP        : 1;            /*!< [4..4] Repetition Interrupt Flag                                          */
            uint32            : 1;
      __IM  uint32 UPD        : 1;            /*!< [6..6] Update Interrupt Flag                                              */
      __IM  uint32 CPT1       : 1;            /*!< [7..7] Capture1 Interrupt Flag                                            */
      __IM  uint32 CPT2       : 1;            /*!< [8..8] Capture2 Interrupt Flag                                            */
      __IM  uint32 SETx1      : 1;            /*!< [9..9] Output 1 Set Interrupt Flag                                        */
      __IM  uint32 RSTx1      : 1;            /*!< [10..10] Output 1 Reset Interrupt Flag                                    */
      __IM  uint32 SETx2      : 1;            /*!< [11..11] Output 2 Set Interrupt Flag                                      */
      __IM  uint32 RSTx2      : 1;            /*!< [12..12] Output 2 Reset Interrupt Flag                                    */
      __IM  uint32 RST        : 1;            /*!< [13..13] Reset Interrupt Flag                                             */
      __IM  uint32 DLYPRT     : 1;            /*!< [14..14] Delayed Protection Flag                                          */
            uint32            : 1;
      __IM  uint32 CPPSTAT    : 1;            /*!< [16..16] Current Push Pull Status                                         */
      __IM  uint32 IPPSTAT    : 1;            /*!< [17..17] Idle Push Pull Status                                            */
      __IM  uint32 O1STAT     : 1;            /*!< [18..18] Output 1 State                                                   */
      __IM  uint32 O2STAT     : 1;            /*!< [19..19] Output 2 State                                                   */
            uint32            : 12;
    } bit;
  } TIMAISR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000008) Timerx Interrupt Clear Register                            */
    
    struct {
      __OM  uint32 CMP1C      : 1;            /*!< [0..0] Compare 1 Interrupt flag Clear                                     */
      __OM  uint32 CMP2C      : 1;            /*!< [1..1] Compare 2 Interrupt flag Clear                                     */
      __OM  uint32 CMP3C      : 1;            /*!< [2..2] Compare 3 Interrupt flag Clear                                     */
      __OM  uint32 CMP4C      : 1;            /*!< [3..3] Compare 4 Interrupt flag Clear                                     */
      __OM  uint32 REPC       : 1;            /*!< [4..4] Repetition Interrupt flag Clear                                    */
            uint32            : 1;
      __OM  uint32 UPDC       : 1;            /*!< [6..6] Update Interrupt flag Clear                                        */
      __OM  uint32 CPT1C      : 1;            /*!< [7..7] Capture1 Interrupt flag Clear                                      */
      __OM  uint32 CPT2C      : 1;            /*!< [8..8] Capture2 Interrupt flag Clear                                      */
      __OM  uint32 SET1xC     : 1;            /*!< [9..9] Output 1 Set flag Clear                                            */
      __OM  uint32 RSTx1C     : 1;            /*!< [10..10] Output 1 Reset flag Clear                                        */
      __OM  uint32 SET2xC     : 1;            /*!< [11..11] Output 2 Set flag Clear                                          */
      __OM  uint32 RSTx2C     : 1;            /*!< [12..12] Output 2 Reset flag Clear                                        */
      __OM  uint32 RSTC       : 1;            /*!< [13..13] Reset Interrupt flag Clear                                       */
      __OM  uint32 DLYPRTC    : 1;            /*!< [14..14] Delayed Protection Flag Clear                                    */
            uint32            : 17;
    } bit;
  } TIMAICR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) TIMxDIER5                                                  */
    
    struct {
      __IOM uint32 CMP1IE     : 1;            /*!< [0..0] CMP1IE                                                             */
      __IOM uint32 CMP2IE     : 1;            /*!< [1..1] CMP2IE                                                             */
      __IOM uint32 CMP3IE     : 1;            /*!< [2..2] CMP3IE                                                             */
      __IOM uint32 CMP4IE     : 1;            /*!< [3..3] CMP4IE                                                             */
      __IOM uint32 REPIE      : 1;            /*!< [4..4] REPIE                                                              */
            uint32            : 1;
      __IOM uint32 UPDIE      : 1;            /*!< [6..6] UPDIE                                                              */
      __IOM uint32 CPT1IE     : 1;            /*!< [7..7] CPT1IE                                                             */
      __IOM uint32 CPT2IE     : 1;            /*!< [8..8] CPT2IE                                                             */
      __IOM uint32 SET1xIE    : 1;            /*!< [9..9] SET1xIE                                                            */
      __IOM uint32 RSTx1IE    : 1;            /*!< [10..10] RSTx1IE                                                          */
      __IOM uint32 SETx2IE    : 1;            /*!< [11..11] SETx2IE                                                          */
      __IOM uint32 RSTx2IE    : 1;            /*!< [12..12] RSTx2IE                                                          */
      __IOM uint32 RSTIE      : 1;            /*!< [13..13] RSTIE                                                            */
      __IOM uint32 DLYPRTIE   : 1;            /*!< [14..14] DLYPRTIE                                                         */
            uint32            : 1;
      __IOM uint32 CMP1DE     : 1;            /*!< [16..16] CMP1DE                                                           */
      __IOM uint32 CMP2DE     : 1;            /*!< [17..17] CMP2DE                                                           */
      __IOM uint32 CMP3DE     : 1;            /*!< [18..18] CMP3DE                                                           */
      __IOM uint32 CMP4DE     : 1;            /*!< [19..19] CMP4DE                                                           */
      __IOM uint32 REPDE      : 1;            /*!< [20..20] REPDE                                                            */
            uint32            : 1;
      __IOM uint32 UPDDE      : 1;            /*!< [22..22] UPDDE                                                            */
      __IOM uint32 CPT1DE     : 1;            /*!< [23..23] CPT1DE                                                           */
      __IOM uint32 CPT2DE     : 1;            /*!< [24..24] CPT2DE                                                           */
      __IOM uint32 SET1xDE    : 1;            /*!< [25..25] SET1xDE                                                          */
      __IOM uint32 RSTx1DE    : 1;            /*!< [26..26] RSTx1DE                                                          */
      __IOM uint32 SETx2DE    : 1;            /*!< [27..27] SETx2DE                                                          */
      __IOM uint32 RSTx2DE    : 1;            /*!< [28..28] RSTx2DE                                                          */
      __IOM uint32 RSTDE      : 1;            /*!< [29..29] RSTDE                                                            */
      __IOM uint32 DLYPRTDE   : 1;            /*!< [30..30] DLYPRTDE                                                         */
            uint32            : 1;
    } bit;
  } TIMADIER5;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) Timerx Counter Register                                    */
    
    struct {
      __IOM uint32 CNTx       : 16;           /*!< [15..0] Timerx Counter value                                              */
            uint32            : 16;
    } bit;
  } CNTAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000014) Timerx Period Register                                     */
    
    struct {
      __IOM uint32 PERx       : 16;           /*!< [15..0] Timerx Period value                                               */
            uint32            : 16;
    } bit;
  } PERAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000018) Timerx Repetition Register                                 */
    
    struct {
      __IOM uint32 REPx       : 8;            /*!< [7..0] Timerx Repetition counter value                                    */
            uint32            : 24;
    } bit;
  } REPAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000001C) Timerx Compare 1 Register                                  */
    
    struct {
      __IOM uint32 CMP1x      : 16;           /*!< [15..0] Timerx Compare 1 value                                            */
            uint32            : 16;
    } bit;
  } CMP1AR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000020) Timerx Compare 1 Compound Register                         */
    
    struct {
      __IOM uint32 CMP1x      : 16;           /*!< [15..0] Timerx Compare 1 value                                            */
      __IOM uint32 REPx       : 8;            /*!< [23..16] Timerx Repetition value (aliased from HRTIM_REPx register)       */
            uint32            : 8;
    } bit;
  } CMP1CAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000024) Timerx Compare 2 Register                                  */
    
    struct {
      __IOM uint32 CMP2x      : 16;           /*!< [15..0] Timerx Compare 2 value                                            */
            uint32            : 16;
    } bit;
  } CMP2AR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000028) Timerx Compare 3 Register                                  */
    
    struct {
      __IOM uint32 CMP3x      : 16;           /*!< [15..0] Timerx Compare 3 value                                            */
            uint32            : 16;
    } bit;
  } CMP3AR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000002C) Timerx Compare 4 Register                                  */
    
    struct {
      __IOM uint32 CMP4x      : 16;           /*!< [15..0] Timerx Compare 4 value                                            */
            uint32            : 16;
    } bit;
  } CMP4AR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000030) Timerx Capture 1 Register                                  */
    
    struct {
      __IM  uint32 CPT1x      : 16;           /*!< [15..0] Timerx Capture 1 value                                            */
            uint32            : 16;
    } bit;
  } CPT1AR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000034) Timerx Capture 2 Register                                  */
    
    struct {
      __IM  uint32 CPT2x      : 16;           /*!< [15..0] Timerx Capture 2 value                                            */
            uint32            : 16;
    } bit;
  } CPT2AR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000038) Timerx Deadtime Register                                   */
    
    struct {
      __IOM uint32 DTRx       : 9;            /*!< [8..0] Deadtime Rising value                                              */
      __IOM uint32 SDTRx      : 1;            /*!< [9..9] Sign Deadtime Rising value                                         */
      __IOM uint32 DTPRSC     : 3;            /*!< [12..10] Deadtime Prescaler                                               */
            uint32            : 1;
      __IOM uint32 DTRSLKx    : 1;            /*!< [14..14] Deadtime Rising Sign Lock                                        */
      __IOM uint32 DTRLKx     : 1;            /*!< [15..15] Deadtime Rising Lock                                             */
      __IOM uint32 DTFx       : 9;            /*!< [24..16] Deadtime Falling value                                           */
      __IOM uint32 SDTFx      : 1;            /*!< [25..25] Sign Deadtime Falling value                                      */
            uint32            : 4;
      __IOM uint32 DTFSLKx    : 1;            /*!< [30..30] Deadtime Falling Sign Lock                                       */
      __IOM uint32 DTFLKx     : 1;            /*!< [31..31] Deadtime Falling Lock                                            */
    } bit;
  } DTAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000003C) Timerx Output1 Set Register                                */
    
    struct {
      __IOM uint32 SST        : 1;            /*!< [0..0] Software Set trigger                                               */
      __IOM uint32 RESYNC     : 1;            /*!< [1..1] Timer A resynchronizaton                                           */
      __IOM uint32 PER        : 1;            /*!< [2..2] Timer A Period                                                     */
      __IOM uint32 CMP1       : 1;            /*!< [3..3] Timer A compare 1                                                  */
      __IOM uint32 CMP2       : 1;            /*!< [4..4] Timer A compare 2                                                  */
      __IOM uint32 CMP3       : 1;            /*!< [5..5] Timer A compare 3                                                  */
      __IOM uint32 CMP4       : 1;            /*!< [6..6] Timer A compare 4                                                  */
      __IOM uint32 MSTPER     : 1;            /*!< [7..7] Master Period                                                      */
      __IOM uint32 MSTCMP1    : 1;            /*!< [8..8] Master Compare 1                                                   */
      __IOM uint32 MSTCMP2    : 1;            /*!< [9..9] Master Compare 2                                                   */
      __IOM uint32 MSTCMP3    : 1;            /*!< [10..10] Master Compare 3                                                 */
      __IOM uint32 MSTCMP4    : 1;            /*!< [11..11] Master Compare 4                                                 */
      __IOM uint32 TIMEVNT1   : 1;            /*!< [12..12] Timer Event 1                                                    */
      __IOM uint32 TIMEVNT2   : 1;            /*!< [13..13] Timer Event 2                                                    */
      __IOM uint32 TIMEVNT3   : 1;            /*!< [14..14] Timer Event 3                                                    */
      __IOM uint32 TIMEVNT4   : 1;            /*!< [15..15] Timer Event 4                                                    */
      __IOM uint32 TIMEVNT5   : 1;            /*!< [16..16] Timer Event 5                                                    */
      __IOM uint32 TIMEVNT6   : 1;            /*!< [17..17] Timer Event 6                                                    */
      __IOM uint32 TIMEVNT7   : 1;            /*!< [18..18] Timer Event 7                                                    */
      __IOM uint32 TIMEVNT8   : 1;            /*!< [19..19] Timer Event 8                                                    */
      __IOM uint32 TIMEVNT9   : 1;            /*!< [20..20] Timer Event 9                                                    */
      __IOM uint32 EXTEVNT1   : 1;            /*!< [21..21] External Event 1                                                 */
      __IOM uint32 EXTEVNT2   : 1;            /*!< [22..22] External Event 2                                                 */
      __IOM uint32 EXTEVNT3   : 1;            /*!< [23..23] External Event 3                                                 */
      __IOM uint32 EXTEVNT4   : 1;            /*!< [24..24] External Event 4                                                 */
      __IOM uint32 EXTEVNT5   : 1;            /*!< [25..25] External Event 5                                                 */
      __IOM uint32 EXTEVNT6   : 1;            /*!< [26..26] External Event 6                                                 */
      __IOM uint32 EXTEVNT7   : 1;            /*!< [27..27] External Event 7                                                 */
      __IOM uint32 EXTEVNT8   : 1;            /*!< [28..28] External Event 8                                                 */
      __IOM uint32 EXTEVNT9   : 1;            /*!< [29..29] External Event 9                                                 */
      __IOM uint32 EXTEVNT10  : 1;            /*!< [30..30] External Event 10                                                */
      __IOM uint32 UPDATE     : 1;            /*!< [31..31] Registers update (transfer preload to active)                    */
    } bit;
  } SETA1R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000040) Timerx Output1 Reset Register                              */
    
    struct {
      __IOM uint32 SRT        : 1;            /*!< [0..0] SRT                                                                */
      __IOM uint32 RESYNC     : 1;            /*!< [1..1] RESYNC                                                             */
      __IOM uint32 PER        : 1;            /*!< [2..2] PER                                                                */
      __IOM uint32 CMP1       : 1;            /*!< [3..3] CMP1                                                               */
      __IOM uint32 CMP2       : 1;            /*!< [4..4] CMP2                                                               */
      __IOM uint32 CMP3       : 1;            /*!< [5..5] CMP3                                                               */
      __IOM uint32 CMP4       : 1;            /*!< [6..6] CMP4                                                               */
      __IOM uint32 MSTPER     : 1;            /*!< [7..7] MSTPER                                                             */
      __IOM uint32 MSTCMP1    : 1;            /*!< [8..8] MSTCMP1                                                            */
      __IOM uint32 MSTCMP2    : 1;            /*!< [9..9] MSTCMP2                                                            */
      __IOM uint32 MSTCMP3    : 1;            /*!< [10..10] MSTCMP3                                                          */
      __IOM uint32 MSTCMP4    : 1;            /*!< [11..11] MSTCMP4                                                          */
      __IOM uint32 TIMEVNT1   : 1;            /*!< [12..12] TIMEVNT1                                                         */
      __IOM uint32 TIMEVNT2   : 1;            /*!< [13..13] TIMEVNT2                                                         */
      __IOM uint32 TIMEVNT3   : 1;            /*!< [14..14] TIMEVNT3                                                         */
      __IOM uint32 TIMEVNT4   : 1;            /*!< [15..15] TIMEVNT4                                                         */
      __IOM uint32 TIMEVNT5   : 1;            /*!< [16..16] TIMEVNT5                                                         */
      __IOM uint32 TIMEVNT6   : 1;            /*!< [17..17] TIMEVNT6                                                         */
      __IOM uint32 TIMEVNT7   : 1;            /*!< [18..18] TIMEVNT7                                                         */
      __IOM uint32 TIMEVNT8   : 1;            /*!< [19..19] TIMEVNT8                                                         */
      __IOM uint32 TIMEVNT9   : 1;            /*!< [20..20] TIMEVNT9                                                         */
      __IOM uint32 EXTEVNT1   : 1;            /*!< [21..21] EXTEVNT1                                                         */
      __IOM uint32 EXTEVNT2   : 1;            /*!< [22..22] EXTEVNT2                                                         */
      __IOM uint32 EXTEVNT3   : 1;            /*!< [23..23] EXTEVNT3                                                         */
      __IOM uint32 EXTEVNT4   : 1;            /*!< [24..24] EXTEVNT4                                                         */
      __IOM uint32 EXTEVNT5   : 1;            /*!< [25..25] EXTEVNT5                                                         */
      __IOM uint32 EXTEVNT6   : 1;            /*!< [26..26] EXTEVNT6                                                         */
      __IOM uint32 EXTEVNT7   : 1;            /*!< [27..27] EXTEVNT7                                                         */
      __IOM uint32 EXTEVNT8   : 1;            /*!< [28..28] EXTEVNT8                                                         */
      __IOM uint32 EXTEVNT9   : 1;            /*!< [29..29] EXTEVNT9                                                         */
      __IOM uint32 EXTEVNT10  : 1;            /*!< [30..30] EXTEVNT10                                                        */
      __IOM uint32 UPDATE     : 1;            /*!< [31..31] UPDATE                                                           */
    } bit;
  } RSTA1R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000044) Timerx Output2 Set Register                                */
    
    struct {
      __IOM uint32 SST        : 1;            /*!< [0..0] SST                                                                */
      __IOM uint32 RESYNC     : 1;            /*!< [1..1] RESYNC                                                             */
      __IOM uint32 PER        : 1;            /*!< [2..2] PER                                                                */
      __IOM uint32 CMP1       : 1;            /*!< [3..3] CMP1                                                               */
      __IOM uint32 CMP2       : 1;            /*!< [4..4] CMP2                                                               */
      __IOM uint32 CMP3       : 1;            /*!< [5..5] CMP3                                                               */
      __IOM uint32 CMP4       : 1;            /*!< [6..6] CMP4                                                               */
      __IOM uint32 MSTPER     : 1;            /*!< [7..7] MSTPER                                                             */
      __IOM uint32 MSTCMP1    : 1;            /*!< [8..8] MSTCMP1                                                            */
      __IOM uint32 MSTCMP2    : 1;            /*!< [9..9] MSTCMP2                                                            */
      __IOM uint32 MSTCMP3    : 1;            /*!< [10..10] MSTCMP3                                                          */
      __IOM uint32 MSTCMP4    : 1;            /*!< [11..11] MSTCMP4                                                          */
      __IOM uint32 TIMEVNT1   : 1;            /*!< [12..12] TIMEVNT1                                                         */
      __IOM uint32 TIMEVNT2   : 1;            /*!< [13..13] TIMEVNT2                                                         */
      __IOM uint32 TIMEVNT3   : 1;            /*!< [14..14] TIMEVNT3                                                         */
      __IOM uint32 TIMEVNT4   : 1;            /*!< [15..15] TIMEVNT4                                                         */
      __IOM uint32 TIMEVNT5   : 1;            /*!< [16..16] TIMEVNT5                                                         */
      __IOM uint32 TIMEVNT6   : 1;            /*!< [17..17] TIMEVNT6                                                         */
      __IOM uint32 TIMEVNT7   : 1;            /*!< [18..18] TIMEVNT7                                                         */
      __IOM uint32 TIMEVNT8   : 1;            /*!< [19..19] TIMEVNT8                                                         */
      __IOM uint32 TIMEVNT9   : 1;            /*!< [20..20] TIMEVNT9                                                         */
      __IOM uint32 EXTEVNT1   : 1;            /*!< [21..21] EXTEVNT1                                                         */
      __IOM uint32 EXTEVNT2   : 1;            /*!< [22..22] EXTEVNT2                                                         */
      __IOM uint32 EXTEVNT3   : 1;            /*!< [23..23] EXTEVNT3                                                         */
      __IOM uint32 EXTEVNT4   : 1;            /*!< [24..24] EXTEVNT4                                                         */
      __IOM uint32 EXTEVNT5   : 1;            /*!< [25..25] EXTEVNT5                                                         */
      __IOM uint32 EXTEVNT6   : 1;            /*!< [26..26] EXTEVNT6                                                         */
      __IOM uint32 EXTEVNT7   : 1;            /*!< [27..27] EXTEVNT7                                                         */
      __IOM uint32 EXTEVNT8   : 1;            /*!< [28..28] EXTEVNT8                                                         */
      __IOM uint32 EXTEVNT9   : 1;            /*!< [29..29] EXTEVNT9                                                         */
      __IOM uint32 EXTEVNT10  : 1;            /*!< [30..30] EXTEVNT10                                                        */
      __IOM uint32 UPDATE     : 1;            /*!< [31..31] UPDATE                                                           */
    } bit;
  } SETA2R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000048) Timerx Output2 Reset Register                              */
    
    struct {
      __IOM uint32 SRT        : 1;            /*!< [0..0] SRT                                                                */
      __IOM uint32 RESYNC     : 1;            /*!< [1..1] RESYNC                                                             */
      __IOM uint32 PER        : 1;            /*!< [2..2] PER                                                                */
      __IOM uint32 CMP1       : 1;            /*!< [3..3] CMP1                                                               */
      __IOM uint32 CMP2       : 1;            /*!< [4..4] CMP2                                                               */
      __IOM uint32 CMP3       : 1;            /*!< [5..5] CMP3                                                               */
      __IOM uint32 CMP4       : 1;            /*!< [6..6] CMP4                                                               */
      __IOM uint32 MSTPER     : 1;            /*!< [7..7] MSTPER                                                             */
      __IOM uint32 MSTCMP1    : 1;            /*!< [8..8] MSTCMP1                                                            */
      __IOM uint32 MSTCMP2    : 1;            /*!< [9..9] MSTCMP2                                                            */
      __IOM uint32 MSTCMP3    : 1;            /*!< [10..10] MSTCMP3                                                          */
      __IOM uint32 MSTCMP4    : 1;            /*!< [11..11] MSTCMP4                                                          */
      __IOM uint32 TIMEVNT1   : 1;            /*!< [12..12] TIMEVNT1                                                         */
      __IOM uint32 TIMEVNT2   : 1;            /*!< [13..13] TIMEVNT2                                                         */
      __IOM uint32 TIMEVNT3   : 1;            /*!< [14..14] TIMEVNT3                                                         */
      __IOM uint32 TIMEVNT4   : 1;            /*!< [15..15] TIMEVNT4                                                         */
      __IOM uint32 TIMEVNT5   : 1;            /*!< [16..16] TIMEVNT5                                                         */
      __IOM uint32 TIMEVNT6   : 1;            /*!< [17..17] TIMEVNT6                                                         */
      __IOM uint32 TIMEVNT7   : 1;            /*!< [18..18] TIMEVNT7                                                         */
      __IOM uint32 TIMEVNT8   : 1;            /*!< [19..19] TIMEVNT8                                                         */
      __IOM uint32 TIMEVNT9   : 1;            /*!< [20..20] TIMEVNT9                                                         */
      __IOM uint32 EXTEVNT1   : 1;            /*!< [21..21] EXTEVNT1                                                         */
      __IOM uint32 EXTEVNT2   : 1;            /*!< [22..22] EXTEVNT2                                                         */
      __IOM uint32 EXTEVNT3   : 1;            /*!< [23..23] EXTEVNT3                                                         */
      __IOM uint32 EXTEVNT4   : 1;            /*!< [24..24] EXTEVNT4                                                         */
      __IOM uint32 EXTEVNT5   : 1;            /*!< [25..25] EXTEVNT5                                                         */
      __IOM uint32 EXTEVNT6   : 1;            /*!< [26..26] EXTEVNT6                                                         */
      __IOM uint32 EXTEVNT7   : 1;            /*!< [27..27] EXTEVNT7                                                         */
      __IOM uint32 EXTEVNT8   : 1;            /*!< [28..28] EXTEVNT8                                                         */
      __IOM uint32 EXTEVNT9   : 1;            /*!< [29..29] EXTEVNT9                                                         */
      __IOM uint32 EXTEVNT10  : 1;            /*!< [30..30] EXTEVNT10                                                        */
      __IOM uint32 UPDATE     : 1;            /*!< [31..31] UPDATE                                                           */
    } bit;
  } RSTA2R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000004C) Timerx External Event Filtering Register 1                 */
    
    struct {
      __IOM uint32 EE1LTCH    : 1;            /*!< [0..0] External Event 1 latch                                             */
      __IOM uint32 EE1FLTR    : 4;            /*!< [4..1] External Event 1 filter                                            */
            uint32            : 1;
      __IOM uint32 EE2LTCH    : 1;            /*!< [6..6] External Event 2 latch                                             */
      __IOM uint32 EE2FLTR    : 4;            /*!< [10..7] External Event 2 filter                                           */
            uint32            : 1;
      __IOM uint32 EE3LTCH    : 1;            /*!< [12..12] External Event 3 latch                                           */
      __IOM uint32 EE3FLTR    : 4;            /*!< [16..13] External Event 3 filter                                          */
            uint32            : 1;
      __IOM uint32 EE4LTCH    : 1;            /*!< [18..18] External Event 4 latch                                           */
      __IOM uint32 EE4FLTR    : 4;            /*!< [22..19] External Event 4 filter                                          */
            uint32            : 1;
      __IOM uint32 EE5LTCH    : 1;            /*!< [24..24] External Event 5 latch                                           */
      __IOM uint32 EE5FLTR    : 4;            /*!< [28..25] External Event 5 filter                                          */
            uint32            : 3;
    } bit;
  } EEFAR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000050) Timerx External Event Filtering Register 2                 */
    
    struct {
      __IOM uint32 EE6LTCH    : 1;            /*!< [0..0] External Event 6 latch                                             */
      __IOM uint32 EE6FLTR    : 4;            /*!< [4..1] External Event 6 filter                                            */
            uint32            : 1;
      __IOM uint32 EE7LTCH    : 1;            /*!< [6..6] External Event 7 latch                                             */
      __IOM uint32 EE7FLTR    : 4;            /*!< [10..7] External Event 7 filter                                           */
            uint32            : 1;
      __IOM uint32 EE8LTCH    : 1;            /*!< [12..12] External Event 8 latch                                           */
      __IOM uint32 EE8FLTR    : 4;            /*!< [16..13] External Event 8 filter                                          */
            uint32            : 1;
      __IOM uint32 EE9LTCH    : 1;            /*!< [18..18] External Event 9 latch                                           */
      __IOM uint32 EE9FLTR    : 4;            /*!< [22..19] External Event 9 filter                                          */
            uint32            : 1;
      __IOM uint32 EE10LTCH   : 1;            /*!< [24..24] External Event 10 latch                                          */
      __IOM uint32 EE10FLTR   : 4;            /*!< [28..25] External Event 10 filter                                         */
            uint32            : 3;
    } bit;
  } EEFAR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000054) TimerA Reset Register                                      */
    
    struct {
            uint32            : 1;
      __IOM uint32 UPDT       : 1;            /*!< [1..1] Timer A Update reset                                               */
      __IOM uint32 CMP2       : 1;            /*!< [2..2] Timer A compare 2 reset                                            */
      __IOM uint32 CMP4       : 1;            /*!< [3..3] Timer A compare 4 reset                                            */
      __IOM uint32 MSTPER     : 1;            /*!< [4..4] Master timer Period                                                */
      __IOM uint32 MSTCMP1    : 1;            /*!< [5..5] Master compare 1                                                   */
      __IOM uint32 MSTCMP2    : 1;            /*!< [6..6] Master compare 2                                                   */
      __IOM uint32 MSTCMP3    : 1;            /*!< [7..7] Master compare 3                                                   */
      __IOM uint32 MSTCMP4    : 1;            /*!< [8..8] Master compare 4                                                   */
      __IOM uint32 EXTEVNT1   : 1;            /*!< [9..9] External Event 1                                                   */
      __IOM uint32 EXTEVNT2   : 1;            /*!< [10..10] External Event 2                                                 */
      __IOM uint32 EXTEVNT3   : 1;            /*!< [11..11] External Event 3                                                 */
      __IOM uint32 EXTEVNT4   : 1;            /*!< [12..12] External Event 4                                                 */
      __IOM uint32 EXTEVNT5   : 1;            /*!< [13..13] External Event 5                                                 */
      __IOM uint32 EXTEVNT6   : 1;            /*!< [14..14] External Event 6                                                 */
      __IOM uint32 EXTEVNT7   : 1;            /*!< [15..15] External Event 7                                                 */
      __IOM uint32 EXTEVNT8   : 1;            /*!< [16..16] External Event 8                                                 */
      __IOM uint32 EXTEVNT9   : 1;            /*!< [17..17] External Event 9                                                 */
      __IOM uint32 EXTEVNT10  : 1;            /*!< [18..18] External Event 10                                                */
      __IOM uint32 TIMBCMP1   : 1;            /*!< [19..19] Timer B Compare 1                                                */
      __IOM uint32 TIMBCMP2   : 1;            /*!< [20..20] Timer B Compare 2                                                */
      __IOM uint32 TIMBCMP4   : 1;            /*!< [21..21] Timer B Compare 4                                                */
      __IOM uint32 TIMCCMP1   : 1;            /*!< [22..22] Timer C Compare 1                                                */
      __IOM uint32 TIMCCMP2   : 1;            /*!< [23..23] Timer C Compare 2                                                */
      __IOM uint32 TIMCCMP4   : 1;            /*!< [24..24] Timer C Compare 4                                                */
      __IOM uint32 TIMDCMP1   : 1;            /*!< [25..25] Timer D Compare 1                                                */
      __IOM uint32 TIMDCMP2   : 1;            /*!< [26..26] Timer D Compare 2                                                */
      __IOM uint32 TIMDCMP4   : 1;            /*!< [27..27] Timer D Compare 4                                                */
      __IOM uint32 TIMECMP1   : 1;            /*!< [28..28] Timer E Compare 1                                                */
      __IOM uint32 TIMECMP2   : 1;            /*!< [29..29] Timer E Compare 2                                                */
      __IOM uint32 TIMECMP4   : 1;            /*!< [30..30] Timer E Compare 4                                                */
            uint32            : 1;
    } bit;
  } RSTAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000058) Timerx Chopper Register                                    */
    
    struct {
      __IOM uint32 CHPFRQ     : 4;            /*!< [3..0] Timerx carrier frequency value                                     */
      __IOM uint32 CHPDTY     : 3;            /*!< [6..4] Timerx chopper duty cycle value                                    */
      __IOM uint32 STRTPW     : 4;            /*!< [10..7] STRTPW                                                            */
            uint32            : 21;
    } bit;
  } CHPAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000005C) Timerx Capture 2 Control Register                          */
    
    struct {
      __IOM uint32 SWCPT      : 1;            /*!< [0..0] Software Capture                                                   */
      __IOM uint32 UDPCPT     : 1;            /*!< [1..1] Update Capture                                                     */
      __IOM uint32 EXEV1CPT   : 1;            /*!< [2..2] External Event 1 Capture                                           */
      __IOM uint32 EXEV2CPT   : 1;            /*!< [3..3] External Event 2 Capture                                           */
      __IOM uint32 EXEV3CPT   : 1;            /*!< [4..4] External Event 3 Capture                                           */
      __IOM uint32 EXEV4CPT   : 1;            /*!< [5..5] External Event 4 Capture                                           */
      __IOM uint32 EXEV5CPT   : 1;            /*!< [6..6] External Event 5 Capture                                           */
      __IOM uint32 EXEV6CPT   : 1;            /*!< [7..7] External Event 6 Capture                                           */
      __IOM uint32 EXEV7CPT   : 1;            /*!< [8..8] External Event 7 Capture                                           */
      __IOM uint32 EXEV8CPT   : 1;            /*!< [9..9] External Event 8 Capture                                           */
      __IOM uint32 EXEV9CPT   : 1;            /*!< [10..10] External Event 9 Capture                                         */
      __IOM uint32 EXEV10CPT  : 1;            /*!< [11..11] External Event 10 Capture                                        */
            uint32            : 4;
      __IOM uint32 TB1SET     : 1;            /*!< [16..16] Timer B output 1 Set                                             */
      __IOM uint32 TB1RST     : 1;            /*!< [17..17] Timer B output 1 Reset                                           */
      __IOM uint32 TBCMP1     : 1;            /*!< [18..18] Timer B Compare 1                                                */
      __IOM uint32 TBCMP2     : 1;            /*!< [19..19] Timer B Compare 2                                                */
      __IOM uint32 TC1SET     : 1;            /*!< [20..20] Timer C output 1 Set                                             */
      __IOM uint32 TC1RST     : 1;            /*!< [21..21] Timer C output 1 Reset                                           */
      __IOM uint32 TCCMP1     : 1;            /*!< [22..22] Timer C Compare 1                                                */
      __IOM uint32 TCCMP2     : 1;            /*!< [23..23] Timer C Compare 2                                                */
      __IOM uint32 TD1SET     : 1;            /*!< [24..24] Timer D output 1 Set                                             */
      __IOM uint32 TD1RST     : 1;            /*!< [25..25] Timer D output 1 Reset                                           */
      __IOM uint32 TDCMP1     : 1;            /*!< [26..26] Timer D Compare 1                                                */
      __IOM uint32 TDCMP2     : 1;            /*!< [27..27] Timer D Compare 2                                                */
      __IOM uint32 TE1SET     : 1;            /*!< [28..28] Timer E output 1 Set                                             */
      __IOM uint32 TE1RST     : 1;            /*!< [29..29] Timer E output 1 Reset                                           */
      __IOM uint32 TECMP1     : 1;            /*!< [30..30] Timer E Compare 1                                                */
      __IOM uint32 TECMP2     : 1;            /*!< [31..31] Timer E Compare 2                                                */
    } bit;
  } CPT1ACR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000060) CPT2xCR                                                    */
    
    struct {
      __IOM uint32 SWCPT      : 1;            /*!< [0..0] Software Capture                                                   */
      __IOM uint32 UDPCPT     : 1;            /*!< [1..1] Update Capture                                                     */
      __IOM uint32 EXEV1CPT   : 1;            /*!< [2..2] External Event 1 Capture                                           */
      __IOM uint32 EXEV2CPT   : 1;            /*!< [3..3] External Event 2 Capture                                           */
      __IOM uint32 EXEV3CPT   : 1;            /*!< [4..4] External Event 3 Capture                                           */
      __IOM uint32 EXEV4CPT   : 1;            /*!< [5..5] External Event 4 Capture                                           */
      __IOM uint32 EXEV5CPT   : 1;            /*!< [6..6] External Event 5 Capture                                           */
      __IOM uint32 EXEV6CPT   : 1;            /*!< [7..7] External Event 6 Capture                                           */
      __IOM uint32 EXEV7CPT   : 1;            /*!< [8..8] External Event 7 Capture                                           */
      __IOM uint32 EXEV8CPT   : 1;            /*!< [9..9] External Event 8 Capture                                           */
      __IOM uint32 EXEV9CPT   : 1;            /*!< [10..10] External Event 9 Capture                                         */
      __IOM uint32 EXEV10CPT  : 1;            /*!< [11..11] External Event 10 Capture                                        */
            uint32            : 4;
      __IOM uint32 TB1SET     : 1;            /*!< [16..16] Timer B output 1 Set                                             */
      __IOM uint32 TB1RST     : 1;            /*!< [17..17] Timer B output 1 Reset                                           */
      __IOM uint32 TBCMP1     : 1;            /*!< [18..18] Timer B Compare 1                                                */
      __IOM uint32 TBCMP2     : 1;            /*!< [19..19] Timer B Compare 2                                                */
      __IOM uint32 TC1SET     : 1;            /*!< [20..20] Timer C output 1 Set                                             */
      __IOM uint32 TC1RST     : 1;            /*!< [21..21] Timer C output 1 Reset                                           */
      __IOM uint32 TCCMP1     : 1;            /*!< [22..22] Timer C Compare 1                                                */
      __IOM uint32 TCCMP2     : 1;            /*!< [23..23] Timer C Compare 2                                                */
      __IOM uint32 TD1SET     : 1;            /*!< [24..24] Timer D output 1 Set                                             */
      __IOM uint32 TD1RST     : 1;            /*!< [25..25] Timer D output 1 Reset                                           */
      __IOM uint32 TDCMP1     : 1;            /*!< [26..26] Timer D Compare 1                                                */
      __IOM uint32 TDCMP2     : 1;            /*!< [27..27] Timer D Compare 2                                                */
      __IOM uint32 TE1SET     : 1;            /*!< [28..28] Timer E output 1 Set                                             */
      __IOM uint32 TE1RST     : 1;            /*!< [29..29] Timer E output 1 Reset                                           */
      __IOM uint32 TECMP1     : 1;            /*!< [30..30] Timer E Compare 1                                                */
      __IOM uint32 TECMP2     : 1;            /*!< [31..31] Timer E Compare 2                                                */
    } bit;
  } CPT2ACR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000064) Timerx Output Register                                     */
    
    struct {
            uint32            : 1;
      __IOM uint32 POL1       : 1;            /*!< [1..1] Output 1 polarity                                                  */
      __IOM uint32 IDLEM1     : 1;            /*!< [2..2] Output 1 Idle mode                                                 */
      __IOM uint32 IDLES1     : 1;            /*!< [3..3] Output 1 Idle State                                                */
      __IOM uint32 FAULT1     : 2;            /*!< [5..4] Output 1 Fault state                                               */
      __IOM uint32 CHP1       : 1;            /*!< [6..6] Output 1 Chopper enable                                            */
      __IOM uint32 DIDL1      : 1;            /*!< [7..7] Output 1 Deadtime upon burst mode Idle entry                       */
      __IOM uint32 DTEN       : 1;            /*!< [8..8] Deadtime enable                                                    */
      __IOM uint32 DLYPRTEN   : 1;            /*!< [9..9] Delayed Protection Enable                                          */
      __IOM uint32 DLYPRT     : 3;            /*!< [12..10] Delayed Protection                                               */
            uint32            : 4;
      __IOM uint32 POL2       : 1;            /*!< [17..17] Output 2 polarity                                                */
      __IOM uint32 IDLEM2     : 1;            /*!< [18..18] Output 2 Idle mode                                               */
      __IOM uint32 IDLES2     : 1;            /*!< [19..19] Output 2 Idle State                                              */
      __IOM uint32 FAULT2     : 2;            /*!< [21..20] Output 2 Fault state                                             */
      __IOM uint32 CHP2       : 1;            /*!< [22..22] Output 2 Chopper enable                                          */
      __IOM uint32 DIDL2      : 1;            /*!< [23..23] Output 2 Deadtime upon burst mode Idle entry                     */
            uint32            : 8;
    } bit;
  } OUTAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000068) Timerx Fault Register                                      */
    
    struct {
      __IOM uint32 FLT1EN     : 1;            /*!< [0..0] Fault 1 enable                                                     */
      __IOM uint32 FLT2EN     : 1;            /*!< [1..1] Fault 2 enable                                                     */
      __IOM uint32 FLT3EN     : 1;            /*!< [2..2] Fault 3 enable                                                     */
      __IOM uint32 FLT4EN     : 1;            /*!< [3..3] Fault 4 enable                                                     */
      __IOM uint32 FLT5EN     : 1;            /*!< [4..4] Fault 5 enable                                                     */
            uint32            : 26;
      __IOM uint32 FLTLCK     : 1;            /*!< [31..31] Fault sources Lock                                               */
    } bit;
  } FLTAR;
} HRTIM_TIMA_Type;                              /*!< Size = 108 (0x6c)                                                         */



/* =========================================================================================================================== */
/* ================                                        HRTIM_TIMB                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief High Resolution Timer: TIMB (HRTIM_TIMB)
  */

typedef struct {                                /*!< (@ 0x40017500) HRTIM_TIMB Structure                                       */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) Timerx Control Register                                    */
    
    struct {
      __IOM uint32 CK_PSCx    : 3;            /*!< [2..0] HRTIM Timer x Clock prescaler                                      */
      __IOM uint32 CONT       : 1;            /*!< [3..3] Continuous mode                                                    */
      __IOM uint32 RETRIG     : 1;            /*!< [4..4] Re-triggerable mode                                                */
      __IOM uint32 HALF       : 1;            /*!< [5..5] Half mode enable                                                   */
      __IOM uint32 PSHPLL     : 1;            /*!< [6..6] Push-Pull mode enable                                              */
            uint32            : 3;
      __IOM uint32 SYNCRSTx   : 1;            /*!< [10..10] Synchronization Resets Timer x                                   */
      __IOM uint32 SYNCSTRTx  : 1;            /*!< [11..11] Synchronization Starts Timer x                                   */
      __IOM uint32 DELCMP2    : 2;            /*!< [13..12] Delayed CMP2 mode                                                */
      __IOM uint32 DELCMP4    : 2;            /*!< [15..14] Delayed CMP4 mode                                                */
            uint32            : 1;
      __IOM uint32 TxREPU     : 1;            /*!< [17..17] Timer x Repetition update                                        */
      __IOM uint32 TxRSTU     : 1;            /*!< [18..18] Timerx reset update                                              */
            uint32            : 1;
      __IOM uint32 TBU        : 1;            /*!< [20..20] TBU                                                              */
      __IOM uint32 TCU        : 1;            /*!< [21..21] TCU                                                              */
      __IOM uint32 TDU        : 1;            /*!< [22..22] TDU                                                              */
      __IOM uint32 TEU        : 1;            /*!< [23..23] TEU                                                              */
      __IOM uint32 MSTU       : 1;            /*!< [24..24] Master Timer update                                              */
      __IOM uint32 DACSYNC    : 2;            /*!< [26..25] AC Synchronization                                               */
      __IOM uint32 PREEN      : 1;            /*!< [27..27] Preload enable                                                   */
      __IOM uint32 UPDGAT     : 4;            /*!< [31..28] Update Gating                                                    */
    } bit;
  } TIMBCR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000004) Timerx Interrupt Status Register                           */
    
    struct {
      __IM  uint32 CMP1       : 1;            /*!< [0..0] Compare 1 Interrupt Flag                                           */
      __IM  uint32 CMP2       : 1;            /*!< [1..1] Compare 2 Interrupt Flag                                           */
      __IM  uint32 CMP3       : 1;            /*!< [2..2] Compare 3 Interrupt Flag                                           */
      __IM  uint32 CMP4       : 1;            /*!< [3..3] Compare 4 Interrupt Flag                                           */
      __IM  uint32 REP        : 1;            /*!< [4..4] Repetition Interrupt Flag                                          */
            uint32            : 1;
      __IM  uint32 UPD        : 1;            /*!< [6..6] Update Interrupt Flag                                              */
      __IM  uint32 CPT1       : 1;            /*!< [7..7] Capture1 Interrupt Flag                                            */
      __IM  uint32 CPT2       : 1;            /*!< [8..8] Capture2 Interrupt Flag                                            */
      __IM  uint32 SETx1      : 1;            /*!< [9..9] Output 1 Set Interrupt Flag                                        */
      __IM  uint32 RSTx1      : 1;            /*!< [10..10] Output 1 Reset Interrupt Flag                                    */
      __IM  uint32 SETx2      : 1;            /*!< [11..11] Output 2 Set Interrupt Flag                                      */
      __IM  uint32 RSTx2      : 1;            /*!< [12..12] Output 2 Reset Interrupt Flag                                    */
      __IM  uint32 RST        : 1;            /*!< [13..13] Reset Interrupt Flag                                             */
      __IM  uint32 DLYPRT     : 1;            /*!< [14..14] Delayed Protection Flag                                          */
            uint32            : 1;
      __IM  uint32 CPPSTAT    : 1;            /*!< [16..16] Current Push Pull Status                                         */
      __IM  uint32 IPPSTAT    : 1;            /*!< [17..17] Idle Push Pull Status                                            */
      __IM  uint32 O1STAT     : 1;            /*!< [18..18] Output 1 State                                                   */
      __IM  uint32 O2STAT     : 1;            /*!< [19..19] Output 2 State                                                   */
            uint32            : 12;
    } bit;
  } TIMBISR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000008) Timerx Interrupt Clear Register                            */
    
    struct {
      __OM  uint32 CMP1C      : 1;            /*!< [0..0] Compare 1 Interrupt flag Clear                                     */
      __OM  uint32 CMP2C      : 1;            /*!< [1..1] Compare 2 Interrupt flag Clear                                     */
      __OM  uint32 CMP3C      : 1;            /*!< [2..2] Compare 3 Interrupt flag Clear                                     */
      __OM  uint32 CMP4C      : 1;            /*!< [3..3] Compare 4 Interrupt flag Clear                                     */
      __OM  uint32 REPC       : 1;            /*!< [4..4] Repetition Interrupt flag Clear                                    */
            uint32            : 1;
      __OM  uint32 UPDC       : 1;            /*!< [6..6] Update Interrupt flag Clear                                        */
      __OM  uint32 CPT1C      : 1;            /*!< [7..7] Capture1 Interrupt flag Clear                                      */
      __OM  uint32 CPT2C      : 1;            /*!< [8..8] Capture2 Interrupt flag Clear                                      */
      __OM  uint32 SET1xC     : 1;            /*!< [9..9] Output 1 Set flag Clear                                            */
      __OM  uint32 RSTx1C     : 1;            /*!< [10..10] Output 1 Reset flag Clear                                        */
      __OM  uint32 SET2xC     : 1;            /*!< [11..11] Output 2 Set flag Clear                                          */
      __OM  uint32 RSTx2C     : 1;            /*!< [12..12] Output 2 Reset flag Clear                                        */
      __OM  uint32 RSTC       : 1;            /*!< [13..13] Reset Interrupt flag Clear                                       */
      __OM  uint32 DLYPRTC    : 1;            /*!< [14..14] Delayed Protection Flag Clear                                    */
            uint32            : 17;
    } bit;
  } TIMBICR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) TIMxDIER5                                                  */
    
    struct {
      __IOM uint32 CMP1IE     : 1;            /*!< [0..0] CMP1IE                                                             */
      __IOM uint32 CMP2IE     : 1;            /*!< [1..1] CMP2IE                                                             */
      __IOM uint32 CMP3IE     : 1;            /*!< [2..2] CMP3IE                                                             */
      __IOM uint32 CMP4IE     : 1;            /*!< [3..3] CMP4IE                                                             */
      __IOM uint32 REPIE      : 1;            /*!< [4..4] REPIE                                                              */
            uint32            : 1;
      __IOM uint32 UPDIE      : 1;            /*!< [6..6] UPDIE                                                              */
      __IOM uint32 CPT1IE     : 1;            /*!< [7..7] CPT1IE                                                             */
      __IOM uint32 CPT2IE     : 1;            /*!< [8..8] CPT2IE                                                             */
      __IOM uint32 SET1xIE    : 1;            /*!< [9..9] SET1xIE                                                            */
      __IOM uint32 RSTx1IE    : 1;            /*!< [10..10] RSTx1IE                                                          */
      __IOM uint32 SETx2IE    : 1;            /*!< [11..11] SETx2IE                                                          */
      __IOM uint32 RSTx2IE    : 1;            /*!< [12..12] RSTx2IE                                                          */
      __IOM uint32 RSTIE      : 1;            /*!< [13..13] RSTIE                                                            */
      __IOM uint32 DLYPRTIE   : 1;            /*!< [14..14] DLYPRTIE                                                         */
            uint32            : 1;
      __IOM uint32 CMP1DE     : 1;            /*!< [16..16] CMP1DE                                                           */
      __IOM uint32 CMP2DE     : 1;            /*!< [17..17] CMP2DE                                                           */
      __IOM uint32 CMP3DE     : 1;            /*!< [18..18] CMP3DE                                                           */
      __IOM uint32 CMP4DE     : 1;            /*!< [19..19] CMP4DE                                                           */
      __IOM uint32 REPDE      : 1;            /*!< [20..20] REPDE                                                            */
            uint32            : 1;
      __IOM uint32 UPDDE      : 1;            /*!< [22..22] UPDDE                                                            */
      __IOM uint32 CPT1DE     : 1;            /*!< [23..23] CPT1DE                                                           */
      __IOM uint32 CPT2DE     : 1;            /*!< [24..24] CPT2DE                                                           */
      __IOM uint32 SET1xDE    : 1;            /*!< [25..25] SET1xDE                                                          */
      __IOM uint32 RSTx1DE    : 1;            /*!< [26..26] RSTx1DE                                                          */
      __IOM uint32 SETx2DE    : 1;            /*!< [27..27] SETx2DE                                                          */
      __IOM uint32 RSTx2DE    : 1;            /*!< [28..28] RSTx2DE                                                          */
      __IOM uint32 RSTDE      : 1;            /*!< [29..29] RSTDE                                                            */
      __IOM uint32 DLYPRTDE   : 1;            /*!< [30..30] DLYPRTDE                                                         */
            uint32            : 1;
    } bit;
  } TIMBDIER5;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) Timerx Counter Register                                    */
    
    struct {
      __IOM uint32 CNTx       : 16;           /*!< [15..0] Timerx Counter value                                              */
            uint32            : 16;
    } bit;
  } CNTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000014) Timerx Period Register                                     */
    
    struct {
      __IOM uint32 PERx       : 16;           /*!< [15..0] Timerx Period value                                               */
            uint32            : 16;
    } bit;
  } PERBR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000018) Timerx Repetition Register                                 */
    
    struct {
      __IOM uint32 REPx       : 8;            /*!< [7..0] Timerx Repetition counter value                                    */
            uint32            : 24;
    } bit;
  } REPBR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000001C) Timerx Compare 1 Register                                  */
    
    struct {
      __IOM uint32 CMP1x      : 16;           /*!< [15..0] Timerx Compare 1 value                                            */
            uint32            : 16;
    } bit;
  } CMP1BR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000020) Timerx Compare 1 Compound Register                         */
    
    struct {
      __IOM uint32 CMP1x      : 16;           /*!< [15..0] Timerx Compare 1 value                                            */
      __IOM uint32 REPx       : 8;            /*!< [23..16] Timerx Repetition value (aliased from HRTIM_REPx register)       */
            uint32            : 8;
    } bit;
  } CMP1CBR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000024) Timerx Compare 2 Register                                  */
    
    struct {
      __IOM uint32 CMP2x      : 16;           /*!< [15..0] Timerx Compare 2 value                                            */
            uint32            : 16;
    } bit;
  } CMP2BR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000028) Timerx Compare 3 Register                                  */
    
    struct {
      __IOM uint32 CMP3x      : 16;           /*!< [15..0] Timerx Compare 3 value                                            */
            uint32            : 16;
    } bit;
  } CMP3BR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000002C) Timerx Compare 4 Register                                  */
    
    struct {
      __IOM uint32 CMP4x      : 16;           /*!< [15..0] Timerx Compare 4 value                                            */
            uint32            : 16;
    } bit;
  } CMP4BR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000030) Timerx Capture 1 Register                                  */
    
    struct {
      __IM  uint32 CPT1x      : 16;           /*!< [15..0] Timerx Capture 1 value                                            */
            uint32            : 16;
    } bit;
  } CPT1BR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000034) Timerx Capture 2 Register                                  */
    
    struct {
      __IM  uint32 CPT2x      : 16;           /*!< [15..0] Timerx Capture 2 value                                            */
            uint32            : 16;
    } bit;
  } CPT2BR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000038) Timerx Deadtime Register                                   */
    
    struct {
      __IOM uint32 DTRx       : 9;            /*!< [8..0] Deadtime Rising value                                              */
      __IOM uint32 SDTRx      : 1;            /*!< [9..9] Sign Deadtime Rising value                                         */
      __IOM uint32 DTPRSC     : 3;            /*!< [12..10] Deadtime Prescaler                                               */
            uint32            : 1;
      __IOM uint32 DTRSLKx    : 1;            /*!< [14..14] Deadtime Rising Sign Lock                                        */
      __IOM uint32 DTRLKx     : 1;            /*!< [15..15] Deadtime Rising Lock                                             */
      __IOM uint32 DTFx       : 9;            /*!< [24..16] Deadtime Falling value                                           */
      __IOM uint32 SDTFx      : 1;            /*!< [25..25] Sign Deadtime Falling value                                      */
            uint32            : 4;
      __IOM uint32 DTFSLKx    : 1;            /*!< [30..30] Deadtime Falling Sign Lock                                       */
      __IOM uint32 DTFLKx     : 1;            /*!< [31..31] Deadtime Falling Lock                                            */
    } bit;
  } DTBR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000003C) Timerx Output1 Set Register                                */
    
    struct {
      __IOM uint32 SST        : 1;            /*!< [0..0] Software Set trigger                                               */
      __IOM uint32 RESYNC     : 1;            /*!< [1..1] Timer A resynchronizaton                                           */
      __IOM uint32 PER        : 1;            /*!< [2..2] Timer A Period                                                     */
      __IOM uint32 CMP1       : 1;            /*!< [3..3] Timer A compare 1                                                  */
      __IOM uint32 CMP2       : 1;            /*!< [4..4] Timer A compare 2                                                  */
      __IOM uint32 CMP3       : 1;            /*!< [5..5] Timer A compare 3                                                  */
      __IOM uint32 CMP4       : 1;            /*!< [6..6] Timer A compare 4                                                  */
      __IOM uint32 MSTPER     : 1;            /*!< [7..7] Master Period                                                      */
      __IOM uint32 MSTCMP1    : 1;            /*!< [8..8] Master Compare 1                                                   */
      __IOM uint32 MSTCMP2    : 1;            /*!< [9..9] Master Compare 2                                                   */
      __IOM uint32 MSTCMP3    : 1;            /*!< [10..10] Master Compare 3                                                 */
      __IOM uint32 MSTCMP4    : 1;            /*!< [11..11] Master Compare 4                                                 */
      __IOM uint32 TIMEVNT1   : 1;            /*!< [12..12] Timer Event 1                                                    */
      __IOM uint32 TIMEVNT2   : 1;            /*!< [13..13] Timer Event 2                                                    */
      __IOM uint32 TIMEVNT3   : 1;            /*!< [14..14] Timer Event 3                                                    */
      __IOM uint32 TIMEVNT4   : 1;            /*!< [15..15] Timer Event 4                                                    */
      __IOM uint32 TIMEVNT5   : 1;            /*!< [16..16] Timer Event 5                                                    */
      __IOM uint32 TIMEVNT6   : 1;            /*!< [17..17] Timer Event 6                                                    */
      __IOM uint32 TIMEVNT7   : 1;            /*!< [18..18] Timer Event 7                                                    */
      __IOM uint32 TIMEVNT8   : 1;            /*!< [19..19] Timer Event 8                                                    */
      __IOM uint32 TIMEVNT9   : 1;            /*!< [20..20] Timer Event 9                                                    */
      __IOM uint32 EXTEVNT1   : 1;            /*!< [21..21] External Event 1                                                 */
      __IOM uint32 EXTEVNT2   : 1;            /*!< [22..22] External Event 2                                                 */
      __IOM uint32 EXTEVNT3   : 1;            /*!< [23..23] External Event 3                                                 */
      __IOM uint32 EXTEVNT4   : 1;            /*!< [24..24] External Event 4                                                 */
      __IOM uint32 EXTEVNT5   : 1;            /*!< [25..25] External Event 5                                                 */
      __IOM uint32 EXTEVNT6   : 1;            /*!< [26..26] External Event 6                                                 */
      __IOM uint32 EXTEVNT7   : 1;            /*!< [27..27] External Event 7                                                 */
      __IOM uint32 EXTEVNT8   : 1;            /*!< [28..28] External Event 8                                                 */
      __IOM uint32 EXTEVNT9   : 1;            /*!< [29..29] External Event 9                                                 */
      __IOM uint32 EXTEVNT10  : 1;            /*!< [30..30] External Event 10                                                */
      __IOM uint32 UPDATE     : 1;            /*!< [31..31] Registers update (transfer preload to active)                    */
    } bit;
  } SETB1R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000040) Timerx Output1 Reset Register                              */
    
    struct {
      __IOM uint32 SRT        : 1;            /*!< [0..0] SRT                                                                */
      __IOM uint32 RESYNC     : 1;            /*!< [1..1] RESYNC                                                             */
      __IOM uint32 PER        : 1;            /*!< [2..2] PER                                                                */
      __IOM uint32 CMP1       : 1;            /*!< [3..3] CMP1                                                               */
      __IOM uint32 CMP2       : 1;            /*!< [4..4] CMP2                                                               */
      __IOM uint32 CMP3       : 1;            /*!< [5..5] CMP3                                                               */
      __IOM uint32 CMP4       : 1;            /*!< [6..6] CMP4                                                               */
      __IOM uint32 MSTPER     : 1;            /*!< [7..7] MSTPER                                                             */
      __IOM uint32 MSTCMP1    : 1;            /*!< [8..8] MSTCMP1                                                            */
      __IOM uint32 MSTCMP2    : 1;            /*!< [9..9] MSTCMP2                                                            */
      __IOM uint32 MSTCMP3    : 1;            /*!< [10..10] MSTCMP3                                                          */
      __IOM uint32 MSTCMP4    : 1;            /*!< [11..11] MSTCMP4                                                          */
      __IOM uint32 TIMEVNT1   : 1;            /*!< [12..12] TIMEVNT1                                                         */
      __IOM uint32 TIMEVNT2   : 1;            /*!< [13..13] TIMEVNT2                                                         */
      __IOM uint32 TIMEVNT3   : 1;            /*!< [14..14] TIMEVNT3                                                         */
      __IOM uint32 TIMEVNT4   : 1;            /*!< [15..15] TIMEVNT4                                                         */
      __IOM uint32 TIMEVNT5   : 1;            /*!< [16..16] TIMEVNT5                                                         */
      __IOM uint32 TIMEVNT6   : 1;            /*!< [17..17] TIMEVNT6                                                         */
      __IOM uint32 TIMEVNT7   : 1;            /*!< [18..18] TIMEVNT7                                                         */
      __IOM uint32 TIMEVNT8   : 1;            /*!< [19..19] TIMEVNT8                                                         */
      __IOM uint32 TIMEVNT9   : 1;            /*!< [20..20] TIMEVNT9                                                         */
      __IOM uint32 EXTEVNT1   : 1;            /*!< [21..21] EXTEVNT1                                                         */
      __IOM uint32 EXTEVNT2   : 1;            /*!< [22..22] EXTEVNT2                                                         */
      __IOM uint32 EXTEVNT3   : 1;            /*!< [23..23] EXTEVNT3                                                         */
      __IOM uint32 EXTEVNT4   : 1;            /*!< [24..24] EXTEVNT4                                                         */
      __IOM uint32 EXTEVNT5   : 1;            /*!< [25..25] EXTEVNT5                                                         */
      __IOM uint32 EXTEVNT6   : 1;            /*!< [26..26] EXTEVNT6                                                         */
      __IOM uint32 EXTEVNT7   : 1;            /*!< [27..27] EXTEVNT7                                                         */
      __IOM uint32 EXTEVNT8   : 1;            /*!< [28..28] EXTEVNT8                                                         */
      __IOM uint32 EXTEVNT9   : 1;            /*!< [29..29] EXTEVNT9                                                         */
      __IOM uint32 EXTEVNT10  : 1;            /*!< [30..30] EXTEVNT10                                                        */
      __IOM uint32 UPDATE     : 1;            /*!< [31..31] UPDATE                                                           */
    } bit;
  } RSTB1R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000044) Timerx Output2 Set Register                                */
    
    struct {
      __IOM uint32 SST        : 1;            /*!< [0..0] SST                                                                */
      __IOM uint32 RESYNC     : 1;            /*!< [1..1] RESYNC                                                             */
      __IOM uint32 PER        : 1;            /*!< [2..2] PER                                                                */
      __IOM uint32 CMP1       : 1;            /*!< [3..3] CMP1                                                               */
      __IOM uint32 CMP2       : 1;            /*!< [4..4] CMP2                                                               */
      __IOM uint32 CMP3       : 1;            /*!< [5..5] CMP3                                                               */
      __IOM uint32 CMP4       : 1;            /*!< [6..6] CMP4                                                               */
      __IOM uint32 MSTPER     : 1;            /*!< [7..7] MSTPER                                                             */
      __IOM uint32 MSTCMP1    : 1;            /*!< [8..8] MSTCMP1                                                            */
      __IOM uint32 MSTCMP2    : 1;            /*!< [9..9] MSTCMP2                                                            */
      __IOM uint32 MSTCMP3    : 1;            /*!< [10..10] MSTCMP3                                                          */
      __IOM uint32 MSTCMP4    : 1;            /*!< [11..11] MSTCMP4                                                          */
      __IOM uint32 TIMEVNT1   : 1;            /*!< [12..12] TIMEVNT1                                                         */
      __IOM uint32 TIMEVNT2   : 1;            /*!< [13..13] TIMEVNT2                                                         */
      __IOM uint32 TIMEVNT3   : 1;            /*!< [14..14] TIMEVNT3                                                         */
      __IOM uint32 TIMEVNT4   : 1;            /*!< [15..15] TIMEVNT4                                                         */
      __IOM uint32 TIMEVNT5   : 1;            /*!< [16..16] TIMEVNT5                                                         */
      __IOM uint32 TIMEVNT6   : 1;            /*!< [17..17] TIMEVNT6                                                         */
      __IOM uint32 TIMEVNT7   : 1;            /*!< [18..18] TIMEVNT7                                                         */
      __IOM uint32 TIMEVNT8   : 1;            /*!< [19..19] TIMEVNT8                                                         */
      __IOM uint32 TIMEVNT9   : 1;            /*!< [20..20] TIMEVNT9                                                         */
      __IOM uint32 EXTEVNT1   : 1;            /*!< [21..21] EXTEVNT1                                                         */
      __IOM uint32 EXTEVNT2   : 1;            /*!< [22..22] EXTEVNT2                                                         */
      __IOM uint32 EXTEVNT3   : 1;            /*!< [23..23] EXTEVNT3                                                         */
      __IOM uint32 EXTEVNT4   : 1;            /*!< [24..24] EXTEVNT4                                                         */
      __IOM uint32 EXTEVNT5   : 1;            /*!< [25..25] EXTEVNT5                                                         */
      __IOM uint32 EXTEVNT6   : 1;            /*!< [26..26] EXTEVNT6                                                         */
      __IOM uint32 EXTEVNT7   : 1;            /*!< [27..27] EXTEVNT7                                                         */
      __IOM uint32 EXTEVNT8   : 1;            /*!< [28..28] EXTEVNT8                                                         */
      __IOM uint32 EXTEVNT9   : 1;            /*!< [29..29] EXTEVNT9                                                         */
      __IOM uint32 EXTEVNT10  : 1;            /*!< [30..30] EXTEVNT10                                                        */
      __IOM uint32 UPDATE     : 1;            /*!< [31..31] UPDATE                                                           */
    } bit;
  } SETB2R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000048) Timerx Output2 Reset Register                              */
    
    struct {
      __IOM uint32 SRT        : 1;            /*!< [0..0] SRT                                                                */
      __IOM uint32 RESYNC     : 1;            /*!< [1..1] RESYNC                                                             */
      __IOM uint32 PER        : 1;            /*!< [2..2] PER                                                                */
      __IOM uint32 CMP1       : 1;            /*!< [3..3] CMP1                                                               */
      __IOM uint32 CMP2       : 1;            /*!< [4..4] CMP2                                                               */
      __IOM uint32 CMP3       : 1;            /*!< [5..5] CMP3                                                               */
      __IOM uint32 CMP4       : 1;            /*!< [6..6] CMP4                                                               */
      __IOM uint32 MSTPER     : 1;            /*!< [7..7] MSTPER                                                             */
      __IOM uint32 MSTCMP1    : 1;            /*!< [8..8] MSTCMP1                                                            */
      __IOM uint32 MSTCMP2    : 1;            /*!< [9..9] MSTCMP2                                                            */
      __IOM uint32 MSTCMP3    : 1;            /*!< [10..10] MSTCMP3                                                          */
      __IOM uint32 MSTCMP4    : 1;            /*!< [11..11] MSTCMP4                                                          */
      __IOM uint32 TIMEVNT1   : 1;            /*!< [12..12] TIMEVNT1                                                         */
      __IOM uint32 TIMEVNT2   : 1;            /*!< [13..13] TIMEVNT2                                                         */
      __IOM uint32 TIMEVNT3   : 1;            /*!< [14..14] TIMEVNT3                                                         */
      __IOM uint32 TIMEVNT4   : 1;            /*!< [15..15] TIMEVNT4                                                         */
      __IOM uint32 TIMEVNT5   : 1;            /*!< [16..16] TIMEVNT5                                                         */
      __IOM uint32 TIMEVNT6   : 1;            /*!< [17..17] TIMEVNT6                                                         */
      __IOM uint32 TIMEVNT7   : 1;            /*!< [18..18] TIMEVNT7                                                         */
      __IOM uint32 TIMEVNT8   : 1;            /*!< [19..19] TIMEVNT8                                                         */
      __IOM uint32 TIMEVNT9   : 1;            /*!< [20..20] TIMEVNT9                                                         */
      __IOM uint32 EXTEVNT1   : 1;            /*!< [21..21] EXTEVNT1                                                         */
      __IOM uint32 EXTEVNT2   : 1;            /*!< [22..22] EXTEVNT2                                                         */
      __IOM uint32 EXTEVNT3   : 1;            /*!< [23..23] EXTEVNT3                                                         */
      __IOM uint32 EXTEVNT4   : 1;            /*!< [24..24] EXTEVNT4                                                         */
      __IOM uint32 EXTEVNT5   : 1;            /*!< [25..25] EXTEVNT5                                                         */
      __IOM uint32 EXTEVNT6   : 1;            /*!< [26..26] EXTEVNT6                                                         */
      __IOM uint32 EXTEVNT7   : 1;            /*!< [27..27] EXTEVNT7                                                         */
      __IOM uint32 EXTEVNT8   : 1;            /*!< [28..28] EXTEVNT8                                                         */
      __IOM uint32 EXTEVNT9   : 1;            /*!< [29..29] EXTEVNT9                                                         */
      __IOM uint32 EXTEVNT10  : 1;            /*!< [30..30] EXTEVNT10                                                        */
      __IOM uint32 UPDATE     : 1;            /*!< [31..31] UPDATE                                                           */
    } bit;
  } RSTB2R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000004C) Timerx External Event Filtering Register 1                 */
    
    struct {
      __IOM uint32 EE1LTCH    : 1;            /*!< [0..0] External Event 1 latch                                             */
      __IOM uint32 EE1FLTR    : 4;            /*!< [4..1] External Event 1 filter                                            */
            uint32            : 1;
      __IOM uint32 EE2LTCH    : 1;            /*!< [6..6] External Event 2 latch                                             */
      __IOM uint32 EE2FLTR    : 4;            /*!< [10..7] External Event 2 filter                                           */
            uint32            : 1;
      __IOM uint32 EE3LTCH    : 1;            /*!< [12..12] External Event 3 latch                                           */
      __IOM uint32 EE3FLTR    : 4;            /*!< [16..13] External Event 3 filter                                          */
            uint32            : 1;
      __IOM uint32 EE4LTCH    : 1;            /*!< [18..18] External Event 4 latch                                           */
      __IOM uint32 EE4FLTR    : 4;            /*!< [22..19] External Event 4 filter                                          */
            uint32            : 1;
      __IOM uint32 EE5LTCH    : 1;            /*!< [24..24] External Event 5 latch                                           */
      __IOM uint32 EE5FLTR    : 4;            /*!< [28..25] External Event 5 filter                                          */
            uint32            : 3;
    } bit;
  } EEFBR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000050) Timerx External Event Filtering Register 2                 */
    
    struct {
      __IOM uint32 EE6LTCH    : 1;            /*!< [0..0] External Event 6 latch                                             */
      __IOM uint32 EE6FLTR    : 4;            /*!< [4..1] External Event 6 filter                                            */
            uint32            : 1;
      __IOM uint32 EE7LTCH    : 1;            /*!< [6..6] External Event 7 latch                                             */
      __IOM uint32 EE7FLTR    : 4;            /*!< [10..7] External Event 7 filter                                           */
            uint32            : 1;
      __IOM uint32 EE8LTCH    : 1;            /*!< [12..12] External Event 8 latch                                           */
      __IOM uint32 EE8FLTR    : 4;            /*!< [16..13] External Event 8 filter                                          */
            uint32            : 1;
      __IOM uint32 EE9LTCH    : 1;            /*!< [18..18] External Event 9 latch                                           */
      __IOM uint32 EE9FLTR    : 4;            /*!< [22..19] External Event 9 filter                                          */
            uint32            : 1;
      __IOM uint32 EE10LTCH   : 1;            /*!< [24..24] External Event 10 latch                                          */
      __IOM uint32 EE10FLTR   : 4;            /*!< [28..25] External Event 10 filter                                         */
            uint32            : 3;
    } bit;
  } EEFBR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000054) TimerA Reset Register                                      */
    
    struct {
            uint32            : 1;
      __IOM uint32 UPDT       : 1;            /*!< [1..1] Timer A Update reset                                               */
      __IOM uint32 CMP2       : 1;            /*!< [2..2] Timer A compare 2 reset                                            */
      __IOM uint32 CMP4       : 1;            /*!< [3..3] Timer A compare 4 reset                                            */
      __IOM uint32 MSTPER     : 1;            /*!< [4..4] Master timer Period                                                */
      __IOM uint32 MSTCMP1    : 1;            /*!< [5..5] Master compare 1                                                   */
      __IOM uint32 MSTCMP2    : 1;            /*!< [6..6] Master compare 2                                                   */
      __IOM uint32 MSTCMP3    : 1;            /*!< [7..7] Master compare 3                                                   */
      __IOM uint32 MSTCMP4    : 1;            /*!< [8..8] Master compare 4                                                   */
      __IOM uint32 EXTEVNT1   : 1;            /*!< [9..9] External Event 1                                                   */
      __IOM uint32 EXTEVNT2   : 1;            /*!< [10..10] External Event 2                                                 */
      __IOM uint32 EXTEVNT3   : 1;            /*!< [11..11] External Event 3                                                 */
      __IOM uint32 EXTEVNT4   : 1;            /*!< [12..12] External Event 4                                                 */
      __IOM uint32 EXTEVNT5   : 1;            /*!< [13..13] External Event 5                                                 */
      __IOM uint32 EXTEVNT6   : 1;            /*!< [14..14] External Event 6                                                 */
      __IOM uint32 EXTEVNT7   : 1;            /*!< [15..15] External Event 7                                                 */
      __IOM uint32 EXTEVNT8   : 1;            /*!< [16..16] External Event 8                                                 */
      __IOM uint32 EXTEVNT9   : 1;            /*!< [17..17] External Event 9                                                 */
      __IOM uint32 EXTEVNT10  : 1;            /*!< [18..18] External Event 10                                                */
      __IOM uint32 TIMACMP1   : 1;            /*!< [19..19] Timer A Compare 1                                                */
      __IOM uint32 TIMACMP2   : 1;            /*!< [20..20] Timer A Compare 2                                                */
      __IOM uint32 TIMACMP4   : 1;            /*!< [21..21] Timer A Compare 4                                                */
      __IOM uint32 TIMCCMP1   : 1;            /*!< [22..22] Timer C Compare 1                                                */
      __IOM uint32 TIMCCMP2   : 1;            /*!< [23..23] Timer C Compare 2                                                */
      __IOM uint32 TIMCCMP4   : 1;            /*!< [24..24] Timer C Compare 4                                                */
      __IOM uint32 TIMDCMP1   : 1;            /*!< [25..25] Timer D Compare 1                                                */
      __IOM uint32 TIMDCMP2   : 1;            /*!< [26..26] Timer D Compare 2                                                */
      __IOM uint32 TIMDCMP4   : 1;            /*!< [27..27] Timer D Compare 4                                                */
      __IOM uint32 TIMECMP1   : 1;            /*!< [28..28] Timer E Compare 1                                                */
      __IOM uint32 TIMECMP2   : 1;            /*!< [29..29] Timer E Compare 2                                                */
      __IOM uint32 TIMECMP4   : 1;            /*!< [30..30] Timer E Compare 4                                                */
            uint32            : 1;
    } bit;
  } RSTBR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000058) Timerx Chopper Register                                    */
    
    struct {
      __IOM uint32 CHPFRQ     : 4;            /*!< [3..0] Timerx carrier frequency value                                     */
      __IOM uint32 CHPDTY     : 3;            /*!< [6..4] Timerx chopper duty cycle value                                    */
      __IOM uint32 STRTPW     : 4;            /*!< [10..7] STRTPW                                                            */
            uint32            : 21;
    } bit;
  } CHPBR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000005C) Timerx Capture 2 Control Register                          */
    
    struct {
      __IOM uint32 SWCPT      : 1;            /*!< [0..0] Software Capture                                                   */
      __IOM uint32 UDPCPT     : 1;            /*!< [1..1] Update Capture                                                     */
      __IOM uint32 EXEV1CPT   : 1;            /*!< [2..2] External Event 1 Capture                                           */
      __IOM uint32 EXEV2CPT   : 1;            /*!< [3..3] External Event 2 Capture                                           */
      __IOM uint32 EXEV3CPT   : 1;            /*!< [4..4] External Event 3 Capture                                           */
      __IOM uint32 EXEV4CPT   : 1;            /*!< [5..5] External Event 4 Capture                                           */
      __IOM uint32 EXEV5CPT   : 1;            /*!< [6..6] External Event 5 Capture                                           */
      __IOM uint32 EXEV6CPT   : 1;            /*!< [7..7] External Event 6 Capture                                           */
      __IOM uint32 EXEV7CPT   : 1;            /*!< [8..8] External Event 7 Capture                                           */
      __IOM uint32 EXEV8CPT   : 1;            /*!< [9..9] External Event 8 Capture                                           */
      __IOM uint32 EXEV9CPT   : 1;            /*!< [10..10] External Event 9 Capture                                         */
      __IOM uint32 EXEV10CPT  : 1;            /*!< [11..11] External Event 10 Capture                                        */
      __IOM uint32 TA1SET     : 1;            /*!< [12..12] Timer A output 1 Set                                             */
      __IOM uint32 TA1RST     : 1;            /*!< [13..13] Timer A output 1 Reset                                           */
      __IOM uint32 TACMP1     : 1;            /*!< [14..14] Timer A Compare 1                                                */
      __IOM uint32 TACMP2     : 1;            /*!< [15..15] Timer A Compare 2                                                */
            uint32            : 4;
      __IOM uint32 TC1SET     : 1;            /*!< [20..20] Timer C output 1 Set                                             */
      __IOM uint32 TC1RST     : 1;            /*!< [21..21] Timer C output 1 Reset                                           */
      __IOM uint32 TCCMP1     : 1;            /*!< [22..22] Timer C Compare 1                                                */
      __IOM uint32 TCCMP2     : 1;            /*!< [23..23] Timer C Compare 2                                                */
      __IOM uint32 TD1SET     : 1;            /*!< [24..24] Timer D output 1 Set                                             */
      __IOM uint32 TD1RST     : 1;            /*!< [25..25] Timer D output 1 Reset                                           */
      __IOM uint32 TDCMP1     : 1;            /*!< [26..26] Timer D Compare 1                                                */
      __IOM uint32 TDCMP2     : 1;            /*!< [27..27] Timer D Compare 2                                                */
      __IOM uint32 TE1SET     : 1;            /*!< [28..28] Timer E output 1 Set                                             */
      __IOM uint32 TE1RST     : 1;            /*!< [29..29] Timer E output 1 Reset                                           */
      __IOM uint32 TECMP1     : 1;            /*!< [30..30] Timer E Compare 1                                                */
      __IOM uint32 TECMP2     : 1;            /*!< [31..31] Timer E Compare 2                                                */
    } bit;
  } CPT1BCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000060) CPT2xCR                                                    */
    
    struct {
      __IOM uint32 SWCPT      : 1;            /*!< [0..0] Software Capture                                                   */
      __IOM uint32 UDPCPT     : 1;            /*!< [1..1] Update Capture                                                     */
      __IOM uint32 EXEV1CPT   : 1;            /*!< [2..2] External Event 1 Capture                                           */
      __IOM uint32 EXEV2CPT   : 1;            /*!< [3..3] External Event 2 Capture                                           */
      __IOM uint32 EXEV3CPT   : 1;            /*!< [4..4] External Event 3 Capture                                           */
      __IOM uint32 EXEV4CPT   : 1;            /*!< [5..5] External Event 4 Capture                                           */
      __IOM uint32 EXEV5CPT   : 1;            /*!< [6..6] External Event 5 Capture                                           */
      __IOM uint32 EXEV6CPT   : 1;            /*!< [7..7] External Event 6 Capture                                           */
      __IOM uint32 EXEV7CPT   : 1;            /*!< [8..8] External Event 7 Capture                                           */
      __IOM uint32 EXEV8CPT   : 1;            /*!< [9..9] External Event 8 Capture                                           */
      __IOM uint32 EXEV9CPT   : 1;            /*!< [10..10] External Event 9 Capture                                         */
      __IOM uint32 EXEV10CPT  : 1;            /*!< [11..11] External Event 10 Capture                                        */
      __IOM uint32 TA1SET     : 1;            /*!< [12..12] Timer A output 1 Set                                             */
      __IOM uint32 TA1RST     : 1;            /*!< [13..13] Timer A output 1 Reset                                           */
      __IOM uint32 TACMP1     : 1;            /*!< [14..14] Timer A Compare 1                                                */
      __IOM uint32 TACMP2     : 1;            /*!< [15..15] Timer A Compare 2                                                */
            uint32            : 4;
      __IOM uint32 TC1SET     : 1;            /*!< [20..20] Timer C output 1 Set                                             */
      __IOM uint32 TC1RST     : 1;            /*!< [21..21] Timer C output 1 Reset                                           */
      __IOM uint32 TCCMP1     : 1;            /*!< [22..22] Timer C Compare 1                                                */
      __IOM uint32 TCCMP2     : 1;            /*!< [23..23] Timer C Compare 2                                                */
      __IOM uint32 TD1SET     : 1;            /*!< [24..24] Timer D output 1 Set                                             */
      __IOM uint32 TD1RST     : 1;            /*!< [25..25] Timer D output 1 Reset                                           */
      __IOM uint32 TDCMP1     : 1;            /*!< [26..26] Timer D Compare 1                                                */
      __IOM uint32 TDCMP2     : 1;            /*!< [27..27] Timer D Compare 2                                                */
      __IOM uint32 TE1SET     : 1;            /*!< [28..28] Timer E output 1 Set                                             */
      __IOM uint32 TE1RST     : 1;            /*!< [29..29] Timer E output 1 Reset                                           */
      __IOM uint32 TECMP1     : 1;            /*!< [30..30] Timer E Compare 1                                                */
      __IOM uint32 TECMP2     : 1;            /*!< [31..31] Timer E Compare 2                                                */
    } bit;
  } CPT2BCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000064) Timerx Output Register                                     */
    
    struct {
            uint32            : 1;
      __IOM uint32 POL1       : 1;            /*!< [1..1] Output 1 polarity                                                  */
      __IOM uint32 IDLEM1     : 1;            /*!< [2..2] Output 1 Idle mode                                                 */
      __IOM uint32 IDLES1     : 1;            /*!< [3..3] Output 1 Idle State                                                */
      __IOM uint32 FAULT1     : 2;            /*!< [5..4] Output 1 Fault state                                               */
      __IOM uint32 CHP1       : 1;            /*!< [6..6] Output 1 Chopper enable                                            */
      __IOM uint32 DIDL1      : 1;            /*!< [7..7] Output 1 Deadtime upon burst mode Idle entry                       */
      __IOM uint32 DTEN       : 1;            /*!< [8..8] Deadtime enable                                                    */
      __IOM uint32 DLYPRTEN   : 1;            /*!< [9..9] Delayed Protection Enable                                          */
      __IOM uint32 DLYPRT     : 3;            /*!< [12..10] Delayed Protection                                               */
            uint32            : 4;
      __IOM uint32 POL2       : 1;            /*!< [17..17] Output 2 polarity                                                */
      __IOM uint32 IDLEM2     : 1;            /*!< [18..18] Output 2 Idle mode                                               */
      __IOM uint32 IDLES2     : 1;            /*!< [19..19] Output 2 Idle State                                              */
      __IOM uint32 FAULT2     : 2;            /*!< [21..20] Output 2 Fault state                                             */
      __IOM uint32 CHP2       : 1;            /*!< [22..22] Output 2 Chopper enable                                          */
      __IOM uint32 DIDL2      : 1;            /*!< [23..23] Output 2 Deadtime upon burst mode Idle entry                     */
            uint32            : 8;
    } bit;
  } OUTBR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000068) Timerx Fault Register                                      */
    
    struct {
      __IOM uint32 FLT1EN     : 1;            /*!< [0..0] Fault 1 enable                                                     */
      __IOM uint32 FLT2EN     : 1;            /*!< [1..1] Fault 2 enable                                                     */
      __IOM uint32 FLT3EN     : 1;            /*!< [2..2] Fault 3 enable                                                     */
      __IOM uint32 FLT4EN     : 1;            /*!< [3..3] Fault 4 enable                                                     */
      __IOM uint32 FLT5EN     : 1;            /*!< [4..4] Fault 5 enable                                                     */
            uint32            : 26;
      __IOM uint32 FLTLCK     : 1;            /*!< [31..31] Fault sources Lock                                               */
    } bit;
  } FLTBR;
} HRTIM_TIMB_Type;                              /*!< Size = 108 (0x6c)                                                         */



/* =========================================================================================================================== */
/* ================                                        HRTIM_TIMC                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief High Resolution Timer: TIMC (HRTIM_TIMC)
  */

typedef struct {                                /*!< (@ 0x40017580) HRTIM_TIMC Structure                                       */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) Timerx Control Register                                    */
    
    struct {
      __IOM uint32 CK_PSCx    : 3;            /*!< [2..0] HRTIM Timer x Clock prescaler                                      */
      __IOM uint32 CONT       : 1;            /*!< [3..3] Continuous mode                                                    */
      __IOM uint32 RETRIG     : 1;            /*!< [4..4] Re-triggerable mode                                                */
      __IOM uint32 HALF       : 1;            /*!< [5..5] Half mode enable                                                   */
      __IOM uint32 PSHPLL     : 1;            /*!< [6..6] Push-Pull mode enable                                              */
            uint32            : 3;
      __IOM uint32 SYNCRSTx   : 1;            /*!< [10..10] Synchronization Resets Timer x                                   */
      __IOM uint32 SYNCSTRTx  : 1;            /*!< [11..11] Synchronization Starts Timer x                                   */
      __IOM uint32 DELCMP2    : 2;            /*!< [13..12] Delayed CMP2 mode                                                */
      __IOM uint32 DELCMP4    : 2;            /*!< [15..14] Delayed CMP4 mode                                                */
            uint32            : 1;
      __IOM uint32 TxREPU     : 1;            /*!< [17..17] Timer x Repetition update                                        */
      __IOM uint32 TxRSTU     : 1;            /*!< [18..18] Timerx reset update                                              */
            uint32            : 1;
      __IOM uint32 TBU        : 1;            /*!< [20..20] TBU                                                              */
      __IOM uint32 TCU        : 1;            /*!< [21..21] TCU                                                              */
      __IOM uint32 TDU        : 1;            /*!< [22..22] TDU                                                              */
      __IOM uint32 TEU        : 1;            /*!< [23..23] TEU                                                              */
      __IOM uint32 MSTU       : 1;            /*!< [24..24] Master Timer update                                              */
      __IOM uint32 DACSYNC    : 2;            /*!< [26..25] AC Synchronization                                               */
      __IOM uint32 PREEN      : 1;            /*!< [27..27] Preload enable                                                   */
      __IOM uint32 UPDGAT     : 4;            /*!< [31..28] Update Gating                                                    */
    } bit;
  } TIMCCR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000004) Timerx Interrupt Status Register                           */
    
    struct {
      __IM  uint32 CMP1       : 1;            /*!< [0..0] Compare 1 Interrupt Flag                                           */
      __IM  uint32 CMP2       : 1;            /*!< [1..1] Compare 2 Interrupt Flag                                           */
      __IM  uint32 CMP3       : 1;            /*!< [2..2] Compare 3 Interrupt Flag                                           */
      __IM  uint32 CMP4       : 1;            /*!< [3..3] Compare 4 Interrupt Flag                                           */
      __IM  uint32 REP        : 1;            /*!< [4..4] Repetition Interrupt Flag                                          */
            uint32            : 1;
      __IM  uint32 UPD        : 1;            /*!< [6..6] Update Interrupt Flag                                              */
      __IM  uint32 CPT1       : 1;            /*!< [7..7] Capture1 Interrupt Flag                                            */
      __IM  uint32 CPT2       : 1;            /*!< [8..8] Capture2 Interrupt Flag                                            */
      __IM  uint32 SETx1      : 1;            /*!< [9..9] Output 1 Set Interrupt Flag                                        */
      __IM  uint32 RSTx1      : 1;            /*!< [10..10] Output 1 Reset Interrupt Flag                                    */
      __IM  uint32 SETx2      : 1;            /*!< [11..11] Output 2 Set Interrupt Flag                                      */
      __IM  uint32 RSTx2      : 1;            /*!< [12..12] Output 2 Reset Interrupt Flag                                    */
      __IM  uint32 RST        : 1;            /*!< [13..13] Reset Interrupt Flag                                             */
      __IM  uint32 DLYPRT     : 1;            /*!< [14..14] Delayed Protection Flag                                          */
            uint32            : 1;
      __IM  uint32 CPPSTAT    : 1;            /*!< [16..16] Current Push Pull Status                                         */
      __IM  uint32 IPPSTAT    : 1;            /*!< [17..17] Idle Push Pull Status                                            */
      __IM  uint32 O1STAT     : 1;            /*!< [18..18] Output 1 State                                                   */
      __IM  uint32 O2STAT     : 1;            /*!< [19..19] Output 2 State                                                   */
            uint32            : 12;
    } bit;
  } TIMCISR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000008) Timerx Interrupt Clear Register                            */
    
    struct {
      __OM  uint32 CMP1C      : 1;            /*!< [0..0] Compare 1 Interrupt flag Clear                                     */
      __OM  uint32 CMP2C      : 1;            /*!< [1..1] Compare 2 Interrupt flag Clear                                     */
      __OM  uint32 CMP3C      : 1;            /*!< [2..2] Compare 3 Interrupt flag Clear                                     */
      __OM  uint32 CMP4C      : 1;            /*!< [3..3] Compare 4 Interrupt flag Clear                                     */
      __OM  uint32 REPC       : 1;            /*!< [4..4] Repetition Interrupt flag Clear                                    */
            uint32            : 1;
      __OM  uint32 UPDC       : 1;            /*!< [6..6] Update Interrupt flag Clear                                        */
      __OM  uint32 CPT1C      : 1;            /*!< [7..7] Capture1 Interrupt flag Clear                                      */
      __OM  uint32 CPT2C      : 1;            /*!< [8..8] Capture2 Interrupt flag Clear                                      */
      __OM  uint32 SET1xC     : 1;            /*!< [9..9] Output 1 Set flag Clear                                            */
      __OM  uint32 RSTx1C     : 1;            /*!< [10..10] Output 1 Reset flag Clear                                        */
      __OM  uint32 SET2xC     : 1;            /*!< [11..11] Output 2 Set flag Clear                                          */
      __OM  uint32 RSTx2C     : 1;            /*!< [12..12] Output 2 Reset flag Clear                                        */
      __OM  uint32 RSTC       : 1;            /*!< [13..13] Reset Interrupt flag Clear                                       */
      __OM  uint32 DLYPRTC    : 1;            /*!< [14..14] Delayed Protection Flag Clear                                    */
            uint32            : 17;
    } bit;
  } TIMCICR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) TIMxDIER5                                                  */
    
    struct {
      __IOM uint32 CMP1IE     : 1;            /*!< [0..0] CMP1IE                                                             */
      __IOM uint32 CMP2IE     : 1;            /*!< [1..1] CMP2IE                                                             */
      __IOM uint32 CMP3IE     : 1;            /*!< [2..2] CMP3IE                                                             */
      __IOM uint32 CMP4IE     : 1;            /*!< [3..3] CMP4IE                                                             */
      __IOM uint32 REPIE      : 1;            /*!< [4..4] REPIE                                                              */
            uint32            : 1;
      __IOM uint32 UPDIE      : 1;            /*!< [6..6] UPDIE                                                              */
      __IOM uint32 CPT1IE     : 1;            /*!< [7..7] CPT1IE                                                             */
      __IOM uint32 CPT2IE     : 1;            /*!< [8..8] CPT2IE                                                             */
      __IOM uint32 SET1xIE    : 1;            /*!< [9..9] SET1xIE                                                            */
      __IOM uint32 RSTx1IE    : 1;            /*!< [10..10] RSTx1IE                                                          */
      __IOM uint32 SETx2IE    : 1;            /*!< [11..11] SETx2IE                                                          */
      __IOM uint32 RSTx2IE    : 1;            /*!< [12..12] RSTx2IE                                                          */
      __IOM uint32 RSTIE      : 1;            /*!< [13..13] RSTIE                                                            */
      __IOM uint32 DLYPRTIE   : 1;            /*!< [14..14] DLYPRTIE                                                         */
            uint32            : 1;
      __IOM uint32 CMP1DE     : 1;            /*!< [16..16] CMP1DE                                                           */
      __IOM uint32 CMP2DE     : 1;            /*!< [17..17] CMP2DE                                                           */
      __IOM uint32 CMP3DE     : 1;            /*!< [18..18] CMP3DE                                                           */
      __IOM uint32 CMP4DE     : 1;            /*!< [19..19] CMP4DE                                                           */
      __IOM uint32 REPDE      : 1;            /*!< [20..20] REPDE                                                            */
            uint32            : 1;
      __IOM uint32 UPDDE      : 1;            /*!< [22..22] UPDDE                                                            */
      __IOM uint32 CPT1DE     : 1;            /*!< [23..23] CPT1DE                                                           */
      __IOM uint32 CPT2DE     : 1;            /*!< [24..24] CPT2DE                                                           */
      __IOM uint32 SET1xDE    : 1;            /*!< [25..25] SET1xDE                                                          */
      __IOM uint32 RSTx1DE    : 1;            /*!< [26..26] RSTx1DE                                                          */
      __IOM uint32 SETx2DE    : 1;            /*!< [27..27] SETx2DE                                                          */
      __IOM uint32 RSTx2DE    : 1;            /*!< [28..28] RSTx2DE                                                          */
      __IOM uint32 RSTDE      : 1;            /*!< [29..29] RSTDE                                                            */
      __IOM uint32 DLYPRTDE   : 1;            /*!< [30..30] DLYPRTDE                                                         */
            uint32            : 1;
    } bit;
  } TIMCDIER5;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) Timerx Counter Register                                    */
    
    struct {
      __IOM uint32 CNTx       : 16;           /*!< [15..0] Timerx Counter value                                              */
            uint32            : 16;
    } bit;
  } CNTCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000014) Timerx Period Register                                     */
    
    struct {
      __IOM uint32 PERx       : 16;           /*!< [15..0] Timerx Period value                                               */
            uint32            : 16;
    } bit;
  } PERCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000018) Timerx Repetition Register                                 */
    
    struct {
      __IOM uint32 REPx       : 8;            /*!< [7..0] Timerx Repetition counter value                                    */
            uint32            : 24;
    } bit;
  } REPCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000001C) Timerx Compare 1 Register                                  */
    
    struct {
      __IOM uint32 CMP1x      : 16;           /*!< [15..0] Timerx Compare 1 value                                            */
            uint32            : 16;
    } bit;
  } CMP1CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000020) Timerx Compare 1 Compound Register                         */
    
    struct {
      __IOM uint32 CMP1x      : 16;           /*!< [15..0] Timerx Compare 1 value                                            */
      __IOM uint32 REPx       : 8;            /*!< [23..16] Timerx Repetition value (aliased from HRTIM_REPx register)       */
            uint32            : 8;
    } bit;
  } CMP1CCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000024) Timerx Compare 2 Register                                  */
    
    struct {
      __IOM uint32 CMP2x      : 16;           /*!< [15..0] Timerx Compare 2 value                                            */
            uint32            : 16;
    } bit;
  } CMP2CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000028) Timerx Compare 3 Register                                  */
    
    struct {
      __IOM uint32 CMP3x      : 16;           /*!< [15..0] Timerx Compare 3 value                                            */
            uint32            : 16;
    } bit;
  } CMP3CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000002C) Timerx Compare 4 Register                                  */
    
    struct {
      __IOM uint32 CMP4x      : 16;           /*!< [15..0] Timerx Compare 4 value                                            */
            uint32            : 16;
    } bit;
  } CMP4CR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000030) Timerx Capture 1 Register                                  */
    
    struct {
      __IM  uint32 CPT1x      : 16;           /*!< [15..0] Timerx Capture 1 value                                            */
            uint32            : 16;
    } bit;
  } CPT1CR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000034) Timerx Capture 2 Register                                  */
    
    struct {
      __IM  uint32 CPT2x      : 16;           /*!< [15..0] Timerx Capture 2 value                                            */
            uint32            : 16;
    } bit;
  } CPT2CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000038) Timerx Deadtime Register                                   */
    
    struct {
      __IOM uint32 DTRx       : 9;            /*!< [8..0] Deadtime Rising value                                              */
      __IOM uint32 SDTRx      : 1;            /*!< [9..9] Sign Deadtime Rising value                                         */
      __IOM uint32 DTPRSC     : 3;            /*!< [12..10] Deadtime Prescaler                                               */
            uint32            : 1;
      __IOM uint32 DTRSLKx    : 1;            /*!< [14..14] Deadtime Rising Sign Lock                                        */
      __IOM uint32 DTRLKx     : 1;            /*!< [15..15] Deadtime Rising Lock                                             */
      __IOM uint32 DTFx       : 9;            /*!< [24..16] Deadtime Falling value                                           */
      __IOM uint32 SDTFx      : 1;            /*!< [25..25] Sign Deadtime Falling value                                      */
            uint32            : 4;
      __IOM uint32 DTFSLKx    : 1;            /*!< [30..30] Deadtime Falling Sign Lock                                       */
      __IOM uint32 DTFLKx     : 1;            /*!< [31..31] Deadtime Falling Lock                                            */
    } bit;
  } DTCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000003C) Timerx Output1 Set Register                                */
    
    struct {
      __IOM uint32 SST        : 1;            /*!< [0..0] Software Set trigger                                               */
      __IOM uint32 RESYNC     : 1;            /*!< [1..1] Timer A resynchronizaton                                           */
      __IOM uint32 PER        : 1;            /*!< [2..2] Timer A Period                                                     */
      __IOM uint32 CMP1       : 1;            /*!< [3..3] Timer A compare 1                                                  */
      __IOM uint32 CMP2       : 1;            /*!< [4..4] Timer A compare 2                                                  */
      __IOM uint32 CMP3       : 1;            /*!< [5..5] Timer A compare 3                                                  */
      __IOM uint32 CMP4       : 1;            /*!< [6..6] Timer A compare 4                                                  */
      __IOM uint32 MSTPER     : 1;            /*!< [7..7] Master Period                                                      */
      __IOM uint32 MSTCMP1    : 1;            /*!< [8..8] Master Compare 1                                                   */
      __IOM uint32 MSTCMP2    : 1;            /*!< [9..9] Master Compare 2                                                   */
      __IOM uint32 MSTCMP3    : 1;            /*!< [10..10] Master Compare 3                                                 */
      __IOM uint32 MSTCMP4    : 1;            /*!< [11..11] Master Compare 4                                                 */
      __IOM uint32 TIMEVNT1   : 1;            /*!< [12..12] Timer Event 1                                                    */
      __IOM uint32 TIMEVNT2   : 1;            /*!< [13..13] Timer Event 2                                                    */
      __IOM uint32 TIMEVNT3   : 1;            /*!< [14..14] Timer Event 3                                                    */
      __IOM uint32 TIMEVNT4   : 1;            /*!< [15..15] Timer Event 4                                                    */
      __IOM uint32 TIMEVNT5   : 1;            /*!< [16..16] Timer Event 5                                                    */
      __IOM uint32 TIMEVNT6   : 1;            /*!< [17..17] Timer Event 6                                                    */
      __IOM uint32 TIMEVNT7   : 1;            /*!< [18..18] Timer Event 7                                                    */
      __IOM uint32 TIMEVNT8   : 1;            /*!< [19..19] Timer Event 8                                                    */
      __IOM uint32 TIMEVNT9   : 1;            /*!< [20..20] Timer Event 9                                                    */
      __IOM uint32 EXTEVNT1   : 1;            /*!< [21..21] External Event 1                                                 */
      __IOM uint32 EXTEVNT2   : 1;            /*!< [22..22] External Event 2                                                 */
      __IOM uint32 EXTEVNT3   : 1;            /*!< [23..23] External Event 3                                                 */
      __IOM uint32 EXTEVNT4   : 1;            /*!< [24..24] External Event 4                                                 */
      __IOM uint32 EXTEVNT5   : 1;            /*!< [25..25] External Event 5                                                 */
      __IOM uint32 EXTEVNT6   : 1;            /*!< [26..26] External Event 6                                                 */
      __IOM uint32 EXTEVNT7   : 1;            /*!< [27..27] External Event 7                                                 */
      __IOM uint32 EXTEVNT8   : 1;            /*!< [28..28] External Event 8                                                 */
      __IOM uint32 EXTEVNT9   : 1;            /*!< [29..29] External Event 9                                                 */
      __IOM uint32 EXTEVNT10  : 1;            /*!< [30..30] External Event 10                                                */
      __IOM uint32 UPDATE     : 1;            /*!< [31..31] Registers update (transfer preload to active)                    */
    } bit;
  } SETC1R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000040) Timerx Output1 Reset Register                              */
    
    struct {
      __IOM uint32 SRT        : 1;            /*!< [0..0] SRT                                                                */
      __IOM uint32 RESYNC     : 1;            /*!< [1..1] RESYNC                                                             */
      __IOM uint32 PER        : 1;            /*!< [2..2] PER                                                                */
      __IOM uint32 CMP1       : 1;            /*!< [3..3] CMP1                                                               */
      __IOM uint32 CMP2       : 1;            /*!< [4..4] CMP2                                                               */
      __IOM uint32 CMP3       : 1;            /*!< [5..5] CMP3                                                               */
      __IOM uint32 CMP4       : 1;            /*!< [6..6] CMP4                                                               */
      __IOM uint32 MSTPER     : 1;            /*!< [7..7] MSTPER                                                             */
      __IOM uint32 MSTCMP1    : 1;            /*!< [8..8] MSTCMP1                                                            */
      __IOM uint32 MSTCMP2    : 1;            /*!< [9..9] MSTCMP2                                                            */
      __IOM uint32 MSTCMP3    : 1;            /*!< [10..10] MSTCMP3                                                          */
      __IOM uint32 MSTCMP4    : 1;            /*!< [11..11] MSTCMP4                                                          */
      __IOM uint32 TIMEVNT1   : 1;            /*!< [12..12] TIMEVNT1                                                         */
      __IOM uint32 TIMEVNT2   : 1;            /*!< [13..13] TIMEVNT2                                                         */
      __IOM uint32 TIMEVNT3   : 1;            /*!< [14..14] TIMEVNT3                                                         */
      __IOM uint32 TIMEVNT4   : 1;            /*!< [15..15] TIMEVNT4                                                         */
      __IOM uint32 TIMEVNT5   : 1;            /*!< [16..16] TIMEVNT5                                                         */
      __IOM uint32 TIMEVNT6   : 1;            /*!< [17..17] TIMEVNT6                                                         */
      __IOM uint32 TIMEVNT7   : 1;            /*!< [18..18] TIMEVNT7                                                         */
      __IOM uint32 TIMEVNT8   : 1;            /*!< [19..19] TIMEVNT8                                                         */
      __IOM uint32 TIMEVNT9   : 1;            /*!< [20..20] TIMEVNT9                                                         */
      __IOM uint32 EXTEVNT1   : 1;            /*!< [21..21] EXTEVNT1                                                         */
      __IOM uint32 EXTEVNT2   : 1;            /*!< [22..22] EXTEVNT2                                                         */
      __IOM uint32 EXTEVNT3   : 1;            /*!< [23..23] EXTEVNT3                                                         */
      __IOM uint32 EXTEVNT4   : 1;            /*!< [24..24] EXTEVNT4                                                         */
      __IOM uint32 EXTEVNT5   : 1;            /*!< [25..25] EXTEVNT5                                                         */
      __IOM uint32 EXTEVNT6   : 1;            /*!< [26..26] EXTEVNT6                                                         */
      __IOM uint32 EXTEVNT7   : 1;            /*!< [27..27] EXTEVNT7                                                         */
      __IOM uint32 EXTEVNT8   : 1;            /*!< [28..28] EXTEVNT8                                                         */
      __IOM uint32 EXTEVNT9   : 1;            /*!< [29..29] EXTEVNT9                                                         */
      __IOM uint32 EXTEVNT10  : 1;            /*!< [30..30] EXTEVNT10                                                        */
      __IOM uint32 UPDATE     : 1;            /*!< [31..31] UPDATE                                                           */
    } bit;
  } RSTC1R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000044) Timerx Output2 Set Register                                */
    
    struct {
      __IOM uint32 SST        : 1;            /*!< [0..0] SST                                                                */
      __IOM uint32 RESYNC     : 1;            /*!< [1..1] RESYNC                                                             */
      __IOM uint32 PER        : 1;            /*!< [2..2] PER                                                                */
      __IOM uint32 CMP1       : 1;            /*!< [3..3] CMP1                                                               */
      __IOM uint32 CMP2       : 1;            /*!< [4..4] CMP2                                                               */
      __IOM uint32 CMP3       : 1;            /*!< [5..5] CMP3                                                               */
      __IOM uint32 CMP4       : 1;            /*!< [6..6] CMP4                                                               */
      __IOM uint32 MSTPER     : 1;            /*!< [7..7] MSTPER                                                             */
      __IOM uint32 MSTCMP1    : 1;            /*!< [8..8] MSTCMP1                                                            */
      __IOM uint32 MSTCMP2    : 1;            /*!< [9..9] MSTCMP2                                                            */
      __IOM uint32 MSTCMP3    : 1;            /*!< [10..10] MSTCMP3                                                          */
      __IOM uint32 MSTCMP4    : 1;            /*!< [11..11] MSTCMP4                                                          */
      __IOM uint32 TIMEVNT1   : 1;            /*!< [12..12] TIMEVNT1                                                         */
      __IOM uint32 TIMEVNT2   : 1;            /*!< [13..13] TIMEVNT2                                                         */
      __IOM uint32 TIMEVNT3   : 1;            /*!< [14..14] TIMEVNT3                                                         */
      __IOM uint32 TIMEVNT4   : 1;            /*!< [15..15] TIMEVNT4                                                         */
      __IOM uint32 TIMEVNT5   : 1;            /*!< [16..16] TIMEVNT5                                                         */
      __IOM uint32 TIMEVNT6   : 1;            /*!< [17..17] TIMEVNT6                                                         */
      __IOM uint32 TIMEVNT7   : 1;            /*!< [18..18] TIMEVNT7                                                         */
      __IOM uint32 TIMEVNT8   : 1;            /*!< [19..19] TIMEVNT8                                                         */
      __IOM uint32 TIMEVNT9   : 1;            /*!< [20..20] TIMEVNT9                                                         */
      __IOM uint32 EXTEVNT1   : 1;            /*!< [21..21] EXTEVNT1                                                         */
      __IOM uint32 EXTEVNT2   : 1;            /*!< [22..22] EXTEVNT2                                                         */
      __IOM uint32 EXTEVNT3   : 1;            /*!< [23..23] EXTEVNT3                                                         */
      __IOM uint32 EXTEVNT4   : 1;            /*!< [24..24] EXTEVNT4                                                         */
      __IOM uint32 EXTEVNT5   : 1;            /*!< [25..25] EXTEVNT5                                                         */
      __IOM uint32 EXTEVNT6   : 1;            /*!< [26..26] EXTEVNT6                                                         */
      __IOM uint32 EXTEVNT7   : 1;            /*!< [27..27] EXTEVNT7                                                         */
      __IOM uint32 EXTEVNT8   : 1;            /*!< [28..28] EXTEVNT8                                                         */
      __IOM uint32 EXTEVNT9   : 1;            /*!< [29..29] EXTEVNT9                                                         */
      __IOM uint32 EXTEVNT10  : 1;            /*!< [30..30] EXTEVNT10                                                        */
      __IOM uint32 UPDATE     : 1;            /*!< [31..31] UPDATE                                                           */
    } bit;
  } SETC2R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000048) Timerx Output2 Reset Register                              */
    
    struct {
      __IOM uint32 SRT        : 1;            /*!< [0..0] SRT                                                                */
      __IOM uint32 RESYNC     : 1;            /*!< [1..1] RESYNC                                                             */
      __IOM uint32 PER        : 1;            /*!< [2..2] PER                                                                */
      __IOM uint32 CMP1       : 1;            /*!< [3..3] CMP1                                                               */
      __IOM uint32 CMP2       : 1;            /*!< [4..4] CMP2                                                               */
      __IOM uint32 CMP3       : 1;            /*!< [5..5] CMP3                                                               */
      __IOM uint32 CMP4       : 1;            /*!< [6..6] CMP4                                                               */
      __IOM uint32 MSTPER     : 1;            /*!< [7..7] MSTPER                                                             */
      __IOM uint32 MSTCMP1    : 1;            /*!< [8..8] MSTCMP1                                                            */
      __IOM uint32 MSTCMP2    : 1;            /*!< [9..9] MSTCMP2                                                            */
      __IOM uint32 MSTCMP3    : 1;            /*!< [10..10] MSTCMP3                                                          */
      __IOM uint32 MSTCMP4    : 1;            /*!< [11..11] MSTCMP4                                                          */
      __IOM uint32 TIMEVNT1   : 1;            /*!< [12..12] TIMEVNT1                                                         */
      __IOM uint32 TIMEVNT2   : 1;            /*!< [13..13] TIMEVNT2                                                         */
      __IOM uint32 TIMEVNT3   : 1;            /*!< [14..14] TIMEVNT3                                                         */
      __IOM uint32 TIMEVNT4   : 1;            /*!< [15..15] TIMEVNT4                                                         */
      __IOM uint32 TIMEVNT5   : 1;            /*!< [16..16] TIMEVNT5                                                         */
      __IOM uint32 TIMEVNT6   : 1;            /*!< [17..17] TIMEVNT6                                                         */
      __IOM uint32 TIMEVNT7   : 1;            /*!< [18..18] TIMEVNT7                                                         */
      __IOM uint32 TIMEVNT8   : 1;            /*!< [19..19] TIMEVNT8                                                         */
      __IOM uint32 TIMEVNT9   : 1;            /*!< [20..20] TIMEVNT9                                                         */
      __IOM uint32 EXTEVNT1   : 1;            /*!< [21..21] EXTEVNT1                                                         */
      __IOM uint32 EXTEVNT2   : 1;            /*!< [22..22] EXTEVNT2                                                         */
      __IOM uint32 EXTEVNT3   : 1;            /*!< [23..23] EXTEVNT3                                                         */
      __IOM uint32 EXTEVNT4   : 1;            /*!< [24..24] EXTEVNT4                                                         */
      __IOM uint32 EXTEVNT5   : 1;            /*!< [25..25] EXTEVNT5                                                         */
      __IOM uint32 EXTEVNT6   : 1;            /*!< [26..26] EXTEVNT6                                                         */
      __IOM uint32 EXTEVNT7   : 1;            /*!< [27..27] EXTEVNT7                                                         */
      __IOM uint32 EXTEVNT8   : 1;            /*!< [28..28] EXTEVNT8                                                         */
      __IOM uint32 EXTEVNT9   : 1;            /*!< [29..29] EXTEVNT9                                                         */
      __IOM uint32 EXTEVNT10  : 1;            /*!< [30..30] EXTEVNT10                                                        */
      __IOM uint32 UPDATE     : 1;            /*!< [31..31] UPDATE                                                           */
    } bit;
  } RSTC2R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000004C) Timerx External Event Filtering Register 1                 */
    
    struct {
      __IOM uint32 EE1LTCH    : 1;            /*!< [0..0] External Event 1 latch                                             */
      __IOM uint32 EE1FLTR    : 4;            /*!< [4..1] External Event 1 filter                                            */
            uint32            : 1;
      __IOM uint32 EE2LTCH    : 1;            /*!< [6..6] External Event 2 latch                                             */
      __IOM uint32 EE2FLTR    : 4;            /*!< [10..7] External Event 2 filter                                           */
            uint32            : 1;
      __IOM uint32 EE3LTCH    : 1;            /*!< [12..12] External Event 3 latch                                           */
      __IOM uint32 EE3FLTR    : 4;            /*!< [16..13] External Event 3 filter                                          */
            uint32            : 1;
      __IOM uint32 EE4LTCH    : 1;            /*!< [18..18] External Event 4 latch                                           */
      __IOM uint32 EE4FLTR    : 4;            /*!< [22..19] External Event 4 filter                                          */
            uint32            : 1;
      __IOM uint32 EE5LTCH    : 1;            /*!< [24..24] External Event 5 latch                                           */
      __IOM uint32 EE5FLTR    : 4;            /*!< [28..25] External Event 5 filter                                          */
            uint32            : 3;
    } bit;
  } EEFCR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000050) Timerx External Event Filtering Register 2                 */
    
    struct {
      __IOM uint32 EE6LTCH    : 1;            /*!< [0..0] External Event 6 latch                                             */
      __IOM uint32 EE6FLTR    : 4;            /*!< [4..1] External Event 6 filter                                            */
            uint32            : 1;
      __IOM uint32 EE7LTCH    : 1;            /*!< [6..6] External Event 7 latch                                             */
      __IOM uint32 EE7FLTR    : 4;            /*!< [10..7] External Event 7 filter                                           */
            uint32            : 1;
      __IOM uint32 EE8LTCH    : 1;            /*!< [12..12] External Event 8 latch                                           */
      __IOM uint32 EE8FLTR    : 4;            /*!< [16..13] External Event 8 filter                                          */
            uint32            : 1;
      __IOM uint32 EE9LTCH    : 1;            /*!< [18..18] External Event 9 latch                                           */
      __IOM uint32 EE9FLTR    : 4;            /*!< [22..19] External Event 9 filter                                          */
            uint32            : 1;
      __IOM uint32 EE10LTCH   : 1;            /*!< [24..24] External Event 10 latch                                          */
      __IOM uint32 EE10FLTR   : 4;            /*!< [28..25] External Event 10 filter                                         */
            uint32            : 3;
    } bit;
  } EEFCR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000054) TimerA Reset Register                                      */
    
    struct {
            uint32            : 1;
      __IOM uint32 UPDT       : 1;            /*!< [1..1] Timer A Update reset                                               */
      __IOM uint32 CMP2       : 1;            /*!< [2..2] Timer A compare 2 reset                                            */
      __IOM uint32 CMP4       : 1;            /*!< [3..3] Timer A compare 4 reset                                            */
      __IOM uint32 MSTPER     : 1;            /*!< [4..4] Master timer Period                                                */
      __IOM uint32 MSTCMP1    : 1;            /*!< [5..5] Master compare 1                                                   */
      __IOM uint32 MSTCMP2    : 1;            /*!< [6..6] Master compare 2                                                   */
      __IOM uint32 MSTCMP3    : 1;            /*!< [7..7] Master compare 3                                                   */
      __IOM uint32 MSTCMP4    : 1;            /*!< [8..8] Master compare 4                                                   */
      __IOM uint32 EXTEVNT1   : 1;            /*!< [9..9] External Event 1                                                   */
      __IOM uint32 EXTEVNT2   : 1;            /*!< [10..10] External Event 2                                                 */
      __IOM uint32 EXTEVNT3   : 1;            /*!< [11..11] External Event 3                                                 */
      __IOM uint32 EXTEVNT4   : 1;            /*!< [12..12] External Event 4                                                 */
      __IOM uint32 EXTEVNT5   : 1;            /*!< [13..13] External Event 5                                                 */
      __IOM uint32 EXTEVNT6   : 1;            /*!< [14..14] External Event 6                                                 */
      __IOM uint32 EXTEVNT7   : 1;            /*!< [15..15] External Event 7                                                 */
      __IOM uint32 EXTEVNT8   : 1;            /*!< [16..16] External Event 8                                                 */
      __IOM uint32 EXTEVNT9   : 1;            /*!< [17..17] External Event 9                                                 */
      __IOM uint32 EXTEVNT10  : 1;            /*!< [18..18] External Event 10                                                */
      __IOM uint32 TIMACMP1   : 1;            /*!< [19..19] Timer A Compare 1                                                */
      __IOM uint32 TIMACMP2   : 1;            /*!< [20..20] Timer A Compare 2                                                */
      __IOM uint32 TIMACMP4   : 1;            /*!< [21..21] Timer A Compare 4                                                */
      __IOM uint32 TIMBCMP1   : 1;            /*!< [22..22] Timer B Compare 1                                                */
      __IOM uint32 TIMBCMP2   : 1;            /*!< [23..23] Timer B Compare 2                                                */
      __IOM uint32 TIMBCMP4   : 1;            /*!< [24..24] Timer B Compare 4                                                */
      __IOM uint32 TIMDCMP1   : 1;            /*!< [25..25] Timer D Compare 1                                                */
      __IOM uint32 TIMDCMP2   : 1;            /*!< [26..26] Timer D Compare 2                                                */
      __IOM uint32 TIMDCMP4   : 1;            /*!< [27..27] Timer D Compare 4                                                */
      __IOM uint32 TIMECMP1   : 1;            /*!< [28..28] Timer E Compare 1                                                */
      __IOM uint32 TIMECMP2   : 1;            /*!< [29..29] Timer E Compare 2                                                */
      __IOM uint32 TIMECMP4   : 1;            /*!< [30..30] Timer E Compare 4                                                */
            uint32            : 1;
    } bit;
  } RSTCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000058) Timerx Chopper Register                                    */
    
    struct {
      __IOM uint32 CHPFRQ     : 4;            /*!< [3..0] Timerx carrier frequency value                                     */
      __IOM uint32 CHPDTY     : 3;            /*!< [6..4] Timerx chopper duty cycle value                                    */
      __IOM uint32 STRTPW     : 4;            /*!< [10..7] STRTPW                                                            */
            uint32            : 21;
    } bit;
  } CHPCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000005C) Timerx Capture 2 Control Register                          */
    
    struct {
      __IOM uint32 SWCPT      : 1;            /*!< [0..0] Software Capture                                                   */
      __IOM uint32 UDPCPT     : 1;            /*!< [1..1] Update Capture                                                     */
      __IOM uint32 EXEV1CPT   : 1;            /*!< [2..2] External Event 1 Capture                                           */
      __IOM uint32 EXEV2CPT   : 1;            /*!< [3..3] External Event 2 Capture                                           */
      __IOM uint32 EXEV3CPT   : 1;            /*!< [4..4] External Event 3 Capture                                           */
      __IOM uint32 EXEV4CPT   : 1;            /*!< [5..5] External Event 4 Capture                                           */
      __IOM uint32 EXEV5CPT   : 1;            /*!< [6..6] External Event 5 Capture                                           */
      __IOM uint32 EXEV6CPT   : 1;            /*!< [7..7] External Event 6 Capture                                           */
      __IOM uint32 EXEV7CPT   : 1;            /*!< [8..8] External Event 7 Capture                                           */
      __IOM uint32 EXEV8CPT   : 1;            /*!< [9..9] External Event 8 Capture                                           */
      __IOM uint32 EXEV9CPT   : 1;            /*!< [10..10] External Event 9 Capture                                         */
      __IOM uint32 EXEV10CPT  : 1;            /*!< [11..11] External Event 10 Capture                                        */
      __IOM uint32 TA1SET     : 1;            /*!< [12..12] Timer A output 1 Set                                             */
      __IOM uint32 TA1RST     : 1;            /*!< [13..13] Timer A output 1 Reset                                           */
      __IOM uint32 TACMP1     : 1;            /*!< [14..14] Timer A Compare 1                                                */
      __IOM uint32 TACMP2     : 1;            /*!< [15..15] Timer A Compare 2                                                */
      __IOM uint32 TB1SET     : 1;            /*!< [16..16] Timer B output 1 Set                                             */
      __IOM uint32 TB1RST     : 1;            /*!< [17..17] Timer B output 1 Reset                                           */
      __IOM uint32 TBCMP1     : 1;            /*!< [18..18] Timer B Compare 1                                                */
      __IOM uint32 TBCMP2     : 1;            /*!< [19..19] Timer B Compare 2                                                */
            uint32            : 4;
      __IOM uint32 TD1SET     : 1;            /*!< [24..24] Timer D output 1 Set                                             */
      __IOM uint32 TD1RST     : 1;            /*!< [25..25] Timer D output 1 Reset                                           */
      __IOM uint32 TDCMP1     : 1;            /*!< [26..26] Timer D Compare 1                                                */
      __IOM uint32 TDCMP2     : 1;            /*!< [27..27] Timer D Compare 2                                                */
      __IOM uint32 TE1SET     : 1;            /*!< [28..28] Timer E output 1 Set                                             */
      __IOM uint32 TE1RST     : 1;            /*!< [29..29] Timer E output 1 Reset                                           */
      __IOM uint32 TECMP1     : 1;            /*!< [30..30] Timer E Compare 1                                                */
      __IOM uint32 TECMP2     : 1;            /*!< [31..31] Timer E Compare 2                                                */
    } bit;
  } CPT1CCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000060) CPT2xCR                                                    */
    
    struct {
      __IOM uint32 SWCPT      : 1;            /*!< [0..0] Software Capture                                                   */
      __IOM uint32 UDPCPT     : 1;            /*!< [1..1] Update Capture                                                     */
      __IOM uint32 EXEV1CPT   : 1;            /*!< [2..2] External Event 1 Capture                                           */
      __IOM uint32 EXEV2CPT   : 1;            /*!< [3..3] External Event 2 Capture                                           */
      __IOM uint32 EXEV3CPT   : 1;            /*!< [4..4] External Event 3 Capture                                           */
      __IOM uint32 EXEV4CPT   : 1;            /*!< [5..5] External Event 4 Capture                                           */
      __IOM uint32 EXEV5CPT   : 1;            /*!< [6..6] External Event 5 Capture                                           */
      __IOM uint32 EXEV6CPT   : 1;            /*!< [7..7] External Event 6 Capture                                           */
      __IOM uint32 EXEV7CPT   : 1;            /*!< [8..8] External Event 7 Capture                                           */
      __IOM uint32 EXEV8CPT   : 1;            /*!< [9..9] External Event 8 Capture                                           */
      __IOM uint32 EXEV9CPT   : 1;            /*!< [10..10] External Event 9 Capture                                         */
      __IOM uint32 EXEV10CPT  : 1;            /*!< [11..11] External Event 10 Capture                                        */
      __IOM uint32 TA1SET     : 1;            /*!< [12..12] Timer A output 1 Set                                             */
      __IOM uint32 TA1RST     : 1;            /*!< [13..13] Timer A output 1 Reset                                           */
      __IOM uint32 TACMP1     : 1;            /*!< [14..14] Timer A Compare 1                                                */
      __IOM uint32 TACMP2     : 1;            /*!< [15..15] Timer A Compare 2                                                */
      __IOM uint32 TB1SET     : 1;            /*!< [16..16] Timer B output 1 Set                                             */
      __IOM uint32 TB1RST     : 1;            /*!< [17..17] Timer B output 1 Reset                                           */
      __IOM uint32 TBCMP1     : 1;            /*!< [18..18] Timer B Compare 1                                                */
      __IOM uint32 TBCMP2     : 1;            /*!< [19..19] Timer B Compare 2                                                */
            uint32            : 4;
      __IOM uint32 TD1SET     : 1;            /*!< [24..24] Timer D output 1 Set                                             */
      __IOM uint32 TD1RST     : 1;            /*!< [25..25] Timer D output 1 Reset                                           */
      __IOM uint32 TDCMP1     : 1;            /*!< [26..26] Timer D Compare 1                                                */
      __IOM uint32 TDCMP2     : 1;            /*!< [27..27] Timer D Compare 2                                                */
      __IOM uint32 TE1SET     : 1;            /*!< [28..28] Timer E output 1 Set                                             */
      __IOM uint32 TE1RST     : 1;            /*!< [29..29] Timer E output 1 Reset                                           */
      __IOM uint32 TECMP1     : 1;            /*!< [30..30] Timer E Compare 1                                                */
      __IOM uint32 TECMP2     : 1;            /*!< [31..31] Timer E Compare 2                                                */
    } bit;
  } CPT2CCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000064) Timerx Output Register                                     */
    
    struct {
            uint32            : 1;
      __IOM uint32 POL1       : 1;            /*!< [1..1] Output 1 polarity                                                  */
      __IOM uint32 IDLEM1     : 1;            /*!< [2..2] Output 1 Idle mode                                                 */
      __IOM uint32 IDLES1     : 1;            /*!< [3..3] Output 1 Idle State                                                */
      __IOM uint32 FAULT1     : 2;            /*!< [5..4] Output 1 Fault state                                               */
      __IOM uint32 CHP1       : 1;            /*!< [6..6] Output 1 Chopper enable                                            */
      __IOM uint32 DIDL1      : 1;            /*!< [7..7] Output 1 Deadtime upon burst mode Idle entry                       */
      __IOM uint32 DTEN       : 1;            /*!< [8..8] Deadtime enable                                                    */
      __IOM uint32 DLYPRTEN   : 1;            /*!< [9..9] Delayed Protection Enable                                          */
      __IOM uint32 DLYPRT     : 3;            /*!< [12..10] Delayed Protection                                               */
            uint32            : 4;
      __IOM uint32 POL2       : 1;            /*!< [17..17] Output 2 polarity                                                */
      __IOM uint32 IDLEM2     : 1;            /*!< [18..18] Output 2 Idle mode                                               */
      __IOM uint32 IDLES2     : 1;            /*!< [19..19] Output 2 Idle State                                              */
      __IOM uint32 FAULT2     : 2;            /*!< [21..20] Output 2 Fault state                                             */
      __IOM uint32 CHP2       : 1;            /*!< [22..22] Output 2 Chopper enable                                          */
      __IOM uint32 DIDL2      : 1;            /*!< [23..23] Output 2 Deadtime upon burst mode Idle entry                     */
            uint32            : 8;
    } bit;
  } OUTCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000068) Timerx Fault Register                                      */
    
    struct {
      __IOM uint32 FLT1EN     : 1;            /*!< [0..0] Fault 1 enable                                                     */
      __IOM uint32 FLT2EN     : 1;            /*!< [1..1] Fault 2 enable                                                     */
      __IOM uint32 FLT3EN     : 1;            /*!< [2..2] Fault 3 enable                                                     */
      __IOM uint32 FLT4EN     : 1;            /*!< [3..3] Fault 4 enable                                                     */
      __IOM uint32 FLT5EN     : 1;            /*!< [4..4] Fault 5 enable                                                     */
            uint32            : 26;
      __IOM uint32 FLTLCK     : 1;            /*!< [31..31] Fault sources Lock                                               */
    } bit;
  } FLTCR;
} HRTIM_TIMC_Type;                              /*!< Size = 108 (0x6c)                                                         */



/* =========================================================================================================================== */
/* ================                                        HRTIM_TIMD                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief High Resolution Timer: TIMD (HRTIM_TIMD)
  */

typedef struct {                                /*!< (@ 0x40017600) HRTIM_TIMD Structure                                       */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) Timerx Control Register                                    */
    
    struct {
      __IOM uint32 CK_PSCx    : 3;            /*!< [2..0] HRTIM Timer x Clock prescaler                                      */
      __IOM uint32 CONT       : 1;            /*!< [3..3] Continuous mode                                                    */
      __IOM uint32 RETRIG     : 1;            /*!< [4..4] Re-triggerable mode                                                */
      __IOM uint32 HALF       : 1;            /*!< [5..5] Half mode enable                                                   */
      __IOM uint32 PSHPLL     : 1;            /*!< [6..6] Push-Pull mode enable                                              */
            uint32            : 3;
      __IOM uint32 SYNCRSTx   : 1;            /*!< [10..10] Synchronization Resets Timer x                                   */
      __IOM uint32 SYNCSTRTx  : 1;            /*!< [11..11] Synchronization Starts Timer x                                   */
      __IOM uint32 DELCMP2    : 2;            /*!< [13..12] Delayed CMP2 mode                                                */
      __IOM uint32 DELCMP4    : 2;            /*!< [15..14] Delayed CMP4 mode                                                */
            uint32            : 1;
      __IOM uint32 TxREPU     : 1;            /*!< [17..17] Timer x Repetition update                                        */
      __IOM uint32 TxRSTU     : 1;            /*!< [18..18] Timerx reset update                                              */
            uint32            : 1;
      __IOM uint32 TBU        : 1;            /*!< [20..20] TBU                                                              */
      __IOM uint32 TCU        : 1;            /*!< [21..21] TCU                                                              */
      __IOM uint32 TDU        : 1;            /*!< [22..22] TDU                                                              */
      __IOM uint32 TEU        : 1;            /*!< [23..23] TEU                                                              */
      __IOM uint32 MSTU       : 1;            /*!< [24..24] Master Timer update                                              */
      __IOM uint32 DACSYNC    : 2;            /*!< [26..25] AC Synchronization                                               */
      __IOM uint32 PREEN      : 1;            /*!< [27..27] Preload enable                                                   */
      __IOM uint32 UPDGAT     : 4;            /*!< [31..28] Update Gating                                                    */
    } bit;
  } TIMDCR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000004) Timerx Interrupt Status Register                           */
    
    struct {
      __IM  uint32 CMP1       : 1;            /*!< [0..0] Compare 1 Interrupt Flag                                           */
      __IM  uint32 CMP2       : 1;            /*!< [1..1] Compare 2 Interrupt Flag                                           */
      __IM  uint32 CMP3       : 1;            /*!< [2..2] Compare 3 Interrupt Flag                                           */
      __IM  uint32 CMP4       : 1;            /*!< [3..3] Compare 4 Interrupt Flag                                           */
      __IM  uint32 REP        : 1;            /*!< [4..4] Repetition Interrupt Flag                                          */
            uint32            : 1;
      __IM  uint32 UPD        : 1;            /*!< [6..6] Update Interrupt Flag                                              */
      __IM  uint32 CPT1       : 1;            /*!< [7..7] Capture1 Interrupt Flag                                            */
      __IM  uint32 CPT2       : 1;            /*!< [8..8] Capture2 Interrupt Flag                                            */
      __IM  uint32 SETx1      : 1;            /*!< [9..9] Output 1 Set Interrupt Flag                                        */
      __IM  uint32 RSTx1      : 1;            /*!< [10..10] Output 1 Reset Interrupt Flag                                    */
      __IM  uint32 SETx2      : 1;            /*!< [11..11] Output 2 Set Interrupt Flag                                      */
      __IM  uint32 RSTx2      : 1;            /*!< [12..12] Output 2 Reset Interrupt Flag                                    */
      __IM  uint32 RST        : 1;            /*!< [13..13] Reset Interrupt Flag                                             */
      __IM  uint32 DLYPRT     : 1;            /*!< [14..14] Delayed Protection Flag                                          */
            uint32            : 1;
      __IM  uint32 CPPSTAT    : 1;            /*!< [16..16] Current Push Pull Status                                         */
      __IM  uint32 IPPSTAT    : 1;            /*!< [17..17] Idle Push Pull Status                                            */
      __IM  uint32 O1STAT     : 1;            /*!< [18..18] Output 1 State                                                   */
      __IM  uint32 O2STAT     : 1;            /*!< [19..19] Output 2 State                                                   */
            uint32            : 12;
    } bit;
  } TIMDISR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000008) Timerx Interrupt Clear Register                            */
    
    struct {
      __OM  uint32 CMP1C      : 1;            /*!< [0..0] Compare 1 Interrupt flag Clear                                     */
      __OM  uint32 CMP2C      : 1;            /*!< [1..1] Compare 2 Interrupt flag Clear                                     */
      __OM  uint32 CMP3C      : 1;            /*!< [2..2] Compare 3 Interrupt flag Clear                                     */
      __OM  uint32 CMP4C      : 1;            /*!< [3..3] Compare 4 Interrupt flag Clear                                     */
      __OM  uint32 REPC       : 1;            /*!< [4..4] Repetition Interrupt flag Clear                                    */
            uint32            : 1;
      __OM  uint32 UPDC       : 1;            /*!< [6..6] Update Interrupt flag Clear                                        */
      __OM  uint32 CPT1C      : 1;            /*!< [7..7] Capture1 Interrupt flag Clear                                      */
      __OM  uint32 CPT2C      : 1;            /*!< [8..8] Capture2 Interrupt flag Clear                                      */
      __OM  uint32 SET1xC     : 1;            /*!< [9..9] Output 1 Set flag Clear                                            */
      __OM  uint32 RSTx1C     : 1;            /*!< [10..10] Output 1 Reset flag Clear                                        */
      __OM  uint32 SET2xC     : 1;            /*!< [11..11] Output 2 Set flag Clear                                          */
      __OM  uint32 RSTx2C     : 1;            /*!< [12..12] Output 2 Reset flag Clear                                        */
      __OM  uint32 RSTC       : 1;            /*!< [13..13] Reset Interrupt flag Clear                                       */
      __OM  uint32 DLYPRTC    : 1;            /*!< [14..14] Delayed Protection Flag Clear                                    */
            uint32            : 17;
    } bit;
  } TIMDICR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) TIMxDIER5                                                  */
    
    struct {
      __IOM uint32 CMP1IE     : 1;            /*!< [0..0] CMP1IE                                                             */
      __IOM uint32 CMP2IE     : 1;            /*!< [1..1] CMP2IE                                                             */
      __IOM uint32 CMP3IE     : 1;            /*!< [2..2] CMP3IE                                                             */
      __IOM uint32 CMP4IE     : 1;            /*!< [3..3] CMP4IE                                                             */
      __IOM uint32 REPIE      : 1;            /*!< [4..4] REPIE                                                              */
            uint32            : 1;
      __IOM uint32 UPDIE      : 1;            /*!< [6..6] UPDIE                                                              */
      __IOM uint32 CPT1IE     : 1;            /*!< [7..7] CPT1IE                                                             */
      __IOM uint32 CPT2IE     : 1;            /*!< [8..8] CPT2IE                                                             */
      __IOM uint32 SET1xIE    : 1;            /*!< [9..9] SET1xIE                                                            */
      __IOM uint32 RSTx1IE    : 1;            /*!< [10..10] RSTx1IE                                                          */
      __IOM uint32 SETx2IE    : 1;            /*!< [11..11] SETx2IE                                                          */
      __IOM uint32 RSTx2IE    : 1;            /*!< [12..12] RSTx2IE                                                          */
      __IOM uint32 RSTIE      : 1;            /*!< [13..13] RSTIE                                                            */
      __IOM uint32 DLYPRTIE   : 1;            /*!< [14..14] DLYPRTIE                                                         */
            uint32            : 1;
      __IOM uint32 CMP1DE     : 1;            /*!< [16..16] CMP1DE                                                           */
      __IOM uint32 CMP2DE     : 1;            /*!< [17..17] CMP2DE                                                           */
      __IOM uint32 CMP3DE     : 1;            /*!< [18..18] CMP3DE                                                           */
      __IOM uint32 CMP4DE     : 1;            /*!< [19..19] CMP4DE                                                           */
      __IOM uint32 REPDE      : 1;            /*!< [20..20] REPDE                                                            */
            uint32            : 1;
      __IOM uint32 UPDDE      : 1;            /*!< [22..22] UPDDE                                                            */
      __IOM uint32 CPT1DE     : 1;            /*!< [23..23] CPT1DE                                                           */
      __IOM uint32 CPT2DE     : 1;            /*!< [24..24] CPT2DE                                                           */
      __IOM uint32 SET1xDE    : 1;            /*!< [25..25] SET1xDE                                                          */
      __IOM uint32 RSTx1DE    : 1;            /*!< [26..26] RSTx1DE                                                          */
      __IOM uint32 SETx2DE    : 1;            /*!< [27..27] SETx2DE                                                          */
      __IOM uint32 RSTx2DE    : 1;            /*!< [28..28] RSTx2DE                                                          */
      __IOM uint32 RSTDE      : 1;            /*!< [29..29] RSTDE                                                            */
      __IOM uint32 DLYPRTDE   : 1;            /*!< [30..30] DLYPRTDE                                                         */
            uint32            : 1;
    } bit;
  } TIMDDIER5;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) Timerx Counter Register                                    */
    
    struct {
      __IOM uint32 CNTx       : 16;           /*!< [15..0] Timerx Counter value                                              */
            uint32            : 16;
    } bit;
  } CNTDR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000014) Timerx Period Register                                     */
    
    struct {
      __IOM uint32 PERx       : 16;           /*!< [15..0] Timerx Period value                                               */
            uint32            : 16;
    } bit;
  } PERDR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000018) Timerx Repetition Register                                 */
    
    struct {
      __IOM uint32 REPx       : 8;            /*!< [7..0] Timerx Repetition counter value                                    */
            uint32            : 24;
    } bit;
  } REPDR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000001C) Timerx Compare 1 Register                                  */
    
    struct {
      __IOM uint32 CMP1x      : 16;           /*!< [15..0] Timerx Compare 1 value                                            */
            uint32            : 16;
    } bit;
  } CMP1DR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000020) Timerx Compare 1 Compound Register                         */
    
    struct {
      __IOM uint32 CMP1x      : 16;           /*!< [15..0] Timerx Compare 1 value                                            */
      __IOM uint32 REPx       : 8;            /*!< [23..16] Timerx Repetition value (aliased from HRTIM_REPx register)       */
            uint32            : 8;
    } bit;
  } CMP1CDR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000024) Timerx Compare 2 Register                                  */
    
    struct {
      __IOM uint32 CMP2x      : 16;           /*!< [15..0] Timerx Compare 2 value                                            */
            uint32            : 16;
    } bit;
  } CMP2DR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000028) Timerx Compare 3 Register                                  */
    
    struct {
      __IOM uint32 CMP3x      : 16;           /*!< [15..0] Timerx Compare 3 value                                            */
            uint32            : 16;
    } bit;
  } CMP3DR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000002C) Timerx Compare 4 Register                                  */
    
    struct {
      __IOM uint32 CMP4x      : 16;           /*!< [15..0] Timerx Compare 4 value                                            */
            uint32            : 16;
    } bit;
  } CMP4DR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000030) Timerx Capture 1 Register                                  */
    
    struct {
      __IM  uint32 CPT1x      : 16;           /*!< [15..0] Timerx Capture 1 value                                            */
            uint32            : 16;
    } bit;
  } CPT1DR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000034) Timerx Capture 2 Register                                  */
    
    struct {
      __IM  uint32 CPT2x      : 16;           /*!< [15..0] Timerx Capture 2 value                                            */
            uint32            : 16;
    } bit;
  } CPT2DR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000038) Timerx Deadtime Register                                   */
    
    struct {
      __IOM uint32 DTRx       : 9;            /*!< [8..0] Deadtime Rising value                                              */
      __IOM uint32 SDTRx      : 1;            /*!< [9..9] Sign Deadtime Rising value                                         */
      __IOM uint32 DTPRSC     : 3;            /*!< [12..10] Deadtime Prescaler                                               */
            uint32            : 1;
      __IOM uint32 DTRSLKx    : 1;            /*!< [14..14] Deadtime Rising Sign Lock                                        */
      __IOM uint32 DTRLKx     : 1;            /*!< [15..15] Deadtime Rising Lock                                             */
      __IOM uint32 DTFx       : 9;            /*!< [24..16] Deadtime Falling value                                           */
      __IOM uint32 SDTFx      : 1;            /*!< [25..25] Sign Deadtime Falling value                                      */
            uint32            : 4;
      __IOM uint32 DTFSLKx    : 1;            /*!< [30..30] Deadtime Falling Sign Lock                                       */
      __IOM uint32 DTFLKx     : 1;            /*!< [31..31] Deadtime Falling Lock                                            */
    } bit;
  } DTDR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000003C) Timerx Output1 Set Register                                */
    
    struct {
      __IOM uint32 SST        : 1;            /*!< [0..0] Software Set trigger                                               */
      __IOM uint32 RESYNC     : 1;            /*!< [1..1] Timer A resynchronizaton                                           */
      __IOM uint32 PER        : 1;            /*!< [2..2] Timer A Period                                                     */
      __IOM uint32 CMP1       : 1;            /*!< [3..3] Timer A compare 1                                                  */
      __IOM uint32 CMP2       : 1;            /*!< [4..4] Timer A compare 2                                                  */
      __IOM uint32 CMP3       : 1;            /*!< [5..5] Timer A compare 3                                                  */
      __IOM uint32 CMP4       : 1;            /*!< [6..6] Timer A compare 4                                                  */
      __IOM uint32 MSTPER     : 1;            /*!< [7..7] Master Period                                                      */
      __IOM uint32 MSTCMP1    : 1;            /*!< [8..8] Master Compare 1                                                   */
      __IOM uint32 MSTCMP2    : 1;            /*!< [9..9] Master Compare 2                                                   */
      __IOM uint32 MSTCMP3    : 1;            /*!< [10..10] Master Compare 3                                                 */
      __IOM uint32 MSTCMP4    : 1;            /*!< [11..11] Master Compare 4                                                 */
      __IOM uint32 TIMEVNT1   : 1;            /*!< [12..12] Timer Event 1                                                    */
      __IOM uint32 TIMEVNT2   : 1;            /*!< [13..13] Timer Event 2                                                    */
      __IOM uint32 TIMEVNT3   : 1;            /*!< [14..14] Timer Event 3                                                    */
      __IOM uint32 TIMEVNT4   : 1;            /*!< [15..15] Timer Event 4                                                    */
      __IOM uint32 TIMEVNT5   : 1;            /*!< [16..16] Timer Event 5                                                    */
      __IOM uint32 TIMEVNT6   : 1;            /*!< [17..17] Timer Event 6                                                    */
      __IOM uint32 TIMEVNT7   : 1;            /*!< [18..18] Timer Event 7                                                    */
      __IOM uint32 TIMEVNT8   : 1;            /*!< [19..19] Timer Event 8                                                    */
      __IOM uint32 TIMEVNT9   : 1;            /*!< [20..20] Timer Event 9                                                    */
      __IOM uint32 EXTEVNT1   : 1;            /*!< [21..21] External Event 1                                                 */
      __IOM uint32 EXTEVNT2   : 1;            /*!< [22..22] External Event 2                                                 */
      __IOM uint32 EXTEVNT3   : 1;            /*!< [23..23] External Event 3                                                 */
      __IOM uint32 EXTEVNT4   : 1;            /*!< [24..24] External Event 4                                                 */
      __IOM uint32 EXTEVNT5   : 1;            /*!< [25..25] External Event 5                                                 */
      __IOM uint32 EXTEVNT6   : 1;            /*!< [26..26] External Event 6                                                 */
      __IOM uint32 EXTEVNT7   : 1;            /*!< [27..27] External Event 7                                                 */
      __IOM uint32 EXTEVNT8   : 1;            /*!< [28..28] External Event 8                                                 */
      __IOM uint32 EXTEVNT9   : 1;            /*!< [29..29] External Event 9                                                 */
      __IOM uint32 EXTEVNT10  : 1;            /*!< [30..30] External Event 10                                                */
      __IOM uint32 UPDATE     : 1;            /*!< [31..31] Registers update (transfer preload to active)                    */
    } bit;
  } SETD1R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000040) Timerx Output1 Reset Register                              */
    
    struct {
      __IOM uint32 SRT        : 1;            /*!< [0..0] SRT                                                                */
      __IOM uint32 RESYNC     : 1;            /*!< [1..1] RESYNC                                                             */
      __IOM uint32 PER        : 1;            /*!< [2..2] PER                                                                */
      __IOM uint32 CMP1       : 1;            /*!< [3..3] CMP1                                                               */
      __IOM uint32 CMP2       : 1;            /*!< [4..4] CMP2                                                               */
      __IOM uint32 CMP3       : 1;            /*!< [5..5] CMP3                                                               */
      __IOM uint32 CMP4       : 1;            /*!< [6..6] CMP4                                                               */
      __IOM uint32 MSTPER     : 1;            /*!< [7..7] MSTPER                                                             */
      __IOM uint32 MSTCMP1    : 1;            /*!< [8..8] MSTCMP1                                                            */
      __IOM uint32 MSTCMP2    : 1;            /*!< [9..9] MSTCMP2                                                            */
      __IOM uint32 MSTCMP3    : 1;            /*!< [10..10] MSTCMP3                                                          */
      __IOM uint32 MSTCMP4    : 1;            /*!< [11..11] MSTCMP4                                                          */
      __IOM uint32 TIMEVNT1   : 1;            /*!< [12..12] TIMEVNT1                                                         */
      __IOM uint32 TIMEVNT2   : 1;            /*!< [13..13] TIMEVNT2                                                         */
      __IOM uint32 TIMEVNT3   : 1;            /*!< [14..14] TIMEVNT3                                                         */
      __IOM uint32 TIMEVNT4   : 1;            /*!< [15..15] TIMEVNT4                                                         */
      __IOM uint32 TIMEVNT5   : 1;            /*!< [16..16] TIMEVNT5                                                         */
      __IOM uint32 TIMEVNT6   : 1;            /*!< [17..17] TIMEVNT6                                                         */
      __IOM uint32 TIMEVNT7   : 1;            /*!< [18..18] TIMEVNT7                                                         */
      __IOM uint32 TIMEVNT8   : 1;            /*!< [19..19] TIMEVNT8                                                         */
      __IOM uint32 TIMEVNT9   : 1;            /*!< [20..20] TIMEVNT9                                                         */
      __IOM uint32 EXTEVNT1   : 1;            /*!< [21..21] EXTEVNT1                                                         */
      __IOM uint32 EXTEVNT2   : 1;            /*!< [22..22] EXTEVNT2                                                         */
      __IOM uint32 EXTEVNT3   : 1;            /*!< [23..23] EXTEVNT3                                                         */
      __IOM uint32 EXTEVNT4   : 1;            /*!< [24..24] EXTEVNT4                                                         */
      __IOM uint32 EXTEVNT5   : 1;            /*!< [25..25] EXTEVNT5                                                         */
      __IOM uint32 EXTEVNT6   : 1;            /*!< [26..26] EXTEVNT6                                                         */
      __IOM uint32 EXTEVNT7   : 1;            /*!< [27..27] EXTEVNT7                                                         */
      __IOM uint32 EXTEVNT8   : 1;            /*!< [28..28] EXTEVNT8                                                         */
      __IOM uint32 EXTEVNT9   : 1;            /*!< [29..29] EXTEVNT9                                                         */
      __IOM uint32 EXTEVNT10  : 1;            /*!< [30..30] EXTEVNT10                                                        */
      __IOM uint32 UPDATE     : 1;            /*!< [31..31] UPDATE                                                           */
    } bit;
  } RSTD1R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000044) Timerx Output2 Set Register                                */
    
    struct {
      __IOM uint32 SST        : 1;            /*!< [0..0] SST                                                                */
      __IOM uint32 RESYNC     : 1;            /*!< [1..1] RESYNC                                                             */
      __IOM uint32 PER        : 1;            /*!< [2..2] PER                                                                */
      __IOM uint32 CMP1       : 1;            /*!< [3..3] CMP1                                                               */
      __IOM uint32 CMP2       : 1;            /*!< [4..4] CMP2                                                               */
      __IOM uint32 CMP3       : 1;            /*!< [5..5] CMP3                                                               */
      __IOM uint32 CMP4       : 1;            /*!< [6..6] CMP4                                                               */
      __IOM uint32 MSTPER     : 1;            /*!< [7..7] MSTPER                                                             */
      __IOM uint32 MSTCMP1    : 1;            /*!< [8..8] MSTCMP1                                                            */
      __IOM uint32 MSTCMP2    : 1;            /*!< [9..9] MSTCMP2                                                            */
      __IOM uint32 MSTCMP3    : 1;            /*!< [10..10] MSTCMP3                                                          */
      __IOM uint32 MSTCMP4    : 1;            /*!< [11..11] MSTCMP4                                                          */
      __IOM uint32 TIMEVNT1   : 1;            /*!< [12..12] TIMEVNT1                                                         */
      __IOM uint32 TIMEVNT2   : 1;            /*!< [13..13] TIMEVNT2                                                         */
      __IOM uint32 TIMEVNT3   : 1;            /*!< [14..14] TIMEVNT3                                                         */
      __IOM uint32 TIMEVNT4   : 1;            /*!< [15..15] TIMEVNT4                                                         */
      __IOM uint32 TIMEVNT5   : 1;            /*!< [16..16] TIMEVNT5                                                         */
      __IOM uint32 TIMEVNT6   : 1;            /*!< [17..17] TIMEVNT6                                                         */
      __IOM uint32 TIMEVNT7   : 1;            /*!< [18..18] TIMEVNT7                                                         */
      __IOM uint32 TIMEVNT8   : 1;            /*!< [19..19] TIMEVNT8                                                         */
      __IOM uint32 TIMEVNT9   : 1;            /*!< [20..20] TIMEVNT9                                                         */
      __IOM uint32 EXTEVNT1   : 1;            /*!< [21..21] EXTEVNT1                                                         */
      __IOM uint32 EXTEVNT2   : 1;            /*!< [22..22] EXTEVNT2                                                         */
      __IOM uint32 EXTEVNT3   : 1;            /*!< [23..23] EXTEVNT3                                                         */
      __IOM uint32 EXTEVNT4   : 1;            /*!< [24..24] EXTEVNT4                                                         */
      __IOM uint32 EXTEVNT5   : 1;            /*!< [25..25] EXTEVNT5                                                         */
      __IOM uint32 EXTEVNT6   : 1;            /*!< [26..26] EXTEVNT6                                                         */
      __IOM uint32 EXTEVNT7   : 1;            /*!< [27..27] EXTEVNT7                                                         */
      __IOM uint32 EXTEVNT8   : 1;            /*!< [28..28] EXTEVNT8                                                         */
      __IOM uint32 EXTEVNT9   : 1;            /*!< [29..29] EXTEVNT9                                                         */
      __IOM uint32 EXTEVNT10  : 1;            /*!< [30..30] EXTEVNT10                                                        */
      __IOM uint32 UPDATE     : 1;            /*!< [31..31] UPDATE                                                           */
    } bit;
  } SETD2R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000048) Timerx Output2 Reset Register                              */
    
    struct {
      __IOM uint32 SRT        : 1;            /*!< [0..0] SRT                                                                */
      __IOM uint32 RESYNC     : 1;            /*!< [1..1] RESYNC                                                             */
      __IOM uint32 PER        : 1;            /*!< [2..2] PER                                                                */
      __IOM uint32 CMP1       : 1;            /*!< [3..3] CMP1                                                               */
      __IOM uint32 CMP2       : 1;            /*!< [4..4] CMP2                                                               */
      __IOM uint32 CMP3       : 1;            /*!< [5..5] CMP3                                                               */
      __IOM uint32 CMP4       : 1;            /*!< [6..6] CMP4                                                               */
      __IOM uint32 MSTPER     : 1;            /*!< [7..7] MSTPER                                                             */
      __IOM uint32 MSTCMP1    : 1;            /*!< [8..8] MSTCMP1                                                            */
      __IOM uint32 MSTCMP2    : 1;            /*!< [9..9] MSTCMP2                                                            */
      __IOM uint32 MSTCMP3    : 1;            /*!< [10..10] MSTCMP3                                                          */
      __IOM uint32 MSTCMP4    : 1;            /*!< [11..11] MSTCMP4                                                          */
      __IOM uint32 TIMEVNT1   : 1;            /*!< [12..12] TIMEVNT1                                                         */
      __IOM uint32 TIMEVNT2   : 1;            /*!< [13..13] TIMEVNT2                                                         */
      __IOM uint32 TIMEVNT3   : 1;            /*!< [14..14] TIMEVNT3                                                         */
      __IOM uint32 TIMEVNT4   : 1;            /*!< [15..15] TIMEVNT4                                                         */
      __IOM uint32 TIMEVNT5   : 1;            /*!< [16..16] TIMEVNT5                                                         */
      __IOM uint32 TIMEVNT6   : 1;            /*!< [17..17] TIMEVNT6                                                         */
      __IOM uint32 TIMEVNT7   : 1;            /*!< [18..18] TIMEVNT7                                                         */
      __IOM uint32 TIMEVNT8   : 1;            /*!< [19..19] TIMEVNT8                                                         */
      __IOM uint32 TIMEVNT9   : 1;            /*!< [20..20] TIMEVNT9                                                         */
      __IOM uint32 EXTEVNT1   : 1;            /*!< [21..21] EXTEVNT1                                                         */
      __IOM uint32 EXTEVNT2   : 1;            /*!< [22..22] EXTEVNT2                                                         */
      __IOM uint32 EXTEVNT3   : 1;            /*!< [23..23] EXTEVNT3                                                         */
      __IOM uint32 EXTEVNT4   : 1;            /*!< [24..24] EXTEVNT4                                                         */
      __IOM uint32 EXTEVNT5   : 1;            /*!< [25..25] EXTEVNT5                                                         */
      __IOM uint32 EXTEVNT6   : 1;            /*!< [26..26] EXTEVNT6                                                         */
      __IOM uint32 EXTEVNT7   : 1;            /*!< [27..27] EXTEVNT7                                                         */
      __IOM uint32 EXTEVNT8   : 1;            /*!< [28..28] EXTEVNT8                                                         */
      __IOM uint32 EXTEVNT9   : 1;            /*!< [29..29] EXTEVNT9                                                         */
      __IOM uint32 EXTEVNT10  : 1;            /*!< [30..30] EXTEVNT10                                                        */
      __IOM uint32 UPDATE     : 1;            /*!< [31..31] UPDATE                                                           */
    } bit;
  } RSTD2R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000004C) Timerx External Event Filtering Register 1                 */
    
    struct {
      __IOM uint32 EE1LTCH    : 1;            /*!< [0..0] External Event 1 latch                                             */
      __IOM uint32 EE1FLTR    : 4;            /*!< [4..1] External Event 1 filter                                            */
            uint32            : 1;
      __IOM uint32 EE2LTCH    : 1;            /*!< [6..6] External Event 2 latch                                             */
      __IOM uint32 EE2FLTR    : 4;            /*!< [10..7] External Event 2 filter                                           */
            uint32            : 1;
      __IOM uint32 EE3LTCH    : 1;            /*!< [12..12] External Event 3 latch                                           */
      __IOM uint32 EE3FLTR    : 4;            /*!< [16..13] External Event 3 filter                                          */
            uint32            : 1;
      __IOM uint32 EE4LTCH    : 1;            /*!< [18..18] External Event 4 latch                                           */
      __IOM uint32 EE4FLTR    : 4;            /*!< [22..19] External Event 4 filter                                          */
            uint32            : 1;
      __IOM uint32 EE5LTCH    : 1;            /*!< [24..24] External Event 5 latch                                           */
      __IOM uint32 EE5FLTR    : 4;            /*!< [28..25] External Event 5 filter                                          */
            uint32            : 3;
    } bit;
  } EEFDR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000050) Timerx External Event Filtering Register 2                 */
    
    struct {
      __IOM uint32 EE6LTCH    : 1;            /*!< [0..0] External Event 6 latch                                             */
      __IOM uint32 EE6FLTR    : 4;            /*!< [4..1] External Event 6 filter                                            */
            uint32            : 1;
      __IOM uint32 EE7LTCH    : 1;            /*!< [6..6] External Event 7 latch                                             */
      __IOM uint32 EE7FLTR    : 4;            /*!< [10..7] External Event 7 filter                                           */
            uint32            : 1;
      __IOM uint32 EE8LTCH    : 1;            /*!< [12..12] External Event 8 latch                                           */
      __IOM uint32 EE8FLTR    : 4;            /*!< [16..13] External Event 8 filter                                          */
            uint32            : 1;
      __IOM uint32 EE9LTCH    : 1;            /*!< [18..18] External Event 9 latch                                           */
      __IOM uint32 EE9FLTR    : 4;            /*!< [22..19] External Event 9 filter                                          */
            uint32            : 1;
      __IOM uint32 EE10LTCH   : 1;            /*!< [24..24] External Event 10 latch                                          */
      __IOM uint32 EE10FLTR   : 4;            /*!< [28..25] External Event 10 filter                                         */
            uint32            : 3;
    } bit;
  } EEFDR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000054) TimerA Reset Register                                      */
    
    struct {
            uint32            : 1;
      __IOM uint32 UPDT       : 1;            /*!< [1..1] Timer A Update reset                                               */
      __IOM uint32 CMP2       : 1;            /*!< [2..2] Timer A compare 2 reset                                            */
      __IOM uint32 CMP4       : 1;            /*!< [3..3] Timer A compare 4 reset                                            */
      __IOM uint32 MSTPER     : 1;            /*!< [4..4] Master timer Period                                                */
      __IOM uint32 MSTCMP1    : 1;            /*!< [5..5] Master compare 1                                                   */
      __IOM uint32 MSTCMP2    : 1;            /*!< [6..6] Master compare 2                                                   */
      __IOM uint32 MSTCMP3    : 1;            /*!< [7..7] Master compare 3                                                   */
      __IOM uint32 MSTCMP4    : 1;            /*!< [8..8] Master compare 4                                                   */
      __IOM uint32 EXTEVNT1   : 1;            /*!< [9..9] External Event 1                                                   */
      __IOM uint32 EXTEVNT2   : 1;            /*!< [10..10] External Event 2                                                 */
      __IOM uint32 EXTEVNT3   : 1;            /*!< [11..11] External Event 3                                                 */
      __IOM uint32 EXTEVNT4   : 1;            /*!< [12..12] External Event 4                                                 */
      __IOM uint32 EXTEVNT5   : 1;            /*!< [13..13] External Event 5                                                 */
      __IOM uint32 EXTEVNT6   : 1;            /*!< [14..14] External Event 6                                                 */
      __IOM uint32 EXTEVNT7   : 1;            /*!< [15..15] External Event 7                                                 */
      __IOM uint32 EXTEVNT8   : 1;            /*!< [16..16] External Event 8                                                 */
      __IOM uint32 EXTEVNT9   : 1;            /*!< [17..17] External Event 9                                                 */
      __IOM uint32 EXTEVNT10  : 1;            /*!< [18..18] External Event 10                                                */
      __IOM uint32 TIMACMP1   : 1;            /*!< [19..19] Timer A Compare 1                                                */
      __IOM uint32 TIMACMP2   : 1;            /*!< [20..20] Timer A Compare 2                                                */
      __IOM uint32 TIMACMP4   : 1;            /*!< [21..21] Timer A Compare 4                                                */
      __IOM uint32 TIMBCMP1   : 1;            /*!< [22..22] Timer B Compare 1                                                */
      __IOM uint32 TIMBCMP2   : 1;            /*!< [23..23] Timer B Compare 2                                                */
      __IOM uint32 TIMBCMP4   : 1;            /*!< [24..24] Timer B Compare 4                                                */
      __IOM uint32 TIMCCMP1   : 1;            /*!< [25..25] Timer C Compare 1                                                */
      __IOM uint32 TIMCCMP2   : 1;            /*!< [26..26] Timer C Compare 2                                                */
      __IOM uint32 TIMCCMP4   : 1;            /*!< [27..27] Timer C Compare 4                                                */
      __IOM uint32 TIMECMP1   : 1;            /*!< [28..28] Timer E Compare 1                                                */
      __IOM uint32 TIMECMP2   : 1;            /*!< [29..29] Timer E Compare 2                                                */
      __IOM uint32 TIMECMP4   : 1;            /*!< [30..30] Timer E Compare 4                                                */
            uint32            : 1;
    } bit;
  } RSTDR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000058) Timerx Chopper Register                                    */
    
    struct {
      __IOM uint32 CHPFRQ     : 4;            /*!< [3..0] Timerx carrier frequency value                                     */
      __IOM uint32 CHPDTY     : 3;            /*!< [6..4] Timerx chopper duty cycle value                                    */
      __IOM uint32 STRTPW     : 4;            /*!< [10..7] STRTPW                                                            */
            uint32            : 21;
    } bit;
  } CHPDR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000005C) Timerx Capture 2 Control Register                          */
    
    struct {
      __IOM uint32 SWCPT      : 1;            /*!< [0..0] Software Capture                                                   */
      __IOM uint32 UDPCPT     : 1;            /*!< [1..1] Update Capture                                                     */
      __IOM uint32 EXEV1CPT   : 1;            /*!< [2..2] External Event 1 Capture                                           */
      __IOM uint32 EXEV2CPT   : 1;            /*!< [3..3] External Event 2 Capture                                           */
      __IOM uint32 EXEV3CPT   : 1;            /*!< [4..4] External Event 3 Capture                                           */
      __IOM uint32 EXEV4CPT   : 1;            /*!< [5..5] External Event 4 Capture                                           */
      __IOM uint32 EXEV5CPT   : 1;            /*!< [6..6] External Event 5 Capture                                           */
      __IOM uint32 EXEV6CPT   : 1;            /*!< [7..7] External Event 6 Capture                                           */
      __IOM uint32 EXEV7CPT   : 1;            /*!< [8..8] External Event 7 Capture                                           */
      __IOM uint32 EXEV8CPT   : 1;            /*!< [9..9] External Event 8 Capture                                           */
      __IOM uint32 EXEV9CPT   : 1;            /*!< [10..10] External Event 9 Capture                                         */
      __IOM uint32 EXEV10CPT  : 1;            /*!< [11..11] External Event 10 Capture                                        */
      __IOM uint32 TA1SET     : 1;            /*!< [12..12] Timer A output 1 Set                                             */
      __IOM uint32 TA1RST     : 1;            /*!< [13..13] Timer A output 1 Reset                                           */
      __IOM uint32 TACMP1     : 1;            /*!< [14..14] Timer A Compare 1                                                */
      __IOM uint32 TACMP2     : 1;            /*!< [15..15] Timer A Compare 2                                                */
      __IOM uint32 TB1SET     : 1;            /*!< [16..16] Timer B output 1 Set                                             */
      __IOM uint32 TB1RST     : 1;            /*!< [17..17] Timer B output 1 Reset                                           */
      __IOM uint32 TBCMP1     : 1;            /*!< [18..18] Timer B Compare 1                                                */
      __IOM uint32 TBCMP2     : 1;            /*!< [19..19] Timer B Compare 2                                                */
      __IOM uint32 TC1SET     : 1;            /*!< [20..20] Timer C output 1 Set                                             */
      __IOM uint32 TC1RST     : 1;            /*!< [21..21] Timer C output 1 Reset                                           */
      __IOM uint32 TCCMP1     : 1;            /*!< [22..22] Timer C Compare 1                                                */
      __IOM uint32 TCCMP2     : 1;            /*!< [23..23] Timer C Compare 2                                                */
            uint32            : 4;
      __IOM uint32 TE1SET     : 1;            /*!< [28..28] Timer E output 1 Set                                             */
      __IOM uint32 TE1RST     : 1;            /*!< [29..29] Timer E output 1 Reset                                           */
      __IOM uint32 TECMP1     : 1;            /*!< [30..30] Timer E Compare 1                                                */
      __IOM uint32 TECMP2     : 1;            /*!< [31..31] Timer E Compare 2                                                */
    } bit;
  } CPT1DCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000060) CPT2xCR                                                    */
    
    struct {
      __IOM uint32 SWCPT      : 1;            /*!< [0..0] Software Capture                                                   */
      __IOM uint32 UDPCPT     : 1;            /*!< [1..1] Update Capture                                                     */
      __IOM uint32 EXEV1CPT   : 1;            /*!< [2..2] External Event 1 Capture                                           */
      __IOM uint32 EXEV2CPT   : 1;            /*!< [3..3] External Event 2 Capture                                           */
      __IOM uint32 EXEV3CPT   : 1;            /*!< [4..4] External Event 3 Capture                                           */
      __IOM uint32 EXEV4CPT   : 1;            /*!< [5..5] External Event 4 Capture                                           */
      __IOM uint32 EXEV5CPT   : 1;            /*!< [6..6] External Event 5 Capture                                           */
      __IOM uint32 EXEV6CPT   : 1;            /*!< [7..7] External Event 6 Capture                                           */
      __IOM uint32 EXEV7CPT   : 1;            /*!< [8..8] External Event 7 Capture                                           */
      __IOM uint32 EXEV8CPT   : 1;            /*!< [9..9] External Event 8 Capture                                           */
      __IOM uint32 EXEV9CPT   : 1;            /*!< [10..10] External Event 9 Capture                                         */
      __IOM uint32 EXEV10CPT  : 1;            /*!< [11..11] External Event 10 Capture                                        */
      __IOM uint32 TA1SET     : 1;            /*!< [12..12] Timer A output 1 Set                                             */
      __IOM uint32 TA1RST     : 1;            /*!< [13..13] Timer A output 1 Reset                                           */
      __IOM uint32 TACMP1     : 1;            /*!< [14..14] Timer A Compare 1                                                */
      __IOM uint32 TACMP2     : 1;            /*!< [15..15] Timer A Compare 2                                                */
      __IOM uint32 TB1SET     : 1;            /*!< [16..16] Timer B output 1 Set                                             */
      __IOM uint32 TB1RST     : 1;            /*!< [17..17] Timer B output 1 Reset                                           */
      __IOM uint32 TBCMP1     : 1;            /*!< [18..18] Timer B Compare 1                                                */
      __IOM uint32 TBCMP2     : 1;            /*!< [19..19] Timer B Compare 2                                                */
      __IOM uint32 TC1SET     : 1;            /*!< [20..20] Timer C output 1 Set                                             */
      __IOM uint32 TC1RST     : 1;            /*!< [21..21] Timer C output 1 Reset                                           */
      __IOM uint32 TCCMP1     : 1;            /*!< [22..22] Timer C Compare 1                                                */
      __IOM uint32 TCCMP2     : 1;            /*!< [23..23] Timer C Compare 2                                                */
            uint32            : 4;
      __IOM uint32 TE1SET     : 1;            /*!< [28..28] Timer E output 1 Set                                             */
      __IOM uint32 TE1RST     : 1;            /*!< [29..29] Timer E output 1 Reset                                           */
      __IOM uint32 TECMP1     : 1;            /*!< [30..30] Timer E Compare 1                                                */
      __IOM uint32 TECMP2     : 1;            /*!< [31..31] Timer E Compare 2                                                */
    } bit;
  } CPT2DCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000064) Timerx Output Register                                     */
    
    struct {
            uint32            : 1;
      __IOM uint32 POL1       : 1;            /*!< [1..1] Output 1 polarity                                                  */
      __IOM uint32 IDLEM1     : 1;            /*!< [2..2] Output 1 Idle mode                                                 */
      __IOM uint32 IDLES1     : 1;            /*!< [3..3] Output 1 Idle State                                                */
      __IOM uint32 FAULT1     : 2;            /*!< [5..4] Output 1 Fault state                                               */
      __IOM uint32 CHP1       : 1;            /*!< [6..6] Output 1 Chopper enable                                            */
      __IOM uint32 DIDL1      : 1;            /*!< [7..7] Output 1 Deadtime upon burst mode Idle entry                       */
      __IOM uint32 DTEN       : 1;            /*!< [8..8] Deadtime enable                                                    */
      __IOM uint32 DLYPRTEN   : 1;            /*!< [9..9] Delayed Protection Enable                                          */
      __IOM uint32 DLYPRT     : 3;            /*!< [12..10] Delayed Protection                                               */
            uint32            : 4;
      __IOM uint32 POL2       : 1;            /*!< [17..17] Output 2 polarity                                                */
      __IOM uint32 IDLEM2     : 1;            /*!< [18..18] Output 2 Idle mode                                               */
      __IOM uint32 IDLES2     : 1;            /*!< [19..19] Output 2 Idle State                                              */
      __IOM uint32 FAULT2     : 2;            /*!< [21..20] Output 2 Fault state                                             */
      __IOM uint32 CHP2       : 1;            /*!< [22..22] Output 2 Chopper enable                                          */
      __IOM uint32 DIDL2      : 1;            /*!< [23..23] Output 2 Deadtime upon burst mode Idle entry                     */
            uint32            : 8;
    } bit;
  } OUTDR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000068) Timerx Fault Register                                      */
    
    struct {
      __IOM uint32 FLT1EN     : 1;            /*!< [0..0] Fault 1 enable                                                     */
      __IOM uint32 FLT2EN     : 1;            /*!< [1..1] Fault 2 enable                                                     */
      __IOM uint32 FLT3EN     : 1;            /*!< [2..2] Fault 3 enable                                                     */
      __IOM uint32 FLT4EN     : 1;            /*!< [3..3] Fault 4 enable                                                     */
      __IOM uint32 FLT5EN     : 1;            /*!< [4..4] Fault 5 enable                                                     */
            uint32            : 26;
      __IOM uint32 FLTLCK     : 1;            /*!< [31..31] Fault sources Lock                                               */
    } bit;
  } FLTDR;
} HRTIM_TIMD_Type;                              /*!< Size = 108 (0x6c)                                                         */



/* =========================================================================================================================== */
/* ================                                        HRTIM_TIME                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief High Resolution Timer: TIME (HRTIM_TIME)
  */

typedef struct {                                /*!< (@ 0x40017680) HRTIM_TIME Structure                                       */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) Timerx Control Register                                    */
    
    struct {
      __IOM uint32 CK_PSCx    : 3;            /*!< [2..0] HRTIM Timer x Clock prescaler                                      */
      __IOM uint32 CONT       : 1;            /*!< [3..3] Continuous mode                                                    */
      __IOM uint32 RETRIG     : 1;            /*!< [4..4] Re-triggerable mode                                                */
      __IOM uint32 HALF       : 1;            /*!< [5..5] Half mode enable                                                   */
      __IOM uint32 PSHPLL     : 1;            /*!< [6..6] Push-Pull mode enable                                              */
            uint32            : 3;
      __IOM uint32 SYNCRSTx   : 1;            /*!< [10..10] Synchronization Resets Timer x                                   */
      __IOM uint32 SYNCSTRTx  : 1;            /*!< [11..11] Synchronization Starts Timer x                                   */
      __IOM uint32 DELCMP2    : 2;            /*!< [13..12] Delayed CMP2 mode                                                */
      __IOM uint32 DELCMP4    : 2;            /*!< [15..14] Delayed CMP4 mode                                                */
            uint32            : 1;
      __IOM uint32 TxREPU     : 1;            /*!< [17..17] Timer x Repetition update                                        */
      __IOM uint32 TxRSTU     : 1;            /*!< [18..18] Timerx reset update                                              */
            uint32            : 1;
      __IOM uint32 TBU        : 1;            /*!< [20..20] TBU                                                              */
      __IOM uint32 TCU        : 1;            /*!< [21..21] TCU                                                              */
      __IOM uint32 TDU        : 1;            /*!< [22..22] TDU                                                              */
      __IOM uint32 TEU        : 1;            /*!< [23..23] TEU                                                              */
      __IOM uint32 MSTU       : 1;            /*!< [24..24] Master Timer update                                              */
      __IOM uint32 DACSYNC    : 2;            /*!< [26..25] AC Synchronization                                               */
      __IOM uint32 PREEN      : 1;            /*!< [27..27] Preload enable                                                   */
      __IOM uint32 UPDGAT     : 4;            /*!< [31..28] Update Gating                                                    */
    } bit;
  } TIMECR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000004) Timerx Interrupt Status Register                           */
    
    struct {
      __IM  uint32 CMP1       : 1;            /*!< [0..0] Compare 1 Interrupt Flag                                           */
      __IM  uint32 CMP2       : 1;            /*!< [1..1] Compare 2 Interrupt Flag                                           */
      __IM  uint32 CMP3       : 1;            /*!< [2..2] Compare 3 Interrupt Flag                                           */
      __IM  uint32 CMP4       : 1;            /*!< [3..3] Compare 4 Interrupt Flag                                           */
      __IM  uint32 REP        : 1;            /*!< [4..4] Repetition Interrupt Flag                                          */
            uint32            : 1;
      __IM  uint32 UPD        : 1;            /*!< [6..6] Update Interrupt Flag                                              */
      __IM  uint32 CPT1       : 1;            /*!< [7..7] Capture1 Interrupt Flag                                            */
      __IM  uint32 CPT2       : 1;            /*!< [8..8] Capture2 Interrupt Flag                                            */
      __IM  uint32 SETx1      : 1;            /*!< [9..9] Output 1 Set Interrupt Flag                                        */
      __IM  uint32 RSTx1      : 1;            /*!< [10..10] Output 1 Reset Interrupt Flag                                    */
      __IM  uint32 SETx2      : 1;            /*!< [11..11] Output 2 Set Interrupt Flag                                      */
      __IM  uint32 RSTx2      : 1;            /*!< [12..12] Output 2 Reset Interrupt Flag                                    */
      __IM  uint32 RST        : 1;            /*!< [13..13] Reset Interrupt Flag                                             */
      __IM  uint32 DLYPRT     : 1;            /*!< [14..14] Delayed Protection Flag                                          */
            uint32            : 1;
      __IM  uint32 CPPSTAT    : 1;            /*!< [16..16] Current Push Pull Status                                         */
      __IM  uint32 IPPSTAT    : 1;            /*!< [17..17] Idle Push Pull Status                                            */
      __IM  uint32 O1STAT     : 1;            /*!< [18..18] Output 1 State                                                   */
      __IM  uint32 O2STAT     : 1;            /*!< [19..19] Output 2 State                                                   */
            uint32            : 12;
    } bit;
  } TIMEISR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000008) Timerx Interrupt Clear Register                            */
    
    struct {
      __OM  uint32 CMP1C      : 1;            /*!< [0..0] Compare 1 Interrupt flag Clear                                     */
      __OM  uint32 CMP2C      : 1;            /*!< [1..1] Compare 2 Interrupt flag Clear                                     */
      __OM  uint32 CMP3C      : 1;            /*!< [2..2] Compare 3 Interrupt flag Clear                                     */
      __OM  uint32 CMP4C      : 1;            /*!< [3..3] Compare 4 Interrupt flag Clear                                     */
      __OM  uint32 REPC       : 1;            /*!< [4..4] Repetition Interrupt flag Clear                                    */
            uint32            : 1;
      __OM  uint32 UPDC       : 1;            /*!< [6..6] Update Interrupt flag Clear                                        */
      __OM  uint32 CPT1C      : 1;            /*!< [7..7] Capture1 Interrupt flag Clear                                      */
      __OM  uint32 CPT2C      : 1;            /*!< [8..8] Capture2 Interrupt flag Clear                                      */
      __OM  uint32 SET1xC     : 1;            /*!< [9..9] Output 1 Set flag Clear                                            */
      __OM  uint32 RSTx1C     : 1;            /*!< [10..10] Output 1 Reset flag Clear                                        */
      __OM  uint32 SET2xC     : 1;            /*!< [11..11] Output 2 Set flag Clear                                          */
      __OM  uint32 RSTx2C     : 1;            /*!< [12..12] Output 2 Reset flag Clear                                        */
      __OM  uint32 RSTC       : 1;            /*!< [13..13] Reset Interrupt flag Clear                                       */
      __OM  uint32 DLYPRTC    : 1;            /*!< [14..14] Delayed Protection Flag Clear                                    */
            uint32            : 17;
    } bit;
  } TIMEICR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) TIMxDIER5                                                  */
    
    struct {
      __IOM uint32 CMP1IE     : 1;            /*!< [0..0] CMP1IE                                                             */
      __IOM uint32 CMP2IE     : 1;            /*!< [1..1] CMP2IE                                                             */
      __IOM uint32 CMP3IE     : 1;            /*!< [2..2] CMP3IE                                                             */
      __IOM uint32 CMP4IE     : 1;            /*!< [3..3] CMP4IE                                                             */
      __IOM uint32 REPIE      : 1;            /*!< [4..4] REPIE                                                              */
            uint32            : 1;
      __IOM uint32 UPDIE      : 1;            /*!< [6..6] UPDIE                                                              */
      __IOM uint32 CPT1IE     : 1;            /*!< [7..7] CPT1IE                                                             */
      __IOM uint32 CPT2IE     : 1;            /*!< [8..8] CPT2IE                                                             */
      __IOM uint32 SET1xIE    : 1;            /*!< [9..9] SET1xIE                                                            */
      __IOM uint32 RSTx1IE    : 1;            /*!< [10..10] RSTx1IE                                                          */
      __IOM uint32 SETx2IE    : 1;            /*!< [11..11] SETx2IE                                                          */
      __IOM uint32 RSTx2IE    : 1;            /*!< [12..12] RSTx2IE                                                          */
      __IOM uint32 RSTIE      : 1;            /*!< [13..13] RSTIE                                                            */
      __IOM uint32 DLYPRTIE   : 1;            /*!< [14..14] DLYPRTIE                                                         */
            uint32            : 1;
      __IOM uint32 CMP1DE     : 1;            /*!< [16..16] CMP1DE                                                           */
      __IOM uint32 CMP2DE     : 1;            /*!< [17..17] CMP2DE                                                           */
      __IOM uint32 CMP3DE     : 1;            /*!< [18..18] CMP3DE                                                           */
      __IOM uint32 CMP4DE     : 1;            /*!< [19..19] CMP4DE                                                           */
      __IOM uint32 REPDE      : 1;            /*!< [20..20] REPDE                                                            */
            uint32            : 1;
      __IOM uint32 UPDDE      : 1;            /*!< [22..22] UPDDE                                                            */
      __IOM uint32 CPT1DE     : 1;            /*!< [23..23] CPT1DE                                                           */
      __IOM uint32 CPT2DE     : 1;            /*!< [24..24] CPT2DE                                                           */
      __IOM uint32 SET1xDE    : 1;            /*!< [25..25] SET1xDE                                                          */
      __IOM uint32 RSTx1DE    : 1;            /*!< [26..26] RSTx1DE                                                          */
      __IOM uint32 SETx2DE    : 1;            /*!< [27..27] SETx2DE                                                          */
      __IOM uint32 RSTx2DE    : 1;            /*!< [28..28] RSTx2DE                                                          */
      __IOM uint32 RSTDE      : 1;            /*!< [29..29] RSTDE                                                            */
      __IOM uint32 DLYPRTDE   : 1;            /*!< [30..30] DLYPRTDE                                                         */
            uint32            : 1;
    } bit;
  } TIMEDIER5;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) Timerx Counter Register                                    */
    
    struct {
      __IOM uint32 CNTx       : 16;           /*!< [15..0] Timerx Counter value                                              */
            uint32            : 16;
    } bit;
  } CNTER;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000014) Timerx Period Register                                     */
    
    struct {
      __IOM uint32 PERx       : 16;           /*!< [15..0] Timerx Period value                                               */
            uint32            : 16;
    } bit;
  } PERER;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000018) Timerx Repetition Register                                 */
    
    struct {
      __IOM uint32 REPx       : 8;            /*!< [7..0] Timerx Repetition counter value                                    */
            uint32            : 24;
    } bit;
  } REPER;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000001C) Timerx Compare 1 Register                                  */
    
    struct {
      __IOM uint32 CMP1x      : 16;           /*!< [15..0] Timerx Compare 1 value                                            */
            uint32            : 16;
    } bit;
  } CMP1ER;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000020) Timerx Compare 1 Compound Register                         */
    
    struct {
      __IOM uint32 CMP1x      : 16;           /*!< [15..0] Timerx Compare 1 value                                            */
      __IOM uint32 REPx       : 8;            /*!< [23..16] Timerx Repetition value (aliased from HRTIM_REPx register)       */
            uint32            : 8;
    } bit;
  } CMP1CER;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000024) Timerx Compare 2 Register                                  */
    
    struct {
      __IOM uint32 CMP2x      : 16;           /*!< [15..0] Timerx Compare 2 value                                            */
            uint32            : 16;
    } bit;
  } CMP2ER;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000028) Timerx Compare 3 Register                                  */
    
    struct {
      __IOM uint32 CMP3x      : 16;           /*!< [15..0] Timerx Compare 3 value                                            */
            uint32            : 16;
    } bit;
  } CMP3ER;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000002C) Timerx Compare 4 Register                                  */
    
    struct {
      __IOM uint32 CMP4x      : 16;           /*!< [15..0] Timerx Compare 4 value                                            */
            uint32            : 16;
    } bit;
  } CMP4ER;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000030) Timerx Capture 1 Register                                  */
    
    struct {
      __IM  uint32 CPT1x      : 16;           /*!< [15..0] Timerx Capture 1 value                                            */
            uint32            : 16;
    } bit;
  } CPT1ER;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000034) Timerx Capture 2 Register                                  */
    
    struct {
      __IM  uint32 CPT2x      : 16;           /*!< [15..0] Timerx Capture 2 value                                            */
            uint32            : 16;
    } bit;
  } CPT2ER;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000038) Timerx Deadtime Register                                   */
    
    struct {
      __IOM uint32 DTRx       : 9;            /*!< [8..0] Deadtime Rising value                                              */
      __IOM uint32 SDTRx      : 1;            /*!< [9..9] Sign Deadtime Rising value                                         */
      __IOM uint32 DTPRSC     : 3;            /*!< [12..10] Deadtime Prescaler                                               */
            uint32            : 1;
      __IOM uint32 DTRSLKx    : 1;            /*!< [14..14] Deadtime Rising Sign Lock                                        */
      __IOM uint32 DTRLKx     : 1;            /*!< [15..15] Deadtime Rising Lock                                             */
      __IOM uint32 DTFx       : 9;            /*!< [24..16] Deadtime Falling value                                           */
      __IOM uint32 SDTFx      : 1;            /*!< [25..25] Sign Deadtime Falling value                                      */
            uint32            : 4;
      __IOM uint32 DTFSLKx    : 1;            /*!< [30..30] Deadtime Falling Sign Lock                                       */
      __IOM uint32 DTFLKx     : 1;            /*!< [31..31] Deadtime Falling Lock                                            */
    } bit;
  } DTER;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000003C) Timerx Output1 Set Register                                */
    
    struct {
      __IOM uint32 SST        : 1;            /*!< [0..0] Software Set trigger                                               */
      __IOM uint32 RESYNC     : 1;            /*!< [1..1] Timer A resynchronizaton                                           */
      __IOM uint32 PER        : 1;            /*!< [2..2] Timer A Period                                                     */
      __IOM uint32 CMP1       : 1;            /*!< [3..3] Timer A compare 1                                                  */
      __IOM uint32 CMP2       : 1;            /*!< [4..4] Timer A compare 2                                                  */
      __IOM uint32 CMP3       : 1;            /*!< [5..5] Timer A compare 3                                                  */
      __IOM uint32 CMP4       : 1;            /*!< [6..6] Timer A compare 4                                                  */
      __IOM uint32 MSTPER     : 1;            /*!< [7..7] Master Period                                                      */
      __IOM uint32 MSTCMP1    : 1;            /*!< [8..8] Master Compare 1                                                   */
      __IOM uint32 MSTCMP2    : 1;            /*!< [9..9] Master Compare 2                                                   */
      __IOM uint32 MSTCMP3    : 1;            /*!< [10..10] Master Compare 3                                                 */
      __IOM uint32 MSTCMP4    : 1;            /*!< [11..11] Master Compare 4                                                 */
      __IOM uint32 TIMEVNT1   : 1;            /*!< [12..12] Timer Event 1                                                    */
      __IOM uint32 TIMEVNT2   : 1;            /*!< [13..13] Timer Event 2                                                    */
      __IOM uint32 TIMEVNT3   : 1;            /*!< [14..14] Timer Event 3                                                    */
      __IOM uint32 TIMEVNT4   : 1;            /*!< [15..15] Timer Event 4                                                    */
      __IOM uint32 TIMEVNT5   : 1;            /*!< [16..16] Timer Event 5                                                    */
      __IOM uint32 TIMEVNT6   : 1;            /*!< [17..17] Timer Event 6                                                    */
      __IOM uint32 TIMEVNT7   : 1;            /*!< [18..18] Timer Event 7                                                    */
      __IOM uint32 TIMEVNT8   : 1;            /*!< [19..19] Timer Event 8                                                    */
      __IOM uint32 TIMEVNT9   : 1;            /*!< [20..20] Timer Event 9                                                    */
      __IOM uint32 EXTEVNT1   : 1;            /*!< [21..21] External Event 1                                                 */
      __IOM uint32 EXTEVNT2   : 1;            /*!< [22..22] External Event 2                                                 */
      __IOM uint32 EXTEVNT3   : 1;            /*!< [23..23] External Event 3                                                 */
      __IOM uint32 EXTEVNT4   : 1;            /*!< [24..24] External Event 4                                                 */
      __IOM uint32 EXTEVNT5   : 1;            /*!< [25..25] External Event 5                                                 */
      __IOM uint32 EXTEVNT6   : 1;            /*!< [26..26] External Event 6                                                 */
      __IOM uint32 EXTEVNT7   : 1;            /*!< [27..27] External Event 7                                                 */
      __IOM uint32 EXTEVNT8   : 1;            /*!< [28..28] External Event 8                                                 */
      __IOM uint32 EXTEVNT9   : 1;            /*!< [29..29] External Event 9                                                 */
      __IOM uint32 EXTEVNT10  : 1;            /*!< [30..30] External Event 10                                                */
      __IOM uint32 UPDATE     : 1;            /*!< [31..31] Registers update (transfer preload to active)                    */
    } bit;
  } SETE1R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000040) Timerx Output1 Reset Register                              */
    
    struct {
      __IOM uint32 SRT        : 1;            /*!< [0..0] SRT                                                                */
      __IOM uint32 RESYNC     : 1;            /*!< [1..1] RESYNC                                                             */
      __IOM uint32 PER        : 1;            /*!< [2..2] PER                                                                */
      __IOM uint32 CMP1       : 1;            /*!< [3..3] CMP1                                                               */
      __IOM uint32 CMP2       : 1;            /*!< [4..4] CMP2                                                               */
      __IOM uint32 CMP3       : 1;            /*!< [5..5] CMP3                                                               */
      __IOM uint32 CMP4       : 1;            /*!< [6..6] CMP4                                                               */
      __IOM uint32 MSTPER     : 1;            /*!< [7..7] MSTPER                                                             */
      __IOM uint32 MSTCMP1    : 1;            /*!< [8..8] MSTCMP1                                                            */
      __IOM uint32 MSTCMP2    : 1;            /*!< [9..9] MSTCMP2                                                            */
      __IOM uint32 MSTCMP3    : 1;            /*!< [10..10] MSTCMP3                                                          */
      __IOM uint32 MSTCMP4    : 1;            /*!< [11..11] MSTCMP4                                                          */
      __IOM uint32 TIMEVNT1   : 1;            /*!< [12..12] TIMEVNT1                                                         */
      __IOM uint32 TIMEVNT2   : 1;            /*!< [13..13] TIMEVNT2                                                         */
      __IOM uint32 TIMEVNT3   : 1;            /*!< [14..14] TIMEVNT3                                                         */
      __IOM uint32 TIMEVNT4   : 1;            /*!< [15..15] TIMEVNT4                                                         */
      __IOM uint32 TIMEVNT5   : 1;            /*!< [16..16] TIMEVNT5                                                         */
      __IOM uint32 TIMEVNT6   : 1;            /*!< [17..17] TIMEVNT6                                                         */
      __IOM uint32 TIMEVNT7   : 1;            /*!< [18..18] TIMEVNT7                                                         */
      __IOM uint32 TIMEVNT8   : 1;            /*!< [19..19] TIMEVNT8                                                         */
      __IOM uint32 TIMEVNT9   : 1;            /*!< [20..20] TIMEVNT9                                                         */
      __IOM uint32 EXTEVNT1   : 1;            /*!< [21..21] EXTEVNT1                                                         */
      __IOM uint32 EXTEVNT2   : 1;            /*!< [22..22] EXTEVNT2                                                         */
      __IOM uint32 EXTEVNT3   : 1;            /*!< [23..23] EXTEVNT3                                                         */
      __IOM uint32 EXTEVNT4   : 1;            /*!< [24..24] EXTEVNT4                                                         */
      __IOM uint32 EXTEVNT5   : 1;            /*!< [25..25] EXTEVNT5                                                         */
      __IOM uint32 EXTEVNT6   : 1;            /*!< [26..26] EXTEVNT6                                                         */
      __IOM uint32 EXTEVNT7   : 1;            /*!< [27..27] EXTEVNT7                                                         */
      __IOM uint32 EXTEVNT8   : 1;            /*!< [28..28] EXTEVNT8                                                         */
      __IOM uint32 EXTEVNT9   : 1;            /*!< [29..29] EXTEVNT9                                                         */
      __IOM uint32 EXTEVNT10  : 1;            /*!< [30..30] EXTEVNT10                                                        */
      __IOM uint32 UPDATE     : 1;            /*!< [31..31] UPDATE                                                           */
    } bit;
  } RSTE1R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000044) Timerx Output2 Set Register                                */
    
    struct {
      __IOM uint32 SST        : 1;            /*!< [0..0] SST                                                                */
      __IOM uint32 RESYNC     : 1;            /*!< [1..1] RESYNC                                                             */
      __IOM uint32 PER        : 1;            /*!< [2..2] PER                                                                */
      __IOM uint32 CMP1       : 1;            /*!< [3..3] CMP1                                                               */
      __IOM uint32 CMP2       : 1;            /*!< [4..4] CMP2                                                               */
      __IOM uint32 CMP3       : 1;            /*!< [5..5] CMP3                                                               */
      __IOM uint32 CMP4       : 1;            /*!< [6..6] CMP4                                                               */
      __IOM uint32 MSTPER     : 1;            /*!< [7..7] MSTPER                                                             */
      __IOM uint32 MSTCMP1    : 1;            /*!< [8..8] MSTCMP1                                                            */
      __IOM uint32 MSTCMP2    : 1;            /*!< [9..9] MSTCMP2                                                            */
      __IOM uint32 MSTCMP3    : 1;            /*!< [10..10] MSTCMP3                                                          */
      __IOM uint32 MSTCMP4    : 1;            /*!< [11..11] MSTCMP4                                                          */
      __IOM uint32 TIMEVNT1   : 1;            /*!< [12..12] TIMEVNT1                                                         */
      __IOM uint32 TIMEVNT2   : 1;            /*!< [13..13] TIMEVNT2                                                         */
      __IOM uint32 TIMEVNT3   : 1;            /*!< [14..14] TIMEVNT3                                                         */
      __IOM uint32 TIMEVNT4   : 1;            /*!< [15..15] TIMEVNT4                                                         */
      __IOM uint32 TIMEVNT5   : 1;            /*!< [16..16] TIMEVNT5                                                         */
      __IOM uint32 TIMEVNT6   : 1;            /*!< [17..17] TIMEVNT6                                                         */
      __IOM uint32 TIMEVNT7   : 1;            /*!< [18..18] TIMEVNT7                                                         */
      __IOM uint32 TIMEVNT8   : 1;            /*!< [19..19] TIMEVNT8                                                         */
      __IOM uint32 TIMEVNT9   : 1;            /*!< [20..20] TIMEVNT9                                                         */
      __IOM uint32 EXTEVNT1   : 1;            /*!< [21..21] EXTEVNT1                                                         */
      __IOM uint32 EXTEVNT2   : 1;            /*!< [22..22] EXTEVNT2                                                         */
      __IOM uint32 EXTEVNT3   : 1;            /*!< [23..23] EXTEVNT3                                                         */
      __IOM uint32 EXTEVNT4   : 1;            /*!< [24..24] EXTEVNT4                                                         */
      __IOM uint32 EXTEVNT5   : 1;            /*!< [25..25] EXTEVNT5                                                         */
      __IOM uint32 EXTEVNT6   : 1;            /*!< [26..26] EXTEVNT6                                                         */
      __IOM uint32 EXTEVNT7   : 1;            /*!< [27..27] EXTEVNT7                                                         */
      __IOM uint32 EXTEVNT8   : 1;            /*!< [28..28] EXTEVNT8                                                         */
      __IOM uint32 EXTEVNT9   : 1;            /*!< [29..29] EXTEVNT9                                                         */
      __IOM uint32 EXTEVNT10  : 1;            /*!< [30..30] EXTEVNT10                                                        */
      __IOM uint32 UPDATE     : 1;            /*!< [31..31] UPDATE                                                           */
    } bit;
  } SETE2R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000048) Timerx Output2 Reset Register                              */
    
    struct {
      __IOM uint32 SRT        : 1;            /*!< [0..0] SRT                                                                */
      __IOM uint32 RESYNC     : 1;            /*!< [1..1] RESYNC                                                             */
      __IOM uint32 PER        : 1;            /*!< [2..2] PER                                                                */
      __IOM uint32 CMP1       : 1;            /*!< [3..3] CMP1                                                               */
      __IOM uint32 CMP2       : 1;            /*!< [4..4] CMP2                                                               */
      __IOM uint32 CMP3       : 1;            /*!< [5..5] CMP3                                                               */
      __IOM uint32 CMP4       : 1;            /*!< [6..6] CMP4                                                               */
      __IOM uint32 MSTPER     : 1;            /*!< [7..7] MSTPER                                                             */
      __IOM uint32 MSTCMP1    : 1;            /*!< [8..8] MSTCMP1                                                            */
      __IOM uint32 MSTCMP2    : 1;            /*!< [9..9] MSTCMP2                                                            */
      __IOM uint32 MSTCMP3    : 1;            /*!< [10..10] MSTCMP3                                                          */
      __IOM uint32 MSTCMP4    : 1;            /*!< [11..11] MSTCMP4                                                          */
      __IOM uint32 TIMEVNT1   : 1;            /*!< [12..12] TIMEVNT1                                                         */
      __IOM uint32 TIMEVNT2   : 1;            /*!< [13..13] TIMEVNT2                                                         */
      __IOM uint32 TIMEVNT3   : 1;            /*!< [14..14] TIMEVNT3                                                         */
      __IOM uint32 TIMEVNT4   : 1;            /*!< [15..15] TIMEVNT4                                                         */
      __IOM uint32 TIMEVNT5   : 1;            /*!< [16..16] TIMEVNT5                                                         */
      __IOM uint32 TIMEVNT6   : 1;            /*!< [17..17] TIMEVNT6                                                         */
      __IOM uint32 TIMEVNT7   : 1;            /*!< [18..18] TIMEVNT7                                                         */
      __IOM uint32 TIMEVNT8   : 1;            /*!< [19..19] TIMEVNT8                                                         */
      __IOM uint32 TIMEVNT9   : 1;            /*!< [20..20] TIMEVNT9                                                         */
      __IOM uint32 EXTEVNT1   : 1;            /*!< [21..21] EXTEVNT1                                                         */
      __IOM uint32 EXTEVNT2   : 1;            /*!< [22..22] EXTEVNT2                                                         */
      __IOM uint32 EXTEVNT3   : 1;            /*!< [23..23] EXTEVNT3                                                         */
      __IOM uint32 EXTEVNT4   : 1;            /*!< [24..24] EXTEVNT4                                                         */
      __IOM uint32 EXTEVNT5   : 1;            /*!< [25..25] EXTEVNT5                                                         */
      __IOM uint32 EXTEVNT6   : 1;            /*!< [26..26] EXTEVNT6                                                         */
      __IOM uint32 EXTEVNT7   : 1;            /*!< [27..27] EXTEVNT7                                                         */
      __IOM uint32 EXTEVNT8   : 1;            /*!< [28..28] EXTEVNT8                                                         */
      __IOM uint32 EXTEVNT9   : 1;            /*!< [29..29] EXTEVNT9                                                         */
      __IOM uint32 EXTEVNT10  : 1;            /*!< [30..30] EXTEVNT10                                                        */
      __IOM uint32 UPDATE     : 1;            /*!< [31..31] UPDATE                                                           */
    } bit;
  } RSTE2R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000004C) Timerx External Event Filtering Register 1                 */
    
    struct {
      __IOM uint32 EE1LTCH    : 1;            /*!< [0..0] External Event 1 latch                                             */
      __IOM uint32 EE1FLTR    : 4;            /*!< [4..1] External Event 1 filter                                            */
            uint32            : 1;
      __IOM uint32 EE2LTCH    : 1;            /*!< [6..6] External Event 2 latch                                             */
      __IOM uint32 EE2FLTR    : 4;            /*!< [10..7] External Event 2 filter                                           */
            uint32            : 1;
      __IOM uint32 EE3LTCH    : 1;            /*!< [12..12] External Event 3 latch                                           */
      __IOM uint32 EE3FLTR    : 4;            /*!< [16..13] External Event 3 filter                                          */
            uint32            : 1;
      __IOM uint32 EE4LTCH    : 1;            /*!< [18..18] External Event 4 latch                                           */
      __IOM uint32 EE4FLTR    : 4;            /*!< [22..19] External Event 4 filter                                          */
            uint32            : 1;
      __IOM uint32 EE5LTCH    : 1;            /*!< [24..24] External Event 5 latch                                           */
      __IOM uint32 EE5FLTR    : 4;            /*!< [28..25] External Event 5 filter                                          */
            uint32            : 3;
    } bit;
  } EEFER1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000050) Timerx External Event Filtering Register 2                 */
    
    struct {
      __IOM uint32 EE6LTCH    : 1;            /*!< [0..0] External Event 6 latch                                             */
      __IOM uint32 EE6FLTR    : 4;            /*!< [4..1] External Event 6 filter                                            */
            uint32            : 1;
      __IOM uint32 EE7LTCH    : 1;            /*!< [6..6] External Event 7 latch                                             */
      __IOM uint32 EE7FLTR    : 4;            /*!< [10..7] External Event 7 filter                                           */
            uint32            : 1;
      __IOM uint32 EE8LTCH    : 1;            /*!< [12..12] External Event 8 latch                                           */
      __IOM uint32 EE8FLTR    : 4;            /*!< [16..13] External Event 8 filter                                          */
            uint32            : 1;
      __IOM uint32 EE9LTCH    : 1;            /*!< [18..18] External Event 9 latch                                           */
      __IOM uint32 EE9FLTR    : 4;            /*!< [22..19] External Event 9 filter                                          */
            uint32            : 1;
      __IOM uint32 EE10LTCH   : 1;            /*!< [24..24] External Event 10 latch                                          */
      __IOM uint32 EE10FLTR   : 4;            /*!< [28..25] External Event 10 filter                                         */
            uint32            : 3;
    } bit;
  } EEFER2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000054) TimerA Reset Register                                      */
    
    struct {
            uint32            : 1;
      __IOM uint32 UPDT       : 1;            /*!< [1..1] Timer A Update reset                                               */
      __IOM uint32 CMP2       : 1;            /*!< [2..2] Timer A compare 2 reset                                            */
      __IOM uint32 CMP4       : 1;            /*!< [3..3] Timer A compare 4 reset                                            */
      __IOM uint32 MSTPER     : 1;            /*!< [4..4] Master timer Period                                                */
      __IOM uint32 MSTCMP1    : 1;            /*!< [5..5] Master compare 1                                                   */
      __IOM uint32 MSTCMP2    : 1;            /*!< [6..6] Master compare 2                                                   */
      __IOM uint32 MSTCMP3    : 1;            /*!< [7..7] Master compare 3                                                   */
      __IOM uint32 MSTCMP4    : 1;            /*!< [8..8] Master compare 4                                                   */
      __IOM uint32 EXTEVNT1   : 1;            /*!< [9..9] External Event 1                                                   */
      __IOM uint32 EXTEVNT2   : 1;            /*!< [10..10] External Event 2                                                 */
      __IOM uint32 EXTEVNT3   : 1;            /*!< [11..11] External Event 3                                                 */
      __IOM uint32 EXTEVNT4   : 1;            /*!< [12..12] External Event 4                                                 */
      __IOM uint32 EXTEVNT5   : 1;            /*!< [13..13] External Event 5                                                 */
      __IOM uint32 EXTEVNT6   : 1;            /*!< [14..14] External Event 6                                                 */
      __IOM uint32 EXTEVNT7   : 1;            /*!< [15..15] External Event 7                                                 */
      __IOM uint32 EXTEVNT8   : 1;            /*!< [16..16] External Event 8                                                 */
      __IOM uint32 EXTEVNT9   : 1;            /*!< [17..17] External Event 9                                                 */
      __IOM uint32 EXTEVNT10  : 1;            /*!< [18..18] External Event 10                                                */
      __IOM uint32 TIMACMP1   : 1;            /*!< [19..19] Timer A Compare 1                                                */
      __IOM uint32 TIMACMP2   : 1;            /*!< [20..20] Timer A Compare 2                                                */
      __IOM uint32 TIMACMP4   : 1;            /*!< [21..21] Timer A Compare 4                                                */
      __IOM uint32 TIMBCMP1   : 1;            /*!< [22..22] Timer B Compare 1                                                */
      __IOM uint32 TIMBCMP2   : 1;            /*!< [23..23] Timer B Compare 2                                                */
      __IOM uint32 TIMBCMP4   : 1;            /*!< [24..24] Timer B Compare 4                                                */
      __IOM uint32 TIMCCMP1   : 1;            /*!< [25..25] Timer C Compare 1                                                */
      __IOM uint32 TIMCCMP2   : 1;            /*!< [26..26] Timer C Compare 2                                                */
      __IOM uint32 TIMCCMP4   : 1;            /*!< [27..27] Timer C Compare 4                                                */
      __IOM uint32 TIMDCMP1   : 1;            /*!< [28..28] Timer D Compare 1                                                */
      __IOM uint32 TIMDCMP2   : 1;            /*!< [29..29] Timer D Compare 2                                                */
      __IOM uint32 TIMDCMP4   : 1;            /*!< [30..30] Timer D Compare 4                                                */
            uint32            : 1;
    } bit;
  } RSTER;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000058) Timerx Chopper Register                                    */
    
    struct {
      __IOM uint32 CHPFRQ     : 4;            /*!< [3..0] Timerx carrier frequency value                                     */
      __IOM uint32 CHPDTY     : 3;            /*!< [6..4] Timerx chopper duty cycle value                                    */
      __IOM uint32 STRTPW     : 4;            /*!< [10..7] STRTPW                                                            */
            uint32            : 21;
    } bit;
  } CHPER;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000005C) Timerx Capture 2 Control Register                          */
    
    struct {
      __IOM uint32 SWCPT      : 1;            /*!< [0..0] Software Capture                                                   */
      __IOM uint32 UDPCPT     : 1;            /*!< [1..1] Update Capture                                                     */
      __IOM uint32 EXEV1CPT   : 1;            /*!< [2..2] External Event 1 Capture                                           */
      __IOM uint32 EXEV2CPT   : 1;            /*!< [3..3] External Event 2 Capture                                           */
      __IOM uint32 EXEV3CPT   : 1;            /*!< [4..4] External Event 3 Capture                                           */
      __IOM uint32 EXEV4CPT   : 1;            /*!< [5..5] External Event 4 Capture                                           */
      __IOM uint32 EXEV5CPT   : 1;            /*!< [6..6] External Event 5 Capture                                           */
      __IOM uint32 EXEV6CPT   : 1;            /*!< [7..7] External Event 6 Capture                                           */
      __IOM uint32 EXEV7CPT   : 1;            /*!< [8..8] External Event 7 Capture                                           */
      __IOM uint32 EXEV8CPT   : 1;            /*!< [9..9] External Event 8 Capture                                           */
      __IOM uint32 EXEV9CPT   : 1;            /*!< [10..10] External Event 9 Capture                                         */
      __IOM uint32 EXEV10CPT  : 1;            /*!< [11..11] External Event 10 Capture                                        */
      __IOM uint32 TA1SET     : 1;            /*!< [12..12] Timer A output 1 Set                                             */
      __IOM uint32 TA1RST     : 1;            /*!< [13..13] Timer A output 1 Reset                                           */
      __IOM uint32 TACMP1     : 1;            /*!< [14..14] Timer A Compare 1                                                */
      __IOM uint32 TACMP2     : 1;            /*!< [15..15] Timer A Compare 2                                                */
      __IOM uint32 TB1SET     : 1;            /*!< [16..16] Timer B output 1 Set                                             */
      __IOM uint32 TB1RST     : 1;            /*!< [17..17] Timer B output 1 Reset                                           */
      __IOM uint32 TBCMP1     : 1;            /*!< [18..18] Timer B Compare 1                                                */
      __IOM uint32 TBCMP2     : 1;            /*!< [19..19] Timer B Compare 2                                                */
      __IOM uint32 TC1SET     : 1;            /*!< [20..20] Timer C output 1 Set                                             */
      __IOM uint32 TC1RST     : 1;            /*!< [21..21] Timer C output 1 Reset                                           */
      __IOM uint32 TCCMP1     : 1;            /*!< [22..22] Timer C Compare 1                                                */
      __IOM uint32 TCCMP2     : 1;            /*!< [23..23] Timer C Compare 2                                                */
      __IOM uint32 TD1SET     : 1;            /*!< [24..24] Timer D output 1 Set                                             */
      __IOM uint32 TD1RST     : 1;            /*!< [25..25] Timer D output 1 Reset                                           */
      __IOM uint32 TDCMP1     : 1;            /*!< [26..26] Timer D Compare 1                                                */
      __IOM uint32 TDCMP2     : 1;            /*!< [27..27] Timer D Compare 2                                                */
            uint32            : 4;
    } bit;
  } CPT1ECR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000060) CPT2xCR                                                    */
    
    struct {
      __IOM uint32 SWCPT      : 1;            /*!< [0..0] Software Capture                                                   */
      __IOM uint32 UDPCPT     : 1;            /*!< [1..1] Update Capture                                                     */
      __IOM uint32 EXEV1CPT   : 1;            /*!< [2..2] External Event 1 Capture                                           */
      __IOM uint32 EXEV2CPT   : 1;            /*!< [3..3] External Event 2 Capture                                           */
      __IOM uint32 EXEV3CPT   : 1;            /*!< [4..4] External Event 3 Capture                                           */
      __IOM uint32 EXEV4CPT   : 1;            /*!< [5..5] External Event 4 Capture                                           */
      __IOM uint32 EXEV5CPT   : 1;            /*!< [6..6] External Event 5 Capture                                           */
      __IOM uint32 EXEV6CPT   : 1;            /*!< [7..7] External Event 6 Capture                                           */
      __IOM uint32 EXEV7CPT   : 1;            /*!< [8..8] External Event 7 Capture                                           */
      __IOM uint32 EXEV8CPT   : 1;            /*!< [9..9] External Event 8 Capture                                           */
      __IOM uint32 EXEV9CPT   : 1;            /*!< [10..10] External Event 9 Capture                                         */
      __IOM uint32 EXEV10CPT  : 1;            /*!< [11..11] External Event 10 Capture                                        */
      __IOM uint32 TA1SET     : 1;            /*!< [12..12] Timer A output 1 Set                                             */
      __IOM uint32 TA1RST     : 1;            /*!< [13..13] Timer A output 1 Reset                                           */
      __IOM uint32 TACMP1     : 1;            /*!< [14..14] Timer A Compare 1                                                */
      __IOM uint32 TACMP2     : 1;            /*!< [15..15] Timer A Compare 2                                                */
      __IOM uint32 TB1SET     : 1;            /*!< [16..16] Timer B output 1 Set                                             */
      __IOM uint32 TB1RST     : 1;            /*!< [17..17] Timer B output 1 Reset                                           */
      __IOM uint32 TBCMP1     : 1;            /*!< [18..18] Timer B Compare 1                                                */
      __IOM uint32 TBCMP2     : 1;            /*!< [19..19] Timer B Compare 2                                                */
      __IOM uint32 TC1SET     : 1;            /*!< [20..20] Timer C output 1 Set                                             */
      __IOM uint32 TC1RST     : 1;            /*!< [21..21] Timer C output 1 Reset                                           */
      __IOM uint32 TCCMP1     : 1;            /*!< [22..22] Timer C Compare 1                                                */
      __IOM uint32 TCCMP2     : 1;            /*!< [23..23] Timer C Compare 2                                                */
      __IOM uint32 TD1SET     : 1;            /*!< [24..24] Timer D output 1 Set                                             */
      __IOM uint32 TD1RST     : 1;            /*!< [25..25] Timer D output 1 Reset                                           */
      __IOM uint32 TDCMP1     : 1;            /*!< [26..26] Timer D Compare 1                                                */
      __IOM uint32 TDCMP2     : 1;            /*!< [27..27] Timer D Compare 2                                                */
            uint32            : 4;
    } bit;
  } CPT2ECR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000064) Timerx Output Register                                     */
    
    struct {
            uint32            : 1;
      __IOM uint32 POL1       : 1;            /*!< [1..1] Output 1 polarity                                                  */
      __IOM uint32 IDLEM1     : 1;            /*!< [2..2] Output 1 Idle mode                                                 */
      __IOM uint32 IDLES1     : 1;            /*!< [3..3] Output 1 Idle State                                                */
      __IOM uint32 FAULT1     : 2;            /*!< [5..4] Output 1 Fault state                                               */
      __IOM uint32 CHP1       : 1;            /*!< [6..6] Output 1 Chopper enable                                            */
      __IOM uint32 DIDL1      : 1;            /*!< [7..7] Output 1 Deadtime upon burst mode Idle entry                       */
      __IOM uint32 DTEN       : 1;            /*!< [8..8] Deadtime enable                                                    */
      __IOM uint32 DLYPRTEN   : 1;            /*!< [9..9] Delayed Protection Enable                                          */
      __IOM uint32 DLYPRT     : 3;            /*!< [12..10] Delayed Protection                                               */
            uint32            : 4;
      __IOM uint32 POL2       : 1;            /*!< [17..17] Output 2 polarity                                                */
      __IOM uint32 IDLEM2     : 1;            /*!< [18..18] Output 2 Idle mode                                               */
      __IOM uint32 IDLES2     : 1;            /*!< [19..19] Output 2 Idle State                                              */
      __IOM uint32 FAULT2     : 2;            /*!< [21..20] Output 2 Fault state                                             */
      __IOM uint32 CHP2       : 1;            /*!< [22..22] Output 2 Chopper enable                                          */
      __IOM uint32 DIDL2      : 1;            /*!< [23..23] Output 2 Deadtime upon burst mode Idle entry                     */
            uint32            : 8;
    } bit;
  } OUTER;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000068) Timerx Fault Register                                      */
    
    struct {
      __IOM uint32 FLT1EN     : 1;            /*!< [0..0] Fault 1 enable                                                     */
      __IOM uint32 FLT2EN     : 1;            /*!< [1..1] Fault 2 enable                                                     */
      __IOM uint32 FLT3EN     : 1;            /*!< [2..2] Fault 3 enable                                                     */
      __IOM uint32 FLT4EN     : 1;            /*!< [3..3] Fault 4 enable                                                     */
      __IOM uint32 FLT5EN     : 1;            /*!< [4..4] Fault 5 enable                                                     */
            uint32            : 26;
      __IOM uint32 FLTLCK     : 1;            /*!< [31..31] Fault sources Lock                                               */
    } bit;
  } FLTER;
} HRTIM_TIME_Type;                              /*!< Size = 108 (0x6c)                                                         */



/* =========================================================================================================================== */
/* ================                                       HRTIM_Common                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief High Resolution Timer: Common
      functions (HRTIM_Common)
  */

typedef struct {                                /*!< (@ 0x40017780) HRTIM_Common Structure                                     */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) Control Register 1                                         */
    
    struct {
      __IOM uint32 MUDIS      : 1;            /*!< [0..0] Master Update Disable                                              */
      __IOM uint32 TAUDIS     : 1;            /*!< [1..1] Timer A Update Disable                                             */
      __IOM uint32 TBUDIS     : 1;            /*!< [2..2] Timer B Update Disable                                             */
      __IOM uint32 TCUDIS     : 1;            /*!< [3..3] Timer C Update Disable                                             */
      __IOM uint32 TDUDIS     : 1;            /*!< [4..4] Timer D Update Disable                                             */
      __IOM uint32 TEUDIS     : 1;            /*!< [5..5] Timer E Update Disable                                             */
            uint32            : 10;
      __IOM uint32 AD1USRC    : 3;            /*!< [18..16] ADC Trigger 1 Update Source                                      */
      __IOM uint32 AD2USRC    : 3;            /*!< [21..19] ADC Trigger 2 Update Source                                      */
      __IOM uint32 AD3USRC    : 3;            /*!< [24..22] ADC Trigger 3 Update Source                                      */
      __IOM uint32 AD4USRC    : 3;            /*!< [27..25] ADC Trigger 4 Update Source                                      */
            uint32            : 4;
    } bit;
  } CR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) Control Register 2                                         */
    
    struct {
      __IOM uint32 MSWU       : 1;            /*!< [0..0] Master Timer Software update                                       */
      __IOM uint32 TASWU      : 1;            /*!< [1..1] Timer A Software update                                            */
      __IOM uint32 TBSWU      : 1;            /*!< [2..2] Timer B Software Update                                            */
      __IOM uint32 TCSWU      : 1;            /*!< [3..3] Timer C Software Update                                            */
      __IOM uint32 TDSWU      : 1;            /*!< [4..4] Timer D Software Update                                            */
      __IOM uint32 TESWU      : 1;            /*!< [5..5] Timer E Software Update                                            */
            uint32            : 2;
      __IOM uint32 MRST       : 1;            /*!< [8..8] Master Counter software reset                                      */
      __IOM uint32 TARST      : 1;            /*!< [9..9] Timer A counter software reset                                     */
      __IOM uint32 TBRST      : 1;            /*!< [10..10] Timer B counter software reset                                   */
      __IOM uint32 TCRST      : 1;            /*!< [11..11] Timer C counter software reset                                   */
      __IOM uint32 TDRST      : 1;            /*!< [12..12] Timer D counter software reset                                   */
      __IOM uint32 TERST      : 1;            /*!< [13..13] Timer E counter software reset                                   */
            uint32            : 18;
    } bit;
  } CR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) Interrupt Status Register                                  */
    
    struct {
      __IM  uint32 FLT1       : 1;            /*!< [0..0] Fault 1 Interrupt Flag                                             */
      __IM  uint32 FLT2       : 1;            /*!< [1..1] Fault 2 Interrupt Flag                                             */
      __IM  uint32 FLT3       : 1;            /*!< [2..2] Fault 3 Interrupt Flag                                             */
      __IM  uint32 FLT4       : 1;            /*!< [3..3] Fault 4 Interrupt Flag                                             */
      __IM  uint32 FLT5       : 1;            /*!< [4..4] Fault 5 Interrupt Flag                                             */
      __IOM uint32 SYSFLT     : 1;            /*!< [5..5] System Fault Interrupt Flag                                        */
            uint32            : 10;
      __IM  uint32 DLLRDY     : 1;            /*!< [16..16] DLL Ready Interrupt Flag                                         */
      __IM  uint32 BMPER      : 1;            /*!< [17..17] Burst mode Period Interrupt Flag                                 */
            uint32            : 14;
    } bit;
  } ISR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) Interrupt Clear Register                                   */
    
    struct {
      __OM  uint32 FLT1C      : 1;            /*!< [0..0] Fault 1 Interrupt Flag Clear                                       */
      __OM  uint32 FLT2C      : 1;            /*!< [1..1] Fault 2 Interrupt Flag Clear                                       */
      __OM  uint32 FLT3C      : 1;            /*!< [2..2] Fault 3 Interrupt Flag Clear                                       */
      __OM  uint32 FLT4C      : 1;            /*!< [3..3] Fault 4 Interrupt Flag Clear                                       */
      __OM  uint32 FLT5C      : 1;            /*!< [4..4] Fault 5 Interrupt Flag Clear                                       */
      __IOM uint32 SYSFLTC    : 1;            /*!< [5..5] System Fault Interrupt Flag Clear                                  */
            uint32            : 10;
      __OM  uint32 DLLRDYC    : 1;            /*!< [16..16] DLL Ready Interrupt flag Clear                                   */
      __OM  uint32 BMPERC     : 1;            /*!< [17..17] Burst mode period flag Clear                                     */
            uint32            : 14;
    } bit;
  } ICR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) Interrupt Enable Register                                  */
    
    struct {
      __IOM uint32 FLT1IE     : 1;            /*!< [0..0] Fault 1 Interrupt Enable                                           */
      __IOM uint32 FLT2IE     : 1;            /*!< [1..1] Fault 2 Interrupt Enable                                           */
      __IOM uint32 FLT3IE     : 1;            /*!< [2..2] Fault 3 Interrupt Enable                                           */
      __IOM uint32 FLT4IE     : 1;            /*!< [3..3] Fault 4 Interrupt Enable                                           */
      __IOM uint32 FLT5IE     : 1;            /*!< [4..4] Fault 5 Interrupt Enable                                           */
      __IOM uint32 SYSFLTE    : 1;            /*!< [5..5] System Fault Interrupt Enable                                      */
            uint32            : 10;
      __IOM uint32 DLLRDYIE   : 1;            /*!< [16..16] DLL Ready Interrupt Enable                                       */
      __IOM uint32 BMPERIE    : 1;            /*!< [17..17] Burst mode period Interrupt Enable                               */
            uint32            : 14;
    } bit;
  } IER;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000014) Output Enable Register                                     */
    
    struct {
      __OM  uint32 TA1OEN     : 1;            /*!< [0..0] Timer A Output 1 Enable                                            */
      __OM  uint32 TA2OEN     : 1;            /*!< [1..1] Timer A Output 2 Enable                                            */
      __OM  uint32 TB1OEN     : 1;            /*!< [2..2] Timer B Output 1 Enable                                            */
      __OM  uint32 TB2OEN     : 1;            /*!< [3..3] Timer B Output 2 Enable                                            */
      __OM  uint32 TC1OEN     : 1;            /*!< [4..4] Timer C Output 1 Enable                                            */
      __OM  uint32 TC2OEN     : 1;            /*!< [5..5] Timer C Output 2 Enable                                            */
      __OM  uint32 TD1OEN     : 1;            /*!< [6..6] Timer D Output 1 Enable                                            */
      __OM  uint32 TD2OEN     : 1;            /*!< [7..7] Timer D Output 2 Enable                                            */
      __OM  uint32 TE1OEN     : 1;            /*!< [8..8] Timer E Output 1 Enable                                            */
      __OM  uint32 TE2OEN     : 1;            /*!< [9..9] Timer E Output 2 Enable                                            */
            uint32            : 22;
    } bit;
  } OENR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000018) DISR                                                       */
    
    struct {
      __IOM uint32 TA1ODIS    : 1;            /*!< [0..0] TA1ODIS                                                            */
      __IOM uint32 TA2ODIS    : 1;            /*!< [1..1] TA2ODIS                                                            */
      __IOM uint32 TB1ODIS    : 1;            /*!< [2..2] TB1ODIS                                                            */
      __IOM uint32 TB2ODIS    : 1;            /*!< [3..3] TB2ODIS                                                            */
      __IOM uint32 TC1ODIS    : 1;            /*!< [4..4] TC1ODIS                                                            */
      __IOM uint32 TC2ODIS    : 1;            /*!< [5..5] TC2ODIS                                                            */
      __IOM uint32 TD1ODIS    : 1;            /*!< [6..6] TD1ODIS                                                            */
      __IOM uint32 TD2ODIS    : 1;            /*!< [7..7] TD2ODIS                                                            */
      __IOM uint32 TE1ODIS    : 1;            /*!< [8..8] TE1ODIS                                                            */
      __IOM uint32 TE2ODIS    : 1;            /*!< [9..9] TE2ODIS                                                            */
            uint32            : 22;
    } bit;
  } DISR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000001C) Output Disable Status Register                             */
    
    struct {
      __IM  uint32 TA1ODS     : 1;            /*!< [0..0] Timer A Output 1 disable status                                    */
      __IM  uint32 TA2ODS     : 1;            /*!< [1..1] Timer A Output 2 disable status                                    */
      __IM  uint32 TB1ODS     : 1;            /*!< [2..2] Timer B Output 1 disable status                                    */
      __IM  uint32 TB2ODS     : 1;            /*!< [3..3] Timer B Output 2 disable status                                    */
      __IM  uint32 TC1ODS     : 1;            /*!< [4..4] Timer C Output 1 disable status                                    */
      __IM  uint32 TC2ODS     : 1;            /*!< [5..5] Timer C Output 2 disable status                                    */
      __IM  uint32 TD1ODS     : 1;            /*!< [6..6] Timer D Output 1 disable status                                    */
      __IM  uint32 TD2ODS     : 1;            /*!< [7..7] Timer D Output 2 disable status                                    */
      __IM  uint32 TE1ODS     : 1;            /*!< [8..8] Timer E Output 1 disable status                                    */
      __IM  uint32 TE2ODS     : 1;            /*!< [9..9] Timer E Output 2 disable status                                    */
            uint32            : 22;
    } bit;
  } ODSR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000020) Burst Mode Control Register                                */
    
    struct {
      __IOM uint32 BME        : 1;            /*!< [0..0] Burst Mode enable                                                  */
      __IOM uint32 BMOM       : 1;            /*!< [1..1] Burst Mode operating mode                                          */
      __IOM uint32 BMCLK      : 4;            /*!< [5..2] Burst Mode Clock source                                            */
      __IOM uint32 BMPRSC     : 4;            /*!< [9..6] Burst Mode Prescaler                                               */
      __IOM uint32 BMPREN     : 1;            /*!< [10..10] Burst Mode Preload Enable                                        */
            uint32            : 5;
      __IOM uint32 MTBM       : 1;            /*!< [16..16] Master Timer Burst Mode                                          */
      __IOM uint32 TABM       : 1;            /*!< [17..17] Timer A Burst Mode                                               */
      __IOM uint32 TBBM       : 1;            /*!< [18..18] Timer B Burst Mode                                               */
      __IOM uint32 TCBM       : 1;            /*!< [19..19] Timer C Burst Mode                                               */
      __IOM uint32 TDBM       : 1;            /*!< [20..20] Timer D Burst Mode                                               */
      __IOM uint32 TEBM       : 1;            /*!< [21..21] Timer E Burst Mode                                               */
            uint32            : 9;
      __IOM uint32 BMSTAT     : 1;            /*!< [31..31] Burst Mode Status                                                */
    } bit;
  } BMCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000024) BMTRG                                                      */
    
    struct {
      __IOM uint32 SW         : 1;            /*!< [0..0] SW                                                                 */
      __IOM uint32 MSTRST     : 1;            /*!< [1..1] MSTRST                                                             */
      __IOM uint32 MSTREP     : 1;            /*!< [2..2] MSTREP                                                             */
      __IOM uint32 MSTCMP1    : 1;            /*!< [3..3] MSTCMP1                                                            */
      __IOM uint32 MSTCMP2    : 1;            /*!< [4..4] MSTCMP2                                                            */
      __IOM uint32 MSTCMP3    : 1;            /*!< [5..5] MSTCMP3                                                            */
      __IOM uint32 MSTCMP4    : 1;            /*!< [6..6] MSTCMP4                                                            */
      __IOM uint32 TARST      : 1;            /*!< [7..7] TARST                                                              */
      __IOM uint32 TAREP      : 1;            /*!< [8..8] TAREP                                                              */
      __IOM uint32 TACMP1     : 1;            /*!< [9..9] TACMP1                                                             */
      __IOM uint32 TACMP2     : 1;            /*!< [10..10] TACMP2                                                           */
      __IOM uint32 TBRST      : 1;            /*!< [11..11] TBRST                                                            */
      __IOM uint32 TBREP      : 1;            /*!< [12..12] TBREP                                                            */
      __IOM uint32 TBCMP1     : 1;            /*!< [13..13] TBCMP1                                                           */
      __IOM uint32 TBCMP2     : 1;            /*!< [14..14] TBCMP2                                                           */
      __IOM uint32 TCRST      : 1;            /*!< [15..15] TCRST                                                            */
      __IOM uint32 TCREP      : 1;            /*!< [16..16] TCREP                                                            */
      __IOM uint32 TCCMP1     : 1;            /*!< [17..17] TCCMP1                                                           */
      __IOM uint32 TCCMP2     : 1;            /*!< [18..18] TCCMP2                                                           */
      __IOM uint32 TDRST      : 1;            /*!< [19..19] TDRST                                                            */
      __IOM uint32 TDREP      : 1;            /*!< [20..20] TDREP                                                            */
      __IOM uint32 TDCMP1     : 1;            /*!< [21..21] TDCMP1                                                           */
      __IOM uint32 TDCMP2     : 1;            /*!< [22..22] TDCMP2                                                           */
      __IOM uint32 TERST      : 1;            /*!< [23..23] TERST                                                            */
      __IOM uint32 TEREP      : 1;            /*!< [24..24] TEREP                                                            */
      __IOM uint32 TECMP1     : 1;            /*!< [25..25] TECMP1                                                           */
      __IOM uint32 TECMP2     : 1;            /*!< [26..26] TECMP2                                                           */
            uint32            : 4;
      __IOM uint32 OCHPEV     : 1;            /*!< [31..31] OCHPEV                                                           */
    } bit;
  } BMTRG;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000028) BMCMPR6                                                    */
    
    struct {
      __IOM uint32 BMCMP      : 16;           /*!< [15..0] BMCMP                                                             */
            uint32            : 16;
    } bit;
  } BMCMPR6;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000002C) Burst Mode Period Register                                 */
    
    struct {
      __IOM uint32 BMPER      : 16;           /*!< [15..0] Burst mode Period                                                 */
            uint32            : 16;
    } bit;
  } BMPER;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000030) Timer External Event Control Register 1                    */
    
    struct {
      __IOM uint32 EE1SRC     : 2;            /*!< [1..0] External Event 1 Source                                            */
      __IOM uint32 EE1POL     : 1;            /*!< [2..2] External Event 1 Polarity                                          */
      __IOM uint32 EE1SNS     : 2;            /*!< [4..3] External Event 1 Sensitivity                                       */
      __IOM uint32 EE1FAST    : 1;            /*!< [5..5] External Event 1 Fast mode                                         */
      __IOM uint32 EE2SRC     : 2;            /*!< [7..6] External Event 2 Source                                            */
      __IOM uint32 EE2POL     : 1;            /*!< [8..8] External Event 2 Polarity                                          */
      __IOM uint32 EE2SNS     : 2;            /*!< [10..9] External Event 2 Sensitivity                                      */
      __IOM uint32 EE2FAST    : 1;            /*!< [11..11] External Event 2 Fast mode                                       */
      __IOM uint32 EE3SRC     : 2;            /*!< [13..12] External Event 3 Source                                          */
      __IOM uint32 EE3POL     : 1;            /*!< [14..14] External Event 3 Polarity                                        */
      __IOM uint32 EE3SNS     : 2;            /*!< [16..15] External Event 3 Sensitivity                                     */
      __IOM uint32 EE3FAST    : 1;            /*!< [17..17] External Event 3 Fast mode                                       */
      __IOM uint32 EE4SRC     : 2;            /*!< [19..18] External Event 4 Source                                          */
      __IOM uint32 EE4POL     : 1;            /*!< [20..20] External Event 4 Polarity                                        */
      __IOM uint32 EE4SNS     : 2;            /*!< [22..21] External Event 4 Sensitivity                                     */
      __IOM uint32 EE4FAST    : 1;            /*!< [23..23] External Event 4 Fast mode                                       */
      __IOM uint32 EE5SRC     : 2;            /*!< [25..24] External Event 5 Source                                          */
      __IOM uint32 EE5POL     : 1;            /*!< [26..26] External Event 5 Polarity                                        */
      __IOM uint32 EE5SNS     : 2;            /*!< [28..27] External Event 5 Sensitivity                                     */
      __IOM uint32 EE5FAST    : 1;            /*!< [29..29] External Event 5 Fast mode                                       */
            uint32            : 2;
    } bit;
  } EECR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000034) Timer External Event Control Register 2                    */
    
    struct {
      __IOM uint32 EE6SRC     : 2;            /*!< [1..0] External Event 6 Source                                            */
      __IOM uint32 EE6POL     : 1;            /*!< [2..2] External Event 6 Polarity                                          */
      __IOM uint32 EE6SNS     : 2;            /*!< [4..3] External Event 6 Sensitivity                                       */
            uint32            : 1;
      __IOM uint32 EE7SRC     : 2;            /*!< [7..6] External Event 7 Source                                            */
      __IOM uint32 EE7POL     : 1;            /*!< [8..8] External Event 7 Polarity                                          */
      __IOM uint32 EE7SNS     : 2;            /*!< [10..9] External Event 7 Sensitivity                                      */
            uint32            : 1;
      __IOM uint32 EE8SRC     : 2;            /*!< [13..12] External Event 8 Source                                          */
      __IOM uint32 EE8POL     : 1;            /*!< [14..14] External Event 8 Polarity                                        */
      __IOM uint32 EE8SNS     : 2;            /*!< [16..15] External Event 8 Sensitivity                                     */
            uint32            : 1;
      __IOM uint32 EE9SRC     : 2;            /*!< [19..18] External Event 9 Source                                          */
      __IOM uint32 EE9POL     : 1;            /*!< [20..20] External Event 9 Polarity                                        */
      __IOM uint32 EE9SNS     : 2;            /*!< [22..21] External Event 9 Sensitivity                                     */
            uint32            : 1;
      __IOM uint32 EE10SRC    : 2;            /*!< [25..24] External Event 10 Source                                         */
      __IOM uint32 EE10POL    : 1;            /*!< [26..26] External Event 10 Polarity                                       */
      __IOM uint32 EE10SNS    : 2;            /*!< [28..27] External Event 10 Sensitivity                                    */
            uint32            : 3;
    } bit;
  } EECR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000038) Timer External Event Control Register 3                    */
    
    struct {
      __IOM uint32 EE6SRC     : 2;            /*!< [1..0] EE6SRC                                                             */
      __IOM uint32 EE6POL     : 1;            /*!< [2..2] EE6POL                                                             */
      __IOM uint32 EE6SNS     : 2;            /*!< [4..3] EE6SNS                                                             */
            uint32            : 1;
      __IOM uint32 EE7SRC     : 2;            /*!< [7..6] EE7SRC                                                             */
      __IOM uint32 EE7POL     : 1;            /*!< [8..8] EE7POL                                                             */
      __IOM uint32 EE7SNS     : 2;            /*!< [10..9] EE7SNS                                                            */
            uint32            : 1;
      __IOM uint32 EE8SRC     : 2;            /*!< [13..12] EE8SRC                                                           */
      __IOM uint32 EE8POL     : 1;            /*!< [14..14] EE8POL                                                           */
      __IOM uint32 EE8SNS     : 2;            /*!< [16..15] EE8SNS                                                           */
            uint32            : 1;
      __IOM uint32 EE9SRC     : 2;            /*!< [19..18] EE9SRC                                                           */
      __IOM uint32 EE9POL     : 1;            /*!< [20..20] EE9POL                                                           */
      __IOM uint32 EE9SNS     : 2;            /*!< [22..21] EE9SNS                                                           */
            uint32            : 1;
      __IOM uint32 EE10SRC    : 2;            /*!< [25..24] EE10SRC                                                          */
      __IOM uint32 EE10POL    : 1;            /*!< [26..26] EE10POL                                                          */
      __IOM uint32 EE10SNS    : 2;            /*!< [28..27] EE10SNS                                                          */
            uint32            : 3;
    } bit;
  } EECR3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000003C) ADC Trigger 1 Register                                     */
    
    struct {
      __IOM uint32 AD1MC1     : 1;            /*!< [0..0] ADC trigger 1 on Master Compare 1                                  */
      __IOM uint32 AD1MC2     : 1;            /*!< [1..1] ADC trigger 1 on Master Compare 2                                  */
      __IOM uint32 AD1MC3     : 1;            /*!< [2..2] ADC trigger 1 on Master Compare 3                                  */
      __IOM uint32 AD1MC4     : 1;            /*!< [3..3] ADC trigger 1 on Master Compare 4                                  */
      __IOM uint32 AD1MPER    : 1;            /*!< [4..4] ADC trigger 1 on Master Period                                     */
      __IOM uint32 AD1EEV1    : 1;            /*!< [5..5] ADC trigger 1 on External Event 1                                  */
      __IOM uint32 AD1EEV2    : 1;            /*!< [6..6] ADC trigger 1 on External Event 2                                  */
      __IOM uint32 AD1EEV3    : 1;            /*!< [7..7] ADC trigger 1 on External Event 3                                  */
      __IOM uint32 AD1EEV4    : 1;            /*!< [8..8] ADC trigger 1 on External Event 4                                  */
      __IOM uint32 AD1EEV5    : 1;            /*!< [9..9] ADC trigger 1 on External Event 5                                  */
      __IOM uint32 AD1TAC2    : 1;            /*!< [10..10] ADC trigger 1 on Timer A compare 2                               */
      __IOM uint32 AD1TAC3    : 1;            /*!< [11..11] ADC trigger 1 on Timer A compare 3                               */
      __IOM uint32 AD1TAC4    : 1;            /*!< [12..12] ADC trigger 1 on Timer A compare 4                               */
      __IOM uint32 AD1TAPER   : 1;            /*!< [13..13] ADC trigger 1 on Timer A Period                                  */
      __IOM uint32 AD1TARST   : 1;            /*!< [14..14] ADC trigger 1 on Timer A Reset                                   */
      __IOM uint32 AD1TBC2    : 1;            /*!< [15..15] ADC trigger 1 on Timer B compare 2                               */
      __IOM uint32 AD1TBC3    : 1;            /*!< [16..16] ADC trigger 1 on Timer B compare 3                               */
      __IOM uint32 AD1TBC4    : 1;            /*!< [17..17] ADC trigger 1 on Timer B compare 4                               */
      __IOM uint32 AD1TBPER   : 1;            /*!< [18..18] ADC trigger 1 on Timer B Period                                  */
      __IOM uint32 AD1TBRST   : 1;            /*!< [19..19] ADC trigger 1 on Timer B Reset                                   */
      __IOM uint32 AD1TCC2    : 1;            /*!< [20..20] ADC trigger 1 on Timer C compare 2                               */
      __IOM uint32 AD1TCC3    : 1;            /*!< [21..21] ADC trigger 1 on Timer C compare 3                               */
      __IOM uint32 AD1TCC4    : 1;            /*!< [22..22] ADC trigger 1 on Timer C compare 4                               */
      __IOM uint32 AD1TCPER   : 1;            /*!< [23..23] ADC trigger 1 on Timer C Period                                  */
      __IOM uint32 AD1TDC2    : 1;            /*!< [24..24] ADC trigger 1 on Timer D compare 2                               */
      __IOM uint32 AD1TDC3    : 1;            /*!< [25..25] ADC trigger 1 on Timer D compare 3                               */
      __IOM uint32 AD1TDC4    : 1;            /*!< [26..26] ADC trigger 1 on Timer D compare 4                               */
      __IOM uint32 AD1TDPER   : 1;            /*!< [27..27] ADC trigger 1 on Timer D Period                                  */
      __IOM uint32 AD1TEC2    : 1;            /*!< [28..28] ADC trigger 1 on Timer E compare 2                               */
      __IOM uint32 AD1TEC3    : 1;            /*!< [29..29] ADC trigger 1 on Timer E compare 3                               */
      __IOM uint32 AD1TEC4    : 1;            /*!< [30..30] ADC trigger 1 on Timer E compare 4                               */
      __IOM uint32 AD1TEPER   : 1;            /*!< [31..31] ADC trigger 1 on Timer E Period                                  */
    } bit;
  } ADC1R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000040) ADC Trigger 2 Register                                     */
    
    struct {
      __IOM uint32 AD2MC1     : 1;            /*!< [0..0] ADC trigger 2 on Master Compare 1                                  */
      __IOM uint32 AD2MC2     : 1;            /*!< [1..1] ADC trigger 2 on Master Compare 2                                  */
      __IOM uint32 AD2MC3     : 1;            /*!< [2..2] ADC trigger 2 on Master Compare 3                                  */
      __IOM uint32 AD2MC4     : 1;            /*!< [3..3] ADC trigger 2 on Master Compare 4                                  */
      __IOM uint32 AD2MPER    : 1;            /*!< [4..4] ADC trigger 2 on Master Period                                     */
      __IOM uint32 AD2EEV6    : 1;            /*!< [5..5] ADC trigger 2 on External Event 6                                  */
      __IOM uint32 AD2EEV7    : 1;            /*!< [6..6] ADC trigger 2 on External Event 7                                  */
      __IOM uint32 AD2EEV8    : 1;            /*!< [7..7] ADC trigger 2 on External Event 8                                  */
      __IOM uint32 AD2EEV9    : 1;            /*!< [8..8] ADC trigger 2 on External Event 9                                  */
      __IOM uint32 AD2EEV10   : 1;            /*!< [9..9] ADC trigger 2 on External Event 10                                 */
      __IOM uint32 AD2TAC2    : 1;            /*!< [10..10] ADC trigger 2 on Timer A compare 2                               */
      __IOM uint32 AD2TAC3    : 1;            /*!< [11..11] ADC trigger 2 on Timer A compare 3                               */
      __IOM uint32 AD2TAC4    : 1;            /*!< [12..12] ADC trigger 2 on Timer A compare 4                               */
      __IOM uint32 AD2TAPER   : 1;            /*!< [13..13] ADC trigger 2 on Timer A Period                                  */
      __IOM uint32 AD2TBC2    : 1;            /*!< [14..14] ADC trigger 2 on Timer B compare 2                               */
      __IOM uint32 AD2TBC3    : 1;            /*!< [15..15] ADC trigger 2 on Timer B compare 3                               */
      __IOM uint32 AD2TBC4    : 1;            /*!< [16..16] ADC trigger 2 on Timer B compare 4                               */
      __IOM uint32 AD2TBPER   : 1;            /*!< [17..17] ADC trigger 2 on Timer B Period                                  */
      __IOM uint32 AD2TCC2    : 1;            /*!< [18..18] ADC trigger 2 on Timer C compare 2                               */
      __IOM uint32 AD2TCC3    : 1;            /*!< [19..19] ADC trigger 2 on Timer C compare 3                               */
      __IOM uint32 AD2TCC4    : 1;            /*!< [20..20] ADC trigger 2 on Timer C compare 4                               */
      __IOM uint32 AD2TCPER   : 1;            /*!< [21..21] ADC trigger 2 on Timer C Period                                  */
      __IOM uint32 AD2TCRST   : 1;            /*!< [22..22] ADC trigger 2 on Timer C Reset                                   */
      __IOM uint32 AD2TDC2    : 1;            /*!< [23..23] ADC trigger 2 on Timer D compare 2                               */
      __IOM uint32 AD2TDC3    : 1;            /*!< [24..24] ADC trigger 2 on Timer D compare 3                               */
      __IOM uint32 AD2TDC4    : 1;            /*!< [25..25] ADC trigger 2 on Timer D compare 4                               */
      __IOM uint32 AD2TDPER   : 1;            /*!< [26..26] ADC trigger 2 on Timer D Period                                  */
      __IOM uint32 AD2TDRST   : 1;            /*!< [27..27] ADC trigger 2 on Timer D Reset                                   */
      __IOM uint32 AD2TEC2    : 1;            /*!< [28..28] ADC trigger 2 on Timer E compare 2                               */
      __IOM uint32 AD2TEC3    : 1;            /*!< [29..29] ADC trigger 2 on Timer E compare 3                               */
      __IOM uint32 AD2TEC4    : 1;            /*!< [30..30] ADC trigger 2 on Timer E compare 4                               */
      __IOM uint32 AD2TERST   : 1;            /*!< [31..31] ADC trigger 2 on Timer E Reset                                   */
    } bit;
  } ADC2R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000044) ADC Trigger 3 Register                                     */
    
    struct {
      __IOM uint32 AD1MC1     : 1;            /*!< [0..0] AD1MC1                                                             */
      __IOM uint32 AD1MC2     : 1;            /*!< [1..1] AD1MC2                                                             */
      __IOM uint32 AD1MC3     : 1;            /*!< [2..2] AD1MC3                                                             */
      __IOM uint32 AD1MC4     : 1;            /*!< [3..3] AD1MC4                                                             */
      __IOM uint32 AD1MPER    : 1;            /*!< [4..4] AD1MPER                                                            */
      __IOM uint32 AD1EEV1    : 1;            /*!< [5..5] AD1EEV1                                                            */
      __IOM uint32 AD1EEV2    : 1;            /*!< [6..6] AD1EEV2                                                            */
      __IOM uint32 AD1EEV3    : 1;            /*!< [7..7] AD1EEV3                                                            */
      __IOM uint32 AD1EEV4    : 1;            /*!< [8..8] AD1EEV4                                                            */
      __IOM uint32 AD1EEV5    : 1;            /*!< [9..9] AD1EEV5                                                            */
      __IOM uint32 AD1TAC2    : 1;            /*!< [10..10] AD1TAC2                                                          */
      __IOM uint32 AD1TAC3    : 1;            /*!< [11..11] AD1TAC3                                                          */
      __IOM uint32 AD1TAC4    : 1;            /*!< [12..12] AD1TAC4                                                          */
      __IOM uint32 AD1TAPER   : 1;            /*!< [13..13] AD1TAPER                                                         */
      __IOM uint32 AD1TARST   : 1;            /*!< [14..14] AD1TARST                                                         */
      __IOM uint32 AD1TBC2    : 1;            /*!< [15..15] AD1TBC2                                                          */
      __IOM uint32 AD1TBC3    : 1;            /*!< [16..16] AD1TBC3                                                          */
      __IOM uint32 AD1TBC4    : 1;            /*!< [17..17] AD1TBC4                                                          */
      __IOM uint32 AD1TBPER   : 1;            /*!< [18..18] AD1TBPER                                                         */
      __IOM uint32 AD1TBRST   : 1;            /*!< [19..19] AD1TBRST                                                         */
      __IOM uint32 AD1TCC2    : 1;            /*!< [20..20] AD1TCC2                                                          */
      __IOM uint32 AD1TCC3    : 1;            /*!< [21..21] AD1TCC3                                                          */
      __IOM uint32 AD1TCC4    : 1;            /*!< [22..22] AD1TCC4                                                          */
      __IOM uint32 AD1TCPER   : 1;            /*!< [23..23] AD1TCPER                                                         */
      __IOM uint32 AD1TDC2    : 1;            /*!< [24..24] AD1TDC2                                                          */
      __IOM uint32 AD1TDC3    : 1;            /*!< [25..25] AD1TDC3                                                          */
      __IOM uint32 AD1TDC4    : 1;            /*!< [26..26] AD1TDC4                                                          */
      __IOM uint32 AD1TDPER   : 1;            /*!< [27..27] AD1TDPER                                                         */
      __IOM uint32 AD1TEC2    : 1;            /*!< [28..28] AD1TEC2                                                          */
      __IOM uint32 AD1TEC3    : 1;            /*!< [29..29] AD1TEC3                                                          */
      __IOM uint32 AD1TEC4    : 1;            /*!< [30..30] AD1TEC4                                                          */
      __IOM uint32 AD1TEPER   : 1;            /*!< [31..31] AD1TEPER                                                         */
    } bit;
  } ADC3R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000048) ADC Trigger 4 Register                                     */
    
    struct {
      __IOM uint32 AD2MC1     : 1;            /*!< [0..0] AD2MC1                                                             */
      __IOM uint32 AD2MC2     : 1;            /*!< [1..1] AD2MC2                                                             */
      __IOM uint32 AD2MC3     : 1;            /*!< [2..2] AD2MC3                                                             */
      __IOM uint32 AD2MC4     : 1;            /*!< [3..3] AD2MC4                                                             */
      __IOM uint32 AD2MPER    : 1;            /*!< [4..4] AD2MPER                                                            */
      __IOM uint32 AD2EEV6    : 1;            /*!< [5..5] AD2EEV6                                                            */
      __IOM uint32 AD2EEV7    : 1;            /*!< [6..6] AD2EEV7                                                            */
      __IOM uint32 AD2EEV8    : 1;            /*!< [7..7] AD2EEV8                                                            */
      __IOM uint32 AD2EEV9    : 1;            /*!< [8..8] AD2EEV9                                                            */
      __IOM uint32 AD2EEV10   : 1;            /*!< [9..9] AD2EEV10                                                           */
      __IOM uint32 AD2TAC2    : 1;            /*!< [10..10] AD2TAC2                                                          */
      __IOM uint32 AD2TAC3    : 1;            /*!< [11..11] AD2TAC3                                                          */
      __IOM uint32 AD2TAC4    : 1;            /*!< [12..12] AD2TAC4                                                          */
      __IOM uint32 AD2TAPER   : 1;            /*!< [13..13] AD2TAPER                                                         */
      __IOM uint32 AD2TBC2    : 1;            /*!< [14..14] AD2TBC2                                                          */
      __IOM uint32 AD2TBC3    : 1;            /*!< [15..15] AD2TBC3                                                          */
      __IOM uint32 AD2TBC4    : 1;            /*!< [16..16] AD2TBC4                                                          */
      __IOM uint32 AD2TBPER   : 1;            /*!< [17..17] AD2TBPER                                                         */
      __IOM uint32 AD2TCC2    : 1;            /*!< [18..18] AD2TCC2                                                          */
      __IOM uint32 AD2TCC3    : 1;            /*!< [19..19] AD2TCC3                                                          */
      __IOM uint32 AD2TCC4    : 1;            /*!< [20..20] AD2TCC4                                                          */
      __IOM uint32 AD2TCPER   : 1;            /*!< [21..21] AD2TCPER                                                         */
      __IOM uint32 AD2TCRST   : 1;            /*!< [22..22] AD2TCRST                                                         */
      __IOM uint32 AD2TDC2    : 1;            /*!< [23..23] AD2TDC2                                                          */
      __IOM uint32 AD2TDC3    : 1;            /*!< [24..24] AD2TDC3                                                          */
      __IOM uint32 AD2TDC4    : 1;            /*!< [25..25] AD2TDC4                                                          */
      __IOM uint32 AD2TDPER   : 1;            /*!< [26..26] AD2TDPER                                                         */
      __IOM uint32 AD2TDRST   : 1;            /*!< [27..27] AD2TDRST                                                         */
      __IOM uint32 AD2TEC2    : 1;            /*!< [28..28] AD2TEC2                                                          */
      __IOM uint32 AD2TEC3    : 1;            /*!< [29..29] AD2TEC3                                                          */
      __IOM uint32 AD2TEC4    : 1;            /*!< [30..30] AD2TEC4                                                          */
      __IOM uint32 AD2TERST   : 1;            /*!< [31..31] AD2TERST                                                         */
    } bit;
  } ADC4R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000004C) DLL Control Register                                       */
    
    struct {
      __IOM uint32 CAL        : 1;            /*!< [0..0] DLL Calibration Start                                              */
      __IOM uint32 CALEN      : 1;            /*!< [1..1] DLL Calibration Enable                                             */
      __IOM uint32 CALRTE     : 2;            /*!< [3..2] DLL Calibration rate                                               */
            uint32            : 28;
    } bit;
  } DLLCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000050) HRTIM Fault Input Register 1                               */
    
    struct {
      __IOM uint32 FLT1E      : 1;            /*!< [0..0] FLT1E                                                              */
      __IOM uint32 FLT1P      : 1;            /*!< [1..1] FLT1P                                                              */
      __IOM uint32 FLT1SRC    : 1;            /*!< [2..2] FLT1SRC                                                            */
      __IOM uint32 FLT1F      : 4;            /*!< [6..3] FLT1F                                                              */
      __IOM uint32 FLT1LCK    : 1;            /*!< [7..7] FLT1LCK                                                            */
      __IOM uint32 FLT2E      : 1;            /*!< [8..8] FLT2E                                                              */
      __IOM uint32 FLT2P      : 1;            /*!< [9..9] FLT2P                                                              */
      __IOM uint32 FLT2SRC    : 1;            /*!< [10..10] FLT2SRC                                                          */
      __IOM uint32 FLT2F      : 4;            /*!< [14..11] FLT2F                                                            */
      __IOM uint32 FLT2LCK    : 1;            /*!< [15..15] FLT2LCK                                                          */
      __IOM uint32 FLT3E      : 1;            /*!< [16..16] FLT3E                                                            */
      __IOM uint32 FLT3P      : 1;            /*!< [17..17] FLT3P                                                            */
      __IOM uint32 FLT3SRC    : 1;            /*!< [18..18] FLT3SRC                                                          */
      __IOM uint32 FLT3F      : 4;            /*!< [22..19] FLT3F                                                            */
      __IOM uint32 FLT3LCK    : 1;            /*!< [23..23] FLT3LCK                                                          */
      __IOM uint32 FLT4E      : 1;            /*!< [24..24] FLT4E                                                            */
      __IOM uint32 FLT4P      : 1;            /*!< [25..25] FLT4P                                                            */
      __IOM uint32 FLT4SRC    : 1;            /*!< [26..26] FLT4SRC                                                          */
      __IOM uint32 FLT4F      : 4;            /*!< [30..27] FLT4F                                                            */
      __IOM uint32 FLT4LCK    : 1;            /*!< [31..31] FLT4LCK                                                          */
    } bit;
  } FLTINR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000054) HRTIM Fault Input Register 2                               */
    
    struct {
      __IOM uint32 FLT5E      : 1;            /*!< [0..0] FLT5E                                                              */
      __IOM uint32 FLT5P      : 1;            /*!< [1..1] FLT5P                                                              */
      __IOM uint32 FLT5SRC    : 1;            /*!< [2..2] FLT5SRC                                                            */
      __IOM uint32 FLT5F      : 4;            /*!< [6..3] FLT5F                                                              */
      __IOM uint32 FLT5LCK    : 1;            /*!< [7..7] FLT5LCK                                                            */
            uint32            : 16;
      __IOM uint32 FLTSD      : 2;            /*!< [25..24] FLTSD                                                            */
            uint32            : 6;
    } bit;
  } FLTINR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000058) BDMUPDR                                                    */
    
    struct {
      __IOM uint32 MCR        : 1;            /*!< [0..0] MCR                                                                */
      __IOM uint32 MICR       : 1;            /*!< [1..1] MICR                                                               */
      __IOM uint32 MDIER      : 1;            /*!< [2..2] MDIER                                                              */
      __IOM uint32 MCNT       : 1;            /*!< [3..3] MCNT                                                               */
      __IOM uint32 MPER       : 1;            /*!< [4..4] MPER                                                               */
      __IOM uint32 MREP       : 1;            /*!< [5..5] MREP                                                               */
      __IOM uint32 MCMP1      : 1;            /*!< [6..6] MCMP1                                                              */
      __IOM uint32 MCMP2      : 1;            /*!< [7..7] MCMP2                                                              */
      __IOM uint32 MCMP3      : 1;            /*!< [8..8] MCMP3                                                              */
      __IOM uint32 MCMP4      : 1;            /*!< [9..9] MCMP4                                                              */
            uint32            : 22;
    } bit;
  } BDMUPDR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000005C) Burst DMA Timerx update Register                           */
    
    struct {
      __IOM uint32 TIMxCR     : 1;            /*!< [0..0] HRTIM_TIMxCR register update enable                                */
      __IOM uint32 TIMxICR    : 1;            /*!< [1..1] HRTIM_TIMxICR register update enable                               */
      __IOM uint32 TIMxDIER   : 1;            /*!< [2..2] HRTIM_TIMxDIER register update enable                              */
      __IOM uint32 TIMxCNT    : 1;            /*!< [3..3] HRTIM_CNTxR register update enable                                 */
      __IOM uint32 TIMxPER    : 1;            /*!< [4..4] HRTIM_PERxR register update enable                                 */
      __IOM uint32 TIMxREP    : 1;            /*!< [5..5] HRTIM_REPxR register update enable                                 */
      __IOM uint32 TIMxCMP1   : 1;            /*!< [6..6] HRTIM_CMP1xR register update enable                                */
      __IOM uint32 TIMxCMP2   : 1;            /*!< [7..7] HRTIM_CMP2xR register update enable                                */
      __IOM uint32 TIMxCMP3   : 1;            /*!< [8..8] HRTIM_CMP3xR register update enable                                */
      __IOM uint32 TIMxCMP4   : 1;            /*!< [9..9] HRTIM_CMP4xR register update enable                                */
      __IOM uint32 TIMx_DTxR  : 1;            /*!< [10..10] HRTIM_DTxR register update enable                                */
      __IOM uint32 TIMxSET1R  : 1;            /*!< [11..11] HRTIM_SET1xR register update enable                              */
      __IOM uint32 TIMxRST1R  : 1;            /*!< [12..12] HRTIM_RST1xR register update enable                              */
      __IOM uint32 TIMxSET2R  : 1;            /*!< [13..13] HRTIM_SET2xR register update enable                              */
      __IOM uint32 TIMxRST2R  : 1;            /*!< [14..14] HRTIM_RST2xR register update enable                              */
      __IOM uint32 TIMxEEFR1  : 1;            /*!< [15..15] HRTIM_EEFxR1 register update enable                              */
      __IOM uint32 TIMxEEFR2  : 1;            /*!< [16..16] HRTIM_EEFxR2 register update enable                              */
      __IOM uint32 TIMxRSTR   : 1;            /*!< [17..17] HRTIM_RSTxR register update enable                               */
      __IOM uint32 TIMxCHPR   : 1;            /*!< [18..18] HRTIM_CHPxR register update enable                               */
      __IOM uint32 TIMxOUTR   : 1;            /*!< [19..19] HRTIM_OUTxR register update enable                               */
      __IOM uint32 TIMxFLTR   : 1;            /*!< [20..20] HRTIM_FLTxR register update enable                               */
            uint32            : 11;
    } bit;
  } BDTxUPR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000060) Burst DMA Data Register                                    */
    
    struct {
      __IOM uint32 BDMADR     : 32;           /*!< [31..0] Burst DMA Data register                                           */
    } bit;
  } BDMADR;
} HRTIM_Common_Type;                            /*!< Size = 100 (0x64)                                                         */



/* =========================================================================================================================== */
/* ================                                           DFSDM                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Digital filter for sigma delta
      modulators (DFSDM)
  */

typedef struct {                                /*!< (@ 0x40017000) DFSDM Structure                                            */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) DFSDM channel configuration 0 register 1                   */
    
    struct {
      __IOM uint32 SITP       : 2;            /*!< [1..0] Serial interface type for channel 0                                */
      __IOM uint32 SPICKSEL   : 2;            /*!< [3..2] SPI clock select for channel 0                                     */
            uint32            : 1;
      __IOM uint32 SCDEN      : 1;            /*!< [5..5] Short-circuit detector enable on channel 0                         */
      __IOM uint32 CKABEN     : 1;            /*!< [6..6] Clock absence detector enable on channel 0                         */
      __IOM uint32 CHEN       : 1;            /*!< [7..7] Channel 0 enable                                                   */
      __IOM uint32 CHINSEL    : 1;            /*!< [8..8] Channel inputs selection                                           */
            uint32            : 3;
      __IOM uint32 DATMPX     : 2;            /*!< [13..12] Input data multiplexer for channel 0                             */
      __IOM uint32 DATPACK    : 2;            /*!< [15..14] Data packing mode in DFSDM_CHDATINyR register                    */
      __IOM uint32 CKOUTDIV   : 8;            /*!< [23..16] Output serial clock divider                                      */
            uint32            : 6;
      __IOM uint32 CKOUTSRC   : 1;            /*!< [30..30] Output serial clock source selection                             */
      __IOM uint32 DFSDMEN    : 1;            /*!< [31..31] Global enable for DFSDM interface                                */
    } bit;
  } DFSDM_CHCFG0R1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) DFSDM channel configuration 1 register 1                   */
    
    struct {
      __IOM uint32 SITP       : 2;            /*!< [1..0] Serial interface type for channel 1                                */
      __IOM uint32 SPICKSEL   : 2;            /*!< [3..2] SPI clock select for channel 1                                     */
            uint32            : 1;
      __IOM uint32 SCDEN      : 1;            /*!< [5..5] Short-circuit detector enable on channel 1                         */
      __IOM uint32 CKABEN     : 1;            /*!< [6..6] Clock absence detector enable on channel 1                         */
      __IOM uint32 CHEN       : 1;            /*!< [7..7] Channel 1 enable                                                   */
      __IOM uint32 CHINSEL    : 1;            /*!< [8..8] Channel inputs selection                                           */
            uint32            : 3;
      __IOM uint32 DATMPX     : 2;            /*!< [13..12] Input data multiplexer for channel 1                             */
      __IOM uint32 DATPACK    : 2;            /*!< [15..14] Data packing mode in DFSDM_CHDATINyR register                    */
      __IOM uint32 CKOUTDIV   : 8;            /*!< [23..16] Output serial clock divider                                      */
            uint32            : 6;
      __IOM uint32 CKOUTSRC   : 1;            /*!< [30..30] Output serial clock source selection                             */
      __IOM uint32 DFSDMEN    : 1;            /*!< [31..31] Global enable for DFSDM interface                                */
    } bit;
  } DFSDM_CHCFG1R1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) DFSDM channel configuration 2 register 1                   */
    
    struct {
      __IOM uint32 SITP       : 2;            /*!< [1..0] Serial interface type for channel 2                                */
      __IOM uint32 SPICKSEL   : 2;            /*!< [3..2] SPI clock select for channel 2                                     */
            uint32            : 1;
      __IOM uint32 SCDEN      : 1;            /*!< [5..5] Short-circuit detector enable on channel 2                         */
      __IOM uint32 CKABEN     : 1;            /*!< [6..6] Clock absence detector enable on channel 2                         */
      __IOM uint32 CHEN       : 1;            /*!< [7..7] Channel 2 enable                                                   */
      __IOM uint32 CHINSEL    : 1;            /*!< [8..8] Channel inputs selection                                           */
            uint32            : 3;
      __IOM uint32 DATMPX     : 2;            /*!< [13..12] Input data multiplexer for channel 2                             */
      __IOM uint32 DATPACK    : 2;            /*!< [15..14] Data packing mode in DFSDM_CHDATINyR register                    */
      __IOM uint32 CKOUTDIV   : 8;            /*!< [23..16] Output serial clock divider                                      */
            uint32            : 6;
      __IOM uint32 CKOUTSRC   : 1;            /*!< [30..30] Output serial clock source selection                             */
      __IOM uint32 DFSDMEN    : 1;            /*!< [31..31] Global enable for DFSDM interface                                */
    } bit;
  } DFSDM_CHCFG2R1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) DFSDM channel configuration 3 register 1                   */
    
    struct {
      __IOM uint32 SITP       : 2;            /*!< [1..0] Serial interface type for channel 3                                */
      __IOM uint32 SPICKSEL   : 2;            /*!< [3..2] SPI clock select for channel 3                                     */
            uint32            : 1;
      __IOM uint32 SCDEN      : 1;            /*!< [5..5] Short-circuit detector enable on channel 3                         */
      __IOM uint32 CKABEN     : 1;            /*!< [6..6] Clock absence detector enable on channel 3                         */
      __IOM uint32 CHEN       : 1;            /*!< [7..7] Channel 3 enable                                                   */
      __IOM uint32 CHINSEL    : 1;            /*!< [8..8] Channel inputs selection                                           */
            uint32            : 3;
      __IOM uint32 DATMPX     : 2;            /*!< [13..12] Input data multiplexer for channel 3                             */
      __IOM uint32 DATPACK    : 2;            /*!< [15..14] Data packing mode in DFSDM_CHDATINyR register                    */
      __IOM uint32 CKOUTDIV   : 8;            /*!< [23..16] Output serial clock divider                                      */
            uint32            : 6;
      __IOM uint32 CKOUTSRC   : 1;            /*!< [30..30] Output serial clock source selection                             */
      __IOM uint32 DFSDMEN    : 1;            /*!< [31..31] Global enable for DFSDM interface                                */
    } bit;
  } DFSDM_CHCFG3R1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) DFSDM channel configuration 4 register 1                   */
    
    struct {
      __IOM uint32 SITP       : 2;            /*!< [1..0] Serial interface type for channel 4                                */
      __IOM uint32 SPICKSEL   : 2;            /*!< [3..2] SPI clock select for channel 4                                     */
            uint32            : 1;
      __IOM uint32 SCDEN      : 1;            /*!< [5..5] Short-circuit detector enable on channel 4                         */
      __IOM uint32 CKABEN     : 1;            /*!< [6..6] Clock absence detector enable on channel 4                         */
      __IOM uint32 CHEN       : 1;            /*!< [7..7] Channel 4 enable                                                   */
      __IOM uint32 CHINSEL    : 1;            /*!< [8..8] Channel inputs selection                                           */
            uint32            : 3;
      __IOM uint32 DATMPX     : 2;            /*!< [13..12] Input data multiplexer for channel 4                             */
      __IOM uint32 DATPACK    : 2;            /*!< [15..14] Data packing mode in DFSDM_CHDATINyR register                    */
      __IOM uint32 CKOUTDIV   : 8;            /*!< [23..16] Output serial clock divider                                      */
            uint32            : 6;
      __IOM uint32 CKOUTSRC   : 1;            /*!< [30..30] Output serial clock source selection                             */
      __IOM uint32 DFSDMEN    : 1;            /*!< [31..31] Global enable for DFSDM interface                                */
    } bit;
  } DFSDM_CHCFG4R1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000014) DFSDM channel configuration 5 register 1                   */
    
    struct {
      __IOM uint32 SITP       : 2;            /*!< [1..0] Serial interface type for channel 5                                */
      __IOM uint32 SPICKSEL   : 2;            /*!< [3..2] SPI clock select for channel 5                                     */
            uint32            : 1;
      __IOM uint32 SCDEN      : 1;            /*!< [5..5] Short-circuit detector enable on channel 5                         */
      __IOM uint32 CKABEN     : 1;            /*!< [6..6] Clock absence detector enable on channel 5                         */
      __IOM uint32 CHEN       : 1;            /*!< [7..7] Channel 5 enable                                                   */
      __IOM uint32 CHINSEL    : 1;            /*!< [8..8] Channel inputs selection                                           */
            uint32            : 3;
      __IOM uint32 DATMPX     : 2;            /*!< [13..12] Input data multiplexer for channel 5                             */
      __IOM uint32 DATPACK    : 2;            /*!< [15..14] Data packing mode in DFSDM_CHDATINyR register                    */
      __IOM uint32 CKOUTDIV   : 8;            /*!< [23..16] Output serial clock divider                                      */
            uint32            : 6;
      __IOM uint32 CKOUTSRC   : 1;            /*!< [30..30] Output serial clock source selection                             */
      __IOM uint32 DFSDMEN    : 1;            /*!< [31..31] Global enable for DFSDM interface                                */
    } bit;
  } DFSDM_CHCFG5R1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000018) DFSDM channel configuration 6 register 1                   */
    
    struct {
      __IOM uint32 SITP       : 2;            /*!< [1..0] Serial interface type for channel 6                                */
      __IOM uint32 SPICKSEL   : 2;            /*!< [3..2] SPI clock select for channel 6                                     */
            uint32            : 1;
      __IOM uint32 SCDEN      : 1;            /*!< [5..5] Short-circuit detector enable on channel 6                         */
      __IOM uint32 CKABEN     : 1;            /*!< [6..6] Clock absence detector enable on channel 6                         */
      __IOM uint32 CHEN       : 1;            /*!< [7..7] Channel 6 enable                                                   */
      __IOM uint32 CHINSEL    : 1;            /*!< [8..8] Channel inputs selection                                           */
            uint32            : 3;
      __IOM uint32 DATMPX     : 2;            /*!< [13..12] Input data multiplexer for channel 6                             */
      __IOM uint32 DATPACK    : 2;            /*!< [15..14] Data packing mode in DFSDM_CHDATINyR register                    */
      __IOM uint32 CKOUTDIV   : 8;            /*!< [23..16] Output serial clock divider                                      */
            uint32            : 6;
      __IOM uint32 CKOUTSRC   : 1;            /*!< [30..30] Output serial clock source selection                             */
      __IOM uint32 DFSDMEN    : 1;            /*!< [31..31] Global enable for DFSDM interface                                */
    } bit;
  } DFSDM_CHCFG6R1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000001C) DFSDM channel configuration 7 register 1                   */
    
    struct {
      __IOM uint32 SITP       : 2;            /*!< [1..0] Serial interface type for channel 7                                */
      __IOM uint32 SPICKSEL   : 2;            /*!< [3..2] SPI clock select for channel 7                                     */
            uint32            : 1;
      __IOM uint32 SCDEN      : 1;            /*!< [5..5] Short-circuit detector enable on channel 7                         */
      __IOM uint32 CKABEN     : 1;            /*!< [6..6] Clock absence detector enable on channel 7                         */
      __IOM uint32 CHEN       : 1;            /*!< [7..7] Channel 7 enable                                                   */
      __IOM uint32 CHINSEL    : 1;            /*!< [8..8] Channel inputs selection                                           */
            uint32            : 3;
      __IOM uint32 DATMPX     : 2;            /*!< [13..12] Input data multiplexer for channel 7                             */
      __IOM uint32 DATPACK    : 2;            /*!< [15..14] Data packing mode in DFSDM_CHDATINyR register                    */
      __IOM uint32 CKOUTDIV   : 8;            /*!< [23..16] Output serial clock divider                                      */
            uint32            : 6;
      __IOM uint32 CKOUTSRC   : 1;            /*!< [30..30] Output serial clock source selection                             */
      __IOM uint32 DFSDMEN    : 1;            /*!< [31..31] Global enable for DFSDM interface                                */
    } bit;
  } DFSDM_CHCFG7R1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000020) DFSDM channel configuration 0 register 2                   */
    
    struct {
            uint32            : 3;
      __IOM uint32 DTRBS      : 5;            /*!< [7..3] Data right bit-shift for channel 0                                 */
      __IOM uint32 OFFSET     : 24;           /*!< [31..8] 24-bit calibration offset for channel 0                           */
    } bit;
  } DFSDM_CHCFG0R2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000024) DFSDM channel configuration 1 register 2                   */
    
    struct {
            uint32            : 3;
      __IOM uint32 DTRBS      : 5;            /*!< [7..3] Data right bit-shift for channel 1                                 */
      __IOM uint32 OFFSET     : 24;           /*!< [31..8] 24-bit calibration offset for channel 1                           */
    } bit;
  } DFSDM_CHCFG1R2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000028) DFSDM channel configuration 2 register 2                   */
    
    struct {
            uint32            : 3;
      __IOM uint32 DTRBS      : 5;            /*!< [7..3] Data right bit-shift for channel 2                                 */
      __IOM uint32 OFFSET     : 24;           /*!< [31..8] 24-bit calibration offset for channel 2                           */
    } bit;
  } DFSDM_CHCFG2R2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000002C) DFSDM channel configuration 3 register 2                   */
    
    struct {
            uint32            : 3;
      __IOM uint32 DTRBS      : 5;            /*!< [7..3] Data right bit-shift for channel 3                                 */
      __IOM uint32 OFFSET     : 24;           /*!< [31..8] 24-bit calibration offset for channel 3                           */
    } bit;
  } DFSDM_CHCFG3R2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000030) DFSDM channel configuration 4 register 2                   */
    
    struct {
            uint32            : 3;
      __IOM uint32 DTRBS      : 5;            /*!< [7..3] Data right bit-shift for channel 4                                 */
      __IOM uint32 OFFSET     : 24;           /*!< [31..8] 24-bit calibration offset for channel 4                           */
    } bit;
  } DFSDM_CHCFG4R2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000034) DFSDM channel configuration 5 register 2                   */
    
    struct {
            uint32            : 3;
      __IOM uint32 DTRBS      : 5;            /*!< [7..3] Data right bit-shift for channel 5                                 */
      __IOM uint32 OFFSET     : 24;           /*!< [31..8] 24-bit calibration offset for channel 5                           */
    } bit;
  } DFSDM_CHCFG5R2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000038) DFSDM channel configuration 6 register 2                   */
    
    struct {
            uint32            : 3;
      __IOM uint32 DTRBS      : 5;            /*!< [7..3] Data right bit-shift for channel 6                                 */
      __IOM uint32 OFFSET     : 24;           /*!< [31..8] 24-bit calibration offset for channel 6                           */
    } bit;
  } DFSDM_CHCFG6R2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000003C) DFSDM channel configuration 7 register 2                   */
    
    struct {
            uint32            : 3;
      __IOM uint32 DTRBS      : 5;            /*!< [7..3] Data right bit-shift for channel 7                                 */
      __IOM uint32 OFFSET     : 24;           /*!< [31..8] 24-bit calibration offset for channel 7                           */
    } bit;
  } DFSDM_CHCFG7R2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000040) DFSDM analog watchdog and short-circuit detector
                                                                    register                                                   */
    
    struct {
      __IOM uint32 SCDT       : 8;            /*!< [7..0] short-circuit detector threshold for channel 0                     */
            uint32            : 4;
      __IOM uint32 BKSCD      : 4;            /*!< [15..12] Break signal assignment for short-circuit detector
                                                     on channel 0                                                              */
      __IOM uint32 AWFOSR     : 5;            /*!< [20..16] Analog watchdog filter oversampling ratio (decimation
                                                     rate) on channel 0                                                        */
            uint32            : 1;
      __IOM uint32 AWFORD     : 2;            /*!< [23..22] Analog watchdog Sinc filter order on channel 0                   */
            uint32            : 8;
    } bit;
  } DFSDM_AWSCD0R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000044) DFSDM analog watchdog and short-circuit detector
                                                                    register                                                   */
    
    struct {
      __IOM uint32 SCDT       : 8;            /*!< [7..0] short-circuit detector threshold for channel 1                     */
            uint32            : 4;
      __IOM uint32 BKSCD      : 4;            /*!< [15..12] Break signal assignment for short-circuit detector
                                                     on channel 1                                                              */
      __IOM uint32 AWFOSR     : 5;            /*!< [20..16] Analog watchdog filter oversampling ratio (decimation
                                                     rate) on channel 1                                                        */
            uint32            : 1;
      __IOM uint32 AWFORD     : 2;            /*!< [23..22] Analog watchdog Sinc filter order on channel 1                   */
            uint32            : 8;
    } bit;
  } DFSDM_AWSCD1R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000048) DFSDM analog watchdog and short-circuit detector
                                                                    register                                                   */
    
    struct {
      __IOM uint32 SCDT       : 8;            /*!< [7..0] short-circuit detector threshold for channel 2                     */
            uint32            : 4;
      __IOM uint32 BKSCD      : 4;            /*!< [15..12] Break signal assignment for short-circuit detector
                                                     on channel 2                                                              */
      __IOM uint32 AWFOSR     : 5;            /*!< [20..16] Analog watchdog filter oversampling ratio (decimation
                                                     rate) on channel 2                                                        */
            uint32            : 1;
      __IOM uint32 AWFORD     : 2;            /*!< [23..22] Analog watchdog Sinc filter order on channel 2                   */
            uint32            : 8;
    } bit;
  } DFSDM_AWSCD2R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000004C) DFSDM analog watchdog and short-circuit detector
                                                                    register                                                   */
    
    struct {
      __IOM uint32 SCDT       : 8;            /*!< [7..0] short-circuit detector threshold for channel 3                     */
            uint32            : 4;
      __IOM uint32 BKSCD      : 4;            /*!< [15..12] Break signal assignment for short-circuit detector
                                                     on channel 3                                                              */
      __IOM uint32 AWFOSR     : 5;            /*!< [20..16] Analog watchdog filter oversampling ratio (decimation
                                                     rate) on channel 3                                                        */
            uint32            : 1;
      __IOM uint32 AWFORD     : 2;            /*!< [23..22] Analog watchdog Sinc filter order on channel 3                   */
            uint32            : 8;
    } bit;
  } DFSDM_AWSCD3R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000050) DFSDM analog watchdog and short-circuit detector
                                                                    register                                                   */
    
    struct {
      __IOM uint32 SCDT       : 8;            /*!< [7..0] short-circuit detector threshold for channel 4                     */
            uint32            : 4;
      __IOM uint32 BKSCD      : 4;            /*!< [15..12] Break signal assignment for short-circuit detector
                                                     on channel 4                                                              */
      __IOM uint32 AWFOSR     : 5;            /*!< [20..16] Analog watchdog filter oversampling ratio (decimation
                                                     rate) on channel 4                                                        */
            uint32            : 1;
      __IOM uint32 AWFORD     : 2;            /*!< [23..22] Analog watchdog Sinc filter order on channel 4                   */
            uint32            : 8;
    } bit;
  } DFSDM_AWSCD4R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000054) DFSDM analog watchdog and short-circuit detector
                                                                    register                                                   */
    
    struct {
      __IOM uint32 SCDT       : 8;            /*!< [7..0] short-circuit detector threshold for channel 5                     */
            uint32            : 4;
      __IOM uint32 BKSCD      : 4;            /*!< [15..12] Break signal assignment for short-circuit detector
                                                     on channel 5                                                              */
      __IOM uint32 AWFOSR     : 5;            /*!< [20..16] Analog watchdog filter oversampling ratio (decimation
                                                     rate) on channel 5                                                        */
            uint32            : 1;
      __IOM uint32 AWFORD     : 2;            /*!< [23..22] Analog watchdog Sinc filter order on channel 5                   */
            uint32            : 8;
    } bit;
  } DFSDM_AWSCD5R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000058) DFSDM analog watchdog and short-circuit detector
                                                                    register                                                   */
    
    struct {
      __IOM uint32 SCDT       : 8;            /*!< [7..0] short-circuit detector threshold for channel 6                     */
            uint32            : 4;
      __IOM uint32 BKSCD      : 4;            /*!< [15..12] Break signal assignment for short-circuit detector
                                                     on channel 6                                                              */
      __IOM uint32 AWFOSR     : 5;            /*!< [20..16] Analog watchdog filter oversampling ratio (decimation
                                                     rate) on channel 6                                                        */
            uint32            : 1;
      __IOM uint32 AWFORD     : 2;            /*!< [23..22] Analog watchdog Sinc filter order on channel 6                   */
            uint32            : 8;
    } bit;
  } DFSDM_AWSCD6R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000005C) DFSDM analog watchdog and short-circuit detector
                                                                    register                                                   */
    
    struct {
      __IOM uint32 SCDT       : 8;            /*!< [7..0] short-circuit detector threshold for channel 7                     */
            uint32            : 4;
      __IOM uint32 BKSCD      : 4;            /*!< [15..12] Break signal assignment for short-circuit detector
                                                     on channel 7                                                              */
      __IOM uint32 AWFOSR     : 5;            /*!< [20..16] Analog watchdog filter oversampling ratio (decimation
                                                     rate) on channel 7                                                        */
            uint32            : 1;
      __IOM uint32 AWFORD     : 2;            /*!< [23..22] Analog watchdog Sinc filter order on channel 7                   */
            uint32            : 8;
    } bit;
  } DFSDM_AWSCD7R;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000060) DFSDM channel watchdog filter data register                */
    
    struct {
      __IM  uint32 WDATA      : 16;           /*!< [15..0] Input channel y watchdog data                                     */
            uint32            : 16;
    } bit;
  } DFSDM_CHWDAT0R;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000064) DFSDM channel watchdog filter data register                */
    
    struct {
      __IM  uint32 WDATA      : 16;           /*!< [15..0] Input channel y watchdog data                                     */
            uint32            : 16;
    } bit;
  } DFSDM_CHWDAT1R;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000068) DFSDM channel watchdog filter data register                */
    
    struct {
      __IM  uint32 WDATA      : 16;           /*!< [15..0] Input channel y watchdog data                                     */
            uint32            : 16;
    } bit;
  } DFSDM_CHWDAT2R;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000006C) DFSDM channel watchdog filter data register                */
    
    struct {
      __IM  uint32 WDATA      : 16;           /*!< [15..0] Input channel y watchdog data                                     */
            uint32            : 16;
    } bit;
  } DFSDM_CHWDAT3R;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000070) DFSDM channel watchdog filter data register                */
    
    struct {
      __IM  uint32 WDATA      : 16;           /*!< [15..0] Input channel y watchdog data                                     */
            uint32            : 16;
    } bit;
  } DFSDM_CHWDAT4R;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000074) DFSDM channel watchdog filter data register                */
    
    struct {
      __IM  uint32 WDATA      : 16;           /*!< [15..0] Input channel y watchdog data                                     */
            uint32            : 16;
    } bit;
  } DFSDM_CHWDAT5R;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000078) DFSDM channel watchdog filter data register                */
    
    struct {
      __IM  uint32 WDATA      : 16;           /*!< [15..0] Input channel y watchdog data                                     */
            uint32            : 16;
    } bit;
  } DFSDM_CHWDAT6R;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000007C) DFSDM channel watchdog filter data register                */
    
    struct {
      __IM  uint32 WDATA      : 16;           /*!< [15..0] Input channel y watchdog data                                     */
            uint32            : 16;
    } bit;
  } DFSDM_CHWDAT7R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000080) DFSDM channel data input register                          */
    
    struct {
      __IOM uint32 INDAT0     : 16;           /*!< [15..0] Input data for channel 0                                          */
      __IOM uint32 INDAT1     : 16;           /*!< [31..16] Input data for channel 1                                         */
    } bit;
  } DFSDM_CHDATIN0R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000084) DFSDM channel data input register                          */
    
    struct {
      __IOM uint32 INDAT0     : 16;           /*!< [15..0] Input data for channel 1                                          */
      __IOM uint32 INDAT1     : 16;           /*!< [31..16] Input data for channel 2                                         */
    } bit;
  } DFSDM_CHDATIN1R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000088) DFSDM channel data input register                          */
    
    struct {
      __IOM uint32 INDAT0     : 16;           /*!< [15..0] Input data for channel 2                                          */
      __IOM uint32 INDAT1     : 16;           /*!< [31..16] Input data for channel 3                                         */
    } bit;
  } DFSDM_CHDATIN2R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000008C) DFSDM channel data input register                          */
    
    struct {
      __IOM uint32 INDAT0     : 16;           /*!< [15..0] Input data for channel 3                                          */
      __IOM uint32 INDAT1     : 16;           /*!< [31..16] Input data for channel 4                                         */
    } bit;
  } DFSDM_CHDATIN3R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000090) DFSDM channel data input register                          */
    
    struct {
      __IOM uint32 INDAT0     : 16;           /*!< [15..0] Input data for channel 4                                          */
      __IOM uint32 INDAT1     : 16;           /*!< [31..16] Input data for channel 5                                         */
    } bit;
  } DFSDM_CHDATIN4R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000094) DFSDM channel data input register                          */
    
    struct {
      __IOM uint32 INDAT0     : 16;           /*!< [15..0] Input data for channel 5                                          */
      __IOM uint32 INDAT1     : 16;           /*!< [31..16] Input data for channel 6                                         */
    } bit;
  } DFSDM_CHDATIN5R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000098) DFSDM channel data input register                          */
    
    struct {
      __IOM uint32 INDAT0     : 16;           /*!< [15..0] Input data for channel 6                                          */
      __IOM uint32 INDAT1     : 16;           /*!< [31..16] Input data for channel 7                                         */
    } bit;
  } DFSDM_CHDATIN6R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000009C) DFSDM channel data input register                          */
    
    struct {
      __IOM uint32 INDAT0     : 16;           /*!< [15..0] Input data for channel 7                                          */
      __IOM uint32 INDAT1     : 16;           /*!< [31..16] Input data for channel 8                                         */
    } bit;
  } DFSDM_CHDATIN7R;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000A0) DFSDM control register 1                                   */
    
    struct {
      __IOM uint32 DFEN       : 1;            /*!< [0..0] DFSDM enable                                                       */
      __IOM uint32 JSWSTART   : 1;            /*!< [1..1] Start a conversion of the injected group of channels               */
            uint32            : 1;
      __IOM uint32 JSYNC      : 1;            /*!< [3..3] Launch an injected conversion synchronously with the
                                                     DFSDM0 JSWSTART trigger                                                   */
      __IOM uint32 JSCAN      : 1;            /*!< [4..4] Scanning conversion mode for injected conversions                  */
      __IOM uint32 JDMAEN     : 1;            /*!< [5..5] DMA channel enabled to read data for the injected channel
                                                     group                                                                     */
            uint32            : 2;
      __IOM uint32 JEXTSEL    : 5;            /*!< [12..8] Trigger signal selection for launching injected conversions       */
      __IOM uint32 JEXTEN     : 2;            /*!< [14..13] Trigger enable and trigger edge selection for injected
                                                     conversions                                                               */
            uint32            : 2;
      __IOM uint32 RSWSTART   : 1;            /*!< [17..17] Software start of a conversion on the regular channel            */
      __IOM uint32 RCONT      : 1;            /*!< [18..18] Continuous mode selection for regular conversions                */
      __IOM uint32 RSYNC      : 1;            /*!< [19..19] Launch regular conversion synchronously with DFSDM0              */
            uint32            : 1;
      __IOM uint32 RDMAEN     : 1;            /*!< [21..21] DMA channel enabled to read data for the regular conversion      */
            uint32            : 2;
      __IOM uint32 RCH        : 3;            /*!< [26..24] Regular channel selection                                        */
            uint32            : 2;
      __IOM uint32 FAST       : 1;            /*!< [29..29] Fast conversion mode selection for regular conversions           */
      __IOM uint32 AWFSEL     : 1;            /*!< [30..30] Analog watchdog fast mode select                                 */
            uint32            : 1;
    } bit;
  } DFSDM0_CR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000A4) DFSDM control register 1                                   */
    
    struct {
      __IOM uint32 DFEN       : 1;            /*!< [0..0] DFSDM enable                                                       */
      __IOM uint32 JSWSTART   : 1;            /*!< [1..1] Start a conversion of the injected group of channels               */
            uint32            : 1;
      __IOM uint32 JSYNC      : 1;            /*!< [3..3] Launch an injected conversion synchronously with the
                                                     DFSDM0 JSWSTART trigger                                                   */
      __IOM uint32 JSCAN      : 1;            /*!< [4..4] Scanning conversion mode for injected conversions                  */
      __IOM uint32 JDMAEN     : 1;            /*!< [5..5] DMA channel enabled to read data for the injected channel
                                                     group                                                                     */
            uint32            : 2;
      __IOM uint32 JEXTSEL    : 5;            /*!< [12..8] Trigger signal selection for launching injected conversions       */
      __IOM uint32 JEXTEN     : 2;            /*!< [14..13] Trigger enable and trigger edge selection for injected
                                                     conversions                                                               */
            uint32            : 2;
      __IOM uint32 RSWSTART   : 1;            /*!< [17..17] Software start of a conversion on the regular channel            */
      __IOM uint32 RCONT      : 1;            /*!< [18..18] Continuous mode selection for regular conversions                */
      __IOM uint32 RSYNC      : 1;            /*!< [19..19] Launch regular conversion synchronously with DFSDM0              */
            uint32            : 1;
      __IOM uint32 RDMAEN     : 1;            /*!< [21..21] DMA channel enabled to read data for the regular conversion      */
            uint32            : 2;
      __IOM uint32 RCH        : 3;            /*!< [26..24] Regular channel selection                                        */
            uint32            : 2;
      __IOM uint32 FAST       : 1;            /*!< [29..29] Fast conversion mode selection for regular conversions           */
      __IOM uint32 AWFSEL     : 1;            /*!< [30..30] Analog watchdog fast mode select                                 */
            uint32            : 1;
    } bit;
  } DFSDM1_CR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000A8) DFSDM control register 1                                   */
    
    struct {
      __IOM uint32 DFEN       : 1;            /*!< [0..0] DFSDM enable                                                       */
      __IOM uint32 JSWSTART   : 1;            /*!< [1..1] Start a conversion of the injected group of channels               */
            uint32            : 1;
      __IOM uint32 JSYNC      : 1;            /*!< [3..3] Launch an injected conversion synchronously with the
                                                     DFSDM0 JSWSTART trigger                                                   */
      __IOM uint32 JSCAN      : 1;            /*!< [4..4] Scanning conversion mode for injected conversions                  */
      __IOM uint32 JDMAEN     : 1;            /*!< [5..5] DMA channel enabled to read data for the injected channel
                                                     group                                                                     */
            uint32            : 2;
      __IOM uint32 JEXTSEL    : 5;            /*!< [12..8] Trigger signal selection for launching injected conversions       */
      __IOM uint32 JEXTEN     : 2;            /*!< [14..13] Trigger enable and trigger edge selection for injected
                                                     conversions                                                               */
            uint32            : 2;
      __IOM uint32 RSWSTART   : 1;            /*!< [17..17] Software start of a conversion on the regular channel            */
      __IOM uint32 RCONT      : 1;            /*!< [18..18] Continuous mode selection for regular conversions                */
      __IOM uint32 RSYNC      : 1;            /*!< [19..19] Launch regular conversion synchronously with DFSDM0              */
            uint32            : 1;
      __IOM uint32 RDMAEN     : 1;            /*!< [21..21] DMA channel enabled to read data for the regular conversion      */
            uint32            : 2;
      __IOM uint32 RCH        : 3;            /*!< [26..24] Regular channel selection                                        */
            uint32            : 2;
      __IOM uint32 FAST       : 1;            /*!< [29..29] Fast conversion mode selection for regular conversions           */
      __IOM uint32 AWFSEL     : 1;            /*!< [30..30] Analog watchdog fast mode select                                 */
            uint32            : 1;
    } bit;
  } DFSDM2_CR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000AC) DFSDM control register 1                                   */
    
    struct {
      __IOM uint32 DFEN       : 1;            /*!< [0..0] DFSDM enable                                                       */
      __IOM uint32 JSWSTART   : 1;            /*!< [1..1] Start a conversion of the injected group of channels               */
            uint32            : 1;
      __IOM uint32 JSYNC      : 1;            /*!< [3..3] Launch an injected conversion synchronously with the
                                                     DFSDM0 JSWSTART trigger                                                   */
      __IOM uint32 JSCAN      : 1;            /*!< [4..4] Scanning conversion mode for injected conversions                  */
      __IOM uint32 JDMAEN     : 1;            /*!< [5..5] DMA channel enabled to read data for the injected channel
                                                     group                                                                     */
            uint32            : 2;
      __IOM uint32 JEXTSEL    : 5;            /*!< [12..8] Trigger signal selection for launching injected conversions       */
      __IOM uint32 JEXTEN     : 2;            /*!< [14..13] Trigger enable and trigger edge selection for injected
                                                     conversions                                                               */
            uint32            : 2;
      __IOM uint32 RSWSTART   : 1;            /*!< [17..17] Software start of a conversion on the regular channel            */
      __IOM uint32 RCONT      : 1;            /*!< [18..18] Continuous mode selection for regular conversions                */
      __IOM uint32 RSYNC      : 1;            /*!< [19..19] Launch regular conversion synchronously with DFSDM0              */
            uint32            : 1;
      __IOM uint32 RDMAEN     : 1;            /*!< [21..21] DMA channel enabled to read data for the regular conversion      */
            uint32            : 2;
      __IOM uint32 RCH        : 3;            /*!< [26..24] Regular channel selection                                        */
            uint32            : 2;
      __IOM uint32 FAST       : 1;            /*!< [29..29] Fast conversion mode selection for regular conversions           */
      __IOM uint32 AWFSEL     : 1;            /*!< [30..30] Analog watchdog fast mode select                                 */
            uint32            : 1;
    } bit;
  } DFSDM3_CR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000B0) DFSDM control register 2                                   */
    
    struct {
      __IOM uint32 JEOCIE     : 1;            /*!< [0..0] Injected end of conversion interrupt enable                        */
      __IOM uint32 REOCIE     : 1;            /*!< [1..1] Regular end of conversion interrupt enable                         */
      __IOM uint32 JOVRIE     : 1;            /*!< [2..2] Injected data overrun interrupt enable                             */
      __IOM uint32 ROVRIE     : 1;            /*!< [3..3] Regular data overrun interrupt enable                              */
      __IOM uint32 AWDIE      : 1;            /*!< [4..4] Analog watchdog interrupt enable                                   */
      __IOM uint32 SCDIE      : 1;            /*!< [5..5] Short-circuit detector interrupt enable                            */
      __IOM uint32 CKABIE     : 1;            /*!< [6..6] Clock absence interrupt enable                                     */
            uint32            : 1;
      __IOM uint32 EXCH       : 8;            /*!< [15..8] Extremes detector channel selection                               */
      __IOM uint32 AWDCH      : 8;            /*!< [23..16] Analog watchdog channel selection                                */
            uint32            : 8;
    } bit;
  } DFSDM0_CR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000B4) DFSDM control register 2                                   */
    
    struct {
      __IOM uint32 JEOCIE     : 1;            /*!< [0..0] Injected end of conversion interrupt enable                        */
      __IOM uint32 REOCIE     : 1;            /*!< [1..1] Regular end of conversion interrupt enable                         */
      __IOM uint32 JOVRIE     : 1;            /*!< [2..2] Injected data overrun interrupt enable                             */
      __IOM uint32 ROVRIE     : 1;            /*!< [3..3] Regular data overrun interrupt enable                              */
      __IOM uint32 AWDIE      : 1;            /*!< [4..4] Analog watchdog interrupt enable                                   */
      __IOM uint32 SCDIE      : 1;            /*!< [5..5] Short-circuit detector interrupt enable                            */
      __IOM uint32 CKABIE     : 1;            /*!< [6..6] Clock absence interrupt enable                                     */
            uint32            : 1;
      __IOM uint32 EXCH       : 8;            /*!< [15..8] Extremes detector channel selection                               */
      __IOM uint32 AWDCH      : 8;            /*!< [23..16] Analog watchdog channel selection                                */
            uint32            : 8;
    } bit;
  } DFSDM1_CR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000B8) DFSDM control register 2                                   */
    
    struct {
      __IOM uint32 JEOCIE     : 1;            /*!< [0..0] Injected end of conversion interrupt enable                        */
      __IOM uint32 REOCIE     : 1;            /*!< [1..1] Regular end of conversion interrupt enable                         */
      __IOM uint32 JOVRIE     : 1;            /*!< [2..2] Injected data overrun interrupt enable                             */
      __IOM uint32 ROVRIE     : 1;            /*!< [3..3] Regular data overrun interrupt enable                              */
      __IOM uint32 AWDIE      : 1;            /*!< [4..4] Analog watchdog interrupt enable                                   */
      __IOM uint32 SCDIE      : 1;            /*!< [5..5] Short-circuit detector interrupt enable                            */
      __IOM uint32 CKABIE     : 1;            /*!< [6..6] Clock absence interrupt enable                                     */
            uint32            : 1;
      __IOM uint32 EXCH       : 8;            /*!< [15..8] Extremes detector channel selection                               */
      __IOM uint32 AWDCH      : 8;            /*!< [23..16] Analog watchdog channel selection                                */
            uint32            : 8;
    } bit;
  } DFSDM2_CR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000BC) DFSDM control register 2                                   */
    
    struct {
      __IOM uint32 JEOCIE     : 1;            /*!< [0..0] Injected end of conversion interrupt enable                        */
      __IOM uint32 REOCIE     : 1;            /*!< [1..1] Regular end of conversion interrupt enable                         */
      __IOM uint32 JOVRIE     : 1;            /*!< [2..2] Injected data overrun interrupt enable                             */
      __IOM uint32 ROVRIE     : 1;            /*!< [3..3] Regular data overrun interrupt enable                              */
      __IOM uint32 AWDIE      : 1;            /*!< [4..4] Analog watchdog interrupt enable                                   */
      __IOM uint32 SCDIE      : 1;            /*!< [5..5] Short-circuit detector interrupt enable                            */
      __IOM uint32 CKABIE     : 1;            /*!< [6..6] Clock absence interrupt enable                                     */
            uint32            : 1;
      __IOM uint32 EXCH       : 8;            /*!< [15..8] Extremes detector channel selection                               */
      __IOM uint32 AWDCH      : 8;            /*!< [23..16] Analog watchdog channel selection                                */
            uint32            : 8;
    } bit;
  } DFSDM3_CR2;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000000C0) DFSDM interrupt and status register                        */
    
    struct {
      __IM  uint32 JEOCF      : 1;            /*!< [0..0] End of injected conversion flag                                    */
      __IM  uint32 REOCF      : 1;            /*!< [1..1] End of regular conversion flag                                     */
      __IM  uint32 JOVRF      : 1;            /*!< [2..2] Injected conversion overrun flag                                   */
      __IM  uint32 ROVRF      : 1;            /*!< [3..3] Regular conversion overrun flag                                    */
      __IM  uint32 AWDF       : 1;            /*!< [4..4] Analog watchdog                                                    */
            uint32            : 8;
      __IM  uint32 JCIP       : 1;            /*!< [13..13] Injected conversion in progress status                           */
      __IM  uint32 RCIP       : 1;            /*!< [14..14] Regular conversion in progress status                            */
            uint32            : 1;
      __IM  uint32 CKABF      : 8;            /*!< [23..16] Clock absence flag                                               */
      __IM  uint32 SCDF       : 8;            /*!< [31..24] short-circuit detector flag                                      */
    } bit;
  } DFSDM0_ISR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000000C4) DFSDM interrupt and status register                        */
    
    struct {
      __IM  uint32 JEOCF      : 1;            /*!< [0..0] End of injected conversion flag                                    */
      __IM  uint32 REOCF      : 1;            /*!< [1..1] End of regular conversion flag                                     */
      __IM  uint32 JOVRF      : 1;            /*!< [2..2] Injected conversion overrun flag                                   */
      __IM  uint32 ROVRF      : 1;            /*!< [3..3] Regular conversion overrun flag                                    */
      __IM  uint32 AWDF       : 1;            /*!< [4..4] Analog watchdog                                                    */
            uint32            : 8;
      __IM  uint32 JCIP       : 1;            /*!< [13..13] Injected conversion in progress status                           */
      __IM  uint32 RCIP       : 1;            /*!< [14..14] Regular conversion in progress status                            */
            uint32            : 1;
      __IM  uint32 CKABF      : 8;            /*!< [23..16] Clock absence flag                                               */
      __IM  uint32 SCDF       : 8;            /*!< [31..24] short-circuit detector flag                                      */
    } bit;
  } DFSDM1_ISR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000000C8) DFSDM interrupt and status register                        */
    
    struct {
      __IM  uint32 JEOCF      : 1;            /*!< [0..0] End of injected conversion flag                                    */
      __IM  uint32 REOCF      : 1;            /*!< [1..1] End of regular conversion flag                                     */
      __IM  uint32 JOVRF      : 1;            /*!< [2..2] Injected conversion overrun flag                                   */
      __IM  uint32 ROVRF      : 1;            /*!< [3..3] Regular conversion overrun flag                                    */
      __IM  uint32 AWDF       : 1;            /*!< [4..4] Analog watchdog                                                    */
            uint32            : 8;
      __IM  uint32 JCIP       : 1;            /*!< [13..13] Injected conversion in progress status                           */
      __IM  uint32 RCIP       : 1;            /*!< [14..14] Regular conversion in progress status                            */
            uint32            : 1;
      __IM  uint32 CKABF      : 8;            /*!< [23..16] Clock absence flag                                               */
      __IM  uint32 SCDF       : 8;            /*!< [31..24] short-circuit detector flag                                      */
    } bit;
  } DFSDM2_ISR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000000CC) DFSDM interrupt and status register                        */
    
    struct {
      __IM  uint32 JEOCF      : 1;            /*!< [0..0] End of injected conversion flag                                    */
      __IM  uint32 REOCF      : 1;            /*!< [1..1] End of regular conversion flag                                     */
      __IM  uint32 JOVRF      : 1;            /*!< [2..2] Injected conversion overrun flag                                   */
      __IM  uint32 ROVRF      : 1;            /*!< [3..3] Regular conversion overrun flag                                    */
      __IM  uint32 AWDF       : 1;            /*!< [4..4] Analog watchdog                                                    */
            uint32            : 8;
      __IM  uint32 JCIP       : 1;            /*!< [13..13] Injected conversion in progress status                           */
      __IM  uint32 RCIP       : 1;            /*!< [14..14] Regular conversion in progress status                            */
            uint32            : 1;
      __IM  uint32 CKABF      : 8;            /*!< [23..16] Clock absence flag                                               */
      __IM  uint32 SCDF       : 8;            /*!< [31..24] short-circuit detector flag                                      */
    } bit;
  } DFSDM3_ISR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000D0) DFSDM interrupt flag clear register                        */
    
    struct {
            uint32            : 2;
      __IOM uint32 CLRJOVRF   : 1;            /*!< [2..2] Clear the injected conversion overrun flag                         */
      __IOM uint32 CLRROVRF   : 1;            /*!< [3..3] Clear the regular conversion overrun flag                          */
            uint32            : 12;
      __IOM uint32 CLRCKABF   : 8;            /*!< [23..16] Clear the clock absence flag                                     */
      __IOM uint32 CLRSCDF    : 8;            /*!< [31..24] Clear the short-circuit detector flag                            */
    } bit;
  } DFSDM0_ICR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000D4) DFSDM interrupt flag clear register                        */
    
    struct {
            uint32            : 2;
      __IOM uint32 CLRJOVRF   : 1;            /*!< [2..2] Clear the injected conversion overrun flag                         */
      __IOM uint32 CLRROVRF   : 1;            /*!< [3..3] Clear the regular conversion overrun flag                          */
            uint32            : 12;
      __IOM uint32 CLRCKABF   : 8;            /*!< [23..16] Clear the clock absence flag                                     */
      __IOM uint32 CLRSCDF    : 8;            /*!< [31..24] Clear the short-circuit detector flag                            */
    } bit;
  } DFSDM1_ICR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000D8) DFSDM interrupt flag clear register                        */
    
    struct {
            uint32            : 2;
      __IOM uint32 CLRJOVRF   : 1;            /*!< [2..2] Clear the injected conversion overrun flag                         */
      __IOM uint32 CLRROVRF   : 1;            /*!< [3..3] Clear the regular conversion overrun flag                          */
            uint32            : 12;
      __IOM uint32 CLRCKABF   : 8;            /*!< [23..16] Clear the clock absence flag                                     */
      __IOM uint32 CLRSCDF    : 8;            /*!< [31..24] Clear the short-circuit detector flag                            */
    } bit;
  } DFSDM2_ICR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000DC) DFSDM interrupt flag clear register                        */
    
    struct {
            uint32            : 2;
      __IOM uint32 CLRJOVRF   : 1;            /*!< [2..2] Clear the injected conversion overrun flag                         */
      __IOM uint32 CLRROVRF   : 1;            /*!< [3..3] Clear the regular conversion overrun flag                          */
            uint32            : 12;
      __IOM uint32 CLRCKABF   : 8;            /*!< [23..16] Clear the clock absence flag                                     */
      __IOM uint32 CLRSCDF    : 8;            /*!< [31..24] Clear the short-circuit detector flag                            */
    } bit;
  } DFSDM3_ICR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000E0) DFSDM injected channel group selection register            */
    
    struct {
      __IOM uint32 JCHG       : 8;            /*!< [7..0] Injected channel group selection                                   */
            uint32            : 24;
    } bit;
  } DFSDM0_JCHGR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000E4) DFSDM injected channel group selection register            */
    
    struct {
      __IOM uint32 JCHG       : 8;            /*!< [7..0] Injected channel group selection                                   */
            uint32            : 24;
    } bit;
  } DFSDM1_JCHGR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000E8) DFSDM injected channel group selection register            */
    
    struct {
      __IOM uint32 JCHG       : 8;            /*!< [7..0] Injected channel group selection                                   */
            uint32            : 24;
    } bit;
  } DFSDM2_JCHGR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000EC) DFSDM injected channel group selection register            */
    
    struct {
      __IOM uint32 JCHG       : 8;            /*!< [7..0] Injected channel group selection                                   */
            uint32            : 24;
    } bit;
  } DFSDM3_JCHGR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000F0) DFSDM filter control register                              */
    
    struct {
      __IOM uint32 IOSR       : 8;            /*!< [7..0] Integrator oversampling ratio (averaging length)                   */
            uint32            : 8;
      __IOM uint32 FOSR       : 10;           /*!< [25..16] Sinc filter oversampling ratio (decimation rate)                 */
            uint32            : 3;
      __IOM uint32 FORD       : 3;            /*!< [31..29] Sinc filter order                                                */
    } bit;
  } DFSDM0_FCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000F4) DFSDM filter control register                              */
    
    struct {
      __IOM uint32 IOSR       : 8;            /*!< [7..0] Integrator oversampling ratio (averaging length)                   */
            uint32            : 8;
      __IOM uint32 FOSR       : 10;           /*!< [25..16] Sinc filter oversampling ratio (decimation rate)                 */
            uint32            : 3;
      __IOM uint32 FORD       : 3;            /*!< [31..29] Sinc filter order                                                */
    } bit;
  } DFSDM1_FCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000F8) DFSDM filter control register                              */
    
    struct {
      __IOM uint32 IOSR       : 8;            /*!< [7..0] Integrator oversampling ratio (averaging length)                   */
            uint32            : 8;
      __IOM uint32 FOSR       : 10;           /*!< [25..16] Sinc filter oversampling ratio (decimation rate)                 */
            uint32            : 3;
      __IOM uint32 FORD       : 3;            /*!< [31..29] Sinc filter order                                                */
    } bit;
  } DFSDM2_FCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000FC) DFSDM filter control register                              */
    
    struct {
      __IOM uint32 IOSR       : 8;            /*!< [7..0] Integrator oversampling ratio (averaging length)                   */
            uint32            : 8;
      __IOM uint32 FOSR       : 10;           /*!< [25..16] Sinc filter oversampling ratio (decimation rate)                 */
            uint32            : 3;
      __IOM uint32 FORD       : 3;            /*!< [31..29] Sinc filter order                                                */
    } bit;
  } DFSDM3_FCR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000100) DFSDM data register for injected group                     */
    
    struct {
      __IM  uint32 JDATACH    : 3;            /*!< [2..0] Injected channel most recently converted                           */
            uint32            : 5;
      __IM  uint32 JDATA      : 24;           /*!< [31..8] Injected group conversion data                                    */
    } bit;
  } DFSDM0_JDATAR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000104) DFSDM data register for injected group                     */
    
    struct {
      __IM  uint32 JDATACH    : 3;            /*!< [2..0] Injected channel most recently converted                           */
            uint32            : 5;
      __IM  uint32 JDATA      : 24;           /*!< [31..8] Injected group conversion data                                    */
    } bit;
  } DFSDM1_JDATAR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000108) DFSDM data register for injected group                     */
    
    struct {
      __IM  uint32 JDATACH    : 3;            /*!< [2..0] Injected channel most recently converted                           */
            uint32            : 5;
      __IM  uint32 JDATA      : 24;           /*!< [31..8] Injected group conversion data                                    */
    } bit;
  } DFSDM2_JDATAR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000010C) DFSDM data register for injected group                     */
    
    struct {
      __IM  uint32 JDATACH    : 3;            /*!< [2..0] Injected channel most recently converted                           */
            uint32            : 5;
      __IM  uint32 JDATA      : 24;           /*!< [31..8] Injected group conversion data                                    */
    } bit;
  } DFSDM3_JDATAR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000110) DFSDM data register for the regular channel                */
    
    struct {
      __IM  uint32 RDATACH    : 3;            /*!< [2..0] Regular channel most recently converted                            */
            uint32            : 1;
      __IM  uint32 RPEND      : 1;            /*!< [4..4] Regular channel pending data                                       */
            uint32            : 3;
      __IM  uint32 RDATA      : 24;           /*!< [31..8] Regular channel conversion data                                   */
    } bit;
  } DFSDM0_RDATAR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000114) DFSDM data register for the regular channel                */
    
    struct {
      __IM  uint32 RDATACH    : 3;            /*!< [2..0] Regular channel most recently converted                            */
            uint32            : 1;
      __IM  uint32 RPEND      : 1;            /*!< [4..4] Regular channel pending data                                       */
            uint32            : 3;
      __IM  uint32 RDATA      : 24;           /*!< [31..8] Regular channel conversion data                                   */
    } bit;
  } DFSDM1_RDATAR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000118) DFSDM data register for the regular channel                */
    
    struct {
      __IM  uint32 RDATACH    : 3;            /*!< [2..0] Regular channel most recently converted                            */
            uint32            : 1;
      __IM  uint32 RPEND      : 1;            /*!< [4..4] Regular channel pending data                                       */
            uint32            : 3;
      __IM  uint32 RDATA      : 24;           /*!< [31..8] Regular channel conversion data                                   */
    } bit;
  } DFSDM2_RDATAR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000011C) DFSDM data register for the regular channel                */
    
    struct {
      __IM  uint32 RDATACH    : 3;            /*!< [2..0] Regular channel most recently converted                            */
            uint32            : 1;
      __IM  uint32 RPEND      : 1;            /*!< [4..4] Regular channel pending data                                       */
            uint32            : 3;
      __IM  uint32 RDATA      : 24;           /*!< [31..8] Regular channel conversion data                                   */
    } bit;
  } DFSDM3_RDATAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000120) DFSDM analog watchdog high threshold register              */
    
    struct {
      __IOM uint32 BKAWH      : 4;            /*!< [3..0] Break signal assignment to analog watchdog high threshold
                                                     event                                                                     */
            uint32            : 4;
      __IOM uint32 AWHT       : 24;           /*!< [31..8] Analog watchdog high threshold                                    */
    } bit;
  } DFSDM0_AWHTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000124) DFSDM analog watchdog high threshold register              */
    
    struct {
      __IOM uint32 BKAWH      : 4;            /*!< [3..0] Break signal assignment to analog watchdog high threshold
                                                     event                                                                     */
            uint32            : 4;
      __IOM uint32 AWHT       : 24;           /*!< [31..8] Analog watchdog high threshold                                    */
    } bit;
  } DFSDM1_AWHTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000128) DFSDM analog watchdog high threshold register              */
    
    struct {
      __IOM uint32 BKAWH      : 4;            /*!< [3..0] Break signal assignment to analog watchdog high threshold
                                                     event                                                                     */
            uint32            : 4;
      __IOM uint32 AWHT       : 24;           /*!< [31..8] Analog watchdog high threshold                                    */
    } bit;
  } DFSDM2_AWHTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000012C) DFSDM analog watchdog high threshold register              */
    
    struct {
      __IOM uint32 BKAWH      : 4;            /*!< [3..0] Break signal assignment to analog watchdog high threshold
                                                     event                                                                     */
            uint32            : 4;
      __IOM uint32 AWHT       : 24;           /*!< [31..8] Analog watchdog high threshold                                    */
    } bit;
  } DFSDM3_AWHTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000130) DFSDM analog watchdog low threshold register               */
    
    struct {
      __IOM uint32 BKAWL      : 4;            /*!< [3..0] Break signal assignment to analog watchdog low threshold
                                                     event                                                                     */
            uint32            : 4;
      __IOM uint32 AWLT       : 24;           /*!< [31..8] Analog watchdog low threshold                                     */
    } bit;
  } DFSDM0_AWLTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000134) DFSDM analog watchdog low threshold register               */
    
    struct {
      __IOM uint32 BKAWL      : 4;            /*!< [3..0] Break signal assignment to analog watchdog low threshold
                                                     event                                                                     */
            uint32            : 4;
      __IOM uint32 AWLT       : 24;           /*!< [31..8] Analog watchdog low threshold                                     */
    } bit;
  } DFSDM1_AWLTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000138) DFSDM analog watchdog low threshold register               */
    
    struct {
      __IOM uint32 BKAWL      : 4;            /*!< [3..0] Break signal assignment to analog watchdog low threshold
                                                     event                                                                     */
            uint32            : 4;
      __IOM uint32 AWLT       : 24;           /*!< [31..8] Analog watchdog low threshold                                     */
    } bit;
  } DFSDM2_AWLTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000013C) DFSDM analog watchdog low threshold register               */
    
    struct {
      __IOM uint32 BKAWL      : 4;            /*!< [3..0] Break signal assignment to analog watchdog low threshold
                                                     event                                                                     */
            uint32            : 4;
      __IOM uint32 AWLT       : 24;           /*!< [31..8] Analog watchdog low threshold                                     */
    } bit;
  } DFSDM3_AWLTR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000140) DFSDM analog watchdog status register                      */
    
    struct {
      __IM  uint32 AWLTF      : 8;            /*!< [7..0] Analog watchdog low threshold flag                                 */
      __IM  uint32 AWHTF      : 8;            /*!< [15..8] Analog watchdog high threshold flag                               */
            uint32            : 16;
    } bit;
  } DFSDM0_AWSR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000144) DFSDM analog watchdog status register                      */
    
    struct {
      __IM  uint32 AWLTF      : 8;            /*!< [7..0] Analog watchdog low threshold flag                                 */
      __IM  uint32 AWHTF      : 8;            /*!< [15..8] Analog watchdog high threshold flag                               */
            uint32            : 16;
    } bit;
  } DFSDM1_AWSR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000148) DFSDM analog watchdog status register                      */
    
    struct {
      __IM  uint32 AWLTF      : 8;            /*!< [7..0] Analog watchdog low threshold flag                                 */
      __IM  uint32 AWHTF      : 8;            /*!< [15..8] Analog watchdog high threshold flag                               */
            uint32            : 16;
    } bit;
  } DFSDM2_AWSR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000014C) DFSDM analog watchdog status register                      */
    
    struct {
      __IM  uint32 AWLTF      : 8;            /*!< [7..0] Analog watchdog low threshold flag                                 */
      __IM  uint32 AWHTF      : 8;            /*!< [15..8] Analog watchdog high threshold flag                               */
            uint32            : 16;
    } bit;
  } DFSDM3_AWSR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000150) DFSDM analog watchdog clear flag register                  */
    
    struct {
      __IOM uint32 CLRAWLTF   : 8;            /*!< [7..0] Clear the analog watchdog low threshold flag                       */
      __IOM uint32 CLRAWHTF   : 8;            /*!< [15..8] Clear the analog watchdog high threshold flag                     */
            uint32            : 16;
    } bit;
  } DFSDM0_AWCFR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000154) DFSDM analog watchdog clear flag register                  */
    
    struct {
      __IOM uint32 CLRAWLTF   : 8;            /*!< [7..0] Clear the analog watchdog low threshold flag                       */
      __IOM uint32 CLRAWHTF   : 8;            /*!< [15..8] Clear the analog watchdog high threshold flag                     */
            uint32            : 16;
    } bit;
  } DFSDM1_AWCFR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000158) DFSDM analog watchdog clear flag register                  */
    
    struct {
      __IOM uint32 CLRAWLTF   : 8;            /*!< [7..0] Clear the analog watchdog low threshold flag                       */
      __IOM uint32 CLRAWHTF   : 8;            /*!< [15..8] Clear the analog watchdog high threshold flag                     */
            uint32            : 16;
    } bit;
  } DFSDM2_AWCFR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000015C) DFSDM analog watchdog clear flag register                  */
    
    struct {
      __IOM uint32 CLRAWLTF   : 8;            /*!< [7..0] Clear the analog watchdog low threshold flag                       */
      __IOM uint32 CLRAWHTF   : 8;            /*!< [15..8] Clear the analog watchdog high threshold flag                     */
            uint32            : 16;
    } bit;
  } DFSDM3_AWCFR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000160) DFSDM Extremes detector maximum register                   */
    
    struct {
      __IM  uint32 EXMAXCH    : 3;            /*!< [2..0] Extremes detector maximum data channel                             */
            uint32            : 5;
      __IM  uint32 EXMAX      : 24;           /*!< [31..8] Extremes detector maximum value                                   */
    } bit;
  } DFSDM0_EXMAX;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000164) DFSDM Extremes detector maximum register                   */
    
    struct {
      __IM  uint32 EXMAXCH    : 3;            /*!< [2..0] Extremes detector maximum data channel                             */
            uint32            : 5;
      __IM  uint32 EXMAX      : 24;           /*!< [31..8] Extremes detector maximum value                                   */
    } bit;
  } DFSDM1_EXMAX;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000168) DFSDM Extremes detector maximum register                   */
    
    struct {
      __IM  uint32 EXMAXCH    : 3;            /*!< [2..0] Extremes detector maximum data channel                             */
            uint32            : 5;
      __IM  uint32 EXMAX      : 24;           /*!< [31..8] Extremes detector maximum value                                   */
    } bit;
  } DFSDM2_EXMAX;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000016C) DFSDM Extremes detector maximum register                   */
    
    struct {
      __IM  uint32 EXMAXCH    : 3;            /*!< [2..0] Extremes detector maximum data channel                             */
            uint32            : 5;
      __IM  uint32 EXMAX      : 24;           /*!< [31..8] Extremes detector maximum value                                   */
    } bit;
  } DFSDM3_EXMAX;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000170) DFSDM Extremes detector minimum register                   */
    
    struct {
      __IM  uint32 EXMINCH    : 3;            /*!< [2..0] Extremes detector minimum data channel                             */
            uint32            : 5;
      __IM  uint32 EXMIN      : 24;           /*!< [31..8] Extremes detector minimum value                                   */
    } bit;
  } DFSDM0_EXMIN;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000174) DFSDM Extremes detector minimum register                   */
    
    struct {
      __IM  uint32 EXMINCH    : 3;            /*!< [2..0] Extremes detector minimum data channel                             */
            uint32            : 5;
      __IM  uint32 EXMIN      : 24;           /*!< [31..8] Extremes detector minimum value                                   */
    } bit;
  } DFSDM1_EXMIN;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000178) DFSDM Extremes detector minimum register                   */
    
    struct {
      __IM  uint32 EXMINCH    : 3;            /*!< [2..0] Extremes detector minimum data channel                             */
            uint32            : 5;
      __IM  uint32 EXMIN      : 24;           /*!< [31..8] Extremes detector minimum value                                   */
    } bit;
  } DFSDM2_EXMIN;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000017C) DFSDM Extremes detector minimum register                   */
    
    struct {
      __IM  uint32 EXMINCH    : 3;            /*!< [2..0] Extremes detector minimum data channel                             */
            uint32            : 5;
      __IM  uint32 EXMIN      : 24;           /*!< [31..8] Extremes detector minimum value                                   */
    } bit;
  } DFSDM3_EXMIN;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000180) DFSDM conversion timer register                            */
    
    struct {
            uint32            : 4;
      __IM  uint32 CNVCNT     : 28;           /*!< [31..4] 28-bit timer counting conversion time                             */
    } bit;
  } DFSDM0_CNVTIMR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000184) DFSDM conversion timer register                            */
    
    struct {
            uint32            : 4;
      __IM  uint32 CNVCNT     : 28;           /*!< [31..4] 28-bit timer counting conversion time                             */
    } bit;
  } DFSDM1_CNVTIMR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000188) DFSDM conversion timer register                            */
    
    struct {
            uint32            : 4;
      __IM  uint32 CNVCNT     : 28;           /*!< [31..4] 28-bit timer counting conversion time                             */
    } bit;
  } DFSDM2_CNVTIMR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000018C) DFSDM conversion timer register                            */
    
    struct {
            uint32            : 4;
      __IM  uint32 CNVCNT     : 28;           /*!< [31..4] 28-bit timer counting conversion time                             */
    } bit;
  } DFSDM3_CNVTIMR;
} DFSDM_Type;                                   /*!< Size = 400 (0x190)                                                        */



/* =========================================================================================================================== */
/* ================                                           TIM16                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief General-purpose-timers (TIM16)
  */

typedef struct {                                /*!< (@ 0x40014400) TIM16 Structure                                            */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) control register 1                                         */
    
    struct {
      __IOM uint32 CEN        : 1;            /*!< [0..0] Counter enable                                                     */
      __IOM uint32 UDIS       : 1;            /*!< [1..1] Update disable                                                     */
      __IOM uint32 URS        : 1;            /*!< [2..2] Update request source                                              */
      __IOM uint32 OPM        : 1;            /*!< [3..3] One-pulse mode                                                     */
            uint32            : 3;
      __IOM uint32 ARPE       : 1;            /*!< [7..7] Auto-reload preload enable                                         */
      __IOM uint32 CKD        : 2;            /*!< [9..8] Clock division                                                     */
            uint32            : 1;
      __IOM uint32 UIFREMAP   : 1;            /*!< [11..11] UIF status bit remapping                                         */
            uint32            : 20;
    } bit;
  } CR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) control register 2                                         */
    
    struct {
      __IOM uint32 CCPC       : 1;            /*!< [0..0] Capture/compare preloaded control                                  */
            uint32            : 1;
      __IOM uint32 CCUS       : 1;            /*!< [2..2] Capture/compare control update selection                           */
      __IOM uint32 CCDS       : 1;            /*!< [3..3] Capture/compare DMA selection                                      */
            uint32            : 4;
      __IOM uint32 OIS1       : 1;            /*!< [8..8] Output Idle state 1                                                */
      __IOM uint32 OIS1N      : 1;            /*!< [9..9] Output Idle state 1                                                */
            uint32            : 22;
    } bit;
  } CR2;
  __IM  uint32  RESERVED;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) DMA/Interrupt enable register                              */
    
    struct {
      __IOM uint32 UIE        : 1;            /*!< [0..0] Update interrupt enable                                            */
      __IOM uint32 CC1IE      : 1;            /*!< [1..1] Capture/Compare 1 interrupt enable                                 */
            uint32            : 3;
      __IOM uint32 COMIE      : 1;            /*!< [5..5] COM interrupt enable                                               */
            uint32            : 1;
      __IOM uint32 BIE        : 1;            /*!< [7..7] Break interrupt enable                                             */
      __IOM uint32 UDE        : 1;            /*!< [8..8] Update DMA request enable                                          */
      __IOM uint32 CC1DE      : 1;            /*!< [9..9] Capture/Compare 1 DMA request enable                               */
            uint32            : 3;
      __IOM uint32 COMDE      : 1;            /*!< [13..13] COM DMA request enable                                           */
            uint32            : 18;
    } bit;
  } DIER;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) status register                                            */
    
    struct {
      __IOM uint32 UIF        : 1;            /*!< [0..0] Update interrupt flag                                              */
      __IOM uint32 CC1IF      : 1;            /*!< [1..1] Capture/compare 1 interrupt flag                                   */
            uint32            : 3;
      __IOM uint32 COMIF      : 1;            /*!< [5..5] COM interrupt flag                                                 */
            uint32            : 1;
      __IOM uint32 BIF        : 1;            /*!< [7..7] Break interrupt flag                                               */
            uint32            : 1;
      __IOM uint32 CC1OF      : 1;            /*!< [9..9] Capture/Compare 1 overcapture flag                                 */
            uint32            : 22;
    } bit;
  } SR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000014) event generation register                                  */
    
    struct {
      __OM  uint32 UG         : 1;            /*!< [0..0] Update generation                                                  */
      __OM  uint32 CC1G       : 1;            /*!< [1..1] Capture/compare 1 generation                                       */
            uint32            : 3;
      __OM  uint32 COMG       : 1;            /*!< [5..5] Capture/Compare control update generation                          */
            uint32            : 1;
      __OM  uint32 BG         : 1;            /*!< [7..7] Break generation                                                   */
            uint32            : 24;
    } bit;
  } EGR;
  
  union {
    union {
      __IOM uint32 reg;                       /*!< (@ 0x00000018) capture/compare mode register (output mode)                */
      
      struct {
        __IOM uint32 CC1S     : 2;            /*!< [1..0] Capture/Compare 1 selection                                        */
        __IOM uint32 OC1FE    : 1;            /*!< [2..2] Output Compare 1 fast enable                                       */
        __IOM uint32 OC1PE    : 1;            /*!< [3..3] Output Compare 1 preload enable                                    */
        __IOM uint32 OC1M     : 3;            /*!< [6..4] Output Compare 1 mode                                              */
              uint32          : 9;
        __IOM uint32 OC1M_3   : 1;            /*!< [16..16] Output Compare 1 mode                                            */
              uint32          : 15;
      } bit;
    } CCMR1_Output;
    
    union {
      __IOM uint32 reg;                       /*!< (@ 0x00000018) capture/compare mode register 1 (input mode)               */
      
      struct {
        __IOM uint32 CC1S     : 2;            /*!< [1..0] Capture/Compare 1 selection                                        */
        __IOM uint32 IC1PSC   : 2;            /*!< [3..2] Input capture 1 prescaler                                          */
        __IOM uint32 IC1F     : 4;            /*!< [7..4] Input capture 1 filter                                             */
              uint32          : 24;
      } bit;
    } CCMR1_Input;
  };
  __IM  uint32  RESERVED1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000020) capture/compare enable register                            */
    
    struct {
      __IOM uint32 CC1E       : 1;            /*!< [0..0] Capture/Compare 1 output enable                                    */
      __IOM uint32 CC1P       : 1;            /*!< [1..1] Capture/Compare 1 output Polarity                                  */
      __IOM uint32 CC1NE      : 1;            /*!< [2..2] Capture/Compare 1 complementary output enable                      */
      __IOM uint32 CC1NP      : 1;            /*!< [3..3] Capture/Compare 1 output Polarity                                  */
            uint32            : 28;
    } bit;
  } CCER;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000024) counter                                                    */
    
    struct {
      __IOM uint32 CNT        : 16;           /*!< [15..0] counter value                                                     */
            uint32            : 15;
      __IM  uint32 UIFCPY     : 1;            /*!< [31..31] UIF Copy                                                         */
    } bit;
  } CNT;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000028) prescaler                                                  */
    
    struct {
      __IOM uint32 PSC        : 16;           /*!< [15..0] Prescaler value                                                   */
            uint32            : 16;
    } bit;
  } PSC;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000002C) auto-reload register                                       */
    
    struct {
      __IOM uint32 ARR        : 16;           /*!< [15..0] Auto-reload value                                                 */
            uint32            : 16;
    } bit;
  } ARR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000030) repetition counter register                                */
    
    struct {
      __IOM uint32 REP        : 8;            /*!< [7..0] Repetition counter value                                           */
            uint32            : 24;
    } bit;
  } RCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000034) capture/compare register 1                                 */
    
    struct {
      __IOM uint32 CCR1       : 16;           /*!< [15..0] Capture/Compare 1 value                                           */
            uint32            : 16;
    } bit;
  } CCR1;
  __IM  uint32  RESERVED2[3];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000044) break and dead-time register                               */
    
    struct {
      __IOM uint32 DTG        : 8;            /*!< [7..0] Dead-time generator setup                                          */
      __IOM uint32 LOCK       : 2;            /*!< [9..8] Lock configuration                                                 */
      __IOM uint32 OSSI       : 1;            /*!< [10..10] Off-state selection for Idle mode                                */
      __IOM uint32 OSSR       : 1;            /*!< [11..11] Off-state selection for Run mode                                 */
      __IOM uint32 BKE        : 1;            /*!< [12..12] Break enable                                                     */
      __IOM uint32 BKP        : 1;            /*!< [13..13] Break polarity                                                   */
      __IOM uint32 AOE        : 1;            /*!< [14..14] Automatic output enable                                          */
      __IOM uint32 MOE        : 1;            /*!< [15..15] Main output enable                                               */
      __IOM uint32 BKF        : 4;            /*!< [19..16] Break filter                                                     */
            uint32            : 12;
    } bit;
  } BDTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000048) DMA control register                                       */
    
    struct {
      __IOM uint32 DBA        : 5;            /*!< [4..0] DMA base address                                                   */
            uint32            : 3;
      __IOM uint32 DBL        : 5;            /*!< [12..8] DMA burst length                                                  */
            uint32            : 19;
    } bit;
  } DCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000004C) DMA address for full transfer                              */
    
    struct {
      __IOM uint32 DMAB       : 16;           /*!< [15..0] DMA register for burst accesses                                   */
            uint32            : 16;
    } bit;
  } DMAR;
  __IM  uint32  RESERVED3[4];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000060) TIM16 alternate function register 1                        */
    
    struct {
      __IOM uint32 BKINE      : 1;            /*!< [0..0] BRK BKIN input enable                                              */
      __IOM uint32 BKCMP1E    : 1;            /*!< [1..1] BRK COMP1 enable                                                   */
      __IOM uint32 BKCMP2E    : 1;            /*!< [2..2] BRK COMP2 enable                                                   */
            uint32            : 5;
      __IOM uint32 BKDFBK1E   : 1;            /*!< [8..8] BRK dfsdm1_break[1] enable                                         */
      __IOM uint32 BKINP      : 1;            /*!< [9..9] BRK BKIN input polarity                                            */
      __IOM uint32 BKCMP1P    : 1;            /*!< [10..10] BRK COMP1 input polarity                                         */
      __IOM uint32 BKCMP2P    : 1;            /*!< [11..11] BRK COMP2 input polarity                                         */
            uint32            : 20;
    } bit;
  } TIM16_AF1;
  __IM  uint32  RESERVED4;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000068) TIM16 input selection register                             */
    
    struct {
      __IOM uint32 TI1SEL     : 4;            /*!< [3..0] selects TI1[0] to TI1[15] input                                    */
            uint32            : 28;
    } bit;
  } TIM16_TISEL;
} TIM16_Type;                                   /*!< Size = 108 (0x6c)                                                         */



/* =========================================================================================================================== */
/* ================                                           TIM17                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief General-purpose-timers (TIM17)
  */

typedef struct {                                /*!< (@ 0x40014800) TIM17 Structure                                            */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) control register 1                                         */
    
    struct {
      __IOM uint32 CEN        : 1;            /*!< [0..0] Counter enable                                                     */
      __IOM uint32 UDIS       : 1;            /*!< [1..1] Update disable                                                     */
      __IOM uint32 URS        : 1;            /*!< [2..2] Update request source                                              */
      __IOM uint32 OPM        : 1;            /*!< [3..3] One-pulse mode                                                     */
            uint32            : 3;
      __IOM uint32 ARPE       : 1;            /*!< [7..7] Auto-reload preload enable                                         */
      __IOM uint32 CKD        : 2;            /*!< [9..8] Clock division                                                     */
            uint32            : 1;
      __IOM uint32 UIFREMAP   : 1;            /*!< [11..11] UIF status bit remapping                                         */
            uint32            : 20;
    } bit;
  } CR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) control register 2                                         */
    
    struct {
      __IOM uint32 CCPC       : 1;            /*!< [0..0] Capture/compare preloaded control                                  */
            uint32            : 1;
      __IOM uint32 CCUS       : 1;            /*!< [2..2] Capture/compare control update selection                           */
      __IOM uint32 CCDS       : 1;            /*!< [3..3] Capture/compare DMA selection                                      */
            uint32            : 4;
      __IOM uint32 OIS1       : 1;            /*!< [8..8] Output Idle state 1                                                */
      __IOM uint32 OIS1N      : 1;            /*!< [9..9] Output Idle state 1                                                */
            uint32            : 22;
    } bit;
  } CR2;
  __IM  uint32  RESERVED;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) DMA/Interrupt enable register                              */
    
    struct {
      __IOM uint32 UIE        : 1;            /*!< [0..0] Update interrupt enable                                            */
      __IOM uint32 CC1IE      : 1;            /*!< [1..1] Capture/Compare 1 interrupt enable                                 */
            uint32            : 3;
      __IOM uint32 COMIE      : 1;            /*!< [5..5] COM interrupt enable                                               */
            uint32            : 1;
      __IOM uint32 BIE        : 1;            /*!< [7..7] Break interrupt enable                                             */
      __IOM uint32 UDE        : 1;            /*!< [8..8] Update DMA request enable                                          */
      __IOM uint32 CC1DE      : 1;            /*!< [9..9] Capture/Compare 1 DMA request enable                               */
            uint32            : 3;
      __IOM uint32 COMDE      : 1;            /*!< [13..13] COM DMA request enable                                           */
            uint32            : 18;
    } bit;
  } DIER;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) status register                                            */
    
    struct {
      __IOM uint32 UIF        : 1;            /*!< [0..0] Update interrupt flag                                              */
      __IOM uint32 CC1IF      : 1;            /*!< [1..1] Capture/compare 1 interrupt flag                                   */
            uint32            : 3;
      __IOM uint32 COMIF      : 1;            /*!< [5..5] COM interrupt flag                                                 */
            uint32            : 1;
      __IOM uint32 BIF        : 1;            /*!< [7..7] Break interrupt flag                                               */
            uint32            : 1;
      __IOM uint32 CC1OF      : 1;            /*!< [9..9] Capture/Compare 1 overcapture flag                                 */
            uint32            : 22;
    } bit;
  } SR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000014) event generation register                                  */
    
    struct {
      __OM  uint32 UG         : 1;            /*!< [0..0] Update generation                                                  */
      __OM  uint32 CC1G       : 1;            /*!< [1..1] Capture/compare 1 generation                                       */
            uint32            : 3;
      __OM  uint32 COMG       : 1;            /*!< [5..5] Capture/Compare control update generation                          */
            uint32            : 1;
      __OM  uint32 BG         : 1;            /*!< [7..7] Break generation                                                   */
            uint32            : 24;
    } bit;
  } EGR;
  
  union {
    union {
      __IOM uint32 reg;                       /*!< (@ 0x00000018) capture/compare mode register (output mode)                */
      
      struct {
        __IOM uint32 CC1S     : 2;            /*!< [1..0] Capture/Compare 1 selection                                        */
        __IOM uint32 OC1FE    : 1;            /*!< [2..2] Output Compare 1 fast enable                                       */
        __IOM uint32 OC1PE    : 1;            /*!< [3..3] Output Compare 1 preload enable                                    */
        __IOM uint32 OC1M     : 3;            /*!< [6..4] Output Compare 1 mode                                              */
              uint32          : 9;
        __IOM uint32 OC1M_3   : 1;            /*!< [16..16] Output Compare 1 mode                                            */
              uint32          : 15;
      } bit;
    } CCMR1_Output;
    
    union {
      __IOM uint32 reg;                       /*!< (@ 0x00000018) capture/compare mode register 1 (input mode)               */
      
      struct {
        __IOM uint32 CC1S     : 2;            /*!< [1..0] Capture/Compare 1 selection                                        */
        __IOM uint32 IC1PSC   : 2;            /*!< [3..2] Input capture 1 prescaler                                          */
        __IOM uint32 IC1F     : 4;            /*!< [7..4] Input capture 1 filter                                             */
              uint32          : 24;
      } bit;
    } CCMR1_Input;
  };
  __IM  uint32  RESERVED1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000020) capture/compare enable register                            */
    
    struct {
      __IOM uint32 CC1E       : 1;            /*!< [0..0] Capture/Compare 1 output enable                                    */
      __IOM uint32 CC1P       : 1;            /*!< [1..1] Capture/Compare 1 output Polarity                                  */
      __IOM uint32 CC1NE      : 1;            /*!< [2..2] Capture/Compare 1 complementary output enable                      */
      __IOM uint32 CC1NP      : 1;            /*!< [3..3] Capture/Compare 1 output Polarity                                  */
            uint32            : 28;
    } bit;
  } CCER;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000024) counter                                                    */
    
    struct {
      __IOM uint32 CNT        : 16;           /*!< [15..0] counter value                                                     */
            uint32            : 15;
      __IM  uint32 UIFCPY     : 1;            /*!< [31..31] UIF Copy                                                         */
    } bit;
  } CNT;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000028) prescaler                                                  */
    
    struct {
      __IOM uint32 PSC        : 16;           /*!< [15..0] Prescaler value                                                   */
            uint32            : 16;
    } bit;
  } PSC;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000002C) auto-reload register                                       */
    
    struct {
      __IOM uint32 ARR        : 16;           /*!< [15..0] Auto-reload value                                                 */
            uint32            : 16;
    } bit;
  } ARR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000030) repetition counter register                                */
    
    struct {
      __IOM uint32 REP        : 8;            /*!< [7..0] Repetition counter value                                           */
            uint32            : 24;
    } bit;
  } RCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000034) capture/compare register 1                                 */
    
    struct {
      __IOM uint32 CCR1       : 16;           /*!< [15..0] Capture/Compare 1 value                                           */
            uint32            : 16;
    } bit;
  } CCR1;
  __IM  uint32  RESERVED2[3];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000044) break and dead-time register                               */
    
    struct {
      __IOM uint32 DTG        : 8;            /*!< [7..0] Dead-time generator setup                                          */
      __IOM uint32 LOCK       : 2;            /*!< [9..8] Lock configuration                                                 */
      __IOM uint32 OSSI       : 1;            /*!< [10..10] Off-state selection for Idle mode                                */
      __IOM uint32 OSSR       : 1;            /*!< [11..11] Off-state selection for Run mode                                 */
      __IOM uint32 BKE        : 1;            /*!< [12..12] Break enable                                                     */
      __IOM uint32 BKP        : 1;            /*!< [13..13] Break polarity                                                   */
      __IOM uint32 AOE        : 1;            /*!< [14..14] Automatic output enable                                          */
      __IOM uint32 MOE        : 1;            /*!< [15..15] Main output enable                                               */
      __IOM uint32 BKF        : 4;            /*!< [19..16] Break filter                                                     */
            uint32            : 12;
    } bit;
  } BDTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000048) DMA control register                                       */
    
    struct {
      __IOM uint32 DBA        : 5;            /*!< [4..0] DMA base address                                                   */
            uint32            : 3;
      __IOM uint32 DBL        : 5;            /*!< [12..8] DMA burst length                                                  */
            uint32            : 19;
    } bit;
  } DCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000004C) DMA address for full transfer                              */
    
    struct {
      __IOM uint32 DMAB       : 16;           /*!< [15..0] DMA register for burst accesses                                   */
            uint32            : 16;
    } bit;
  } DMAR;
  __IM  uint32  RESERVED3[4];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000060) TIM17 alternate function register 1                        */
    
    struct {
      __IOM uint32 BKINE      : 1;            /*!< [0..0] BRK BKIN input enable                                              */
      __IOM uint32 BKCMP1E    : 1;            /*!< [1..1] BRK COMP1 enable                                                   */
      __IOM uint32 BKCMP2E    : 1;            /*!< [2..2] BRK COMP2 enable                                                   */
            uint32            : 5;
      __IOM uint32 BKDFBK1E   : 1;            /*!< [8..8] BRK dfsdm1_break[1] enable                                         */
      __IOM uint32 BKINP      : 1;            /*!< [9..9] BRK BKIN input polarity                                            */
      __IOM uint32 BKCMP1P    : 1;            /*!< [10..10] BRK COMP1 input polarity                                         */
      __IOM uint32 BKCMP2P    : 1;            /*!< [11..11] BRK COMP2 input polarity                                         */
            uint32            : 20;
    } bit;
  } TIM17_AF1;
  __IM  uint32  RESERVED4;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000068) TIM17 input selection register                             */
    
    struct {
      __IOM uint32 TI1SEL     : 4;            /*!< [3..0] selects TI1[0] to TI1[15] input                                    */
            uint32            : 28;
    } bit;
  } TIM17_TISEL;
} TIM17_Type;                                   /*!< Size = 108 (0x6c)                                                         */



/* =========================================================================================================================== */
/* ================                                           TIM15                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief General purpose timers (TIM15)
  */

typedef struct {                                /*!< (@ 0x40014000) TIM15 Structure                                            */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) control register 1                                         */
    
    struct {
      __IOM uint32 CEN        : 1;            /*!< [0..0] Counter enable                                                     */
      __IOM uint32 UDIS       : 1;            /*!< [1..1] Update disable                                                     */
      __IOM uint32 URS        : 1;            /*!< [2..2] Update request source                                              */
      __IOM uint32 OPM        : 1;            /*!< [3..3] One-pulse mode                                                     */
            uint32            : 3;
      __IOM uint32 ARPE       : 1;            /*!< [7..7] Auto-reload preload enable                                         */
      __IOM uint32 CKD        : 2;            /*!< [9..8] Clock division                                                     */
            uint32            : 1;
      __IOM uint32 UIFREMAP   : 1;            /*!< [11..11] UIF status bit remapping                                         */
            uint32            : 20;
    } bit;
  } CR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) control register 2                                         */
    
    struct {
      __IOM uint32 CCPC       : 1;            /*!< [0..0] Capture/compare preloaded control                                  */
            uint32            : 1;
      __IOM uint32 CCUS       : 1;            /*!< [2..2] Capture/compare control update selection                           */
      __IOM uint32 CCDS       : 1;            /*!< [3..3] Capture/compare DMA selection                                      */
      __IOM uint32 MMS        : 3;            /*!< [6..4] Master mode selection                                              */
      __IOM uint32 TI1S       : 1;            /*!< [7..7] TI1 selection                                                      */
      __IOM uint32 OIS1       : 1;            /*!< [8..8] Output Idle state 1                                                */
      __IOM uint32 OIS1N      : 1;            /*!< [9..9] Output Idle state 1                                                */
      __IOM uint32 OIS2       : 1;            /*!< [10..10] Output Idle state 2                                              */
            uint32            : 21;
    } bit;
  } CR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) slave mode control register                                */
    
    struct {
      __IOM uint32 SMS        : 3;            /*!< [2..0] Slave mode selection                                               */
            uint32            : 1;
      __IOM uint32 TS_2_0     : 3;            /*!< [6..4] Trigger selection                                                  */
      __IOM uint32 MSM        : 1;            /*!< [7..7] Master/Slave mode                                                  */
            uint32            : 8;
      __IOM uint32 SMS_3      : 1;            /*!< [16..16] Slave mode selection bit 3                                       */
            uint32            : 3;
      __IOM uint32 TS_4_3     : 2;            /*!< [21..20] Trigger selection - bit 4:3                                      */
            uint32            : 10;
    } bit;
  } SMCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) DMA/Interrupt enable register                              */
    
    struct {
      __IOM uint32 UIE        : 1;            /*!< [0..0] Update interrupt enable                                            */
      __IOM uint32 CC1IE      : 1;            /*!< [1..1] Capture/Compare 1 interrupt enable                                 */
      __IOM uint32 CC2IE      : 1;            /*!< [2..2] Capture/Compare 2 interrupt enable                                 */
            uint32            : 2;
      __IOM uint32 COMIE      : 1;            /*!< [5..5] COM interrupt enable                                               */
      __IOM uint32 TIE        : 1;            /*!< [6..6] Trigger interrupt enable                                           */
      __IOM uint32 BIE        : 1;            /*!< [7..7] Break interrupt enable                                             */
      __IOM uint32 UDE        : 1;            /*!< [8..8] Update DMA request enable                                          */
      __IOM uint32 CC1DE      : 1;            /*!< [9..9] Capture/Compare 1 DMA request enable                               */
      __IOM uint32 CC2DE      : 1;            /*!< [10..10] Capture/Compare 2 DMA request enable                             */
            uint32            : 2;
      __IOM uint32 COMDE      : 1;            /*!< [13..13] COM DMA request enable                                           */
      __IOM uint32 TDE        : 1;            /*!< [14..14] Trigger DMA request enable                                       */
            uint32            : 17;
    } bit;
  } DIER;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) status register                                            */
    
    struct {
      __IOM uint32 UIF        : 1;            /*!< [0..0] Update interrupt flag                                              */
      __IOM uint32 CC1IF      : 1;            /*!< [1..1] Capture/compare 1 interrupt flag                                   */
      __IOM uint32 CC2IF      : 1;            /*!< [2..2] Capture/Compare 2 interrupt flag                                   */
            uint32            : 2;
      __IOM uint32 COMIF      : 1;            /*!< [5..5] COM interrupt flag                                                 */
      __IOM uint32 TIF        : 1;            /*!< [6..6] Trigger interrupt flag                                             */
      __IOM uint32 BIF        : 1;            /*!< [7..7] Break interrupt flag                                               */
            uint32            : 1;
      __IOM uint32 CC1OF      : 1;            /*!< [9..9] Capture/Compare 1 overcapture flag                                 */
      __IOM uint32 CC2OF      : 1;            /*!< [10..10] Capture/compare 2 overcapture flag                               */
            uint32            : 21;
    } bit;
  } SR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000014) event generation register                                  */
    
    struct {
      __OM  uint32 UG         : 1;            /*!< [0..0] Update generation                                                  */
      __OM  uint32 CC1G       : 1;            /*!< [1..1] Capture/compare 1 generation                                       */
      __OM  uint32 CC2G       : 1;            /*!< [2..2] Capture/compare 2 generation                                       */
            uint32            : 2;
      __OM  uint32 COMG       : 1;            /*!< [5..5] Capture/Compare control update generation                          */
      __OM  uint32 TG         : 1;            /*!< [6..6] Trigger generation                                                 */
      __OM  uint32 BG         : 1;            /*!< [7..7] Break generation                                                   */
            uint32            : 24;
    } bit;
  } EGR;
  
  union {
    union {
      __IOM uint32 reg;                       /*!< (@ 0x00000018) capture/compare mode register (output mode)                */
      
      struct {
        __IOM uint32 CC1S     : 2;            /*!< [1..0] Capture/Compare 1 selection                                        */
        __IOM uint32 OC1FE    : 1;            /*!< [2..2] Output Compare 1 fast enable                                       */
        __IOM uint32 OC1PE    : 1;            /*!< [3..3] Output Compare 1 preload enable                                    */
        __IOM uint32 OC1M     : 3;            /*!< [6..4] Output Compare 1 mode                                              */
              uint32          : 1;
        __IOM uint32 CC2S     : 2;            /*!< [9..8] Capture/Compare 2 selection                                        */
        __IOM uint32 OC2FE    : 1;            /*!< [10..10] Output Compare 2 fast enable                                     */
        __IOM uint32 OC2PE    : 1;            /*!< [11..11] Output Compare 2 preload enable                                  */
        __IOM uint32 OC2M     : 3;            /*!< [14..12] Output Compare 2 mode                                            */
              uint32          : 1;
        __IOM uint32 OC1M_3   : 1;            /*!< [16..16] Output Compare 1 mode bit 3                                      */
              uint32          : 7;
        __IOM uint32 OC2M_3   : 1;            /*!< [24..24] Output Compare 2 mode bit 3                                      */
              uint32          : 7;
      } bit;
    } CCMR1_Output;
    
    union {
      __IOM uint32 reg;                       /*!< (@ 0x00000018) capture/compare mode register 1 (input mode)               */
      
      struct {
        __IOM uint32 CC1S     : 2;            /*!< [1..0] Capture/Compare 1 selection                                        */
        __IOM uint32 IC1PSC   : 2;            /*!< [3..2] Input capture 1 prescaler                                          */
        __IOM uint32 IC1F     : 4;            /*!< [7..4] Input capture 1 filter                                             */
        __IOM uint32 CC2S     : 2;            /*!< [9..8] Capture/Compare 2 selection                                        */
        __IOM uint32 IC2PSC   : 2;            /*!< [11..10] Input capture 2 prescaler                                        */
        __IOM uint32 IC2F     : 4;            /*!< [15..12] Input capture 2 filter                                           */
              uint32          : 16;
      } bit;
    } CCMR1_Input;
  };
  __IM  uint32  RESERVED;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000020) capture/compare enable register                            */
    
    struct {
      __IOM uint32 CC1E       : 1;            /*!< [0..0] Capture/Compare 1 output enable                                    */
      __IOM uint32 CC1P       : 1;            /*!< [1..1] Capture/Compare 1 output Polarity                                  */
      __IOM uint32 CC1NE      : 1;            /*!< [2..2] Capture/Compare 1 complementary output enable                      */
      __IOM uint32 CC1NP      : 1;            /*!< [3..3] Capture/Compare 1 output Polarity                                  */
      __IOM uint32 CC2E       : 1;            /*!< [4..4] Capture/Compare 2 output enable                                    */
      __IOM uint32 CC2P       : 1;            /*!< [5..5] Capture/Compare 2 output Polarity                                  */
            uint32            : 1;
      __IOM uint32 CC2NP      : 1;            /*!< [7..7] Capture/Compare 2 output Polarity                                  */
            uint32            : 24;
    } bit;
  } CCER;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000024) counter                                                    */
    
    struct {
      __IOM uint32 CNT        : 16;           /*!< [15..0] counter value                                                     */
            uint32            : 15;
      __IM  uint32 UIFCPY     : 1;            /*!< [31..31] UIF copy                                                         */
    } bit;
  } CNT;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000028) prescaler                                                  */
    
    struct {
      __IOM uint32 PSC        : 16;           /*!< [15..0] Prescaler value                                                   */
            uint32            : 16;
    } bit;
  } PSC;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000002C) auto-reload register                                       */
    
    struct {
      __IOM uint32 ARR        : 16;           /*!< [15..0] Auto-reload value                                                 */
            uint32            : 16;
    } bit;
  } ARR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000030) repetition counter register                                */
    
    struct {
      __IOM uint32 REP        : 8;            /*!< [7..0] Repetition counter value                                           */
            uint32            : 24;
    } bit;
  } RCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000034) capture/compare register 1                                 */
    
    struct {
      __IOM uint32 CCR1       : 16;           /*!< [15..0] Capture/Compare 1 value                                           */
            uint32            : 16;
    } bit;
  } CCR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000038) capture/compare register 2                                 */
    
    struct {
      __IOM uint32 CCR2       : 16;           /*!< [15..0] Capture/Compare 2 value                                           */
            uint32            : 16;
    } bit;
  } CCR2;
  __IM  uint32  RESERVED1[2];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000044) break and dead-time register                               */
    
    struct {
      __IOM uint32 DTG        : 8;            /*!< [7..0] Dead-time generator setup                                          */
      __IOM uint32 LOCK       : 2;            /*!< [9..8] Lock configuration                                                 */
      __IOM uint32 OSSI       : 1;            /*!< [10..10] Off-state selection for Idle mode                                */
      __IOM uint32 OSSR       : 1;            /*!< [11..11] Off-state selection for Run mode                                 */
      __IOM uint32 BKE        : 1;            /*!< [12..12] Break enable                                                     */
      __IOM uint32 BKP        : 1;            /*!< [13..13] Break polarity                                                   */
      __IOM uint32 AOE        : 1;            /*!< [14..14] Automatic output enable                                          */
      __IOM uint32 MOE        : 1;            /*!< [15..15] Main output enable                                               */
      __IOM uint32 BKF        : 4;            /*!< [19..16] Break filter                                                     */
            uint32            : 12;
    } bit;
  } BDTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000048) DMA control register                                       */
    
    struct {
      __IOM uint32 DBA        : 5;            /*!< [4..0] DMA base address                                                   */
            uint32            : 3;
      __IOM uint32 DBL        : 5;            /*!< [12..8] DMA burst length                                                  */
            uint32            : 19;
    } bit;
  } DCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000004C) DMA address for full transfer                              */
    
    struct {
      __IOM uint32 DMAB       : 16;           /*!< [15..0] DMA register for burst accesses                                   */
            uint32            : 16;
    } bit;
  } DMAR;
  __IM  uint32  RESERVED2[4];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000060) TIM15 alternate fdfsdm1_breakon register 1                 */
    
    struct {
      __IOM uint32 BKINE      : 1;            /*!< [0..0] BRK BKIN input enable                                              */
      __IOM uint32 BKCMP1E    : 1;            /*!< [1..1] BRK COMP1 enable                                                   */
      __IOM uint32 BKCMP2E    : 1;            /*!< [2..2] BRK COMP2 enable                                                   */
            uint32            : 5;
      __IOM uint32 BKDF1BK0E  : 1;            /*!< [8..8] BRK dfsdm1_break[0] enable                                         */
      __IOM uint32 BKINP      : 1;            /*!< [9..9] BRK BKIN input polarity                                            */
      __IOM uint32 BKCMP1P    : 1;            /*!< [10..10] BRK COMP1 input polarity                                         */
      __IOM uint32 BKCMP2P    : 1;            /*!< [11..11] BRK COMP2 input polarity                                         */
            uint32            : 20;
    } bit;
  } AF1;
  __IM  uint32  RESERVED3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000068) TIM15 input selection register                             */
    
    struct {
      __IOM uint32 TI1SEL     : 4;            /*!< [3..0] selects TI1[0] to TI1[15] input                                    */
            uint32            : 4;
      __IOM uint32 TI2SEL     : 4;            /*!< [11..8] selects TI2[0] to TI2[15] input                                   */
            uint32            : 20;
    } bit;
  } TISEL;
} TIM15_Type;                                   /*!< Size = 108 (0x6c)                                                         */



/* =========================================================================================================================== */
/* ================                                          USART1                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Universal synchronous asynchronous receiver
      transmitter (USART1)
  */

typedef struct {                                /*!< (@ 0x40011000) USART1 Structure                                           */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) Control register 1                                         */
    
    struct {
      __IOM uint32 UE         : 1;            /*!< [0..0] USART enable                                                       */
      __IOM uint32 UESM       : 1;            /*!< [1..1] USART enable in Stop mode                                          */
      __IOM uint32 RE         : 1;            /*!< [2..2] Receiver enable                                                    */
      __IOM uint32 TE         : 1;            /*!< [3..3] Transmitter enable                                                 */
      __IOM uint32 IDLEIE     : 1;            /*!< [4..4] IDLE interrupt enable                                              */
      __IOM uint32 RXNEIE     : 1;            /*!< [5..5] RXNE interrupt enable                                              */
      __IOM uint32 TCIE       : 1;            /*!< [6..6] Transmission complete interrupt enable                             */
      __IOM uint32 TXEIE      : 1;            /*!< [7..7] interrupt enable                                                   */
      __IOM uint32 PEIE       : 1;            /*!< [8..8] PE interrupt enable                                                */
      __IOM uint32 PS         : 1;            /*!< [9..9] Parity selection                                                   */
      __IOM uint32 PCE        : 1;            /*!< [10..10] Parity control enable                                            */
      __IOM uint32 WAKE       : 1;            /*!< [11..11] Receiver wakeup method                                           */
      __IOM uint32 M0         : 1;            /*!< [12..12] Word length                                                      */
      __IOM uint32 MME        : 1;            /*!< [13..13] Mute mode enable                                                 */
      __IOM uint32 CMIE       : 1;            /*!< [14..14] Character match interrupt enable                                 */
      __IOM uint32 OVER8      : 1;            /*!< [15..15] Oversampling mode                                                */
      __IOM uint32 DEDT0      : 1;            /*!< [16..16] DEDT0                                                            */
      __IOM uint32 DEDT1      : 1;            /*!< [17..17] DEDT1                                                            */
      __IOM uint32 DEDT2      : 1;            /*!< [18..18] DEDT2                                                            */
      __IOM uint32 DEDT3      : 1;            /*!< [19..19] DEDT3                                                            */
      __IOM uint32 DEDT4      : 1;            /*!< [20..20] Driver Enable de-assertion time                                  */
      __IOM uint32 DEAT0      : 1;            /*!< [21..21] DEAT0                                                            */
      __IOM uint32 DEAT1      : 1;            /*!< [22..22] DEAT1                                                            */
      __IOM uint32 DEAT2      : 1;            /*!< [23..23] DEAT2                                                            */
      __IOM uint32 DEAT3      : 1;            /*!< [24..24] DEAT3                                                            */
      __IOM uint32 DEAT4      : 1;            /*!< [25..25] Driver Enable assertion time                                     */
      __IOM uint32 RTOIE      : 1;            /*!< [26..26] Receiver timeout interrupt enable                                */
      __IOM uint32 EOBIE      : 1;            /*!< [27..27] End of Block interrupt enable                                    */
      __IOM uint32 M1         : 1;            /*!< [28..28] Word length                                                      */
      __IOM uint32 FIFOEN     : 1;            /*!< [29..29] FIFO mode enable                                                 */
      __IOM uint32 TXFEIE     : 1;            /*!< [30..30] TXFIFO empty interrupt enable                                    */
      __IOM uint32 RXFFIE     : 1;            /*!< [31..31] RXFIFO Full interrupt enable                                     */
    } bit;
  } CR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) Control register 2                                         */
    
    struct {
      __IOM uint32 SLVEN      : 1;            /*!< [0..0] Synchronous Slave mode enable                                      */
            uint32            : 2;
      __IOM uint32 DIS_NSS    : 1;            /*!< [3..3] When the DSI_NSS bit is set, the NSS pin input is ignored          */
      __IOM uint32 ADDM7      : 1;            /*!< [4..4] 7-bit Address Detection/4-bit Address Detection                    */
      __IOM uint32 LBDL       : 1;            /*!< [5..5] LIN break detection length                                         */
      __IOM uint32 LBDIE      : 1;            /*!< [6..6] LIN break detection interrupt enable                               */
            uint32            : 1;
      __IOM uint32 LBCL       : 1;            /*!< [8..8] Last bit clock pulse                                               */
      __IOM uint32 CPHA       : 1;            /*!< [9..9] Clock phase                                                        */
      __IOM uint32 CPOL       : 1;            /*!< [10..10] Clock polarity                                                   */
      __IOM uint32 CLKEN      : 1;            /*!< [11..11] Clock enable                                                     */
      __IOM uint32 STOP       : 2;            /*!< [13..12] STOP bits                                                        */
      __IOM uint32 LINEN      : 1;            /*!< [14..14] LIN mode enable                                                  */
      __IOM uint32 SWAP       : 1;            /*!< [15..15] Swap TX/RX pins                                                  */
      __IOM uint32 RXINV      : 1;            /*!< [16..16] RX pin active level inversion                                    */
      __IOM uint32 TXINV      : 1;            /*!< [17..17] TX pin active level inversion                                    */
      __IOM uint32 TAINV      : 1;            /*!< [18..18] Binary data inversion                                            */
      __IOM uint32 MSBFIRST   : 1;            /*!< [19..19] Most significant bit first                                       */
      __IOM uint32 ABREN      : 1;            /*!< [20..20] Auto baud rate enable                                            */
      __IOM uint32 ABRMOD0    : 1;            /*!< [21..21] ABRMOD0                                                          */
      __IOM uint32 ABRMOD1    : 1;            /*!< [22..22] Auto baud rate mode                                              */
      __IOM uint32 RTOEN      : 1;            /*!< [23..23] Receiver timeout enable                                          */
      __IOM uint32 ADD0_3     : 4;            /*!< [27..24] Address of the USART node                                        */
      __IOM uint32 ADD4_7     : 4;            /*!< [31..28] Address of the USART node                                        */
    } bit;
  } CR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) Control register 3                                         */
    
    struct {
      __IOM uint32 EIE        : 1;            /*!< [0..0] Error interrupt enable                                             */
      __IOM uint32 IREN       : 1;            /*!< [1..1] Ir mode enable                                                     */
      __IOM uint32 IRLP       : 1;            /*!< [2..2] Ir low-power                                                       */
      __IOM uint32 HDSEL      : 1;            /*!< [3..3] Half-duplex selection                                              */
      __IOM uint32 NACK       : 1;            /*!< [4..4] Smartcard NACK enable                                              */
      __IOM uint32 SCEN       : 1;            /*!< [5..5] Smartcard mode enable                                              */
      __IOM uint32 DMAR       : 1;            /*!< [6..6] DMA enable receiver                                                */
      __IOM uint32 DMAT       : 1;            /*!< [7..7] DMA enable transmitter                                             */
      __IOM uint32 RTSE       : 1;            /*!< [8..8] RTS enable                                                         */
      __IOM uint32 CTSE       : 1;            /*!< [9..9] CTS enable                                                         */
      __IOM uint32 CTSIE      : 1;            /*!< [10..10] CTS interrupt enable                                             */
      __IOM uint32 ONEBIT     : 1;            /*!< [11..11] One sample bit method enable                                     */
      __IOM uint32 OVRDIS     : 1;            /*!< [12..12] Overrun Disable                                                  */
      __IOM uint32 DDRE       : 1;            /*!< [13..13] DMA Disable on Reception Error                                   */
      __IOM uint32 DEM        : 1;            /*!< [14..14] Driver enable mode                                               */
      __IOM uint32 DEP        : 1;            /*!< [15..15] Driver enable polarity selection                                 */
            uint32            : 1;
      __IOM uint32 SCARCNT    : 3;            /*!< [19..17] Smartcard auto-retry count                                       */
      __IOM uint32 WUS        : 2;            /*!< [21..20] Wakeup from Stop mode interrupt flag selection                   */
      __IOM uint32 WUFIE      : 1;            /*!< [22..22] Wakeup from Stop mode interrupt enable                           */
      __IOM uint32 TXFTIE     : 1;            /*!< [23..23] TXFIFO threshold interrupt enable                                */
      __IOM uint32 TCBGTIE    : 1;            /*!< [24..24] Transmission Complete before guard time, interrupt
                                                     enable                                                                    */
      __IOM uint32 RXFTCFG    : 3;            /*!< [27..25] Receive FIFO threshold configuration                             */
      __IOM uint32 RXFTIE     : 1;            /*!< [28..28] RXFIFO threshold interrupt enable                                */
      __IOM uint32 TXFTCFG    : 3;            /*!< [31..29] TXFIFO threshold configuration                                   */
    } bit;
  } CR3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) Baud rate register                                         */
    
    struct {
      __IOM uint32 BRR_0_3    : 4;            /*!< [3..0] DIV_Fraction                                                       */
      __IOM uint32 BRR_4_15   : 12;           /*!< [15..4] DIV_Mantissa                                                      */
            uint32            : 16;
    } bit;
  } BRR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) Guard time and prescaler register                          */
    
    struct {
      __IOM uint32 PSC        : 8;            /*!< [7..0] Prescaler value                                                    */
      __IOM uint32 GT         : 8;            /*!< [15..8] Guard time value                                                  */
            uint32            : 16;
    } bit;
  } GTPR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000014) Receiver timeout register                                  */
    
    struct {
      __IOM uint32 RTO        : 24;           /*!< [23..0] Receiver timeout value                                            */
      __IOM uint32 BLEN       : 8;            /*!< [31..24] Block Length                                                     */
    } bit;
  } RTOR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000018) Request register                                           */
    
    struct {
      __OM  uint32 ABRRQ      : 1;            /*!< [0..0] Auto baud rate request                                             */
      __OM  uint32 SBKRQ      : 1;            /*!< [1..1] Send break request                                                 */
      __OM  uint32 MMRQ       : 1;            /*!< [2..2] Mute mode request                                                  */
      __OM  uint32 RXFRQ      : 1;            /*!< [3..3] Receive data flush request                                         */
      __OM  uint32 TXFRQ      : 1;            /*!< [4..4] Transmit data flush request                                        */
            uint32            : 27;
    } bit;
  } RQR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000001C) Interrupt & status register                                */
    
    struct {
      __IM  uint32 PE         : 1;            /*!< [0..0] PE                                                                 */
      __IM  uint32 FE         : 1;            /*!< [1..1] FE                                                                 */
      __IM  uint32 NF         : 1;            /*!< [2..2] NF                                                                 */
      __IM  uint32 ORE        : 1;            /*!< [3..3] ORE                                                                */
      __IM  uint32 IDLE       : 1;            /*!< [4..4] IDLE                                                               */
      __IM  uint32 RXNE       : 1;            /*!< [5..5] RXNE                                                               */
      __IM  uint32 TC         : 1;            /*!< [6..6] TC                                                                 */
      __IM  uint32 TXE        : 1;            /*!< [7..7] TXE                                                                */
      __IM  uint32 LBDF       : 1;            /*!< [8..8] LBDF                                                               */
      __IM  uint32 CTSIF      : 1;            /*!< [9..9] CTSIF                                                              */
      __IM  uint32 CTS        : 1;            /*!< [10..10] CTS                                                              */
      __IM  uint32 RTOF       : 1;            /*!< [11..11] RTOF                                                             */
      __IM  uint32 EOBF       : 1;            /*!< [12..12] EOBF                                                             */
      __IM  uint32 UDR        : 1;            /*!< [13..13] SPI slave underrun error flag                                    */
      __IM  uint32 ABRE       : 1;            /*!< [14..14] ABRE                                                             */
      __IM  uint32 ABRF       : 1;            /*!< [15..15] ABRF                                                             */
      __IM  uint32 BUSY       : 1;            /*!< [16..16] BUSY                                                             */
      __IM  uint32 CMF        : 1;            /*!< [17..17] CMF                                                              */
      __IM  uint32 SBKF       : 1;            /*!< [18..18] SBKF                                                             */
      __IM  uint32 RWU        : 1;            /*!< [19..19] RWU                                                              */
      __IM  uint32 WUF        : 1;            /*!< [20..20] WUF                                                              */
      __IM  uint32 TEACK      : 1;            /*!< [21..21] TEACK                                                            */
      __IM  uint32 REACK      : 1;            /*!< [22..22] REACK                                                            */
      __IM  uint32 TXFE       : 1;            /*!< [23..23] TXFIFO Empty                                                     */
      __IM  uint32 RXFF       : 1;            /*!< [24..24] RXFIFO Full                                                      */
      __IM  uint32 TCBGT      : 1;            /*!< [25..25] Transmission complete before guard time flag                     */
      __IM  uint32 RXFT       : 1;            /*!< [26..26] RXFIFO threshold flag                                            */
      __IM  uint32 TXFT       : 1;            /*!< [27..27] TXFIFO threshold flag                                            */
            uint32            : 4;
    } bit;
  } ISR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000020) Interrupt flag clear register                              */
    
    struct {
      __OM  uint32 PECF       : 1;            /*!< [0..0] Parity error clear flag                                            */
      __OM  uint32 FECF       : 1;            /*!< [1..1] Framing error clear flag                                           */
      __OM  uint32 NCF        : 1;            /*!< [2..2] Noise detected clear flag                                          */
      __OM  uint32 ORECF      : 1;            /*!< [3..3] Overrun error clear flag                                           */
      __OM  uint32 IDLECF     : 1;            /*!< [4..4] Idle line detected clear flag                                      */
      __OM  uint32 TXFECF     : 1;            /*!< [5..5] TXFIFO empty clear flag                                            */
      __OM  uint32 TCCF       : 1;            /*!< [6..6] Transmission complete clear flag                                   */
      __OM  uint32 TCBGTC     : 1;            /*!< [7..7] Transmission complete before Guard time clear flag                 */
      __OM  uint32 LBDCF      : 1;            /*!< [8..8] LIN break detection clear flag                                     */
      __OM  uint32 CTSCF      : 1;            /*!< [9..9] CTS clear flag                                                     */
            uint32            : 1;
      __OM  uint32 RTOCF      : 1;            /*!< [11..11] Receiver timeout clear flag                                      */
      __OM  uint32 EOBCF      : 1;            /*!< [12..12] End of block clear flag                                          */
      __OM  uint32 UDRCF      : 1;            /*!< [13..13] SPI slave underrun clear flag                                    */
            uint32            : 3;
      __OM  uint32 CMCF       : 1;            /*!< [17..17] Character match clear flag                                       */
            uint32            : 2;
      __OM  uint32 WUCF       : 1;            /*!< [20..20] Wakeup from Stop mode clear flag                                 */
            uint32            : 11;
    } bit;
  } ICR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000024) Receive data register                                      */
    
    struct {
      __IM  uint32 RDR        : 9;            /*!< [8..0] Receive data value                                                 */
            uint32            : 23;
    } bit;
  } RDR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000028) Transmit data register                                     */
    
    struct {
      __IOM uint32 TDR        : 9;            /*!< [8..0] Transmit data value                                                */
            uint32            : 23;
    } bit;
  } TDR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000002C) USART prescaler register                                   */
    
    struct {
      __IOM uint32 PRESCALER  : 4;            /*!< [3..0] Clock prescaler                                                    */
            uint32            : 28;
    } bit;
  } PRESC;
} USART1_Type;                                  /*!< Size = 48 (0x30)                                                          */



/* =========================================================================================================================== */
/* ================                                           TIM1                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Advanced-timers (TIM1)
  */

typedef struct {                                /*!< (@ 0x40010000) TIM1 Structure                                             */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) control register 1                                         */
    
    struct {
      __IOM uint32 CEN        : 1;            /*!< [0..0] Counter enable                                                     */
      __IOM uint32 UDIS       : 1;            /*!< [1..1] Update disable                                                     */
      __IOM uint32 URS        : 1;            /*!< [2..2] Update request source                                              */
      __IOM uint32 OPM        : 1;            /*!< [3..3] One-pulse mode                                                     */
      __IOM uint32 DIR        : 1;            /*!< [4..4] Direction                                                          */
      __IOM uint32 CMS        : 2;            /*!< [6..5] Center-aligned mode selection                                      */
      __IOM uint32 ARPE       : 1;            /*!< [7..7] Auto-reload preload enable                                         */
      __IOM uint32 CKD        : 2;            /*!< [9..8] Clock division                                                     */
            uint32            : 1;
      __IOM uint32 UIFREMAP   : 1;            /*!< [11..11] UIF status bit remapping                                         */
            uint32            : 20;
    } bit;
  } CR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) control register 2                                         */
    
    struct {
      __IOM uint32 CCPC       : 1;            /*!< [0..0] Capture/compare preloaded control                                  */
            uint32            : 1;
      __IOM uint32 CCUS       : 1;            /*!< [2..2] Capture/compare control update selection                           */
      __IOM uint32 CCDS       : 1;            /*!< [3..3] Capture/compare DMA selection                                      */
      __IOM uint32 MMS        : 3;            /*!< [6..4] Master mode selection                                              */
      __IOM uint32 TI1S       : 1;            /*!< [7..7] TI1 selection                                                      */
      __IOM uint32 OIS1       : 1;            /*!< [8..8] Output Idle state 1                                                */
      __IOM uint32 OIS1N      : 1;            /*!< [9..9] Output Idle state 1                                                */
      __IOM uint32 OIS2       : 1;            /*!< [10..10] Output Idle state 2                                              */
      __IOM uint32 OIS2N      : 1;            /*!< [11..11] Output Idle state 2                                              */
      __IOM uint32 OIS3       : 1;            /*!< [12..12] Output Idle state 3                                              */
      __IOM uint32 OIS3N      : 1;            /*!< [13..13] Output Idle state 3                                              */
      __IOM uint32 OIS4       : 1;            /*!< [14..14] Output Idle state 4                                              */
            uint32            : 1;
      __IOM uint32 OIS5       : 1;            /*!< [16..16] Output Idle state 5                                              */
            uint32            : 1;
      __IOM uint32 OIS6       : 1;            /*!< [18..18] Output Idle state 6                                              */
            uint32            : 1;
      __IOM uint32 MMS2       : 4;            /*!< [23..20] Master mode selection 2                                          */
            uint32            : 8;
    } bit;
  } CR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) slave mode control register                                */
    
    struct {
      __IOM uint32 SMS        : 3;            /*!< [2..0] Slave mode selection                                               */
            uint32            : 1;
      __IOM uint32 TS         : 3;            /*!< [6..4] Trigger selection                                                  */
      __IOM uint32 MSM        : 1;            /*!< [7..7] Master/Slave mode                                                  */
      __IOM uint32 ETF        : 4;            /*!< [11..8] External trigger filter                                           */
      __IOM uint32 ETPS       : 2;            /*!< [13..12] External trigger prescaler                                       */
      __IOM uint32 ECE        : 1;            /*!< [14..14] External clock enable                                            */
      __IOM uint32 ETP        : 1;            /*!< [15..15] External trigger polarity                                        */
      __IOM uint32 SMS_3      : 1;            /*!< [16..16] Slave mode selection - bit 3                                     */
            uint32            : 3;
      __IOM uint32 TS_4_3     : 2;            /*!< [21..20] Trigger selection - bit 4:3                                      */
            uint32            : 10;
    } bit;
  } SMCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) DMA/Interrupt enable register                              */
    
    struct {
      __IOM uint32 UIE        : 1;            /*!< [0..0] Update interrupt enable                                            */
      __IOM uint32 CC1IE      : 1;            /*!< [1..1] Capture/Compare 1 interrupt enable                                 */
      __IOM uint32 CC2IE      : 1;            /*!< [2..2] Capture/Compare 2 interrupt enable                                 */
      __IOM uint32 CC3IE      : 1;            /*!< [3..3] Capture/Compare 3 interrupt enable                                 */
      __IOM uint32 CC4IE      : 1;            /*!< [4..4] Capture/Compare 4 interrupt enable                                 */
      __IOM uint32 COMIE      : 1;            /*!< [5..5] COM interrupt enable                                               */
      __IOM uint32 TIE        : 1;            /*!< [6..6] Trigger interrupt enable                                           */
      __IOM uint32 BIE        : 1;            /*!< [7..7] Break interrupt enable                                             */
      __IOM uint32 UDE        : 1;            /*!< [8..8] Update DMA request enable                                          */
      __IOM uint32 CC1DE      : 1;            /*!< [9..9] Capture/Compare 1 DMA request enable                               */
      __IOM uint32 CC2DE      : 1;            /*!< [10..10] Capture/Compare 2 DMA request enable                             */
      __IOM uint32 CC3DE      : 1;            /*!< [11..11] Capture/Compare 3 DMA request enable                             */
      __IOM uint32 CC4DE      : 1;            /*!< [12..12] Capture/Compare 4 DMA request enable                             */
      __IOM uint32 COMDE      : 1;            /*!< [13..13] COM DMA request enable                                           */
      __IOM uint32 TDE        : 1;            /*!< [14..14] Trigger DMA request enable                                       */
            uint32            : 17;
    } bit;
  } DIER;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) status register                                            */
    
    struct {
      __IOM uint32 UIF        : 1;            /*!< [0..0] Update interrupt flag                                              */
      __IOM uint32 CC1IF      : 1;            /*!< [1..1] Capture/compare 1 interrupt flag                                   */
      __IOM uint32 CC2IF      : 1;            /*!< [2..2] Capture/Compare 2 interrupt flag                                   */
      __IOM uint32 CC3IF      : 1;            /*!< [3..3] Capture/Compare 3 interrupt flag                                   */
      __IOM uint32 CC4IF      : 1;            /*!< [4..4] Capture/Compare 4 interrupt flag                                   */
      __IOM uint32 COMIF      : 1;            /*!< [5..5] COM interrupt flag                                                 */
      __IOM uint32 TIF        : 1;            /*!< [6..6] Trigger interrupt flag                                             */
      __IOM uint32 BIF        : 1;            /*!< [7..7] Break interrupt flag                                               */
      __IOM uint32 B2IF       : 1;            /*!< [8..8] Break 2 interrupt flag                                             */
      __IOM uint32 CC1OF      : 1;            /*!< [9..9] Capture/Compare 1 overcapture flag                                 */
      __IOM uint32 CC2OF      : 1;            /*!< [10..10] Capture/compare 2 overcapture flag                               */
      __IOM uint32 CC3OF      : 1;            /*!< [11..11] Capture/Compare 3 overcapture flag                               */
      __IOM uint32 CC4OF      : 1;            /*!< [12..12] Capture/Compare 4 overcapture flag                               */
      __IOM uint32 SBIF       : 1;            /*!< [13..13] System Break interrupt flag                                      */
            uint32            : 2;
      __IOM uint32 CC5IF      : 1;            /*!< [16..16] Compare 5 interrupt flag                                         */
      __IOM uint32 CC6IF      : 1;            /*!< [17..17] Compare 6 interrupt flag                                         */
            uint32            : 14;
    } bit;
  } SR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000014) event generation register                                  */
    
    struct {
      __OM  uint32 UG         : 1;            /*!< [0..0] Update generation                                                  */
      __OM  uint32 CC1G       : 1;            /*!< [1..1] Capture/compare 1 generation                                       */
      __OM  uint32 CC2G       : 1;            /*!< [2..2] Capture/compare 2 generation                                       */
      __OM  uint32 CC3G       : 1;            /*!< [3..3] Capture/compare 3 generation                                       */
      __OM  uint32 CC4G       : 1;            /*!< [4..4] Capture/compare 4 generation                                       */
      __OM  uint32 COMG       : 1;            /*!< [5..5] Capture/Compare control update generation                          */
      __OM  uint32 TG         : 1;            /*!< [6..6] Trigger generation                                                 */
      __OM  uint32 BG         : 1;            /*!< [7..7] Break generation                                                   */
      __OM  uint32 B2G        : 1;            /*!< [8..8] Break 2 generation                                                 */
            uint32            : 23;
    } bit;
  } EGR;
  
  union {
    union {
      __IOM uint32 reg;                       /*!< (@ 0x00000018) capture/compare mode register 1 (output mode)              */
      
      struct {
        __IOM uint32 CC1S     : 2;            /*!< [1..0] Capture/Compare 1 selection                                        */
        __IOM uint32 OC1FE    : 1;            /*!< [2..2] Output Compare 1 fast enable                                       */
        __IOM uint32 OC1PE    : 1;            /*!< [3..3] Output Compare 1 preload enable                                    */
        __IOM uint32 OC1M     : 3;            /*!< [6..4] Output Compare 1 mode                                              */
        __IOM uint32 OC1CE    : 1;            /*!< [7..7] Output Compare 1 clear enable                                      */
        __IOM uint32 CC2S     : 2;            /*!< [9..8] Capture/Compare 2 selection                                        */
        __IOM uint32 OC2FE    : 1;            /*!< [10..10] Output Compare 2 fast enable                                     */
        __IOM uint32 OC2PE    : 1;            /*!< [11..11] Output Compare 2 preload enable                                  */
        __IOM uint32 OC2M     : 3;            /*!< [14..12] Output Compare 2 mode                                            */
        __IOM uint32 OC2CE    : 1;            /*!< [15..15] Output Compare 2 clear enable                                    */
        __IOM uint32 OC1M_3   : 1;            /*!< [16..16] Output Compare 1 mode - bit 3                                    */
              uint32          : 7;
        __IOM uint32 OC2M_3   : 1;            /*!< [24..24] Output Compare 2 mode - bit 3                                    */
              uint32          : 7;
      } bit;
    } CCMR1_Output;
    
    union {
      __IOM uint32 reg;                       /*!< (@ 0x00000018) capture/compare mode register 1 (input mode)               */
      
      struct {
        __IOM uint32 CC1S     : 2;            /*!< [1..0] Capture/Compare 1 selection                                        */
        __IOM uint32 ICPCS    : 2;            /*!< [3..2] Input capture 1 prescaler                                          */
        __IOM uint32 IC1F     : 4;            /*!< [7..4] Input capture 1 filter                                             */
        __IOM uint32 CC2S     : 2;            /*!< [9..8] Capture/Compare 2 selection                                        */
        __IOM uint32 IC2PCS   : 2;            /*!< [11..10] Input capture 2 prescaler                                        */
        __IOM uint32 IC2F     : 4;            /*!< [15..12] Input capture 2 filter                                           */
              uint32          : 16;
      } bit;
    } CCMR1_Input;
  };
  
  union {
    union {
      __IOM uint32 reg;                       /*!< (@ 0x0000001C) capture/compare mode register 2 (output mode)              */
      
      struct {
        __IOM uint32 CC3S     : 2;            /*!< [1..0] Capture/Compare 3 selection                                        */
        __IOM uint32 OC3FE    : 1;            /*!< [2..2] Output compare 3 fast enable                                       */
        __IOM uint32 OC3PE    : 1;            /*!< [3..3] Output compare 3 preload enable                                    */
        __IOM uint32 OC3M     : 3;            /*!< [6..4] Output compare 3 mode                                              */
        __IOM uint32 OC3CE    : 1;            /*!< [7..7] Output compare 3 clear enable                                      */
        __IOM uint32 CC4S     : 2;            /*!< [9..8] Capture/Compare 4 selection                                        */
        __IOM uint32 OC4FE    : 1;            /*!< [10..10] Output compare 4 fast enable                                     */
        __IOM uint32 OC4PE    : 1;            /*!< [11..11] Output compare 4 preload enable                                  */
        __IOM uint32 OC4M     : 3;            /*!< [14..12] Output compare 4 mode                                            */
        __IOM uint32 OC4CE    : 1;            /*!< [15..15] Output compare 4 clear enable                                    */
        __IOM uint32 OC3M_3   : 1;            /*!< [16..16] Output Compare 3 mode - bit 3                                    */
              uint32          : 7;
        __IOM uint32 OC4M_4   : 1;            /*!< [24..24] Output Compare 4 mode - bit 3                                    */
              uint32          : 7;
      } bit;
    } CCMR2_Output;
    
    union {
      __IOM uint32 reg;                       /*!< (@ 0x0000001C) capture/compare mode register 2 (input mode)               */
      
      struct {
        __IOM uint32 CC3S     : 2;            /*!< [1..0] Capture/compare 3 selection                                        */
        __IOM uint32 IC3PSC   : 2;            /*!< [3..2] Input capture 3 prescaler                                          */
        __IOM uint32 IC3F     : 4;            /*!< [7..4] Input capture 3 filter                                             */
        __IOM uint32 CC4S     : 2;            /*!< [9..8] Capture/Compare 4 selection                                        */
        __IOM uint32 IC4PSC   : 2;            /*!< [11..10] Input capture 4 prescaler                                        */
        __IOM uint32 IC4F     : 4;            /*!< [15..12] Input capture 4 filter                                           */
              uint32          : 16;
      } bit;
    } CCMR2_Input;
  };
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000020) capture/compare enable register                            */
    
    struct {
      __IOM uint32 CC1E       : 1;            /*!< [0..0] Capture/Compare 1 output enable                                    */
      __IOM uint32 CC1P       : 1;            /*!< [1..1] Capture/Compare 1 output Polarity                                  */
      __IOM uint32 CC1NE      : 1;            /*!< [2..2] Capture/Compare 1 complementary output enable                      */
      __IOM uint32 CC1NP      : 1;            /*!< [3..3] Capture/Compare 1 output Polarity                                  */
      __IOM uint32 CC2E       : 1;            /*!< [4..4] Capture/Compare 2 output enable                                    */
      __IOM uint32 CC2P       : 1;            /*!< [5..5] Capture/Compare 2 output Polarity                                  */
      __IOM uint32 CC2NE      : 1;            /*!< [6..6] Capture/Compare 2 complementary output enable                      */
      __IOM uint32 CC2NP      : 1;            /*!< [7..7] Capture/Compare 2 output Polarity                                  */
      __IOM uint32 CC3E       : 1;            /*!< [8..8] Capture/Compare 3 output enable                                    */
      __IOM uint32 CC3P       : 1;            /*!< [9..9] Capture/Compare 3 output Polarity                                  */
      __IOM uint32 CC3NE      : 1;            /*!< [10..10] Capture/Compare 3 complementary output enable                    */
      __IOM uint32 CC3NP      : 1;            /*!< [11..11] Capture/Compare 3 output Polarity                                */
      __IOM uint32 CC4E       : 1;            /*!< [12..12] Capture/Compare 4 output enable                                  */
      __IOM uint32 CC4P       : 1;            /*!< [13..13] Capture/Compare 3 output Polarity                                */
            uint32            : 1;
      __IOM uint32 CC4NP      : 1;            /*!< [15..15] Capture/Compare 4 complementary output polarity                  */
      __IOM uint32 CC5E       : 1;            /*!< [16..16] Capture/Compare 5 output enable                                  */
      __IOM uint32 CC5P       : 1;            /*!< [17..17] Capture/Compare 5 output polarity                                */
            uint32            : 2;
      __IOM uint32 CC6E       : 1;            /*!< [20..20] Capture/Compare 6 output enable                                  */
      __IOM uint32 CC6P       : 1;            /*!< [21..21] Capture/Compare 6 output polarity                                */
            uint32            : 10;
    } bit;
  } CCER;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000024) counter                                                    */
    
    struct {
      __IOM uint32 CNT        : 16;           /*!< [15..0] counter value                                                     */
            uint32            : 15;
      __IM  uint32 UIFCPY     : 1;            /*!< [31..31] UIF copy                                                         */
    } bit;
  } CNT;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000028) prescaler                                                  */
    
    struct {
      __IOM uint32 PSC        : 16;           /*!< [15..0] Prescaler value                                                   */
            uint32            : 16;
    } bit;
  } PSC;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000002C) auto-reload register                                       */
    
    struct {
      __IOM uint32 ARR        : 16;           /*!< [15..0] Auto-reload value                                                 */
            uint32            : 16;
    } bit;
  } ARR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000030) repetition counter register                                */
    
    struct {
      __IOM uint32 REP        : 8;            /*!< [7..0] Repetition counter value                                           */
            uint32            : 24;
    } bit;
  } RCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000034) capture/compare register 1                                 */
    
    struct {
      __IOM uint32 CCR1       : 16;           /*!< [15..0] Capture/Compare 1 value                                           */
            uint32            : 16;
    } bit;
  } CCR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000038) capture/compare register 2                                 */
    
    struct {
      __IOM uint32 CCR2       : 16;           /*!< [15..0] Capture/Compare 2 value                                           */
            uint32            : 16;
    } bit;
  } CCR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000003C) capture/compare register 3                                 */
    
    struct {
      __IOM uint32 CCR3       : 16;           /*!< [15..0] Capture/Compare value                                             */
            uint32            : 16;
    } bit;
  } CCR3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000040) capture/compare register 4                                 */
    
    struct {
      __IOM uint32 CCR4       : 16;           /*!< [15..0] Capture/Compare value                                             */
            uint32            : 16;
    } bit;
  } CCR4;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000044) break and dead-time register                               */
    
    struct {
      __IOM uint32 DTG        : 8;            /*!< [7..0] Dead-time generator setup                                          */
      __IOM uint32 LOCK       : 2;            /*!< [9..8] Lock configuration                                                 */
      __IOM uint32 OSSI       : 1;            /*!< [10..10] Off-state selection for Idle mode                                */
      __IOM uint32 OSSR       : 1;            /*!< [11..11] Off-state selection for Run mode                                 */
      __IOM uint32 BKE        : 1;            /*!< [12..12] Break enable                                                     */
      __IOM uint32 BKP        : 1;            /*!< [13..13] Break polarity                                                   */
      __IOM uint32 AOE        : 1;            /*!< [14..14] Automatic output enable                                          */
      __IOM uint32 MOE        : 1;            /*!< [15..15] Main output enable                                               */
      __IOM uint32 BKF        : 4;            /*!< [19..16] Break filter                                                     */
      __IOM uint32 BK2F       : 4;            /*!< [23..20] Break 2 filter                                                   */
      __IOM uint32 BK2E       : 1;            /*!< [24..24] Break 2 enable                                                   */
      __IOM uint32 BK2P       : 1;            /*!< [25..25] Break 2 polarity                                                 */
            uint32            : 6;
    } bit;
  } BDTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000048) DMA control register                                       */
    
    struct {
      __IOM uint32 DBA        : 5;            /*!< [4..0] DMA base address                                                   */
            uint32            : 3;
      __IOM uint32 DBL        : 5;            /*!< [12..8] DMA burst length                                                  */
            uint32            : 19;
    } bit;
  } DCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000004C) DMA address for full transfer                              */
    
    struct {
      __IOM uint32 DMAB       : 16;           /*!< [15..0] DMA register for burst accesses                                   */
            uint32            : 16;
    } bit;
  } DMAR;
  __IM  uint32  RESERVED;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000054) capture/compare mode register 3 (output mode)              */
    
    struct {
            uint32            : 2;
      __IOM uint32 OC5FE      : 1;            /*!< [2..2] Output compare 5 fast enable                                       */
      __IOM uint32 OC5PE      : 1;            /*!< [3..3] Output compare 5 preload enable                                    */
      __IOM uint32 OC5M       : 3;            /*!< [6..4] Output compare 5 mode                                              */
      __IOM uint32 OC5CE      : 1;            /*!< [7..7] Output compare 5 clear enable                                      */
            uint32            : 2;
      __IOM uint32 OC6FE      : 1;            /*!< [10..10] Output compare 6 fast enable                                     */
      __IOM uint32 OC6PE      : 1;            /*!< [11..11] Output compare 6 preload enable                                  */
      __IOM uint32 OC6M       : 3;            /*!< [14..12] Output compare 6 mode                                            */
      __IOM uint32 OC6CE      : 1;            /*!< [15..15] Output compare 6 clear enable                                    */
      __IOM uint32 OC5M3      : 1;            /*!< [16..16] Output Compare 5 mode                                            */
            uint32            : 7;
      __IOM uint32 OC6M3      : 1;            /*!< [24..24] Output Compare 6 mode                                            */
            uint32            : 7;
    } bit;
  } CCMR3_Output;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000058) capture/compare register 5                                 */
    
    struct {
      __IOM uint32 CCR5       : 16;           /*!< [15..0] Capture/Compare 5 value                                           */
            uint32            : 13;
      __IOM uint32 GC5C1      : 1;            /*!< [29..29] Group Channel 5 and Channel 1                                    */
      __IOM uint32 GC5C2      : 1;            /*!< [30..30] Group Channel 5 and Channel 2                                    */
      __IOM uint32 GC5C3      : 1;            /*!< [31..31] Group Channel 5 and Channel 3                                    */
    } bit;
  } CCR5;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000005C) capture/compare register 6                                 */
    
    struct {
      __IOM uint32 CCR6       : 16;           /*!< [15..0] Capture/Compare 6 value                                           */
            uint32            : 16;
    } bit;
  } CRR6;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000060) TIM1 alternate function option register 1                  */
    
    struct {
      __IOM uint32 BKINE      : 1;            /*!< [0..0] BRK BKIN input enable                                              */
      __IOM uint32 BKCMP1E    : 1;            /*!< [1..1] BRK COMP1 enable                                                   */
      __IOM uint32 BKCMP2E    : 1;            /*!< [2..2] BRK COMP2 enable                                                   */
            uint32            : 5;
      __IOM uint32 BKDF1BK0E  : 1;            /*!< [8..8] BRK dfsdm1_break[0] enable                                         */
      __IOM uint32 BKINP      : 1;            /*!< [9..9] BRK BKIN input polarity                                            */
      __IOM uint32 BKCMP1P    : 1;            /*!< [10..10] BRK COMP1 input polarity                                         */
      __IOM uint32 BKCMP2P    : 1;            /*!< [11..11] BRK COMP2 input polarity                                         */
            uint32            : 2;
      __IOM uint32 ETRSEL     : 4;            /*!< [17..14] ETR source selection                                             */
            uint32            : 14;
    } bit;
  } AF1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000064) TIM1 Alternate function odfsdm1_breakster 2                */
    
    struct {
      __IOM uint32 BK2INE     : 1;            /*!< [0..0] BRK2 BKIN input enable                                             */
      __IOM uint32 BK2CMP1E   : 1;            /*!< [1..1] BRK2 COMP1 enable                                                  */
      __IOM uint32 BK2CMP2E   : 1;            /*!< [2..2] BRK2 COMP2 enable                                                  */
            uint32            : 5;
      __IOM uint32 BK2DF1BK1E : 1;            /*!< [8..8] BRK2 dfsdm1_break[1] enable                                        */
      __IOM uint32 BK2INP     : 1;            /*!< [9..9] BRK2 BKIN2 input polarity                                          */
      __IOM uint32 BK2CMP1P   : 1;            /*!< [10..10] BRK2 COMP1 input polarit                                         */
      __IOM uint32 BK2CMP2P   : 1;            /*!< [11..11] BRK2 COMP2 input polarity                                        */
            uint32            : 20;
    } bit;
  } AF2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000068) TIM1 timer input selection register                        */
    
    struct {
      __IOM uint32 TI1SEL     : 4;            /*!< [3..0] selects TI1[0] to TI1[15] input                                    */
            uint32            : 4;
      __IOM uint32 TI2SEL     : 4;            /*!< [11..8] selects TI2[0] to TI2[15] input                                   */
            uint32            : 4;
      __IOM uint32 TI3SEL     : 4;            /*!< [19..16] selects TI3[0] to TI3[15] input                                  */
            uint32            : 4;
      __IOM uint32 TI4SEL     : 4;            /*!< [27..24] selects TI4[0] to TI4[15] input                                  */
            uint32            : 4;
    } bit;
  } TISEL;
} TIM1_Type;                                    /*!< Size = 108 (0x6c)                                                         */



/* =========================================================================================================================== */
/* ================                                          FDCAN1                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief FDCAN1 (FDCAN1)
  */

typedef struct {                                /*!< (@ 0x4000A000) FDCAN1 Structure                                           */
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000000) FDCAN Core Release Register                                */
    
    struct {
      __IM  uint32 DAY        : 8;            /*!< [7..0] Timestamp Day                                                      */
      __IM  uint32 MON        : 8;            /*!< [15..8] Timestamp Month                                                   */
      __IM  uint32 YEAR       : 4;            /*!< [19..16] Timestamp Year                                                   */
      __IM  uint32 SUBSTEP    : 4;            /*!< [23..20] Sub-step of Core release                                         */
      __IM  uint32 STEP       : 4;            /*!< [27..24] Step of Core release                                             */
      __IM  uint32 REL        : 4;            /*!< [31..28] Core release                                                     */
    } bit;
  } FDCAN_CREL;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000004) FDCAN Core Release Register                                */
    
    struct {
      __IM  uint32 ETV        : 32;           /*!< [31..0] Endiannes Test Value                                              */
    } bit;
  } FDCAN_ENDN;
  __IM  uint32  RESERVED;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000000C) FDCAN Data Bit Timing and Prescaler Register               */
    
    struct {
      __IM  uint32 DSJW       : 4;            /*!< [3..0] Synchronization Jump Width                                         */
      __IM  uint32 DTSEG2     : 4;            /*!< [7..4] Data time segment after sample point                               */
      __IM  uint32 DTSEG1     : 5;            /*!< [12..8] Data time segment after sample point                              */
            uint32            : 3;
      __IM  uint32 DBRP       : 5;            /*!< [20..16] Data BIt Rate Prescaler                                          */
            uint32            : 2;
      __IM  uint32 TDC        : 1;            /*!< [23..23] Transceiver Delay Compensation                                   */
            uint32            : 8;
    } bit;
  } FDCAN_DBTP;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000010) FDCAN Test Register                                        */
    
    struct {
            uint32            : 4;
      __IM  uint32 LBCK       : 1;            /*!< [4..4] Loop Back mode                                                     */
      __IM  uint32 TX         : 2;            /*!< [6..5] Loop Back mode                                                     */
      __IM  uint32 RX         : 1;            /*!< [7..7] Control of Transmit Pin                                            */
            uint32            : 24;
    } bit;
  } FDCAN_TEST;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000014) FDCAN RAM Watchdog Register                                */
    
    struct {
      __IM  uint32 WDC        : 8;            /*!< [7..0] Watchdog configuration                                             */
      __IM  uint32 WDV        : 8;            /*!< [15..8] Watchdog value                                                    */
            uint32            : 16;
    } bit;
  } FDCAN_RWD;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000018) FDCAN CC Control Register                                  */
    
    struct {
      __IOM uint32 INIT       : 1;            /*!< [0..0] Initialization                                                     */
      __IOM uint32 CCE        : 1;            /*!< [1..1] Configuration Change Enable                                        */
      __IOM uint32 ASM        : 1;            /*!< [2..2] ASM Restricted Operation Mode                                      */
      __IOM uint32 CSA        : 1;            /*!< [3..3] Clock Stop Acknowledge                                             */
      __IOM uint32 CSR        : 1;            /*!< [4..4] Clock Stop Request                                                 */
      __IOM uint32 MON        : 1;            /*!< [5..5] Bus Monitoring Mode                                                */
      __IOM uint32 DAR        : 1;            /*!< [6..6] Disable Automatic Retransmission                                   */
      __IOM uint32 TEST       : 1;            /*!< [7..7] Test Mode Enable                                                   */
      __IOM uint32 FDOE       : 1;            /*!< [8..8] FD Operation Enable                                                */
      __IOM uint32 BSE        : 1;            /*!< [9..9] FDCAN Bit Rate Switching                                           */
            uint32            : 2;
      __IOM uint32 PXHD       : 1;            /*!< [12..12] Protocol Exception Handling Disable                              */
      __IOM uint32 EFBI       : 1;            /*!< [13..13] Edge Filtering during Bus Integration                            */
      __IOM uint32 TXP        : 1;            /*!< [14..14] TXP                                                              */
      __IOM uint32 NISO       : 1;            /*!< [15..15] Non ISO Operation                                                */
            uint32            : 16;
    } bit;
  } FDCAN_CCCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000001C) FDCAN Nominal Bit Timing and Prescaler Register            */
    
    struct {
      __IOM uint32 TSEG2      : 7;            /*!< [6..0] Nominal Time segment after sample point                            */
            uint32            : 1;
      __IOM uint32 NTSEG1     : 8;            /*!< [15..8] Nominal Time segment before sample point                          */
      __IOM uint32 NBRP       : 9;            /*!< [24..16] Bit Rate Prescaler                                               */
      __IOM uint32 NSJW       : 7;            /*!< [31..25] NSJW: Nominal (Re)Synchronization Jump Width                     */
    } bit;
  } FDCAN_NBTP;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000020) FDCAN Timestamp Counter Configuration Register             */
    
    struct {
      __IOM uint32 TSS        : 2;            /*!< [1..0] Timestamp Select                                                   */
            uint32            : 14;
      __IOM uint32 TCP        : 4;            /*!< [19..16] Timestamp Counter Prescaler                                      */
            uint32            : 12;
    } bit;
  } FDCAN_TSCC;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000024) FDCAN Timestamp Counter Value Register                     */
    
    struct {
      __IOM uint32 TSC        : 16;           /*!< [15..0] Timestamp Counter                                                 */
            uint32            : 16;
    } bit;
  } FDCAN_TSCV;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000028) FDCAN Timeout Counter Configuration Register               */
    
    struct {
      __IOM uint32 ETOC       : 1;            /*!< [0..0] Enable Timeout Counter                                             */
      __IOM uint32 TOS        : 2;            /*!< [2..1] Timeout Select                                                     */
            uint32            : 13;
      __IOM uint32 TOP        : 16;           /*!< [31..16] Timeout Period                                                   */
    } bit;
  } FDCAN_TOCC;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000002C) FDCAN Timeout Counter Value Register                       */
    
    struct {
      __IOM uint32 TOC        : 16;           /*!< [15..0] Timeout Counter                                                   */
            uint32            : 16;
    } bit;
  } FDCAN_TOCV;
  __IM  uint32  RESERVED1[4];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000040) FDCAN Error Counter Register                               */
    
    struct {
      __IOM uint32 TEC        : 8;            /*!< [7..0] Transmit Error Counter                                             */
      __IOM uint32 TREC       : 7;            /*!< [14..8] Receive Error Counter                                             */
      __IOM uint32 RP         : 1;            /*!< [15..15] Receive Error Passive                                            */
      __IOM uint32 CEL        : 8;            /*!< [23..16] AN Error Logging                                                 */
            uint32            : 8;
    } bit;
  } FDCAN_ECR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000044) FDCAN Protocol Status Register                             */
    
    struct {
      __IOM uint32 LEC        : 3;            /*!< [2..0] Last Error Code                                                    */
      __IOM uint32 ACT        : 2;            /*!< [4..3] Activity                                                           */
      __IOM uint32 EP         : 1;            /*!< [5..5] Error Passive                                                      */
      __IOM uint32 EW         : 1;            /*!< [6..6] Warning Status                                                     */
      __IOM uint32 BO         : 1;            /*!< [7..7] Bus_Off Status                                                     */
      __IOM uint32 DLEC       : 3;            /*!< [10..8] Data Last Error Code                                              */
      __IOM uint32 RESI       : 1;            /*!< [11..11] ESI flag of last received FDCAN Message                          */
      __IOM uint32 RBRS       : 1;            /*!< [12..12] BRS flag of last received FDCAN Message                          */
      __IOM uint32 REDL       : 1;            /*!< [13..13] Received FDCAN Message                                           */
      __IOM uint32 PXE        : 1;            /*!< [14..14] Protocol Exception Event                                         */
            uint32            : 1;
      __IOM uint32 TDCV       : 7;            /*!< [22..16] Transmitter Delay Compensation Value                             */
            uint32            : 9;
    } bit;
  } FDCAN_PSR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000048) FDCAN Transmitter Delay Compensation Register              */
    
    struct {
      __IM  uint32 TDCF       : 7;            /*!< [6..0] Transmitter Delay Compensation Filter Window Length                */
            uint32            : 1;
      __IM  uint32 TDCO       : 7;            /*!< [14..8] Transmitter Delay Compensation Offset                             */
            uint32            : 17;
    } bit;
  } FDCAN_TDCR;
  __IM  uint32  RESERVED2;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000050) FDCAN Interrupt Register                                   */
    
    struct {
      __IM  uint32 RF0N       : 1;            /*!< [0..0] Rx FIFO 0 New Message                                              */
      __IM  uint32 RF0W       : 1;            /*!< [1..1] Rx FIFO 0 Full                                                     */
      __IM  uint32 RF0F       : 1;            /*!< [2..2] Rx FIFO 0 Full                                                     */
      __IM  uint32 RF0L       : 1;            /*!< [3..3] Rx FIFO 0 Message Lost                                             */
      __IM  uint32 RF1N       : 1;            /*!< [4..4] Rx FIFO 1 New Message                                              */
      __IM  uint32 RF1W       : 1;            /*!< [5..5] Rx FIFO 1 Watermark Reached                                        */
      __IM  uint32 RF1F       : 1;            /*!< [6..6] Rx FIFO 1 Watermark Reached                                        */
      __IM  uint32 RF1L       : 1;            /*!< [7..7] Rx FIFO 1 Message Lost                                             */
      __IM  uint32 HPM        : 1;            /*!< [8..8] High Priority Message                                              */
      __IM  uint32 TC         : 1;            /*!< [9..9] Transmission Completed                                             */
      __IM  uint32 TCF        : 1;            /*!< [10..10] Transmission Cancellation Finished                               */
      __IM  uint32 TEF        : 1;            /*!< [11..11] Tx FIFO Empty                                                    */
      __IM  uint32 TEFN       : 1;            /*!< [12..12] Tx Event FIFO New Entry                                          */
      __IM  uint32 TEFW       : 1;            /*!< [13..13] Tx Event FIFO Watermark Reached                                  */
      __IM  uint32 TEFF       : 1;            /*!< [14..14] Tx Event FIFO Full                                               */
      __IM  uint32 TEFL       : 1;            /*!< [15..15] Tx Event FIFO Element Lost                                       */
      __IM  uint32 TSW        : 1;            /*!< [16..16] Timestamp Wraparound                                             */
      __IM  uint32 MRAF       : 1;            /*!< [17..17] Message RAM Access Failure                                       */
      __IM  uint32 TOO        : 1;            /*!< [18..18] Timeout Occurred                                                 */
      __IM  uint32 DRX        : 1;            /*!< [19..19] Message stored to Dedicated Rx Buffer                            */
            uint32            : 2;
      __IM  uint32 ELO        : 1;            /*!< [22..22] Error Logging Overflow                                           */
      __IM  uint32 EP         : 1;            /*!< [23..23] Error Passive                                                    */
      __IM  uint32 EW         : 1;            /*!< [24..24] Warning Status                                                   */
      __IM  uint32 BO         : 1;            /*!< [25..25] Bus_Off Status                                                   */
      __IM  uint32 WDI        : 1;            /*!< [26..26] Watchdog Interrupt                                               */
      __IM  uint32 PEA        : 1;            /*!< [27..27] Protocol Error in Arbitration Phase (Nominal Bit Time
                                                     is used)                                                                  */
      __IM  uint32 PED        : 1;            /*!< [28..28] Protocol Error in Data Phase (Data Bit Time is used)             */
      __IM  uint32 ARA        : 1;            /*!< [29..29] Access to Reserved Address                                       */
            uint32            : 2;
    } bit;
  } FDCAN_IR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000054) FDCAN Interrupt Enable Register                            */
    
    struct {
      __IM  uint32 RF0NE      : 1;            /*!< [0..0] Rx FIFO 0 New Message Enable                                       */
      __IM  uint32 RF0WE      : 1;            /*!< [1..1] Rx FIFO 0 Full Enable                                              */
      __IM  uint32 RF0FE      : 1;            /*!< [2..2] Rx FIFO 0 Full Enable                                              */
      __IM  uint32 RF0LE      : 1;            /*!< [3..3] Rx FIFO 0 Message Lost Enable                                      */
      __IM  uint32 RF1NE      : 1;            /*!< [4..4] Rx FIFO 1 New Message Enable                                       */
      __IM  uint32 RF1WE      : 1;            /*!< [5..5] Rx FIFO 1 Watermark Reached Enable                                 */
      __IM  uint32 RF1FE      : 1;            /*!< [6..6] Rx FIFO 1 Watermark Reached Enable                                 */
      __IM  uint32 RF1LE      : 1;            /*!< [7..7] Rx FIFO 1 Message Lost Enable                                      */
      __IM  uint32 HPME       : 1;            /*!< [8..8] High Priority Message Enable                                       */
      __IM  uint32 TCE        : 1;            /*!< [9..9] Transmission Completed Enable                                      */
      __IM  uint32 TCFE       : 1;            /*!< [10..10] Transmission Cancellation Finished Enable                        */
      __IM  uint32 TEFE       : 1;            /*!< [11..11] Tx FIFO Empty Enable                                             */
      __IM  uint32 TEFNE      : 1;            /*!< [12..12] Tx Event FIFO New Entry Enable                                   */
      __IM  uint32 TEFWE      : 1;            /*!< [13..13] Tx Event FIFO Watermark Reached Enable                           */
      __IM  uint32 TEFFE      : 1;            /*!< [14..14] Tx Event FIFO Full Enable                                        */
      __IM  uint32 TEFLE      : 1;            /*!< [15..15] Tx Event FIFO Element Lost Enable                                */
      __IM  uint32 TSWE       : 1;            /*!< [16..16] Timestamp Wraparound Enable                                      */
      __IM  uint32 MRAFE      : 1;            /*!< [17..17] Message RAM Access Failure Enable                                */
      __IM  uint32 TOOE       : 1;            /*!< [18..18] Timeout Occurred Enable                                          */
      __IM  uint32 DRXE       : 1;            /*!< [19..19] Message stored to Dedicated Rx Buffer Enable                     */
      __IM  uint32 BECE       : 1;            /*!< [20..20] Bit Error Corrected Interrupt Enable                             */
      __IM  uint32 BEUE       : 1;            /*!< [21..21] Bit Error Uncorrected Interrupt Enable                           */
      __IM  uint32 ELOE       : 1;            /*!< [22..22] Error Logging Overflow Enable                                    */
      __IM  uint32 EPE        : 1;            /*!< [23..23] Error Passive Enable                                             */
      __IM  uint32 EWE        : 1;            /*!< [24..24] Warning Status Enable                                            */
      __IM  uint32 BOE        : 1;            /*!< [25..25] Bus_Off Status Enable                                            */
      __IM  uint32 WDIE       : 1;            /*!< [26..26] Watchdog Interrupt Enable                                        */
      __IM  uint32 PEAE       : 1;            /*!< [27..27] Protocol Error in Arbitration Phase Enable                       */
      __IM  uint32 PEDE       : 1;            /*!< [28..28] Protocol Error in Data Phase Enable                              */
      __IM  uint32 ARAE       : 1;            /*!< [29..29] Access to Reserved Address Enable                                */
            uint32            : 2;
    } bit;
  } FDCAN_IE;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000058) FDCAN Interrupt Line Select Register                       */
    
    struct {
      __IM  uint32 RF0NL      : 1;            /*!< [0..0] Rx FIFO 0 New Message Interrupt Line                               */
      __IM  uint32 RF0WL      : 1;            /*!< [1..1] Rx FIFO 0 Watermark Reached Interrupt Line                         */
      __IM  uint32 RF0FL      : 1;            /*!< [2..2] Rx FIFO 0 Full Interrupt Line                                      */
      __IM  uint32 RF0LL      : 1;            /*!< [3..3] Rx FIFO 0 Message Lost Interrupt Line                              */
      __IM  uint32 RF1NL      : 1;            /*!< [4..4] Rx FIFO 1 New Message Interrupt Line                               */
      __IM  uint32 RF1WL      : 1;            /*!< [5..5] Rx FIFO 1 Watermark Reached Interrupt Line                         */
      __IM  uint32 RF1FL      : 1;            /*!< [6..6] Rx FIFO 1 Full Interrupt Line                                      */
      __IM  uint32 RF1LL      : 1;            /*!< [7..7] Rx FIFO 1 Message Lost Interrupt Line                              */
      __IM  uint32 HPML       : 1;            /*!< [8..8] High Priority Message Interrupt Line                               */
      __IM  uint32 TCL        : 1;            /*!< [9..9] Transmission Completed Interrupt Line                              */
      __IM  uint32 TCFL       : 1;            /*!< [10..10] Transmission Cancellation Finished Interrupt Line                */
      __IM  uint32 TEFL       : 1;            /*!< [11..11] Tx FIFO Empty Interrupt Line                                     */
      __IM  uint32 TEFNL      : 1;            /*!< [12..12] Tx Event FIFO New Entry Interrupt Line                           */
      __IM  uint32 TEFWL      : 1;            /*!< [13..13] Tx Event FIFO Watermark Reached Interrupt Line                   */
      __IM  uint32 TEFFL      : 1;            /*!< [14..14] Tx Event FIFO Full Interrupt Line                                */
      __IM  uint32 TEFLL      : 1;            /*!< [15..15] Tx Event FIFO Element Lost Interrupt Line                        */
      __IM  uint32 TSWL       : 1;            /*!< [16..16] Timestamp Wraparound Interrupt Line                              */
      __IM  uint32 MRAFL      : 1;            /*!< [17..17] Message RAM Access Failure Interrupt Line                        */
      __IM  uint32 TOOL       : 1;            /*!< [18..18] Timeout Occurred Interrupt Line                                  */
      __IM  uint32 DRXL       : 1;            /*!< [19..19] Message stored to Dedicated Rx Buffer Interrupt Line             */
      __IM  uint32 BECL       : 1;            /*!< [20..20] Bit Error Corrected Interrupt Line                               */
      __IM  uint32 BEUL       : 1;            /*!< [21..21] Bit Error Uncorrected Interrupt Line                             */
      __IM  uint32 ELOL       : 1;            /*!< [22..22] Error Logging Overflow Interrupt Line                            */
      __IM  uint32 EPL        : 1;            /*!< [23..23] Error Passive Interrupt Line                                     */
      __IM  uint32 EWL        : 1;            /*!< [24..24] Warning Status Interrupt Line                                    */
      __IM  uint32 BOL        : 1;            /*!< [25..25] Bus_Off Status                                                   */
      __IM  uint32 WDIL       : 1;            /*!< [26..26] Watchdog Interrupt Line                                          */
      __IM  uint32 PEAL       : 1;            /*!< [27..27] Protocol Error in Arbitration Phase Line                         */
      __IM  uint32 PEDL       : 1;            /*!< [28..28] Protocol Error in Data Phase Line                                */
      __IM  uint32 ARAL       : 1;            /*!< [29..29] Access to Reserved Address Line                                  */
            uint32            : 2;
    } bit;
  } FDCAN_ILS;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000005C) FDCAN Interrupt Line Enable Register                       */
    
    struct {
      __IOM uint32 EINT0      : 1;            /*!< [0..0] Enable Interrupt Line 0                                            */
      __IOM uint32 EINT1      : 1;            /*!< [1..1] Enable Interrupt Line 1                                            */
            uint32            : 30;
    } bit;
  } FDCAN_ILE;
  __IM  uint32  RESERVED3[8];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000080) FDCAN Global Filter Configuration Register                 */
    
    struct {
      __IOM uint32 RRFE       : 1;            /*!< [0..0] Reject Remote Frames Extended                                      */
      __IOM uint32 RRFS       : 1;            /*!< [1..1] Reject Remote Frames Standard                                      */
      __IOM uint32 ANFE       : 2;            /*!< [3..2] Accept Non-matching Frames Extended                                */
      __IOM uint32 ANFS       : 2;            /*!< [5..4] Accept Non-matching Frames Standard                                */
            uint32            : 26;
    } bit;
  } FDCAN_GFC;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000084) FDCAN Standard ID Filter Configuration Register            */
    
    struct {
            uint32            : 2;
      __IOM uint32 FLSSA      : 14;           /*!< [15..2] Filter List Standard Start Address                                */
      __IOM uint32 LSS        : 8;            /*!< [23..16] List Size Standard                                               */
            uint32            : 8;
    } bit;
  } FDCAN_SIDFC;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000088) FDCAN Extended ID Filter Configuration Register            */
    
    struct {
            uint32            : 2;
      __IOM uint32 FLESA      : 14;           /*!< [15..2] Filter List Standard Start Address                                */
      __IOM uint32 LSE        : 8;            /*!< [23..16] List Size Extended                                               */
            uint32            : 8;
    } bit;
  } FDCAN_XIDFC;
  __IM  uint32  RESERVED4;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000090) FDCAN Extended ID and Mask Register                        */
    
    struct {
      __IOM uint32 EIDM       : 29;           /*!< [28..0] Extended ID Mask                                                  */
            uint32            : 3;
    } bit;
  } FDCAN_XIDAM;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000094) FDCAN High Priority Message Status Register                */
    
    struct {
      __IM  uint32 BIDX       : 6;            /*!< [5..0] Buffer Index                                                       */
      __IM  uint32 MSI        : 2;            /*!< [7..6] Message Storage Indicator                                          */
      __IM  uint32 FIDX       : 7;            /*!< [14..8] Filter Index                                                      */
      __IM  uint32 FLST       : 1;            /*!< [15..15] Filter List                                                      */
            uint32            : 16;
    } bit;
  } FDCAN_HPMS;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000098) FDCAN New Data 1 Register                                  */
    
    struct {
      __IM  uint32 ND0        : 1;            /*!< [0..0] New data                                                           */
      __IM  uint32 ND1        : 1;            /*!< [1..1] New data                                                           */
      __IM  uint32 ND2        : 1;            /*!< [2..2] New data                                                           */
      __IM  uint32 ND3        : 1;            /*!< [3..3] New data                                                           */
      __IM  uint32 ND4        : 1;            /*!< [4..4] New data                                                           */
      __IM  uint32 ND5        : 1;            /*!< [5..5] New data                                                           */
      __IM  uint32 ND6        : 1;            /*!< [6..6] New data                                                           */
      __IM  uint32 ND7        : 1;            /*!< [7..7] New data                                                           */
      __IM  uint32 ND8        : 1;            /*!< [8..8] New data                                                           */
      __IM  uint32 ND9        : 1;            /*!< [9..9] New data                                                           */
      __IM  uint32 ND10       : 1;            /*!< [10..10] New data                                                         */
      __IM  uint32 ND11       : 1;            /*!< [11..11] New data                                                         */
      __IM  uint32 ND12       : 1;            /*!< [12..12] New data                                                         */
      __IM  uint32 ND13       : 1;            /*!< [13..13] New data                                                         */
      __IM  uint32 ND14       : 1;            /*!< [14..14] New data                                                         */
      __IM  uint32 ND15       : 1;            /*!< [15..15] New data                                                         */
      __IM  uint32 ND16       : 1;            /*!< [16..16] New data                                                         */
      __IM  uint32 ND17       : 1;            /*!< [17..17] New data                                                         */
      __IM  uint32 ND18       : 1;            /*!< [18..18] New data                                                         */
      __IM  uint32 ND19       : 1;            /*!< [19..19] New data                                                         */
      __IM  uint32 ND20       : 1;            /*!< [20..20] New data                                                         */
      __IM  uint32 ND21       : 1;            /*!< [21..21] New data                                                         */
      __IM  uint32 ND22       : 1;            /*!< [22..22] New data                                                         */
      __IM  uint32 ND23       : 1;            /*!< [23..23] New data                                                         */
      __IM  uint32 ND24       : 1;            /*!< [24..24] New data                                                         */
      __IM  uint32 ND25       : 1;            /*!< [25..25] New data                                                         */
      __IM  uint32 ND26       : 1;            /*!< [26..26] New data                                                         */
      __IM  uint32 ND27       : 1;            /*!< [27..27] New data                                                         */
      __IM  uint32 ND28       : 1;            /*!< [28..28] New data                                                         */
      __IM  uint32 ND29       : 1;            /*!< [29..29] New data                                                         */
      __IM  uint32 ND30       : 1;            /*!< [30..30] New data                                                         */
      __IM  uint32 ND31       : 1;            /*!< [31..31] New data                                                         */
    } bit;
  } FDCAN_NDAT1;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000009C) FDCAN New Data 2 Register                                  */
    
    struct {
      __IM  uint32 ND32       : 1;            /*!< [0..0] New data                                                           */
      __IM  uint32 ND33       : 1;            /*!< [1..1] New data                                                           */
      __IM  uint32 ND34       : 1;            /*!< [2..2] New data                                                           */
      __IM  uint32 ND35       : 1;            /*!< [3..3] New data                                                           */
      __IM  uint32 ND36       : 1;            /*!< [4..4] New data                                                           */
      __IM  uint32 ND37       : 1;            /*!< [5..5] New data                                                           */
      __IM  uint32 ND38       : 1;            /*!< [6..6] New data                                                           */
      __IM  uint32 ND39       : 1;            /*!< [7..7] New data                                                           */
      __IM  uint32 ND40       : 1;            /*!< [8..8] New data                                                           */
      __IM  uint32 ND41       : 1;            /*!< [9..9] New data                                                           */
      __IM  uint32 ND42       : 1;            /*!< [10..10] New data                                                         */
      __IM  uint32 ND43       : 1;            /*!< [11..11] New data                                                         */
      __IM  uint32 ND44       : 1;            /*!< [12..12] New data                                                         */
      __IM  uint32 ND45       : 1;            /*!< [13..13] New data                                                         */
      __IM  uint32 ND46       : 1;            /*!< [14..14] New data                                                         */
      __IM  uint32 ND47       : 1;            /*!< [15..15] New data                                                         */
      __IM  uint32 ND48       : 1;            /*!< [16..16] New data                                                         */
      __IM  uint32 ND49       : 1;            /*!< [17..17] New data                                                         */
      __IM  uint32 ND50       : 1;            /*!< [18..18] New data                                                         */
      __IM  uint32 ND51       : 1;            /*!< [19..19] New data                                                         */
      __IM  uint32 ND52       : 1;            /*!< [20..20] New data                                                         */
      __IM  uint32 ND53       : 1;            /*!< [21..21] New data                                                         */
      __IM  uint32 ND54       : 1;            /*!< [22..22] New data                                                         */
      __IM  uint32 ND55       : 1;            /*!< [23..23] New data                                                         */
      __IM  uint32 ND56       : 1;            /*!< [24..24] New data                                                         */
      __IM  uint32 ND57       : 1;            /*!< [25..25] New data                                                         */
      __IM  uint32 ND58       : 1;            /*!< [26..26] New data                                                         */
      __IM  uint32 ND59       : 1;            /*!< [27..27] New data                                                         */
      __IM  uint32 ND60       : 1;            /*!< [28..28] New data                                                         */
      __IM  uint32 ND61       : 1;            /*!< [29..29] New data                                                         */
      __IM  uint32 ND62       : 1;            /*!< [30..30] New data                                                         */
      __IM  uint32 ND63       : 1;            /*!< [31..31] New data                                                         */
    } bit;
  } FDCAN_NDAT2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000A0) FDCAN Rx FIFO 0 Configuration Register                     */
    
    struct {
            uint32            : 2;
      __IOM uint32 F0SA       : 14;           /*!< [15..2] Rx FIFO 0 Start Address                                           */
      __IOM uint32 F0S        : 8;            /*!< [23..16] Rx FIFO 0 Size                                                   */
      __IOM uint32 F0WM       : 8;            /*!< [31..24] FIFO 0 Watermark                                                 */
    } bit;
  } FDCAN_RXF0C;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000A4) FDCAN Rx FIFO 0 Status Register                            */
    
    struct {
      __IOM uint32 F0FL       : 7;            /*!< [6..0] Rx FIFO 0 Fill Level                                               */
            uint32            : 1;
      __IOM uint32 F0G        : 6;            /*!< [13..8] Rx FIFO 0 Get Index                                               */
            uint32            : 2;
      __IOM uint32 F0P        : 6;            /*!< [21..16] Rx FIFO 0 Put Index                                              */
            uint32            : 2;
      __IOM uint32 F0F        : 1;            /*!< [24..24] Rx FIFO 0 Full                                                   */
      __IOM uint32 RF0L       : 1;            /*!< [25..25] Rx FIFO 0 Message Lost                                           */
            uint32            : 6;
    } bit;
  } FDCAN_RXF0S;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000A8) CAN Rx FIFO 0 Acknowledge Register                         */
    
    struct {
      __IOM uint32 FA01       : 6;            /*!< [5..0] Rx FIFO 0 Acknowledge Index                                        */
            uint32            : 26;
    } bit;
  } FDCAN_RXF0A;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000AC) FDCAN Rx Buffer Configuration Register                     */
    
    struct {
            uint32            : 2;
      __IOM uint32 RBSA       : 14;           /*!< [15..2] Rx Buffer Start Address                                           */
            uint32            : 16;
    } bit;
  } FDCAN_RXBC;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000B0) FDCAN Rx FIFO 1 Configuration Register                     */
    
    struct {
            uint32            : 2;
      __IOM uint32 F1SA       : 14;           /*!< [15..2] Rx FIFO 1 Start Address                                           */
      __IOM uint32 F1S        : 7;            /*!< [22..16] Rx FIFO 1 Size                                                   */
            uint32            : 1;
      __IOM uint32 F1WM       : 7;            /*!< [30..24] Rx FIFO 1 Watermark                                              */
            uint32            : 1;
    } bit;
  } FDCAN_RXF1C;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000B4) FDCAN Rx FIFO 1 Status Register                            */
    
    struct {
      __IOM uint32 F1FL       : 7;            /*!< [6..0] Rx FIFO 1 Fill Level                                               */
            uint32            : 1;
      __IOM uint32 F1GI       : 7;            /*!< [14..8] Rx FIFO 1 Get Index                                               */
            uint32            : 1;
      __IOM uint32 F1PI       : 7;            /*!< [22..16] Rx FIFO 1 Put Index                                              */
            uint32            : 1;
      __IOM uint32 F1F        : 1;            /*!< [24..24] Rx FIFO 1 Full                                                   */
      __IOM uint32 RF1L       : 1;            /*!< [25..25] Rx FIFO 1 Message Lost                                           */
            uint32            : 4;
      __IOM uint32 DMS        : 2;            /*!< [31..30] Debug Message Status                                             */
    } bit;
  } FDCAN_RXF1S;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000B8) FDCAN Rx FIFO 1 Acknowledge Register                       */
    
    struct {
      __IOM uint32 F1AI       : 6;            /*!< [5..0] Rx FIFO 1 Acknowledge Index                                        */
            uint32            : 26;
    } bit;
  } FDCAN_RXF1A;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000BC) FDCAN Rx Buffer Element Size Configuration Register        */
    
    struct {
      __IOM uint32 F0DS       : 3;            /*!< [2..0] Rx FIFO 1 Data Field Size:                                         */
            uint32            : 1;
      __IOM uint32 F1DS       : 3;            /*!< [6..4] Rx FIFO 0 Data Field Size:                                         */
            uint32            : 1;
      __IOM uint32 RBDS       : 3;            /*!< [10..8] Rx Buffer Data Field Size:                                        */
            uint32            : 21;
    } bit;
  } FDCAN_RXESC;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000C0) FDCAN Tx Buffer Configuration Register                     */
    
    struct {
            uint32            : 2;
      __IOM uint32 TBSA       : 14;           /*!< [15..2] Tx Buffers Start Address                                          */
      __IOM uint32 NDTB       : 6;            /*!< [21..16] Number of Dedicated Transmit Buffers                             */
            uint32            : 2;
      __IOM uint32 TFQS       : 6;            /*!< [29..24] Transmit FIFO/Queue Size                                         */
      __IOM uint32 TFQM       : 1;            /*!< [30..30] Tx FIFO/Queue Mode                                               */
            uint32            : 1;
    } bit;
  } FDCAN_TXBC;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000000C4) FDCAN Tx FIFO/Queue Status Register                        */
    
    struct {
      __IM  uint32 TFFL       : 6;            /*!< [5..0] Tx FIFO Free Level                                                 */
            uint32            : 2;
      __IM  uint32 TFGI       : 5;            /*!< [12..8] TFGI                                                              */
            uint32            : 3;
      __IM  uint32 TFQPI      : 5;            /*!< [20..16] Tx FIFO/Queue Put Index                                          */
      __IM  uint32 TFQF       : 1;            /*!< [21..21] Tx FIFO/Queue Full                                               */
            uint32            : 10;
    } bit;
  } FDCAN_TXFQS;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000C8) FDCAN Tx Buffer Element Size Configuration Register        */
    
    struct {
      __IOM uint32 TBDS       : 3;            /*!< [2..0] Tx Buffer Data Field Size:                                         */
            uint32            : 29;
    } bit;
  } FDCAN_TXESC;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000000CC) FDCAN Tx Buffer Request Pending Register                   */
    
    struct {
      __IM  uint32 TRP        : 32;           /*!< [31..0] Transmission Request Pending                                      */
    } bit;
  } FDCAN_TXBRP;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000D0) FDCAN Tx Buffer Add Request Register                       */
    
    struct {
      __IOM uint32 AR         : 32;           /*!< [31..0] Add Request                                                       */
    } bit;
  } FDCAN_TXBAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000D4) FDCAN Tx Buffer Cancellation Request Register              */
    
    struct {
      __IOM uint32 CR         : 32;           /*!< [31..0] Cancellation Request                                              */
    } bit;
  } FDCAN_TXBCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000D8) FDCAN Tx Buffer Transmission Occurred Register             */
    
    struct {
      __IOM uint32 TO         : 32;           /*!< [31..0] Transmission Occurred.                                            */
    } bit;
  } FDCAN_TXBTO;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x000000DC) FDCAN Tx Buffer Cancellation Finished Register             */
    
    struct {
      __IM  uint32 CF         : 32;           /*!< [31..0] Cancellation Finished                                             */
    } bit;
  } FDCAN_TXBCF;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000E0) FDCAN Tx Buffer Transmission Interrupt Enable
                                                                    Register                                                   */
    
    struct {
      __IOM uint32 TIE        : 32;           /*!< [31..0] Transmission Interrupt Enable                                     */
    } bit;
  } FDCAN_TXBTIE;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000E4) FDCAN Tx Buffer Cancellation Finished Interrupt
                                                                    Enable Register                                            */
    
    struct {
      __IOM uint32 CF         : 32;           /*!< [31..0] Cancellation Finished Interrupt Enable                            */
    } bit;
  } FDCAN_TXBCIE;
  __IM  uint32  RESERVED5[2];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000F0) FDCAN Tx Event FIFO Configuration Register                 */
    
    struct {
            uint32            : 2;
      __IOM uint32 EFSA       : 14;           /*!< [15..2] Event FIFO Start Address                                          */
      __IOM uint32 EFS        : 6;            /*!< [21..16] Event FIFO Size                                                  */
            uint32            : 2;
      __IOM uint32 EFWM       : 6;            /*!< [29..24] Event FIFO Watermark                                             */
            uint32            : 2;
    } bit;
  } FDCAN_TXEFC;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000F4) FDCAN Tx Event FIFO Status Register                        */
    
    struct {
      __IOM uint32 EFFL       : 6;            /*!< [5..0] Event FIFO Fill Level                                              */
            uint32            : 2;
      __IOM uint32 EFGI       : 5;            /*!< [12..8] Event FIFO Get Index.                                             */
            uint32            : 11;
      __IOM uint32 EFF        : 1;            /*!< [24..24] Event FIFO Full.                                                 */
      __IOM uint32 TEFL       : 1;            /*!< [25..25] Tx Event FIFO Element Lost.                                      */
            uint32            : 6;
    } bit;
  } FDCAN_TXEFS;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000F8) FDCAN Tx Event FIFO Acknowledge Register                   */
    
    struct {
      __IOM uint32 EFAI       : 5;            /*!< [4..0] Event FIFO Acknowledge Index                                       */
            uint32            : 27;
    } bit;
  } FDCAN_TXEFA;
  __IM  uint32  RESERVED6;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000100) FDCAN TT Trigger Memory Configuration Register             */
    
    struct {
            uint32            : 2;
      __IOM uint32 TMSA       : 14;           /*!< [15..2] Trigger Memory Start Address                                      */
      __IOM uint32 TME        : 7;            /*!< [22..16] Trigger Memory Elements                                          */
            uint32            : 9;
    } bit;
  } FDCAN_TTTMC;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000104) FDCAN TT Reference Message Configuration Register          */
    
    struct {
      __IOM uint32 RID        : 29;           /*!< [28..0] Reference Identifier.                                             */
            uint32            : 1;
      __IOM uint32 XTD        : 1;            /*!< [30..30] Extended Identifier                                              */
      __IOM uint32 RMPS       : 1;            /*!< [31..31] Reference Message Payload Select                                 */
    } bit;
  } FDCAN_TTRMC;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000108) FDCAN TT Operation Configuration Register                  */
    
    struct {
      __IOM uint32 OM         : 2;            /*!< [1..0] Operation Mode                                                     */
            uint32            : 1;
      __IOM uint32 GEN        : 1;            /*!< [3..3] Gap Enable                                                         */
      __IOM uint32 TM         : 1;            /*!< [4..4] Time Master                                                        */
      __IOM uint32 LDSDL      : 3;            /*!< [7..5] LD of Synchronization Deviation Limit                              */
      __IOM uint32 IRTO       : 7;            /*!< [14..8] Initial Reference Trigger Offset                                  */
      __IOM uint32 EECS       : 1;            /*!< [15..15] Enable External Clock Synchronization                            */
      __IOM uint32 AWL        : 8;            /*!< [23..16] Application Watchdog Limit                                       */
      __IOM uint32 EGTF       : 1;            /*!< [24..24] Enable Global Time Filtering                                     */
      __IOM uint32 ECC        : 1;            /*!< [25..25] Enable Clock Calibration                                         */
      __IOM uint32 EVTP       : 1;            /*!< [26..26] Event Trigger Polarity                                           */
            uint32            : 5;
    } bit;
  } FDCAN_TTOCF;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000010C) FDCAN TT Matrix Limits Register                            */
    
    struct {
      __IOM uint32 CCM        : 6;            /*!< [5..0] Cycle Count Max                                                    */
      __IOM uint32 CSS        : 2;            /*!< [7..6] Cycle Start Synchronization                                        */
      __IOM uint32 TXEW       : 4;            /*!< [11..8] Tx Enable Window                                                  */
            uint32            : 4;
      __IOM uint32 ENTT       : 12;           /*!< [27..16] Expected Number of Tx Triggers                                   */
            uint32            : 4;
    } bit;
  } FDCAN_TTMLM;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000110) FDCAN TUR Configuration Register                           */
    
    struct {
      __IOM uint32 NCL        : 16;           /*!< [15..0] Numerator Configuration Low.                                      */
      __IOM uint32 DC         : 14;           /*!< [29..16] Denominator Configuration.                                       */
            uint32            : 1;
      __IOM uint32 ELT        : 1;            /*!< [31..31] Enable Local Time                                                */
    } bit;
  } FDCAN_TURCF;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000114) FDCAN TT Operation Control Register                        */
    
    struct {
      __IOM uint32 SGT        : 1;            /*!< [0..0] Set Global time                                                    */
      __IOM uint32 ECS        : 1;            /*!< [1..1] External Clock Synchronization                                     */
      __IOM uint32 SWP        : 1;            /*!< [2..2] Stop Watch Polarity                                                */
      __IOM uint32 SWS        : 2;            /*!< [4..3] Stop Watch Source.                                                 */
      __IOM uint32 RTIE       : 1;            /*!< [5..5] Register Time Mark Interrupt Pulse Enable                          */
      __IOM uint32 TMC        : 2;            /*!< [7..6] Register Time Mark Compare                                         */
      __IOM uint32 TTIE       : 1;            /*!< [8..8] Trigger Time Mark Interrupt Pulse Enable                           */
      __IOM uint32 GCS        : 1;            /*!< [9..9] Gap Control Select                                                 */
      __IOM uint32 FGP        : 1;            /*!< [10..10] Finish Gap.                                                      */
      __IOM uint32 TMG        : 1;            /*!< [11..11] Time Mark Gap                                                    */
      __IOM uint32 NIG        : 1;            /*!< [12..12] Next is Gap                                                      */
      __IOM uint32 ESCN       : 1;            /*!< [13..13] External Synchronization Control                                 */
            uint32            : 1;
      __IOM uint32 LCKC       : 1;            /*!< [15..15] TT Operation Control Register Locked                             */
            uint32            : 16;
    } bit;
  } FDCAN_TTOCN;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000118) FDCAN TT Global Time Preset Register                       */
    
    struct {
      __IOM uint32 NCL        : 16;           /*!< [15..0] Time Preset                                                       */
      __IOM uint32 CTP        : 16;           /*!< [31..16] Cycle Time Target Phase                                          */
    } bit;
  } CAN_TTGTP;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000011C) FDCAN TT Time Mark Register                                */
    
    struct {
      __IOM uint32 TM         : 16;           /*!< [15..0] Time Mark                                                         */
      __IOM uint32 TICC       : 7;            /*!< [22..16] Time Mark Cycle Code                                             */
            uint32            : 8;
      __IOM uint32 LCKM       : 1;            /*!< [31..31] TT Time Mark Register Locked                                     */
    } bit;
  } FDCAN_TTTMK;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000120) FDCAN TT Interrupt Register                                */
    
    struct {
      __IOM uint32 SBC        : 1;            /*!< [0..0] Start of Basic Cycle                                               */
      __IOM uint32 SMC        : 1;            /*!< [1..1] Start of Matrix Cycle                                              */
      __IOM uint32 CSM        : 1;            /*!< [2..2] Change of Synchronization Mode                                     */
      __IOM uint32 SOG        : 1;            /*!< [3..3] Start of Gap                                                       */
      __IOM uint32 RTMI       : 1;            /*!< [4..4] Register Time Mark Interrupt.                                      */
      __IOM uint32 TTMI       : 1;            /*!< [5..5] Trigger Time Mark Event Internal                                   */
      __IOM uint32 SWE        : 1;            /*!< [6..6] Stop Watch Event                                                   */
      __IOM uint32 GTW        : 1;            /*!< [7..7] Global Time Wrap                                                   */
      __IOM uint32 GTD        : 1;            /*!< [8..8] Global Time Discontinuity                                          */
      __IOM uint32 GTE        : 1;            /*!< [9..9] Global Time Error                                                  */
      __IOM uint32 TXU        : 1;            /*!< [10..10] Tx Count Underflow                                               */
      __IOM uint32 TXO        : 1;            /*!< [11..11] Tx Count Overflow                                                */
      __IOM uint32 SE1        : 1;            /*!< [12..12] Scheduling Error 1                                               */
      __IOM uint32 SE2        : 1;            /*!< [13..13] Scheduling Error 2                                               */
      __IOM uint32 ELC        : 1;            /*!< [14..14] Error Level Changed.                                             */
      __IOM uint32 IWTG       : 1;            /*!< [15..15] Initialization Watch Trigger                                     */
      __IOM uint32 WT         : 1;            /*!< [16..16] Watch Trigger                                                    */
      __IOM uint32 AW         : 1;            /*!< [17..17] Application Watchdog                                             */
      __IOM uint32 CER        : 1;            /*!< [18..18] Configuration Error                                              */
            uint32            : 13;
    } bit;
  } FDCAN_TTIR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000124) FDCAN TT Interrupt Enable Register                         */
    
    struct {
      __IOM uint32 SBCE       : 1;            /*!< [0..0] Start of Basic Cycle Interrupt Enable                              */
      __IOM uint32 SMCE       : 1;            /*!< [1..1] Start of Matrix Cycle Interrupt Enable                             */
      __IOM uint32 CSME       : 1;            /*!< [2..2] Change of Synchronization Mode Interrupt Enable                    */
      __IOM uint32 SOGE       : 1;            /*!< [3..3] Start of Gap Interrupt Enable                                      */
      __IOM uint32 RTMIE      : 1;            /*!< [4..4] Register Time Mark Interrupt Enable                                */
      __IOM uint32 TTMIE      : 1;            /*!< [5..5] Trigger Time Mark Event Internal Interrupt Enable                  */
      __IOM uint32 SWEE       : 1;            /*!< [6..6] Stop Watch Event Interrupt Enable                                  */
      __IOM uint32 GTWE       : 1;            /*!< [7..7] Global Time Wrap Interrupt Enable                                  */
      __IOM uint32 GTDE       : 1;            /*!< [8..8] Global Time Discontinuity Interrupt Enable                         */
      __IOM uint32 GTEE       : 1;            /*!< [9..9] Global Time Error Interrupt Enable                                 */
      __IOM uint32 TXUE       : 1;            /*!< [10..10] Tx Count Underflow Interrupt Enable                              */
      __IOM uint32 TXOE       : 1;            /*!< [11..11] Tx Count Overflow Interrupt Enable                               */
      __IOM uint32 SE1E       : 1;            /*!< [12..12] Scheduling Error 1 Interrupt Enable                              */
      __IOM uint32 SE2E       : 1;            /*!< [13..13] Scheduling Error 2 Interrupt Enable                              */
      __IOM uint32 ELCE       : 1;            /*!< [14..14] Change Error Level Interrupt Enable                              */
      __IOM uint32 IWTGE      : 1;            /*!< [15..15] Initialization Watch Trigger Interrupt Enable                    */
      __IOM uint32 WTE        : 1;            /*!< [16..16] Watch Trigger Interrupt Enable                                   */
      __IOM uint32 AWE        : 1;            /*!< [17..17] Application Watchdog Interrupt Enable                            */
      __IOM uint32 CERE       : 1;            /*!< [18..18] Configuration Error Interrupt Enable                             */
            uint32            : 13;
    } bit;
  } FDCAN_TTIE;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000128) FDCAN TT Interrupt Line Select Register                    */
    
    struct {
      __IOM uint32 SBCL       : 1;            /*!< [0..0] Start of Basic Cycle Interrupt Line                                */
      __IOM uint32 SMCL       : 1;            /*!< [1..1] Start of Matrix Cycle Interrupt Line                               */
      __IOM uint32 CSML       : 1;            /*!< [2..2] Change of Synchronization Mode Interrupt Line                      */
      __IOM uint32 SOGL       : 1;            /*!< [3..3] Start of Gap Interrupt Line                                        */
      __IOM uint32 RTMIL      : 1;            /*!< [4..4] Register Time Mark Interrupt Line                                  */
      __IOM uint32 TTMIL      : 1;            /*!< [5..5] Trigger Time Mark Event Internal Interrupt Line                    */
      __IOM uint32 SWEL       : 1;            /*!< [6..6] Stop Watch Event Interrupt Line                                    */
      __IOM uint32 GTWL       : 1;            /*!< [7..7] Global Time Wrap Interrupt Line                                    */
      __IOM uint32 GTDL       : 1;            /*!< [8..8] Global Time Discontinuity Interrupt Line                           */
      __IOM uint32 GTEL       : 1;            /*!< [9..9] Global Time Error Interrupt Line                                   */
      __IOM uint32 TXUL       : 1;            /*!< [10..10] Tx Count Underflow Interrupt Line                                */
      __IOM uint32 TXOL       : 1;            /*!< [11..11] Tx Count Overflow Interrupt Line                                 */
      __IOM uint32 SE1L       : 1;            /*!< [12..12] Scheduling Error 1 Interrupt Line                                */
      __IOM uint32 SE2L       : 1;            /*!< [13..13] Scheduling Error 2 Interrupt Line                                */
      __IOM uint32 ELCL       : 1;            /*!< [14..14] Change Error Level Interrupt Line                                */
      __IOM uint32 IWTGL      : 1;            /*!< [15..15] Initialization Watch Trigger Interrupt Line                      */
      __IOM uint32 WTL        : 1;            /*!< [16..16] Watch Trigger Interrupt Line                                     */
      __IOM uint32 AWL        : 1;            /*!< [17..17] Application Watchdog Interrupt Line                              */
      __IOM uint32 CERL       : 1;            /*!< [18..18] Configuration Error Interrupt Line                               */
            uint32            : 13;
    } bit;
  } FDCAN_TTILS;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000012C) FDCAN TT Operation Status Register                         */
    
    struct {
      __IOM uint32 EL         : 2;            /*!< [1..0] Error Level                                                        */
      __IOM uint32 MS         : 2;            /*!< [3..2] Master State.                                                      */
      __IOM uint32 SYS        : 2;            /*!< [5..4] Synchronization State                                              */
      __IOM uint32 GTP        : 1;            /*!< [6..6] Quality of Global Time Phase                                       */
      __IOM uint32 QCS        : 1;            /*!< [7..7] Quality of Clock Speed                                             */
      __IOM uint32 RTO        : 8;            /*!< [15..8] Reference Trigger Offset                                          */
            uint32            : 6;
      __IOM uint32 WGTD       : 1;            /*!< [22..22] Wait for Global Time Discontinuity                               */
      __IOM uint32 GFI        : 1;            /*!< [23..23] Gap Finished Indicator.                                          */
      __IOM uint32 TMP        : 3;            /*!< [26..24] Time Master Priority                                             */
      __IOM uint32 GSI        : 1;            /*!< [27..27] Gap Started Indicator.                                           */
      __IOM uint32 WFE        : 1;            /*!< [28..28] Wait for Event                                                   */
      __IOM uint32 AWE        : 1;            /*!< [29..29] Application Watchdog Event                                       */
      __IOM uint32 WECS       : 1;            /*!< [30..30] Wait for External Clock Synchronization                          */
      __IOM uint32 SPL        : 1;            /*!< [31..31] Schedule Phase Lock                                              */
    } bit;
  } FDCAN_TTOST;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000130) FDCAN TUR Numerator Actual Register                        */
    
    struct {
      __IM  uint32 NAV        : 18;           /*!< [17..0] Numerator Actual Value                                            */
            uint32            : 14;
    } bit;
  } FDCAN_TURNA;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000134) FDCAN TT Local and Global Time Register                    */
    
    struct {
      __IM  uint32 LT         : 16;           /*!< [15..0] Local Time                                                        */
      __IM  uint32 GT         : 16;           /*!< [31..16] Global Time                                                      */
    } bit;
  } FDCAN_TTLGT;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000138) FDCAN TT Cycle Time and Count Register                     */
    
    struct {
      __IM  uint32 CT         : 16;           /*!< [15..0] Cycle Time                                                        */
      __IM  uint32 CC         : 6;            /*!< [21..16] Cycle Count                                                      */
            uint32            : 10;
    } bit;
  } FDCAN_TTCTC;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000013C) FDCAN TT Capture Time Register                             */
    
    struct {
      __IM  uint32 CT         : 6;            /*!< [5..0] Cycle Count Value                                                  */
            uint32            : 10;
      __IM  uint32 SWV        : 16;           /*!< [31..16] Stop Watch Value                                                 */
    } bit;
  } FDCAN_TTCPT;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000140) FDCAN TT Cycle Sync Mark Register                          */
    
    struct {
      __IM  uint32 CSM        : 16;           /*!< [15..0] Cycle Sync Mark                                                   */
            uint32            : 16;
    } bit;
  } FDCAN_TTCSM;
  __IM  uint32  RESERVED7[111];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000300) FDCAN TT Trigger Select Register                           */
    
    struct {
      __IOM uint32 SWTDEL     : 2;            /*!< [1..0] Stop watch trigger input selection                                 */
            uint32            : 2;
      __IOM uint32 EVTSEL     : 2;            /*!< [5..4] Event trigger input selection                                      */
            uint32            : 26;
    } bit;
  } FDCAN_TTTS;
} FDCAN1_Type;                                  /*!< Size = 772 (0x304)                                                        */



/* =========================================================================================================================== */
/* ================                                           MDIOS                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Management data input/output slave (MDIOS)
  */

typedef struct {                                /*!< (@ 0x40009400) MDIOS Structure                                            */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) MDIOS configuration register                               */
    
    struct {
      __IOM uint32 EN         : 1;            /*!< [0..0] Peripheral enable                                                  */
      __IOM uint32 WRIE       : 1;            /*!< [1..1] Register write interrupt enable                                    */
      __IOM uint32 RDIE       : 1;            /*!< [2..2] Register Read Interrupt Enable                                     */
      __IOM uint32 EIE        : 1;            /*!< [3..3] Error interrupt enable                                             */
            uint32            : 3;
      __IOM uint32 DPC        : 1;            /*!< [7..7] Disable Preamble Check                                             */
      __IOM uint32 PORT_ADDRESS : 5;          /*!< [12..8] Slaves's address                                                  */
            uint32            : 19;
    } bit;
  } MDIOS_CR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000004) MDIOS write flag register                                  */
    
    struct {
      __IM  uint32 WRF        : 32;           /*!< [31..0] Write flags for MDIO registers 0 to 31                            */
    } bit;
  } MDIOS_WRFR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) MDIOS clear write flag register                            */
    
    struct {
      __IOM uint32 CWRF       : 32;           /*!< [31..0] Clear the write flag                                              */
    } bit;
  } MDIOS_CWRFR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000000C) MDIOS read flag register                                   */
    
    struct {
      __IM  uint32 RDF        : 32;           /*!< [31..0] Read flags for MDIO registers 0 to 31                             */
    } bit;
  } MDIOS_RDFR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) MDIOS clear read flag register                             */
    
    struct {
      __IOM uint32 CRDF       : 32;           /*!< [31..0] Clear the read flag                                               */
    } bit;
  } MDIOS_CRDFR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000014) MDIOS status register                                      */
    
    struct {
      __IM  uint32 PERF       : 1;            /*!< [0..0] Preamble error flag                                                */
      __IM  uint32 SERF       : 1;            /*!< [1..1] Start error flag                                                   */
      __IM  uint32 TERF       : 1;            /*!< [2..2] Turnaround error flag                                              */
            uint32            : 29;
    } bit;
  } MDIOS_SR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000018) MDIOS clear flag register                                  */
    
    struct {
      __IOM uint32 CPERF      : 1;            /*!< [0..0] Clear the preamble error flag                                      */
      __IOM uint32 CSERF      : 1;            /*!< [1..1] Clear the start error flag                                         */
      __IOM uint32 CTERF      : 1;            /*!< [2..2] Clear the turnaround error flag                                    */
            uint32            : 29;
    } bit;
  } MDIOS_CLRFR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000001C) MDIOS input data register 0                                */
    
    struct {
      __IM  uint32 DIN0       : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32            : 16;
    } bit;
  } MDIOS_DINR0;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000020) MDIOS input data register 1                                */
    
    struct {
      __IM  uint32 DIN1       : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32            : 16;
    } bit;
  } MDIOS_DINR1;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000024) MDIOS input data register 2                                */
    
    struct {
      __IM  uint32 DIN2       : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32            : 16;
    } bit;
  } MDIOS_DINR2;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000028) MDIOS input data register 3                                */
    
    struct {
      __IM  uint32 DIN3       : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32            : 16;
    } bit;
  } MDIOS_DINR3;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000002C) MDIOS input data register 4                                */
    
    struct {
      __IM  uint32 DIN4       : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32            : 16;
    } bit;
  } MDIOS_DINR4;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000030) MDIOS input data register 5                                */
    
    struct {
      __IM  uint32 DIN5       : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32            : 16;
    } bit;
  } MDIOS_DINR5;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000034) MDIOS input data register 6                                */
    
    struct {
      __IM  uint32 DIN6       : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32            : 16;
    } bit;
  } MDIOS_DINR6;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000038) MDIOS input data register 7                                */
    
    struct {
      __IM  uint32 DIN7       : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32            : 16;
    } bit;
  } MDIOS_DINR7;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000003C) MDIOS input data register 8                                */
    
    struct {
      __IM  uint32 DIN8       : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32            : 16;
    } bit;
  } MDIOS_DINR8;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000040) MDIOS input data register 9                                */
    
    struct {
      __IM  uint32 DIN9       : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32            : 16;
    } bit;
  } MDIOS_DINR9;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000044) MDIOS input data register 10                               */
    
    struct {
      __IM  uint32 DIN10      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32            : 16;
    } bit;
  } MDIOS_DINR10;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000048) MDIOS input data register 11                               */
    
    struct {
      __IM  uint32 DIN11      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32            : 16;
    } bit;
  } MDIOS_DINR11;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000004C) MDIOS input data register 12                               */
    
    struct {
      __IM  uint32 DIN12      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32            : 16;
    } bit;
  } MDIOS_DINR12;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000050) MDIOS input data register 13                               */
    
    struct {
      __IM  uint32 DIN13      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32            : 16;
    } bit;
  } MDIOS_DINR13;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000054) MDIOS input data register 14                               */
    
    struct {
      __IM  uint32 DIN14      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32            : 16;
    } bit;
  } MDIOS_DINR14;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000058) MDIOS input data register 15                               */
    
    struct {
      __IM  uint32 DIN15      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32            : 16;
    } bit;
  } MDIOS_DINR15;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000005C) MDIOS input data register 16                               */
    
    struct {
      __IM  uint32 DIN16      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32            : 16;
    } bit;
  } MDIOS_DINR16;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000060) MDIOS input data register 17                               */
    
    struct {
      __IM  uint32 DIN17      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32            : 16;
    } bit;
  } MDIOS_DINR17;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000064) MDIOS input data register 18                               */
    
    struct {
      __IM  uint32 DIN18      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32            : 16;
    } bit;
  } MDIOS_DINR18;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000068) MDIOS input data register 19                               */
    
    struct {
      __IM  uint32 DIN19      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32            : 16;
    } bit;
  } MDIOS_DINR19;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000006C) MDIOS input data register 20                               */
    
    struct {
      __IM  uint32 DIN20      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32            : 16;
    } bit;
  } MDIOS_DINR20;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000070) MDIOS input data register 21                               */
    
    struct {
      __IM  uint32 DIN21      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32            : 16;
    } bit;
  } MDIOS_DINR21;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000074) MDIOS input data register 22                               */
    
    struct {
      __IM  uint32 DIN22      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32            : 16;
    } bit;
  } MDIOS_DINR22;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000078) MDIOS input data register 23                               */
    
    struct {
      __IM  uint32 DIN23      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32            : 16;
    } bit;
  } MDIOS_DINR23;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000007C) MDIOS input data register 24                               */
    
    struct {
      __IM  uint32 DIN24      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32            : 16;
    } bit;
  } MDIOS_DINR24;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000080) MDIOS input data register 25                               */
    
    struct {
      __IM  uint32 DIN25      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32            : 16;
    } bit;
  } MDIOS_DINR25;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000084) MDIOS input data register 26                               */
    
    struct {
      __IM  uint32 DIN26      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32            : 16;
    } bit;
  } MDIOS_DINR26;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000088) MDIOS input data register 27                               */
    
    struct {
      __IM  uint32 DIN27      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32            : 16;
    } bit;
  } MDIOS_DINR27;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000008C) MDIOS input data register 28                               */
    
    struct {
      __IM  uint32 DIN28      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32            : 16;
    } bit;
  } MDIOS_DINR28;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000090) MDIOS input data register 29                               */
    
    struct {
      __IM  uint32 DIN29      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32            : 16;
    } bit;
  } MDIOS_DINR29;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000094) MDIOS input data register 30                               */
    
    struct {
      __IM  uint32 DIN30      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32            : 16;
    } bit;
  } MDIOS_DINR30;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000098) MDIOS input data register 31                               */
    
    struct {
      __IM  uint32 DIN31      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32            : 16;
    } bit;
  } MDIOS_DINR31;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000009C) MDIOS output data register 0                               */
    
    struct {
      __IOM uint32 DOUT0      : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32            : 16;
    } bit;
  } MDIOS_DOUTR0;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000A0) MDIOS output data register 1                               */
    
    struct {
      __IOM uint32 DOUT1      : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32            : 16;
    } bit;
  } MDIOS_DOUTR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000A4) MDIOS output data register 2                               */
    
    struct {
      __IOM uint32 DOUT2      : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32            : 16;
    } bit;
  } MDIOS_DOUTR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000A8) MDIOS output data register 3                               */
    
    struct {
      __IOM uint32 DOUT3      : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32            : 16;
    } bit;
  } MDIOS_DOUTR3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000AC) MDIOS output data register 4                               */
    
    struct {
      __IOM uint32 DOUT4      : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32            : 16;
    } bit;
  } MDIOS_DOUTR4;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000B0) MDIOS output data register 5                               */
    
    struct {
      __IOM uint32 DOUT5      : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32            : 16;
    } bit;
  } MDIOS_DOUTR5;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000B4) MDIOS output data register 6                               */
    
    struct {
      __IOM uint32 DOUT6      : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32            : 16;
    } bit;
  } MDIOS_DOUTR6;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000B8) MDIOS output data register 7                               */
    
    struct {
      __IOM uint32 DOUT7      : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32            : 16;
    } bit;
  } MDIOS_DOUTR7;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000BC) MDIOS output data register 8                               */
    
    struct {
      __IOM uint32 DOUT8      : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32            : 16;
    } bit;
  } MDIOS_DOUTR8;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000C0) MDIOS output data register 9                               */
    
    struct {
      __IOM uint32 DOUT9      : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32            : 16;
    } bit;
  } MDIOS_DOUTR9;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000C4) MDIOS output data register 10                              */
    
    struct {
      __IOM uint32 DOUT10     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32            : 16;
    } bit;
  } MDIOS_DOUTR10;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000C8) MDIOS output data register 11                              */
    
    struct {
      __IOM uint32 DOUT11     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32            : 16;
    } bit;
  } MDIOS_DOUTR11;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000CC) MDIOS output data register 12                              */
    
    struct {
      __IOM uint32 DOUT12     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32            : 16;
    } bit;
  } MDIOS_DOUTR12;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000D0) MDIOS output data register 13                              */
    
    struct {
      __IOM uint32 DOUT13     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32            : 16;
    } bit;
  } MDIOS_DOUTR13;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000D4) MDIOS output data register 14                              */
    
    struct {
      __IOM uint32 DOUT14     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32            : 16;
    } bit;
  } MDIOS_DOUTR14;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000D8) MDIOS output data register 15                              */
    
    struct {
      __IOM uint32 DOUT15     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32            : 16;
    } bit;
  } MDIOS_DOUTR15;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000DC) MDIOS output data register 16                              */
    
    struct {
      __IOM uint32 DOUT16     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32            : 16;
    } bit;
  } MDIOS_DOUTR16;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000E0) MDIOS output data register 17                              */
    
    struct {
      __IOM uint32 DOUT17     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32            : 16;
    } bit;
  } MDIOS_DOUTR17;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000E4) MDIOS output data register 18                              */
    
    struct {
      __IOM uint32 DOUT18     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32            : 16;
    } bit;
  } MDIOS_DOUTR18;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000E8) MDIOS output data register 19                              */
    
    struct {
      __IOM uint32 DOUT19     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32            : 16;
    } bit;
  } MDIOS_DOUTR19;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000EC) MDIOS output data register 20                              */
    
    struct {
      __IOM uint32 DOUT20     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32            : 16;
    } bit;
  } MDIOS_DOUTR20;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000F0) MDIOS output data register 21                              */
    
    struct {
      __IOM uint32 DOUT21     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32            : 16;
    } bit;
  } MDIOS_DOUTR21;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000F4) MDIOS output data register 22                              */
    
    struct {
      __IOM uint32 DOUT22     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32            : 16;
    } bit;
  } MDIOS_DOUTR22;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000F8) MDIOS output data register 23                              */
    
    struct {
      __IOM uint32 DOUT23     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32            : 16;
    } bit;
  } MDIOS_DOUTR23;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x000000FC) MDIOS output data register 24                              */
    
    struct {
      __IOM uint32 DOUT24     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32            : 16;
    } bit;
  } MDIOS_DOUTR24;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000100) MDIOS output data register 25                              */
    
    struct {
      __IOM uint32 DOUT25     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32            : 16;
    } bit;
  } MDIOS_DOUTR25;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000104) MDIOS output data register 26                              */
    
    struct {
      __IOM uint32 DOUT26     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32            : 16;
    } bit;
  } MDIOS_DOUTR26;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000108) MDIOS output data register 27                              */
    
    struct {
      __IOM uint32 DOUT27     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32            : 16;
    } bit;
  } MDIOS_DOUTR27;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000010C) MDIOS output data register 28                              */
    
    struct {
      __IOM uint32 DOUT28     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32            : 16;
    } bit;
  } MDIOS_DOUTR28;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000110) MDIOS output data register 29                              */
    
    struct {
      __IOM uint32 DOUT29     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32            : 16;
    } bit;
  } MDIOS_DOUTR29;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000114) MDIOS output data register 30                              */
    
    struct {
      __IOM uint32 DOUT30     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32            : 16;
    } bit;
  } MDIOS_DOUTR30;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000118) MDIOS output data register 31                              */
    
    struct {
      __IOM uint32 DOUT31     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32            : 16;
    } bit;
  } MDIOS_DOUTR31;
} MDIOS_Type;                                   /*!< Size = 284 (0x11c)                                                        */



/* =========================================================================================================================== */
/* ================                                           OPAMP                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Operational amplifiers (OPAMP)
  */

typedef struct {                                /*!< (@ 0x40009000) OPAMP Structure                                            */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) OPAMP1 control/status register                             */
    
    struct {
      __IOM uint32 OPAEN      : 1;            /*!< [0..0] Operational amplifier Enable                                       */
      __IOM uint32 FORCE_VP   : 1;            /*!< [1..1] Force internal reference on VP (reserved for test                  */
      __IOM uint32 VP_SEL     : 2;            /*!< [3..2] Operational amplifier PGA mode                                     */
            uint32            : 1;
      __IOM uint32 VM_SEL     : 2;            /*!< [6..5] Inverting input selection                                          */
            uint32            : 1;
      __IOM uint32 OPAHSM     : 1;            /*!< [8..8] Operational amplifier high-speed mode                              */
            uint32            : 2;
      __IOM uint32 CALON      : 1;            /*!< [11..11] Calibration mode enabled                                         */
      __IOM uint32 CALSEL     : 2;            /*!< [13..12] Calibration selection                                            */
      __IOM uint32 PGA_GAIN   : 4;            /*!< [17..14] allows to switch from AOP offset trimmed values to
                                                     AOP offset                                                                */
      __IOM uint32 USERTRIM   : 1;            /*!< [18..18] User trimming enable                                             */
            uint32            : 10;
      __IOM uint32 TSTREF     : 1;            /*!< [29..29] OPAMP calibration reference voltage output control
                                                     (reserved for test)                                                       */
      __IOM uint32 CALOUT     : 1;            /*!< [30..30] Operational amplifier calibration output                         */
            uint32            : 1;
    } bit;
  } OPAMP1_CSR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) OPAMP1 offset trimming register in normal mode             */
    
    struct {
      __IOM uint32 TRIMOFFSETN : 5;           /*!< [4..0] Trim for NMOS differential pairs                                   */
            uint32            : 3;
      __IOM uint32 TRIMOFFSETP : 5;           /*!< [12..8] Trim for PMOS differential pairs                                  */
            uint32            : 19;
    } bit;
  } OPAMP1_OTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) OPAMP1 offset trimming register in low-power
                                                                    mode                                                       */
    
    struct {
      __IOM uint32 TRIMLPOFFSETN : 5;         /*!< [4..0] Trim for NMOS differential pairs                                   */
            uint32            : 3;
      __IOM uint32 TRIMLPOFFSETP : 5;         /*!< [12..8] Trim for PMOS differential pairs                                  */
            uint32            : 19;
    } bit;
  } OPAMP1_HSOTR;
  __IM  uint32  RESERVED;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) OPAMP2 control/status register                             */
    
    struct {
      __IOM uint32 OPAEN      : 1;            /*!< [0..0] Operational amplifier Enable                                       */
      __IOM uint32 FORCE_VP   : 1;            /*!< [1..1] Force internal reference on VP (reserved for test)                 */
            uint32            : 3;
      __IOM uint32 VM_SEL     : 2;            /*!< [6..5] Inverting input selection                                          */
            uint32            : 1;
      __IOM uint32 OPAHSM     : 1;            /*!< [8..8] Operational amplifier high-speed mode                              */
            uint32            : 2;
      __IOM uint32 CALON      : 1;            /*!< [11..11] Calibration mode enabled                                         */
      __IOM uint32 CALSEL     : 2;            /*!< [13..12] Calibration selection                                            */
      __IOM uint32 PGA_GAIN   : 4;            /*!< [17..14] Operational amplifier Programmable amplifier gain value          */
      __IOM uint32 USERTRIM   : 1;            /*!< [18..18] User trimming enable                                             */
            uint32            : 10;
      __IOM uint32 TSTREF     : 1;            /*!< [29..29] OPAMP calibration reference voltage output control
                                                     (reserved for test)                                                       */
      __IOM uint32 CALOUT     : 1;            /*!< [30..30] Operational amplifier calibration output                         */
            uint32            : 1;
    } bit;
  } OPAMP2_CSR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000014) OPAMP2 offset trimming register in normal mode             */
    
    struct {
      __IOM uint32 TRIMOFFSETN : 5;           /*!< [4..0] Trim for NMOS differential pairs                                   */
            uint32            : 3;
      __IOM uint32 TRIMOFFSETP : 5;           /*!< [12..8] Trim for PMOS differential pairs                                  */
            uint32            : 19;
    } bit;
  } OPAMP2_OTR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000018) OPAMP2 offset trimming register in low-power
                                                                    mode                                                       */
    
    struct {
      __IOM uint32 TRIMLPOFFSETN : 5;         /*!< [4..0] Trim for NMOS differential pairs                                   */
            uint32            : 3;
      __IOM uint32 TRIMLPOFFSETP : 5;         /*!< [12..8] Trim for PMOS differential pairs                                  */
            uint32            : 19;
    } bit;
  } OPAMP2_HSOTR;
} OPAMP_Type;                                   /*!< Size = 28 (0x1c)                                                          */



/* =========================================================================================================================== */
/* ================                                           SWPMI                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Single Wire Protocol Master
      Interface (SWPMI)
  */

typedef struct {                                /*!< (@ 0x40008800) SWPMI Structure                                            */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) SWPMI Configuration/Control register                       */
    
    struct {
      __IOM uint32 RXDMA      : 1;            /*!< [0..0] Reception DMA enable                                               */
      __IOM uint32 TXDMA      : 1;            /*!< [1..1] Transmission DMA enable                                            */
      __IOM uint32 RXMODE     : 1;            /*!< [2..2] Reception buffering mode                                           */
      __IOM uint32 TXMODE     : 1;            /*!< [3..3] Transmission buffering mode                                        */
      __IOM uint32 LPBK       : 1;            /*!< [4..4] Loopback mode enable                                               */
      __IOM uint32 SWPACT     : 1;            /*!< [5..5] Single wire protocol master interface activate                     */
            uint32            : 4;
      __IOM uint32 DEACT      : 1;            /*!< [10..10] Single wire protocol master interface deactivate                 */
      __IOM uint32 SWPTEN     : 1;            /*!< [11..11] Single wire protocol master transceiver enable                   */
            uint32            : 20;
    } bit;
  } CR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) SWPMI Bitrate register                                     */
    
    struct {
      __IOM uint32 BR         : 8;            /*!< [7..0] Bitrate prescaler                                                  */
            uint32            : 24;
    } bit;
  } BRR;
  __IM  uint32  RESERVED;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x0000000C) SWPMI Interrupt and Status register                        */
    
    struct {
      __IM  uint32 RXBFF      : 1;            /*!< [0..0] Receive buffer full flag                                           */
      __IM  uint32 TXBEF      : 1;            /*!< [1..1] Transmit buffer empty flag                                         */
      __IM  uint32 RXBERF     : 1;            /*!< [2..2] Receive CRC error flag                                             */
      __IM  uint32 RXOVRF     : 1;            /*!< [3..3] Receive overrun error flag                                         */
      __IM  uint32 TXUNRF     : 1;            /*!< [4..4] Transmit underrun error flag                                       */
      __IM  uint32 RXNE       : 1;            /*!< [5..5] Receive data register not empty                                    */
      __IM  uint32 TXE        : 1;            /*!< [6..6] Transmit data register empty                                       */
      __IM  uint32 TCF        : 1;            /*!< [7..7] Transfer complete flag                                             */
      __IM  uint32 SRF        : 1;            /*!< [8..8] Slave resume flag                                                  */
      __IM  uint32 SUSP       : 1;            /*!< [9..9] SUSPEND flag                                                       */
      __IM  uint32 DEACTF     : 1;            /*!< [10..10] DEACTIVATED flag                                                 */
      __IM  uint32 RDYF       : 1;            /*!< [11..11] transceiver ready flag                                           */
            uint32            : 20;
    } bit;
  } ISR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000010) SWPMI Interrupt Flag Clear register                        */
    
    struct {
      __OM  uint32 CRXBFF     : 1;            /*!< [0..0] Clear receive buffer full flag                                     */
      __OM  uint32 CTXBEF     : 1;            /*!< [1..1] Clear transmit buffer empty flag                                   */
      __OM  uint32 CRXBERF    : 1;            /*!< [2..2] Clear receive CRC error flag                                       */
      __OM  uint32 CRXOVRF    : 1;            /*!< [3..3] Clear receive overrun error flag                                   */
      __OM  uint32 CTXUNRF    : 1;            /*!< [4..4] Clear transmit underrun error flag                                 */
            uint32            : 2;
      __OM  uint32 CTCF       : 1;            /*!< [7..7] Clear transfer complete flag                                       */
      __OM  uint32 CSRF       : 1;            /*!< [8..8] Clear slave resume flag                                            */
            uint32            : 2;
      __OM  uint32 CRDYF      : 1;            /*!< [11..11] Clear transceiver ready flag                                     */
            uint32            : 20;
    } bit;
  } ICR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000014) SWPMI Interrupt Enable register                            */
    
    struct {
      __IOM uint32 RXBFIE     : 1;            /*!< [0..0] Receive buffer full interrupt enable                               */
      __IOM uint32 TXBEIE     : 1;            /*!< [1..1] Transmit buffer empty interrupt enable                             */
      __IOM uint32 RXBERIE    : 1;            /*!< [2..2] Receive CRC error interrupt enable                                 */
      __IOM uint32 RXOVRIE    : 1;            /*!< [3..3] Receive overrun error interrupt enable                             */
      __IOM uint32 TXUNRIE    : 1;            /*!< [4..4] Transmit underrun error interrupt enable                           */
      __IOM uint32 RIE        : 1;            /*!< [5..5] Receive interrupt enable                                           */
      __IOM uint32 TIE        : 1;            /*!< [6..6] Transmit interrupt enable                                          */
      __IOM uint32 TCIE       : 1;            /*!< [7..7] Transmit complete interrupt enable                                 */
      __IOM uint32 SRIE       : 1;            /*!< [8..8] Slave resume interrupt enable                                      */
            uint32            : 2;
      __IOM uint32 RDYIE      : 1;            /*!< [11..11] Transceiver ready interrupt enable                               */
            uint32            : 20;
    } bit;
  } IER;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000018) SWPMI Receive Frame Length register                        */
    
    struct {
      __IM  uint32 RFL        : 5;            /*!< [4..0] Receive frame length                                               */
            uint32            : 27;
    } bit;
  } RFL;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x0000001C) SWPMI Transmit data register                               */
    
    struct {
      __OM  uint32 TD         : 32;           /*!< [31..0] Transmit data                                                     */
    } bit;
  } TDR;
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000020) SWPMI Receive data register                                */
    
    struct {
      __IM  uint32 RD         : 32;           /*!< [31..0] received data                                                     */
    } bit;
  } RDR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000024) SWPMI Option register                                      */
    
    struct {
      __IOM uint32 SWP_TBYP   : 1;            /*!< [0..0] SWP transceiver bypass                                             */
      __IOM uint32 SWP_CLASS  : 1;            /*!< [1..1] SWP class selection                                                */
            uint32            : 30;
    } bit;
  } OR;
} SWPMI_Type;                                   /*!< Size = 40 (0x28)                                                          */



/* =========================================================================================================================== */
/* ================                                           TIM2                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief General purpose timers (TIM2)
  */

typedef struct {                                /*!< (@ 0x40000000) TIM2 Structure                                             */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) control register 1                                         */
    
    struct {
      __IOM uint32 CEN        : 1;            /*!< [0..0] Counter enable                                                     */
      __IOM uint32 UDIS       : 1;            /*!< [1..1] Update disable                                                     */
      __IOM uint32 URS        : 1;            /*!< [2..2] Update request source                                              */
      __IOM uint32 OPM        : 1;            /*!< [3..3] One-pulse mode                                                     */
      __IOM uint32 DIR        : 1;            /*!< [4..4] Direction                                                          */
      __IOM uint32 CMS        : 2;            /*!< [6..5] Center-aligned mode selection                                      */
      __IOM uint32 ARPE       : 1;            /*!< [7..7] Auto-reload preload enable                                         */
      __IOM uint32 CKD        : 2;            /*!< [9..8] Clock division                                                     */
            uint32            : 1;
      __IOM uint32 UIFREMAP   : 1;            /*!< [11..11] UIF status bit remapping                                         */
            uint32            : 20;
    } bit;
  } CR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) control register 2                                         */
    
    struct {
            uint32            : 3;
      __IOM uint32 CCDS       : 1;            /*!< [3..3] Capture/compare DMA selection                                      */
      __IOM uint32 MMS        : 3;            /*!< [6..4] Master mode selection                                              */
      __IOM uint32 TI1S       : 1;            /*!< [7..7] TI1 selection                                                      */
            uint32            : 24;
    } bit;
  } CR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) slave mode control register                                */
    
    struct {
      __IOM uint32 SMS        : 3;            /*!< [2..0] Slave mode selection                                               */
            uint32            : 1;
      __IOM uint32 TS         : 3;            /*!< [6..4] Trigger selection                                                  */
      __IOM uint32 MSM        : 1;            /*!< [7..7] Master/Slave mode                                                  */
      __IOM uint32 ETF        : 4;            /*!< [11..8] External trigger filter                                           */
      __IOM uint32 ETPS       : 2;            /*!< [13..12] External trigger prescaler                                       */
      __IOM uint32 ECE        : 1;            /*!< [14..14] External clock enable                                            */
      __IOM uint32 ETP        : 1;            /*!< [15..15] External trigger polarity                                        */
      __IOM uint32 SMS_3      : 1;            /*!< [16..16] Slave mode selection - bit 3                                     */
            uint32            : 3;
      __IOM uint32 TS_4_3     : 2;            /*!< [21..20] Trigger selection                                                */
            uint32            : 10;
    } bit;
  } SMCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) DMA/Interrupt enable register                              */
    
    struct {
      __IOM uint32 UIE        : 1;            /*!< [0..0] Update interrupt enable                                            */
      __IOM uint32 CC1IE      : 1;            /*!< [1..1] Capture/Compare 1 interrupt enable                                 */
      __IOM uint32 CC2IE      : 1;            /*!< [2..2] Capture/Compare 2 interrupt enable                                 */
      __IOM uint32 CC3IE      : 1;            /*!< [3..3] Capture/Compare 3 interrupt enable                                 */
      __IOM uint32 CC4IE      : 1;            /*!< [4..4] Capture/Compare 4 interrupt enable                                 */
            uint32            : 1;
      __IOM uint32 TIE        : 1;            /*!< [6..6] Trigger interrupt enable                                           */
            uint32            : 1;
      __IOM uint32 UDE        : 1;            /*!< [8..8] Update DMA request enable                                          */
      __IOM uint32 CC1DE      : 1;            /*!< [9..9] Capture/Compare 1 DMA request enable                               */
      __IOM uint32 CC2DE      : 1;            /*!< [10..10] Capture/Compare 2 DMA request enable                             */
      __IOM uint32 CC3DE      : 1;            /*!< [11..11] Capture/Compare 3 DMA request enable                             */
      __IOM uint32 CC4DE      : 1;            /*!< [12..12] Capture/Compare 4 DMA request enable                             */
            uint32            : 1;
      __IOM uint32 TDE        : 1;            /*!< [14..14] Trigger DMA request enable                                       */
            uint32            : 17;
    } bit;
  } DIER;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) status register                                            */
    
    struct {
      __IOM uint32 UIF        : 1;            /*!< [0..0] Update interrupt flag                                              */
      __IOM uint32 CC1IF      : 1;            /*!< [1..1] Capture/compare 1 interrupt flag                                   */
      __IOM uint32 CC2IF      : 1;            /*!< [2..2] Capture/Compare 2 interrupt flag                                   */
      __IOM uint32 CC3IF      : 1;            /*!< [3..3] Capture/Compare 3 interrupt flag                                   */
      __IOM uint32 CC4IF      : 1;            /*!< [4..4] Capture/Compare 4 interrupt flag                                   */
            uint32            : 1;
      __IOM uint32 TIF        : 1;            /*!< [6..6] Trigger interrupt flag                                             */
            uint32            : 2;
      __IOM uint32 CC1OF      : 1;            /*!< [9..9] Capture/Compare 1 overcapture flag                                 */
      __IOM uint32 CC2OF      : 1;            /*!< [10..10] Capture/compare 2 overcapture flag                               */
      __IOM uint32 CC3OF      : 1;            /*!< [11..11] Capture/Compare 3 overcapture flag                               */
      __IOM uint32 CC4OF      : 1;            /*!< [12..12] Capture/Compare 4 overcapture flag                               */
            uint32            : 19;
    } bit;
  } SR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000014) event generation register                                  */
    
    struct {
      __OM  uint32 UG         : 1;            /*!< [0..0] Update generation                                                  */
      __OM  uint32 CC1G       : 1;            /*!< [1..1] Capture/compare 1 generation                                       */
      __OM  uint32 CC2G       : 1;            /*!< [2..2] Capture/compare 2 generation                                       */
      __OM  uint32 CC3G       : 1;            /*!< [3..3] Capture/compare 3 generation                                       */
      __OM  uint32 CC4G       : 1;            /*!< [4..4] Capture/compare 4 generation                                       */
            uint32            : 1;
      __OM  uint32 TG         : 1;            /*!< [6..6] Trigger generation                                                 */
            uint32            : 25;
    } bit;
  } EGR;
  
  union {
    union {
      __IOM uint32 reg;                       /*!< (@ 0x00000018) capture/compare mode register 1 (output mode)              */
      
      struct {
        __IOM uint32 CC1S     : 2;            /*!< [1..0] CC1S                                                               */
        __IOM uint32 OC1FE    : 1;            /*!< [2..2] OC1FE                                                              */
        __IOM uint32 OC1PE    : 1;            /*!< [3..3] OC1PE                                                              */
        __IOM uint32 OC1M     : 3;            /*!< [6..4] OC1M                                                               */
        __IOM uint32 OC1CE    : 1;            /*!< [7..7] OC1CE                                                              */
        __IOM uint32 CC2S     : 2;            /*!< [9..8] CC2S                                                               */
        __IOM uint32 OC2FE    : 1;            /*!< [10..10] OC2FE                                                            */
        __IOM uint32 OC2PE    : 1;            /*!< [11..11] OC2PE                                                            */
        __IOM uint32 OC2M     : 3;            /*!< [14..12] OC2M                                                             */
        __IOM uint32 OC2CE    : 1;            /*!< [15..15] OC2CE                                                            */
        __IOM uint32 OC1M_3   : 1;            /*!< [16..16] Output Compare 1 mode - bit 3                                    */
              uint32          : 7;
        __IOM uint32 OC2M_3   : 1;            /*!< [24..24] Output Compare 2 mode - bit 3                                    */
              uint32          : 7;
      } bit;
    } CCMR1_Output;
    
    union {
      __IOM uint32 reg;                       /*!< (@ 0x00000018) capture/compare mode register 1 (input mode)               */
      
      struct {
        __IOM uint32 CC1S     : 2;            /*!< [1..0] Capture/Compare 1 selection                                        */
        __IOM uint32 ICPCS    : 2;            /*!< [3..2] Input capture 1 prescaler                                          */
        __IOM uint32 IC1F     : 4;            /*!< [7..4] Input capture 1 filter                                             */
        __IOM uint32 CC2S     : 2;            /*!< [9..8] Capture/Compare 2 selection                                        */
        __IOM uint32 IC2PCS   : 2;            /*!< [11..10] Input capture 2 prescaler                                        */
        __IOM uint32 IC2F     : 4;            /*!< [15..12] Input capture 2 filter                                           */
              uint32          : 16;
      } bit;
    } CCMR1_Input;
  };
  
  union {
    union {
      __IOM uint32 reg;                       /*!< (@ 0x0000001C) capture/compare mode register 2 (output mode)              */
      
      struct {
        __IOM uint32 CC3S     : 2;            /*!< [1..0] CC3S                                                               */
        __IOM uint32 OC3FE    : 1;            /*!< [2..2] OC3FE                                                              */
        __IOM uint32 OC3PE    : 1;            /*!< [3..3] OC3PE                                                              */
        __IOM uint32 OC3M     : 3;            /*!< [6..4] OC3M                                                               */
        __IOM uint32 OC3CE    : 1;            /*!< [7..7] OC3CE                                                              */
        __IOM uint32 CC4S     : 2;            /*!< [9..8] CC4S                                                               */
        __IOM uint32 OC4FE    : 1;            /*!< [10..10] OC4FE                                                            */
        __IOM uint32 OC4PE    : 1;            /*!< [11..11] OC4PE                                                            */
        __IOM uint32 OC4M     : 3;            /*!< [14..12] OC4M                                                             */
        __IOM uint32 O24CE    : 1;            /*!< [15..15] O24CE                                                            */
        __IOM uint32 OC3M_3   : 1;            /*!< [16..16] Output Compare 1 mode - bit 3                                    */
              uint32          : 7;
        __IOM uint32 OC4M_3   : 1;            /*!< [24..24] Output Compare 2 mode - bit 3                                    */
              uint32          : 7;
      } bit;
    } CCMR2_Output;
    
    union {
      __IOM uint32 reg;                       /*!< (@ 0x0000001C) capture/compare mode register 2 (input mode)               */
      
      struct {
        __IOM uint32 CC3S     : 2;            /*!< [1..0] Capture/compare 3 selection                                        */
        __IOM uint32 IC3PSC   : 2;            /*!< [3..2] Input capture 3 prescaler                                          */
        __IOM uint32 IC3F     : 4;            /*!< [7..4] Input capture 3 filter                                             */
        __IOM uint32 CC4S     : 2;            /*!< [9..8] Capture/Compare 4 selection                                        */
        __IOM uint32 IC4PSC   : 2;            /*!< [11..10] Input capture 4 prescaler                                        */
        __IOM uint32 IC4F     : 4;            /*!< [15..12] Input capture 4 filter                                           */
              uint32          : 16;
      } bit;
    } CCMR2_Input;
  };
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000020) capture/compare enable register                            */
    
    struct {
      __IOM uint32 CC1E       : 1;            /*!< [0..0] Capture/Compare 1 output enable                                    */
      __IOM uint32 CC1P       : 1;            /*!< [1..1] Capture/Compare 1 output Polarity                                  */
            uint32            : 1;
      __IOM uint32 CC1NP      : 1;            /*!< [3..3] Capture/Compare 1 output Polarity                                  */
      __IOM uint32 CC2E       : 1;            /*!< [4..4] Capture/Compare 2 output enable                                    */
      __IOM uint32 CC2P       : 1;            /*!< [5..5] Capture/Compare 2 output Polarity                                  */
            uint32            : 1;
      __IOM uint32 CC2NP      : 1;            /*!< [7..7] Capture/Compare 2 output Polarity                                  */
      __IOM uint32 CC3E       : 1;            /*!< [8..8] Capture/Compare 3 output enable                                    */
      __IOM uint32 CC3P       : 1;            /*!< [9..9] Capture/Compare 3 output Polarity                                  */
            uint32            : 1;
      __IOM uint32 CC3NP      : 1;            /*!< [11..11] Capture/Compare 3 output Polarity                                */
      __IOM uint32 CC4E       : 1;            /*!< [12..12] Capture/Compare 4 output enable                                  */
      __IOM uint32 CC4P       : 1;            /*!< [13..13] Capture/Compare 3 output Polarity                                */
            uint32            : 1;
      __IOM uint32 CC4NP      : 1;            /*!< [15..15] Capture/Compare 4 output Polarity                                */
            uint32            : 16;
    } bit;
  } CCER;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000024) counter                                                    */
    
    struct {
      __IOM uint32 CNT_L      : 16;           /*!< [15..0] low counter value                                                 */
      __IOM uint32 CNT_H      : 16;           /*!< [31..16] High counter value                                               */
    } bit;
  } CNT;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000028) prescaler                                                  */
    
    struct {
      __IOM uint32 PSC        : 16;           /*!< [15..0] Prescaler value                                                   */
            uint32            : 16;
    } bit;
  } PSC;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000002C) auto-reload register                                       */
    
    struct {
      __IOM uint32 ARR_L      : 16;           /*!< [15..0] Low Auto-reload value                                             */
      __IOM uint32 ARR_H      : 16;           /*!< [31..16] High Auto-reload value                                           */
    } bit;
  } ARR;
  __IM  uint32  RESERVED;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000034) capture/compare register 1                                 */
    
    struct {
      __IOM uint32 CCR1_L     : 16;           /*!< [15..0] Low Capture/Compare 1 value                                       */
      __IOM uint32 CCR1_H     : 16;           /*!< [31..16] High Capture/Compare 1 value                                     */
    } bit;
  } CCR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000038) capture/compare register 2                                 */
    
    struct {
      __IOM uint32 CCR2_L     : 16;           /*!< [15..0] Low Capture/Compare 2 value                                       */
      __IOM uint32 CCR2_H     : 16;           /*!< [31..16] High Capture/Compare 2 value                                     */
    } bit;
  } CCR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000003C) capture/compare register 3                                 */
    
    struct {
      __IOM uint32 CCR3_L     : 16;           /*!< [15..0] Low Capture/Compare value                                         */
      __IOM uint32 CCR3_H     : 16;           /*!< [31..16] High Capture/Compare value                                       */
    } bit;
  } CCR3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000040) capture/compare register 4                                 */
    
    struct {
      __IOM uint32 CCR4_L     : 16;           /*!< [15..0] Low Capture/Compare value                                         */
      __IOM uint32 CCR4_H     : 16;           /*!< [31..16] High Capture/Compare value                                       */
    } bit;
  } CCR4;
  __IM  uint32  RESERVED1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000048) DMA control register                                       */
    
    struct {
      __IOM uint32 DBA        : 5;            /*!< [4..0] DMA base address                                                   */
            uint32            : 3;
      __IOM uint32 DBL        : 5;            /*!< [12..8] DMA burst length                                                  */
            uint32            : 19;
    } bit;
  } DCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000004C) DMA address for full transfer                              */
    
    struct {
      __IOM uint32 DMAB       : 16;           /*!< [15..0] DMA register for burst accesses                                   */
            uint32            : 16;
    } bit;
  } DMAR;
  __IM  uint32  RESERVED2[4];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000060) TIM alternate function option register 1                   */
    
    struct {
            uint32            : 14;
      __IOM uint32 ETRSEL     : 4;            /*!< [17..14] ETR source selection                                             */
            uint32            : 14;
    } bit;
  } AF1;
  __IM  uint32  RESERVED3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000068) TIM timer input selection register                         */
    
    struct {
      __IOM uint32 TI1SEL     : 4;            /*!< [3..0] TI1[0] to TI1[15] input selection                                  */
            uint32            : 4;
      __IOM uint32 TI2SEL     : 4;            /*!< [11..8] TI2[0] to TI2[15] input selection                                 */
            uint32            : 4;
      __IOM uint32 TI3SEL     : 4;            /*!< [19..16] TI3[0] to TI3[15] input selection                                */
            uint32            : 4;
      __IOM uint32 TI4SEL     : 4;            /*!< [27..24] TI4[0] to TI4[15] input selection                                */
            uint32            : 4;
    } bit;
  } TISEL;
} TIM2_Type;                                    /*!< Size = 108 (0x6c)                                                         */



/* =========================================================================================================================== */
/* ================                                           TIM6                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Basic timers (TIM6)
  */

typedef struct {                                /*!< (@ 0x40001000) TIM6 Structure                                             */
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000000) control register 1                                         */
    
    struct {
      __IOM uint32 CEN        : 1;            /*!< [0..0] Counter enable                                                     */
      __IOM uint32 UDIS       : 1;            /*!< [1..1] Update disable                                                     */
      __IOM uint32 URS        : 1;            /*!< [2..2] Update request source                                              */
      __IOM uint32 OPM        : 1;            /*!< [3..3] One-pulse mode                                                     */
            uint32            : 3;
      __IOM uint32 ARPE       : 1;            /*!< [7..7] Auto-reload preload enable                                         */
            uint32            : 3;
      __IOM uint32 UIFREMAP   : 1;            /*!< [11..11] UIF status bit remapping                                         */
            uint32            : 20;
    } bit;
  } CR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) control register 2                                         */
    
    struct {
            uint32            : 4;
      __IOM uint32 MMS        : 3;            /*!< [6..4] Master mode selection                                              */
            uint32            : 25;
    } bit;
  } CR2;
  __IM  uint32  RESERVED;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) DMA/Interrupt enable register                              */
    
    struct {
      __IOM uint32 UIE        : 1;            /*!< [0..0] Update interrupt enable                                            */
            uint32            : 7;
      __IOM uint32 UDE        : 1;            /*!< [8..8] Update DMA request enable                                          */
            uint32            : 23;
    } bit;
  } DIER;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) status register                                            */
    
    struct {
      __IOM uint32 UIF        : 1;            /*!< [0..0] Update interrupt flag                                              */
            uint32            : 31;
    } bit;
  } SR;
  
  union {
    __OM  uint32 reg;                         /*!< (@ 0x00000014) event generation register                                  */
    
    struct {
      __OM  uint32 UG         : 1;            /*!< [0..0] Update generation                                                  */
            uint32            : 31;
    } bit;
  } EGR;
  __IM  uint32  RESERVED1[3];
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000024) counter                                                    */
    
    struct {
      __IOM uint32 CNT        : 16;           /*!< [15..0] Low counter value                                                 */
            uint32            : 15;
      __IOM uint32 UIFCPY     : 1;            /*!< [31..31] UIF Copy                                                         */
    } bit;
  } CNT;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000028) prescaler                                                  */
    
    struct {
      __IOM uint32 PSC        : 16;           /*!< [15..0] Prescaler value                                                   */
            uint32            : 16;
    } bit;
  } PSC;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000002C) auto-reload register                                       */
    
    struct {
      __IOM uint32 ARR        : 16;           /*!< [15..0] Low Auto-reload value                                             */
            uint32            : 16;
    } bit;
  } ARR;
} TIM6_Type;                                    /*!< Size = 48 (0x30)                                                          */

/* =========================================================================================================================== */
/* ================                                            SCB                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief System control block (SCB)
  */

typedef struct {                                /*!< (@ 0xE000ED00) SCB Structure                                              */
  
  union {
    __IM  uint32 reg;                         /*!< (@ 0x00000000) CPUID base register                                        */
    
    struct {
      __IM  uint32 Revision   : 4;            /*!< [3..0] Revision number                                                    */
      __IM  uint32 PartNo     : 12;           /*!< [15..4] Part number of the processor                                      */
      __IM  uint32 Constant   : 4;            /*!< [19..16] Reads as 0xF                                                     */
      __IM  uint32 Variant    : 4;            /*!< [23..20] Variant number                                                   */
      __IM  uint32 Implementer : 8;           /*!< [31..24] Implementer code                                                 */
    } bit;
  } CPUID;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000004) Interrupt control and state register                       */
    
    struct {
      __IOM uint32 VECTACTIVE : 9;            /*!< [8..0] Active vector                                                      */
            uint32            : 2;
      __IOM uint32 RETTOBASE  : 1;            /*!< [11..11] Return to base level                                             */
      __IOM uint32 VECTPENDING : 7;           /*!< [18..12] Pending vector                                                   */
            uint32            : 3;
      __IOM uint32 ISRPENDING : 1;            /*!< [22..22] Interrupt pending flag                                           */
            uint32            : 2;
      __IOM uint32 PENDSTCLR  : 1;            /*!< [25..25] SysTick exception clear-pending bit                              */
      __IOM uint32 PENDSTSET  : 1;            /*!< [26..26] SysTick exception set-pending bit                                */
      __IOM uint32 PENDSVCLR  : 1;            /*!< [27..27] PendSV clear-pending bit                                         */
      __IOM uint32 PENDSVSET  : 1;            /*!< [28..28] PendSV set-pending bit                                           */
            uint32            : 2;
      __IOM uint32 NMIPENDSET : 1;            /*!< [31..31] NMI set-pending bit.                                             */
    } bit;
  } ICSR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000008) Vector table offset register                               */
    
    struct {
            uint32            : 9;
      __IOM uint32 TBLOFF     : 21;           /*!< [29..9] Vector table base offset field                                    */
            uint32            : 2;
    } bit;
  } VTOR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000000C) Application interrupt and reset control register           */
    
    struct {
      __IOM uint32 VECTRESET  : 1;            /*!< [0..0] VECTRESET                                                          */
      __IOM uint32 VECTCLRACTIVE : 1;         /*!< [1..1] VECTCLRACTIVE                                                      */
      __IOM uint32 SYSRESETREQ : 1;           /*!< [2..2] SYSRESETREQ                                                        */
            uint32            : 5;
      __IOM uint32 PRIGROUP   : 3;            /*!< [10..8] PRIGROUP                                                          */
            uint32            : 4;
      __IOM uint32 ENDIANESS  : 1;            /*!< [15..15] ENDIANESS                                                        */
      __IOM uint32 VECTKEYSTAT : 16;          /*!< [31..16] Register key                                                     */
    } bit;
  } AIRCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000010) System control register                                    */
    
    struct {
            uint32            : 1;
      __IOM uint32 SLEEPONEXIT : 1;           /*!< [1..1] SLEEPONEXIT                                                        */
      __IOM uint32 SLEEPDEEP  : 1;            /*!< [2..2] SLEEPDEEP                                                          */
            uint32            : 1;
      __IOM uint32 SEVEONPEND : 1;            /*!< [4..4] Send Event on Pending bit                                          */
            uint32            : 27;
    } bit;
  } SCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000014) Configuration and control register                         */
    
    struct {
      __IOM uint32 NONBASETHRDENA : 1;        /*!< [0..0] Configures how the processor enters Thread mode                    */
      __IOM uint32 USERSETMPEND : 1;          /*!< [1..1] USERSETMPEND                                                       */
            uint32            : 1;
      __IOM uint32 UNALIGN__TRP : 1;          /*!< [3..3] UNALIGN_ TRP                                                       */
      __IOM uint32 DIV_0_TRP  : 1;            /*!< [4..4] DIV_0_TRP                                                          */
            uint32            : 3;
      __IOM uint32 BFHFNMIGN  : 1;            /*!< [8..8] BFHFNMIGN                                                          */
      __IOM uint32 STKALIGN   : 1;            /*!< [9..9] STKALIGN                                                           */
            uint32            : 6;
      __IOM uint32 DC         : 1;            /*!< [16..16] DC                                                               */
      __IOM uint32 IC         : 1;            /*!< [17..17] IC                                                               */
      __IOM uint32 BP         : 1;            /*!< [18..18] BP                                                               */
            uint32            : 13;
    } bit;
  } CCR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000018) System handler priority registers                          */
    
    struct {
      __IOM uint32 PRI_4      : 8;            /*!< [7..0] Priority of system handler 4                                       */
      __IOM uint32 PRI_5      : 8;            /*!< [15..8] Priority of system handler 5                                      */
      __IOM uint32 PRI_6      : 8;            /*!< [23..16] Priority of system handler 6                                     */
            uint32            : 8;
    } bit;
  } SHPR1;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000001C) System handler priority registers                          */
    
    struct {
            uint32            : 24;
      __IOM uint32 PRI_11     : 8;            /*!< [31..24] Priority of system handler 11                                    */
    } bit;
  } SHPR2;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000020) System handler priority registers                          */
    
    struct {
            uint32            : 16;
      __IOM uint32 PRI_14     : 8;            /*!< [23..16] Priority of system handler 14                                    */
      __IOM uint32 PRI_15     : 8;            /*!< [31..24] Priority of system handler 15                                    */
    } bit;
  } SHPR3;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000024) System handler control and state register                  */
    
    struct {
      __IOM uint32 MEMFAULTACT : 1;           /*!< [0..0] Memory management fault exception active bit                       */
      __IOM uint32 BUSFAULTACT : 1;           /*!< [1..1] Bus fault exception active bit                                     */
            uint32            : 1;
      __IOM uint32 USGFAULTACT : 1;           /*!< [3..3] Usage fault exception active bit                                   */
            uint32            : 3;
      __IOM uint32 SVCALLACT  : 1;            /*!< [7..7] SVC call active bit                                                */
      __IOM uint32 MONITORACT : 1;            /*!< [8..8] Debug monitor active bit                                           */
            uint32            : 1;
      __IOM uint32 PENDSVACT  : 1;            /*!< [10..10] PendSV exception active bit                                      */
      __IOM uint32 SYSTICKACT : 1;            /*!< [11..11] SysTick exception active bit                                     */
      __IOM uint32 USGFAULTPENDED : 1;        /*!< [12..12] Usage fault exception pending bit                                */
      __IOM uint32 MEMFAULTPENDED : 1;        /*!< [13..13] Memory management fault exception pending bit                    */
      __IOM uint32 BUSFAULTPENDED : 1;        /*!< [14..14] Bus fault exception pending bit                                  */
      __IOM uint32 SVCALLPENDED : 1;          /*!< [15..15] SVC call pending bit                                             */
      __IOM uint32 MEMFAULTENA : 1;           /*!< [16..16] Memory management fault enable bit                               */
      __IOM uint32 BUSFAULTENA : 1;           /*!< [17..17] Bus fault enable bit                                             */
      __IOM uint32 USGFAULTENA : 1;           /*!< [18..18] Usage fault enable bit                                           */
            uint32            : 13;
    } bit;
  } SHCRS;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000028) Configurable fault status register                         */
    
    struct {
      __IOM uint32 IACCVIOL   : 1;            /*!< [0..0] IACCVIOL                                                           */
      __IOM uint32 DACCVIOL   : 1;            /*!< [1..1] DACCVIOL                                                           */
            uint32            : 1;
      __IOM uint32 MUNSTKERR  : 1;            /*!< [3..3] MUNSTKERR                                                          */
      __IOM uint32 MSTKERR    : 1;            /*!< [4..4] MSTKERR                                                            */
      __IOM uint32 MLSPERR    : 1;            /*!< [5..5] MLSPERR                                                            */
            uint32            : 1;
      __IOM uint32 MMARVALID  : 1;            /*!< [7..7] MMARVALID                                                          */
      __IOM uint32 IBUSERR    : 1;            /*!< [8..8] Instruction bus error                                              */
      __IOM uint32 PRECISERR  : 1;            /*!< [9..9] Precise data bus error                                             */
      __IOM uint32 IMPRECISERR : 1;           /*!< [10..10] Imprecise data bus error                                         */
      __IOM uint32 UNSTKERR   : 1;            /*!< [11..11] Bus fault on unstacking for a return from exception              */
      __IOM uint32 STKERR     : 1;            /*!< [12..12] Bus fault on stacking for exception entry                        */
      __IOM uint32 LSPERR     : 1;            /*!< [13..13] Bus fault on floating-point lazy state preservation              */
            uint32            : 1;
      __IOM uint32 BFARVALID  : 1;            /*!< [15..15] Bus Fault Address Register (BFAR) valid flag                     */
      __IOM uint32 UNDEFINSTR : 1;            /*!< [16..16] Undefined instruction usage fault                                */
      __IOM uint32 INVSTATE   : 1;            /*!< [17..17] Invalid state usage fault                                        */
      __IOM uint32 INVPC      : 1;            /*!< [18..18] Invalid PC load usage fault                                      */
      __IOM uint32 NOCP       : 1;            /*!< [19..19] No coprocessor usage fault.                                      */
            uint32            : 4;
      __IOM uint32 UNALIGNED  : 1;            /*!< [24..24] Unaligned access usage fault                                     */
      __IOM uint32 DIVBYZERO  : 1;            /*!< [25..25] Divide by zero usage fault                                       */
            uint32            : 6;
    } bit;
  } CFSR_UFSR_BFSR_MMFSR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x0000002C) Hard fault status register                                 */
    
    struct {
            uint32            : 1;
      __IOM uint32 VECTTBL    : 1;            /*!< [1..1] Vector table hard fault                                            */
            uint32            : 28;
      __IOM uint32 FORCED     : 1;            /*!< [30..30] Forced hard fault                                                */
      __IOM uint32 DEBUG_VT   : 1;            /*!< [31..31] Reserved for Debug use                                           */
    } bit;
  } HFSR;
  __IM  uint32  RESERVED;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000034) Memory management fault address register                   */
    
    struct {
      __IOM uint32 ADDRESS    : 32;           /*!< [31..0] Memory management fault address                                   */
    } bit;
  } MMFAR;
  
  union {
    __IOM uint32 reg;                         /*!< (@ 0x00000038) Bus fault address register                                 */
    
    struct {
      __IOM uint32 ADDRESS    : 32;           /*!< [31..0] Bus fault address                                                 */
    } bit;
  } BFAR;
} SCB_Type;                                     /*!< Size = 60 (0x3c)                                                          */



/** @} */ /* End of group Device_Peripheral_peripherals */


/* =========================================================================================================================== */
/* ================                          Device Specific Peripheral Address Map                           ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripheralAddr
  * @{
  */

#define COMP1_BASE                  0x58003800UL
#define CRS_BASE                    0x40008400UL
#define DAC_BASE                    0x40007400UL
#define BDMA_BASE                   0x58025400UL
#define DMA2D_BASE                  0x52001000UL
#define DMAMUX2_BASE                0x58025800UL
#define FMC_BASE                    0x52004000UL
#define CEC_BASE                    0x40006C00UL
#define HSEM_BASE                   0x58026400UL
#define I2C1_BASE                   0x40005400UL
#define I2C2_BASE                   0x40005800UL
#define I2C3_BASE                   0x40005C00UL
#define I2C4_BASE                   0x58001C00UL
#define GPIOA_BASE                  0x58020000UL
#define GPIOB_BASE                  0x58020400UL
#define GPIOC_BASE                  0x58020800UL
#define GPIOD_BASE                  0x58020C00UL
#define GPIOE_BASE                  0x58021000UL
#define GPIOF_BASE                  0x58021400UL
#define GPIOG_BASE                  0x58021800UL
#define GPIOH_BASE                  0x58021C00UL
#define GPIOI_BASE                  0x58022000UL
#define GPIOJ_BASE                  0x58022400UL
#define GPIOK_BASE                  0x58022800UL
#define JPEG_BASE                   0x52003000UL
#define MDMA_BASE                   0x52000000UL
#define QUADSPI_BASE                0x52005000UL
#define RNG_BASE                    0x48021800UL
#define RTC_BASE                    0x58004000UL
#define SAI4_BASE                   0x58005400UL
#define SAI1_BASE                   0x40015800UL
#define SAI2_BASE                   0x40015C00UL
#define SAI3_BASE                   0x40016000UL
#define SDMMC1_BASE                 0x52007000UL
#define SDMMC2_BASE                 0x48022400UL
#define VREFBUF_BASE                0x58003C00UL
#define IWDG_BASE                   0x58004800UL
#define WWDG_BASE                   0x50003000UL
#define PWR_BASE                    0x58024800UL
#define SPI1_BASE                   0x40013000UL
#define SPI2_BASE                   0x40003800UL
#define SPI3_BASE                   0x40003C00UL
#define SPI4_BASE                   0x40013400UL
#define SPI5_BASE                   0x40015000UL
#define SPI6_BASE                   0x58001400UL
#define LTDC_BASE                   0x50001000UL
#define SPDIFRX_BASE                0x40004000UL
#define ADC3_BASE                   0x58026000UL
#define ADC1_BASE                   0x40022000UL
#define ADC2_BASE                   0x40022100UL
#define ADC3_Common_BASE            0x58026300UL
#define ADC12_Common_BASE           0x40022300UL
#define DMAMUX1_BASE                0x40020800UL
#define CRC_BASE                    0x58024C00UL
#define RCC_BASE                    0x58024400UL
#define LPTIM1_BASE                 0x40002400UL
#define LPTIM2_BASE                 0x58002400UL
#define LPTIM3_BASE                 0x58002800UL
#define LPTIM4_BASE                 0x58002C00UL
#define LPTIM5_BASE                 0x58003000UL
#define LPUART1_BASE                0x58000C00UL
#define SYSCFG_BASE                 0x58000400UL
#define EXTI_BASE                   0x58000000UL
#define DELAY_Block_SDMMC1_BASE     0x52008000UL
#define DELAY_Block_QUADSPI_BASE    0x52006000UL
#define DELAY_Block_SDMMC2_BASE     0x48022800UL
#define Flash_BASE                  0x52002000UL
#define AXI_BASE                    0x51000000UL
#define HASH_BASE                   0x48021400UL
#define CRYP_BASE                   0x48021000UL
#define DCMI_BASE                   0x48020000UL
#define OTG1_HS_GLOBAL_BASE         0x40040000UL
#define OTG2_HS_GLOBAL_BASE         0x40080000UL
#define OTG1_HS_HOST_BASE           0x40040400UL
#define OTG2_HS_HOST_BASE           0x40080400UL
#define OTG1_HS_DEVICE_BASE         0x40040800UL
#define OTG2_HS_DEVICE_BASE         0x40080800UL
#define OTG1_HS_PWRCLK_BASE         0x40040E00UL
#define OTG2_HS_PWRCLK_BASE         0x40080E00UL
#define Ethernet_MAC_BASE           0x40028000UL
#define DMA1_BASE                   0x40020000UL
#define DMA2_BASE                   0x40020400UL
#define HRTIM_Master_BASE           0x40017400UL
#define HRTIM_TIMA_BASE             0x40017480UL
#define HRTIM_TIMB_BASE             0x40017500UL
#define HRTIM_TIMC_BASE             0x40017580UL
#define HRTIM_TIMD_BASE             0x40017600UL
#define HRTIM_TIME_BASE             0x40017680UL
#define HRTIM_Common_BASE           0x40017780UL
#define DFSDM_BASE                  0x40017000UL
#define TIM16_BASE                  0x40014400UL
#define TIM17_BASE                  0x40014800UL
#define TIM15_BASE                  0x40014000UL
#define USART1_BASE                 0x40011000UL
#define USART2_BASE                 0x40004400UL
#define USART3_BASE                 0x40004800UL
#define UART4_BASE                  0x40004C00UL
#define UART5_BASE                  0x40005000UL
#define USART6_BASE                 0x40011400UL
#define UART7_BASE                  0x40007800UL
#define UART8_BASE                  0x40007C00UL
#define TIM1_BASE                   0x40010000UL
#define TIM8_BASE                   0x40010400UL
#define FDCAN1_BASE                 0x4000A000UL
#define FDCAN2_BASE                 0x4000A400UL
#define CAN_Msg_RAM_BASE            0x4000AC00UL
#define CAN_CCU_BASE                0x4000A800UL
#define MDIOS_BASE                  0x40009400UL
#define OPAMP_BASE                  0x40009000UL
#define SWPMI_BASE                  0x40008800UL
#define TIM2_BASE                   0x40000000UL
#define TIM3_BASE                   0x40000400UL
#define TIM4_BASE                   0x40000800UL
#define TIM5_BASE                   0x40000C00UL
#define TIM12_BASE                  0x40001800UL
#define TIM13_BASE                  0x40001C00UL
#define TIM14_BASE                  0x40002000UL
#define TIM6_BASE                   0x40001000UL
#define TIM7_BASE                   0x40001400UL
#define SCB_BASE                    0xE000ED00UL

/** @} */ /* End of group Device_Peripheral_peripheralAddr */


/* =========================================================================================================================== */
/* ================                                  Peripheral declaration                                   ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_declaration
  * @{
  */

#define COMP1                       ((COMP1_Type*)             COMP1_BASE)
#define CRS                         ((CRS_Type*)               CRS_BASE)
#define DAC                         ((DAC_Type*)               DAC_BASE)
#define BDMA                        ((BDMA_Type*)              BDMA_BASE)
#define DMA2D                       ((DMA2D_Type*)             DMA2D_BASE)
#define DMAMUX2                     ((DMAMUX2_Type*)           DMAMUX2_BASE)
#define FMC                         ((FMC_Type*)               FMC_BASE)
#define CEC                         ((CEC_Type*)               CEC_BASE)
#define HSEM                        ((HSEM_Type*)              HSEM_BASE)
#define I2C1                        ((I2C1_Type*)              I2C1_BASE)
#define I2C2                        ((I2C1_Type*)              I2C2_BASE)
#define I2C3                        ((I2C1_Type*)              I2C3_BASE)
#define I2C4                        ((I2C1_Type*)              I2C4_BASE)
#define GPIOA                       ((GPIOA_Type*)             GPIOA_BASE)
#define GPIOB                       ((GPIOA_Type*)             GPIOB_BASE)
#define GPIOC                       ((GPIOA_Type*)             GPIOC_BASE)
#define GPIOD                       ((GPIOA_Type*)             GPIOD_BASE)
#define GPIOE                       ((GPIOA_Type*)             GPIOE_BASE)
#define GPIOF                       ((GPIOA_Type*)             GPIOF_BASE)
#define GPIOG                       ((GPIOA_Type*)             GPIOG_BASE)
#define GPIOH                       ((GPIOA_Type*)             GPIOH_BASE)
#define GPIOI                       ((GPIOA_Type*)             GPIOI_BASE)
#define GPIOJ                       ((GPIOA_Type*)             GPIOJ_BASE)
#define GPIOK                       ((GPIOA_Type*)             GPIOK_BASE)
#define JPEG                        ((JPEG_Type*)              JPEG_BASE)
#define MDMA                        ((MDMA_Type*)              MDMA_BASE)
#define QUADSPI                     ((QUADSPI_Type*)           QUADSPI_BASE)
#define RNG                         ((RNG_Type*)               RNG_BASE)
#define RTC                         ((RTC_Type*)               RTC_BASE)
#define SAI4                        ((SAI4_Type*)              SAI4_BASE)
#define SAI1                        ((SAI4_Type*)              SAI1_BASE)
#define SAI2                        ((SAI4_Type*)              SAI2_BASE)
#define SAI3                        ((SAI4_Type*)              SAI3_BASE)
#define SDMMC1                      ((SDMMC1_Type*)            SDMMC1_BASE)
#define SDMMC2                      ((SDMMC1_Type*)            SDMMC2_BASE)
#define VREFBUF                     ((VREFBUF_Type*)           VREFBUF_BASE)
#define IWDG                        ((IWDG_Type*)              IWDG_BASE)
#define WWDG                        ((WWDG_Type*)              WWDG_BASE)
#define PWR                         ((PWR_Type*)               PWR_BASE)
#define SPI1                        ((SPI1_Type*)              SPI1_BASE)
#define SPI2                        ((SPI1_Type*)              SPI2_BASE)
#define SPI3                        ((SPI1_Type*)              SPI3_BASE)
#define SPI4                        ((SPI1_Type*)              SPI4_BASE)
#define SPI5                        ((SPI1_Type*)              SPI5_BASE)
#define SPI6                        ((SPI1_Type*)              SPI6_BASE)
#define LTDC                        ((LTDC_Type*)              LTDC_BASE)
#define SPDIFRX                     ((SPDIFRX_Type*)           SPDIFRX_BASE)
#define ADC3                        ((ADC3_Type*)              ADC3_BASE)
#define ADC1                        ((ADC3_Type*)              ADC1_BASE)
#define ADC2                        ((ADC3_Type*)              ADC2_BASE)
#define ADC3_Common                 ((ADC3_Common_Type*)       ADC3_Common_BASE)
#define ADC12_Common                ((ADC3_Common_Type*)       ADC12_Common_BASE)
#define DMAMUX1                     ((DMAMUX1_Type*)           DMAMUX1_BASE)
#define CRC                         ((CRC_Type*)               CRC_BASE)
#define RCC                         ((RCC_Type*)               RCC_BASE)
#define LPTIM1                      ((LPTIM1_Type*)            LPTIM1_BASE)
#define LPTIM2                      ((LPTIM1_Type*)            LPTIM2_BASE)
#define LPTIM3                      ((LPTIM3_Type*)            LPTIM3_BASE)
#define LPTIM4                      ((LPTIM3_Type*)            LPTIM4_BASE)
#define LPTIM5                      ((LPTIM3_Type*)            LPTIM5_BASE)
#define LPUART1                     ((LPUART1_Type*)           LPUART1_BASE)
#define SYSCFG                      ((SYSCFG_Type*)            SYSCFG_BASE)
#define EXTI                        ((EXTI_Type*)              EXTI_BASE)
#define DELAY_Block_SDMMC1          ((DELAY_Block_SDMMC1_Type*)  DELAY_Block_SDMMC1_BASE)
#define DELAY_Block_QUADSPI         ((DELAY_Block_SDMMC1_Type*)  DELAY_Block_QUADSPI_BASE)
#define DELAY_Block_SDMMC2          ((DELAY_Block_SDMMC1_Type*)  DELAY_Block_SDMMC2_BASE)
#define Flash                       ((Flash_Type*)             Flash_BASE)
#define AXI                         ((AXI_Type*)               AXI_BASE)
#define HASH                        ((HASH_Type*)              HASH_BASE)
#define CRYP                        ((CRYP_Type*)              CRYP_BASE)
#define DCMI                        ((DCMI_Type*)              DCMI_BASE)
#define OTG1_HS_GLOBAL              ((OTG1_HS_GLOBAL_Type*)    OTG1_HS_GLOBAL_BASE)
#define OTG2_HS_GLOBAL              ((OTG1_HS_GLOBAL_Type*)    OTG2_HS_GLOBAL_BASE)
#define OTG1_HS_HOST                ((OTG1_HS_HOST_Type*)      OTG1_HS_HOST_BASE)
#define OTG2_HS_HOST                ((OTG1_HS_HOST_Type*)      OTG2_HS_HOST_BASE)
#define OTG1_HS_DEVICE              ((OTG1_HS_DEVICE_Type*)    OTG1_HS_DEVICE_BASE)
#define OTG2_HS_DEVICE              ((OTG1_HS_DEVICE_Type*)    OTG2_HS_DEVICE_BASE)
#define OTG1_HS_PWRCLK              ((OTG1_HS_PWRCLK_Type*)    OTG1_HS_PWRCLK_BASE)
#define OTG2_HS_PWRCLK              ((OTG1_HS_PWRCLK_Type*)    OTG2_HS_PWRCLK_BASE)
#define Ethernet_MAC                ((Ethernet_MAC_Type*)      Ethernet_MAC_BASE)
#define DMA1                        ((DMA1_Type*)              DMA1_BASE)
#define DMA2                        ((DMA1_Type*)              DMA2_BASE)
#define HRTIM_Master                ((HRTIM_Master_Type*)      HRTIM_Master_BASE)
#define HRTIM_TIMA                  ((HRTIM_TIMA_Type*)        HRTIM_TIMA_BASE)
#define HRTIM_TIMB                  ((HRTIM_TIMB_Type*)        HRTIM_TIMB_BASE)
#define HRTIM_TIMC                  ((HRTIM_TIMC_Type*)        HRTIM_TIMC_BASE)
#define HRTIM_TIMD                  ((HRTIM_TIMD_Type*)        HRTIM_TIMD_BASE)
#define HRTIM_TIME                  ((HRTIM_TIME_Type*)        HRTIM_TIME_BASE)
#define HRTIM_Common                ((HRTIM_Common_Type*)      HRTIM_Common_BASE)
#define DFSDM                       ((DFSDM_Type*)             DFSDM_BASE)
#define TIM16                       ((TIM16_Type*)             TIM16_BASE)
#define TIM17                       ((TIM17_Type*)             TIM17_BASE)
#define TIM15                       ((TIM15_Type*)             TIM15_BASE)
#define USART1                      ((USART1_Type*)            USART1_BASE)
#define USART2                      ((USART1_Type*)            USART2_BASE)
#define USART3                      ((USART1_Type*)            USART3_BASE)
#define UART4                       ((USART1_Type*)            UART4_BASE)
#define UART5                       ((USART1_Type*)            UART5_BASE)
#define USART6                      ((USART1_Type*)            USART6_BASE)
#define UART7                       ((USART1_Type*)            UART7_BASE)
#define UART8                       ((USART1_Type*)            UART8_BASE)
#define TIM1                        ((TIM1_Type*)              TIM1_BASE)
#define TIM8                        ((TIM1_Type*)              TIM8_BASE)
#define FDCAN1                      ((FDCAN1_Type*)            FDCAN1_BASE)
#define FDCAN2                      ((FDCAN1_Type*)            FDCAN2_BASE)
#define CAN_Msg_RAM                 ((FDCAN1_Type*)            CAN_Msg_RAM_BASE)
#define CAN_CCU                     ((FDCAN1_Type*)            CAN_CCU_BASE)
#define MDIOS                       ((MDIOS_Type*)             MDIOS_BASE)
#define OPAMP                       ((OPAMP_Type*)             OPAMP_BASE)
#define SWPMI                       ((SWPMI_Type*)             SWPMI_BASE)
#define TIM2                        ((TIM2_Type*)              TIM2_BASE)
#define TIM3                        ((TIM2_Type*)              TIM3_BASE)
#define TIM4                        ((TIM2_Type*)              TIM4_BASE)
#define TIM5                        ((TIM2_Type*)              TIM5_BASE)
#define TIM12                       ((TIM2_Type*)              TIM12_BASE)
#define TIM13                       ((TIM2_Type*)              TIM13_BASE)
#define TIM14                       ((TIM2_Type*)              TIM14_BASE)
#define TIM6                        ((TIM6_Type*)              TIM6_BASE)
#define TIM7                        ((TIM6_Type*)              TIM7_BASE)
#define SCB                         ((SCB_Type*)               SCB_BASE)

#define CPACR  (*(volatile unsigned long*)(0xE000ED88UL))
#define ITCMCR (*(volatile unsigned long*)(0xE000EF90UL))
#define DTCMCR (*(volatile unsigned long*)(0xE000EF94UL))

#ifdef __cplusplus
}
#endif

#endif /* STM32H7X3_H */
